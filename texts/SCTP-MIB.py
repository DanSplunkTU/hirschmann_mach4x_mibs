#
# PySNMP MIB module SCTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/SCTP-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 19:25:45 2022
# On host fv-az121-65 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
InetAddress, InetAddressType, InetPortNumber = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetPortNumber")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Counter64, MibIdentifier, mib_2, Counter32, TimeTicks, IpAddress, ObjectIdentity, iso, ModuleIdentity, Unsigned32, Bits, NotificationType, Gauge32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "MibIdentifier", "mib-2", "Counter32", "TimeTicks", "IpAddress", "ObjectIdentity", "iso", "ModuleIdentity", "Unsigned32", "Bits", "NotificationType", "Gauge32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TimeStamp, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TimeStamp", "TextualConvention", "TruthValue")
sctpMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 104))
sctpMIB.setRevisions(('2004-09-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: sctpMIB.setRevisionsDescriptions((' Initial version, published as RFC 3873',))
if mibBuilder.loadTexts: sctpMIB.setLastUpdated('200409020000Z')
if mibBuilder.loadTexts: sctpMIB.setOrganization('IETF SIGTRAN Working Group')
if mibBuilder.loadTexts: sctpMIB.setContactInfo('\n        WG EMail: sigtran@ietf.org\n\n        Web Page:\n              http://www.ietf.org/html.charters/sigtran-charter.html\n\n        Chair:     Lyndon Ong\n                   Ciena Corporation\n                   0480 Ridgeview Drive\n                   Cupertino, CA  95014\n                   USA\n                   Tel:\n                   Email: lyong@ciena.com\n\n        Editors:   Maria-Carmen Belinchon\n                   R&D Department\n                   Ericsson Espana S. A.\n                   Via de los Poblados, 13\n                   28033 Madrid\n                   Spain\n                   Tel:   +34 91 339 3535\n                   Email: Maria.C.Belinchon@ericsson.com\n\n                   Jose-Javier Pastor-Balbas\n                   R&D Department\n                   Ericsson Espana S. A.\n                   Via de los Poblados, 13\n                   28033 Madrid\n                   Spain\n                   Tel:   +34 91 339 1397\n            Email: J.Javier.Pastor@ericsson.com\n       ')
if mibBuilder.loadTexts: sctpMIB.setDescription('The MIB module for managing SCTP implementations.\n\n       Copyright (C) The Internet Society (2004).  This version of\n       this MIB module is part of RFC 3873; see the RFC itself for\n       full legal notices. ')
sctpObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 1))
sctpStats = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 1, 1))
sctpParams = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 1, 2))
sctpCurrEstab = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpCurrEstab.setReference('Section 4 in RFC2960 covers the SCTP   Association state\n       diagram.')
if mibBuilder.loadTexts: sctpCurrEstab.setStatus('current')
if mibBuilder.loadTexts: sctpCurrEstab.setDescription('The number of associations for which the current state is\n       either ESTABLISHED, SHUTDOWN-RECEIVED or SHUTDOWN-PENDING.')
sctpActiveEstabs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpActiveEstabs.setReference('Section 4 in RFC2960 covers the SCTP   Association state\n       diagram.')
if mibBuilder.loadTexts: sctpActiveEstabs.setStatus('current')
if mibBuilder.loadTexts: sctpActiveEstabs.setDescription('The number of times that associations have made a direct\n       transition to the ESTABLISHED state from the COOKIE-ECHOED\n       state: COOKIE-ECHOED -> ESTABLISHED. The upper layer initiated\n       the association attempt.')
sctpPassiveEstabs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpPassiveEstabs.setReference('Section 4 in RFC2960 covers the SCTP   Association state\n       diagram.')
if mibBuilder.loadTexts: sctpPassiveEstabs.setStatus('current')
if mibBuilder.loadTexts: sctpPassiveEstabs.setDescription('The number of times that associations have made a direct\n       transition to the ESTABLISHED state from the CLOSED state:\n       CLOSED -> ESTABLISHED. The remote endpoint initiated the\n       association attempt.')
sctpAborteds = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAborteds.setReference('Section 4 in RFC2960 covers the SCTP   Association state\n       diagram.')
if mibBuilder.loadTexts: sctpAborteds.setStatus('current')
if mibBuilder.loadTexts: sctpAborteds.setDescription("The number of times that associations have made a direct\n       transition to the CLOSED state from any state using the\n       primitive 'ABORT': AnyState --Abort--> CLOSED. Ungraceful\n       termination of the association.")
sctpShutdowns = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpShutdowns.setReference('Section 4 in RFC2960 covers the SCTP   Association state\n       diagram.')
if mibBuilder.loadTexts: sctpShutdowns.setStatus('current')
if mibBuilder.loadTexts: sctpShutdowns.setDescription('The number of times that associations have made a direct\n       transition to the CLOSED state from either the SHUTDOWN-SENT\n       state or the SHUTDOWN-ACK-SENT state. Graceful termination of\n       the association.')
sctpOutOfBlues = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutOfBlues.setReference('Section 8.4 in RFC2960 deals with the Out-Of-The-Blue\n        (OOTB) packet definition and procedures.')
if mibBuilder.loadTexts: sctpOutOfBlues.setStatus('current')
if mibBuilder.loadTexts: sctpOutOfBlues.setDescription('The number of out of the blue packets received by the host.\n       An out of the blue packet is an SCTP packet correctly formed,\n       including the proper checksum, but for which the receiver was\n       unable to identify an appropriate association.')
sctpChecksumErrors = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpChecksumErrors.setReference('The checksum is located at the end of the SCTP packet as per\n       Section 3.1 in RFC2960. RFC3309 updates SCTP to use a 32 bit\n       CRC checksum.')
if mibBuilder.loadTexts: sctpChecksumErrors.setStatus('current')
if mibBuilder.loadTexts: sctpChecksumErrors.setDescription('The number of SCTP packets received with an invalid\n       checksum.')
sctpOutCtrlChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutCtrlChunks.setReference('Sections 1.3.5 and 1.4 in RFC2960 refer to control chunk as\n       those chunks different from those that contain user\n       information, i.e., DATA chunks.')
if mibBuilder.loadTexts: sctpOutCtrlChunks.setStatus('current')
if mibBuilder.loadTexts: sctpOutCtrlChunks.setDescription('The number of SCTP control chunks sent (retransmissions are\n       not included). Control chunks are those chunks different from\n       DATA.')
sctpOutOrderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutOrderChunks.setReference('Section 3.3.1 in RFC2960 defines the ordered data chunk.')
if mibBuilder.loadTexts: sctpOutOrderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpOutOrderChunks.setDescription('The number of SCTP ordered data chunks sent (retransmissions\n       are not included).')
sctpOutUnorderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutUnorderChunks.setReference('Section 3.3.1 in RFC2960 defines the unordered data chunk.')
if mibBuilder.loadTexts: sctpOutUnorderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpOutUnorderChunks.setDescription('The number of SCTP unordered chunks (data chunks in which the\n       U bit is set to 1) sent (retransmissions are not included).')
sctpInCtrlChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInCtrlChunks.setReference('Sections 1.3.5 and 1.4 in RFC2960 refer to control chunk as\n       those chunks different from those that contain user\n       information, i.e., DATA chunks.')
if mibBuilder.loadTexts: sctpInCtrlChunks.setStatus('current')
if mibBuilder.loadTexts: sctpInCtrlChunks.setDescription('The number of SCTP control chunks received (no duplicate\n       chunks included).')
sctpInOrderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInOrderChunks.setReference('Section 3.3.1 in RFC2960 defines the ordered data chunk.')
if mibBuilder.loadTexts: sctpInOrderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpInOrderChunks.setDescription('The number of SCTP ordered data chunks received (no duplicate\n       chunks included).')
sctpInUnorderChunks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInUnorderChunks.setReference('Section 3.3.1 in RFC2960 defines the unordered data chunk.')
if mibBuilder.loadTexts: sctpInUnorderChunks.setStatus('current')
if mibBuilder.loadTexts: sctpInUnorderChunks.setDescription('The number of SCTP unordered chunks (data chunks in which the\n       U bit is set to 1) received (no duplicate chunks included).')
sctpFragUsrMsgs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpFragUsrMsgs.setStatus('current')
if mibBuilder.loadTexts: sctpFragUsrMsgs.setDescription('The number of user messages that have to be fragmented\n       because of the MTU.')
sctpReasmUsrMsgs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpReasmUsrMsgs.setReference('Section 6.9 in RFC2960 includes a description of the\n       reassembly process.')
if mibBuilder.loadTexts: sctpReasmUsrMsgs.setStatus('current')
if mibBuilder.loadTexts: sctpReasmUsrMsgs.setDescription('The number of user messages reassembled, after conversion\n       into DATA chunks.')
sctpOutSCTPPacks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpOutSCTPPacks.setStatus('current')
if mibBuilder.loadTexts: sctpOutSCTPPacks.setDescription('The number of SCTP packets sent. Retransmitted DATA chunks\n       are included.')
sctpInSCTPPacks = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpInSCTPPacks.setStatus('current')
if mibBuilder.loadTexts: sctpInSCTPPacks.setDescription('The number of SCTP packets received. Duplicates are\n       included.')
sctpDiscontinuityTime = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpDiscontinuityTime.setReference('The inclusion of this object is recommended by RFC2578.')
if mibBuilder.loadTexts: sctpDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: sctpDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which\n       any one or more of this general statistics counters suffered a\n       discontinuity.  The relevant counters are the specific\n       instances associated with this interface of any Counter32 or\n       Counter64 object contained in the SCTP layer statistics\n       (defined below sctpStats branch).  If no such discontinuities\n       have occurred since the last re-initialization of the local\n       management subsystem, then this object contains a zero value.')
sctpRtoAlgorithm = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("vanj", 2))).clone('vanj')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoAlgorithm.setReference('Section 6.3.1 and 6.3.2 in RFC2960 cover the RTO calculation\n       and retransmission timer rules.')
if mibBuilder.loadTexts: sctpRtoAlgorithm.setStatus('current')
if mibBuilder.loadTexts: sctpRtoAlgorithm.setDescription('The algorithm used to determine the timeout value (T3-rtx)\n       used for re-transmitting unacknowledged chunks.')
sctpRtoMin = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 2), Unsigned32().clone(1000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoMin.setStatus('current')
if mibBuilder.loadTexts: sctpRtoMin.setDescription("The minimum value permitted by a SCTP implementation for the\n       retransmission timeout value, measured in milliseconds.  More\n       refined semantics for objects of this type depend upon the\n       algorithm used to determine the retransmission timeout value.\n\n       A retransmission time value of zero means immediate\n       retransmission.\n\n       The value of this object has to be lower than or equal to\n       stcpRtoMax's value.")
sctpRtoMax = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 3), Unsigned32().clone(60000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoMax.setStatus('current')
if mibBuilder.loadTexts: sctpRtoMax.setDescription("The maximum value permitted by a SCTP implementation for the\n       retransmission timeout value, measured in milliseconds.  More\n       refined semantics for objects of this type depend upon the\n       algorithm used to determine the retransmission timeout value.\n\n       A retransmission time value of zero means immediate re-\n       transmission.\n\n       The value of this object has to be greater than or equal to\n       stcpRtoMin's value.")
sctpRtoInitial = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 4), Unsigned32().clone(3000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpRtoInitial.setStatus('current')
if mibBuilder.loadTexts: sctpRtoInitial.setDescription('The initial value for the retransmission timer.\n\n       A retransmission time value of zero means immediate re-\n       transmission.')
sctpMaxAssocs = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpMaxAssocs.setStatus('current')
if mibBuilder.loadTexts: sctpMaxAssocs.setDescription('The limit on the total number of associations the entity can\n       support. In entities where the maximum number of associations\n       is dynamic, this object should contain the value -1.')
sctpValCookieLife = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 6), Unsigned32().clone(60000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpValCookieLife.setReference('Section 5.1.3 in RFC2960 explains the cookie generation\n       process. Recommended value is per section 14 in RFC2960.')
if mibBuilder.loadTexts: sctpValCookieLife.setStatus('current')
if mibBuilder.loadTexts: sctpValCookieLife.setDescription('Valid cookie life in the 4-way start-up handshake procedure.')
sctpMaxInitRetr = MibScalar((1, 3, 6, 1, 2, 1, 104, 1, 2, 7), Unsigned32().clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpMaxInitRetr.setReference('Section 5.1.4, 5.1.6 in RFC2960 refers to Max.Init.Retransmit\n       parameter. Recommended value is per section 14 in RFC2960.')
if mibBuilder.loadTexts: sctpMaxInitRetr.setStatus('current')
if mibBuilder.loadTexts: sctpMaxInitRetr.setDescription('The maximum number of retransmissions at the start-up phase\n       (INIT and COOKIE ECHO chunks). ')
sctpAssocTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 3), )
if mibBuilder.loadTexts: sctpAssocTable.setStatus('current')
if mibBuilder.loadTexts: sctpAssocTable.setDescription('A table containing SCTP association-specific information.')
sctpAssocEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 3, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpAssocEntry.setStatus('current')
if mibBuilder.loadTexts: sctpAssocEntry.setDescription('General common variables and statistics for the whole\n       association.')
sctpAssocId = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: sctpAssocId.setStatus('current')
if mibBuilder.loadTexts: sctpAssocId.setDescription('Association Identification. Value identifying the\n       association. ')
sctpAssocRemHostName = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemHostName.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemHostName.setDescription("The peer's DNS name. This object needs to have the same\n       format as the encoding in the DNS protocol.  This implies that\n       the domain name can be up to 255 octets long, each octet being\n       0<=x<=255 as value with US-ASCII A-Z having a case insensitive\n       matching.\n\n       If no DNS domain name was received from the peer at init time\n       (embedded in the INIT or INIT-ACK chunk), this object is\n       meaningless. In such cases the object MUST contain a zero-\n       length string value. Otherwise, it contains the remote host\n       name received at init time.")
sctpAssocLocalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 3), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocLocalPort.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalPort.setDescription('The local SCTP port number used for this association.')
sctpAssocRemPort = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 4), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemPort.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemPort.setDescription('The remote SCTP port number used for this association.')
sctpAssocRemPrimAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemPrimAddrType.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemPrimAddrType.setDescription('The internet type of primary remote IP address. ')
sctpAssocRemPrimAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemPrimAddr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemPrimAddr.setDescription('The primary remote IP address. The type of this address is\n       determined by the value of sctpAssocRemPrimAddrType.\n\n       The client side will know this value after INIT_ACK message\n       reception, the server side will know this value when sending\n       INIT_ACK message. However, values will be filled in at\n       established(4) state.')
sctpAssocHeartBeatInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 7), Unsigned32().clone(30000)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocHeartBeatInterval.setStatus('current')
if mibBuilder.loadTexts: sctpAssocHeartBeatInterval.setDescription('The current heartbeat interval..\n\n       Zero value means no HeartBeat, even when the concerned\n       sctpAssocRemAddrHBFlag object is true.')
sctpAssocState = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("closed", 1), ("cookieWait", 2), ("cookieEchoed", 3), ("established", 4), ("shutdownPending", 5), ("shutdownSent", 6), ("shutdownReceived", 7), ("shutdownAckSent", 8), ("deleteTCB", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sctpAssocState.setReference('Section 4 in RFC2960 covers the SCTP Association state\n       diagram.')
if mibBuilder.loadTexts: sctpAssocState.setStatus('current')
if mibBuilder.loadTexts: sctpAssocState.setDescription('The state of this SCTP association.\n\n       As in TCP, deleteTCB(9) is the only value that may be set by a\n       management station. If any other value is received, then the\n       agent must return a wrongValue error.\n\n       If a management station sets this object to the value\n       deleteTCB(9), then this has the effect of deleting the TCB (as\n       defined in SCTP) of the corresponding association on the\n       managed node, resulting in immediate termination of the\n       association.\n\n       As an implementation-specific option, an ABORT chunk may be\n       sent from the managed node to the other SCTP endpoint as a\n       result of setting the deleteTCB(9) value. The ABORT chunk\n       implies an ungraceful association shutdown.')
sctpAssocInStreams = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocInStreams.setReference('Section 1.3 in RFC2960 includes a definition of stream.\n       Section 5.1.1 in RFC2960 covers the streams negotiation\n       process.')
if mibBuilder.loadTexts: sctpAssocInStreams.setStatus('current')
if mibBuilder.loadTexts: sctpAssocInStreams.setDescription('Inbound Streams according to the negotiation at association\n       start up.')
sctpAssocOutStreams = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocOutStreams.setReference('Section 1.3 in RFC2960 includes a definition of stream.\n       Section 5.1.1 in RFC2960 covers the streams negotiation\n       process.')
if mibBuilder.loadTexts: sctpAssocOutStreams.setStatus('current')
if mibBuilder.loadTexts: sctpAssocOutStreams.setDescription('Outbound Streams according to the negotiation at association\n       start up. ')
sctpAssocMaxRetr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 11), Unsigned32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocMaxRetr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocMaxRetr.setDescription('The maximum number of data retransmissions in the association\n       context. This value is specific for each association and the\n       upper layer can change it by calling the appropriate\n       primitives. This value has to be smaller than the addition of\n       all the maximum number for all the paths\n       (sctpAssocRemAddrMaxPathRtx).\n\n       A value of zero value means no retransmissions.')
sctpAssocPrimProcess = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocPrimProcess.setStatus('current')
if mibBuilder.loadTexts: sctpAssocPrimProcess.setDescription("This object identifies the system level process which holds\n       primary responsibility for the SCTP association.\n       Wherever possible, this should be the system's native unique\n       identification number. The special value 0 can be used to\n       indicate that no primary process is known.\n\n       Note that the value of this object can be used as a pointer\n       into the swRunTable of the HOST-RESOURCES-MIB(if the value is\n       smaller than 2147483647) or into the sysApplElmtRunTable of\n       the SYSAPPL-MIB.")
sctpAssocT1expireds = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocT1expireds.setReference('Section 5 in RFC2960.')
if mibBuilder.loadTexts: sctpAssocT1expireds.setStatus('current')
if mibBuilder.loadTexts: sctpAssocT1expireds.setDescription('The T1 timer determines how long to wait for an\n       acknowledgement after sending an INIT or COOKIE-ECHO chunk.\n       This object reflects the number of times the T1 timer expires\n       without having received the acknowledgement.\n\n       Discontinuities in the value of this counter can occur at re-\n       initialization of the management system, and at other times as\n       indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocT2expireds = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocT2expireds.setReference('Section 9.2 in RFC2960.')
if mibBuilder.loadTexts: sctpAssocT2expireds.setStatus('current')
if mibBuilder.loadTexts: sctpAssocT2expireds.setDescription('The T2 timer determines how long to wait for an\n       acknowledgement after sending a SHUTDOWN or SHUTDOWN-ACK\n       chunk. This object reflects the number of times that T2- timer\n       expired.\n\n       Discontinuities in the value of this counter can occur at re-\n       initialization of the management system, and at other times as\n       indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocRtxChunks = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRtxChunks.setReference('Section 6 in RFC2960 covers the retransmission process and\n       rules.')
if mibBuilder.loadTexts: sctpAssocRtxChunks.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRtxChunks.setDescription('When T3-rtx expires, the DATA chunks that triggered the T3\n       timer will be re-sent according with the retransmissions\n       rules. Every DATA chunk that was included in the SCTP packet\n       that triggered the T3-rtx timer must be added to the value of\n       this counter.\n\n       Discontinuities in the value of this counter can occur at re-\n       initialization of the management system, and at other times as\n       indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocStartTime.setDescription('The value of sysUpTime at the time that the association\n       represented by this row enters the ESTABLISHED state, i.e.,\n       the sctpAssocState object is set to established(4). The\n       value of this object will be zero:\n       - before the association enters the established(4)\n         state, or\n\n       - if the established(4) state was entered prior to\n         the last re-initialization of the local network management\n         subsystem.')
sctpAssocDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 3, 1, 17), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocDiscontinuityTime.setReference('The inclusion of this object is recommended by RFC2578.')
if mibBuilder.loadTexts: sctpAssocDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which\n       any one or more of this SCTP association counters suffered a\n       discontinuity.  The relevant counters are the specific\n       instances associated with this interface of any Counter32 or\n       Counter64 object contained in the sctpAssocTable or\n       sctpLocalAddrTable or sctpRemAddrTable.  If no such\n       discontinuities have occurred since the last re-initialization\n       of the local management subsystem, then this object contains a\n       zero value. ')
sctpAssocLocalAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 4), )
if mibBuilder.loadTexts: sctpAssocLocalAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrTable.setDescription('Expanded table of sctpAssocTable based on the AssocId index.\n       This table shows data related to each local IP address which\n       is used by this association.')
sctpAssocLocalAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 4, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocId"), (0, "SCTP-MIB", "sctpAssocLocalAddrType"), (0, "SCTP-MIB", "sctpAssocLocalAddr"))
if mibBuilder.loadTexts: sctpAssocLocalAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrEntry.setDescription('Local information about the available addresses. There will\n       be an entry for every local IP address defined for this\n\n       association.\n       Implementors need to be aware that if the size of\n       sctpAssocLocalAddr exceeds 114 octets then OIDs of column\n       instances in this table will have more than 128 sub-\n       identifiers and cannot be accessed using SNMPv1, SNMPv2c, or\n       SNMPv3.')
sctpAssocLocalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: sctpAssocLocalAddrType.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrType.setDescription('Internet type of local IP address used for this association.')
sctpAssocLocalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 4, 1, 2), InetAddress())
if mibBuilder.loadTexts: sctpAssocLocalAddr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddr.setDescription('The value of a local IP address available for this\n       association. The type of this address is determined by the\n       value of sctpAssocLocalAddrType.')
sctpAssocLocalAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 4, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocLocalAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocLocalAddrStartTime.setDescription('The value of sysUpTime at the time that this row was\n       created.')
sctpAssocRemAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 5), )
if mibBuilder.loadTexts: sctpAssocRemAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrTable.setDescription('Expanded table of sctpAssocTable based on the AssocId index.\n       This table shows data related to each remote peer IP address\n       which is used by this association.')
sctpAssocRemAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 5, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocId"), (0, "SCTP-MIB", "sctpAssocRemAddrType"), (0, "SCTP-MIB", "sctpAssocRemAddr"))
if mibBuilder.loadTexts: sctpAssocRemAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrEntry.setDescription('Information about the most important variables for every\n       remote IP address. There will be an entry for every remote IP\n       address defined for this association.\n\n       Implementors need to be aware that if the size of\n       sctpAssocRemAddr exceeds 114 octets then OIDs of column\n       instances in this table will have more than 128 sub-\n       identifiers and cannot be accessed using SNMPv1, SNMPv2c, or\n       SNMPv3.')
sctpAssocRemAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 1), InetAddressType())
if mibBuilder.loadTexts: sctpAssocRemAddrType.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrType.setDescription('Internet type of a remote IP address available for this\n       association.')
sctpAssocRemAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 2), InetAddress())
if mibBuilder.loadTexts: sctpAssocRemAddr.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddr.setDescription('The value of a remote IP address available for this\n       association. The type of this address is determined by the\n       value of sctpAssocLocalAddrType.')
sctpAssocRemAddrActive = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrActive.setReference('The remote transport states are defined as Active and\n       Inactive in the SCTP, RFC2960.')
if mibBuilder.loadTexts: sctpAssocRemAddrActive.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrActive.setDescription("This object gives information about the reachability of this\n       specific remote IP address.\n\n       When the object is set to 'true' (1), the remote IP address is\n       understood as Active. Active means that the threshold of no\n       answers received from this IP address has not been reached.\n\n       When the object is set to 'false' (2), the remote IP address\n       is understood as Inactive. Inactive means that either no\n       heartbeat or any other message was received from this address,\n       reaching the threshold defined by the protocol.")
sctpAssocRemAddrHBActive = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrHBActive.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrHBActive.setDescription('This object indicates whether the optional Heartbeat check\n       associated to one destination transport address is activated\n       or not (value equal to true or false, respectively). ')
sctpAssocRemAddrRTO = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 5), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrRTO.setReference('Section 6.3 in RFC2960 deals with the Retransmission Timer\n       Management.')
if mibBuilder.loadTexts: sctpAssocRemAddrRTO.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrRTO.setDescription('The current Retransmission Timeout. T3-rtx timer as defined\n       in the protocol SCTP.')
sctpAssocRemAddrMaxPathRtx = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 6), Unsigned32().clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrMaxPathRtx.setReference('Section 8.2, 8.3 and 14 in RFC2960.')
if mibBuilder.loadTexts: sctpAssocRemAddrMaxPathRtx.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrMaxPathRtx.setDescription('Maximum number of DATA chunks retransmissions allowed to a\n       remote IP address before it is considered inactive, as defined\n       in RFC2960.')
sctpAssocRemAddrRtx = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrRtx.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrRtx.setDescription('Number of DATA chunks retransmissions to this specific IP\n       address. When T3-rtx expires, the DATA chunk that triggered\n       the T3 timer will be re-sent according to the retransmissions\n       rules. Every DATA chunk that is included in a SCTP packet and\n       was transmitted to this specific IP address before, will be\n       included in this counter.\n\n       Discontinuities in the value of this counter can occur at re-\n       initialization of the management system, and at other times as\n       indicated by the value of sctpAssocDiscontinuityTime.')
sctpAssocRemAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 5, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpAssocRemAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpAssocRemAddrStartTime.setDescription('The value of sysUpTime at the time that this row was\n       created.')
sctpLookupLocalPortTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 6), )
if mibBuilder.loadTexts: sctpLookupLocalPortTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupLocalPortTable.setDescription('With the use of this table, a list of associations which are\n\n       using the specified local port can be retrieved.')
sctpLookupLocalPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 6, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocLocalPort"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupLocalPortEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupLocalPortEntry.setDescription('This table is indexed by local port and association ID.\n       Specifying a local port, we would get a list of the\n       associations whose local port is the one specified.')
sctpLookupLocalPortStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 6, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupLocalPortStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupLocalPortStartTime.setDescription('The value of sysUpTime at the time that this row was created.\n\n       As the table will be created after the sctpAssocTable\n       creation, this value could be equal to the sctpAssocStartTime\n       object from the main table.')
sctpLookupRemPortTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 7), )
if mibBuilder.loadTexts: sctpLookupRemPortTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPortTable.setDescription('With the use of this table, a list of associations which are\n       using the specified remote port can be got')
sctpLookupRemPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 7, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemPort"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemPortEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPortEntry.setDescription('This table is indexed by remote port and association ID.\n       Specifying a remote port we would get a list of the\n       associations whose local port is the one specified ')
sctpLookupRemPortStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 7, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemPortStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPortStartTime.setDescription('The value of sysUpTime at the time that this row was created.\n\n       As the table will be created after the sctpAssocTable\n       creation, this value could be equal to the sctpAssocStartTime\n       object from the main table.')
sctpLookupRemHostNameTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 8), )
if mibBuilder.loadTexts: sctpLookupRemHostNameTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemHostNameTable.setDescription('With the use of this table, a list of associations with that\n       particular host can be retrieved.')
sctpLookupRemHostNameEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 8, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemHostName"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemHostNameEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemHostNameEntry.setDescription('This table is indexed by remote host name and association ID.\n       Specifying a host name we would get a list of the associations\n       specifying that host name as the remote one.\n\n       Implementors need to be aware that if the size of\n       sctpAssocRemHostName exceeds 115 octets then OIDs of column\n       instances in this table will have more than 128 sub-\n       identifiers and cannot be accessed using SNMPv1, SNMPv2c, or\n       SNMPv3.')
sctpLookupRemHostNameStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 8, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemHostNameStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemHostNameStartTime.setDescription('The value of sysUpTime at the time that this row was created.\n\n       As the table will be created after the sctpAssocTable\n       creation, this value could be equal to the sctpAssocStartTime\n       object from the main table.')
sctpLookupRemPrimIPAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 9), )
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrTable.setDescription('With the use of this table, a list of associations that have\n       the specified IP address as primary within the remote set of\n       active addresses can be retrieved.')
sctpLookupRemPrimIPAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 9, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemPrimAddrType"), (0, "SCTP-MIB", "sctpAssocRemPrimAddr"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrEntry.setDescription('This table is indexed by primary address and association ID.\n       Specifying a primary address, we would get a list of the\n       associations that have the specified remote IP address marked\n       as primary.\n       Implementors need to be aware that if the size of\n       sctpAssocRemPrimAddr exceeds 114 octets then OIDs of column\n       instances in this table will have more than 128 sub-\n       identifiers and cannot be accessed using SNMPv1, SNMPv2c, or\n       SNMPv3.')
sctpLookupRemPrimIPAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 9, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemPrimIPAddrStartTime.setDescription('The value of SysUpTime at the time that this row was created.\n\n       As the table will be created after the sctpAssocTable\n       creation, this value could be equal to the sctpAssocStartTime\n       object from the main table.')
sctpLookupRemIPAddrTable = MibTable((1, 3, 6, 1, 2, 1, 104, 1, 10), )
if mibBuilder.loadTexts: sctpLookupRemIPAddrTable.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemIPAddrTable.setDescription('With the use of this table, a list of associations that have\n       the specified IP address as one of the remote ones can be\n       retrieved. ')
sctpLookupRemIPAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 104, 1, 10, 1), ).setIndexNames((0, "SCTP-MIB", "sctpAssocRemAddrType"), (0, "SCTP-MIB", "sctpAssocRemAddr"), (0, "SCTP-MIB", "sctpAssocId"))
if mibBuilder.loadTexts: sctpLookupRemIPAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemIPAddrEntry.setDescription('This table is indexed by a remote IP address and association\n       ID. Specifying an IP address we would get a list of the\n       associations that have the specified IP address included\n       within the set of remote IP addresses.')
sctpLookupRemIPAddrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 104, 1, 10, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sctpLookupRemIPAddrStartTime.setStatus('current')
if mibBuilder.loadTexts: sctpLookupRemIPAddrStartTime.setDescription('The value of SysUpTime at the time that this row was created.\n\n       As the table will be created after the sctpAssocTable\n       creation, this value could be equal to the sctpAssocStartTime\n       object from the main table.')
sctpMibConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 2))
sctpMibCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 2, 1))
sctpMibGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 104, 2, 2))
sctpLayerParamsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 1)).setObjects(("SCTP-MIB", "sctpRtoAlgorithm"), ("SCTP-MIB", "sctpRtoMin"), ("SCTP-MIB", "sctpRtoMax"), ("SCTP-MIB", "sctpRtoInitial"), ("SCTP-MIB", "sctpMaxAssocs"), ("SCTP-MIB", "sctpValCookieLife"), ("SCTP-MIB", "sctpMaxInitRetr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpLayerParamsGroup = sctpLayerParamsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpLayerParamsGroup.setDescription('Common parameters for the SCTP layer, i.e., for all the\n       associations. They can usually be referred to as configuration\n       parameters.')
sctpStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 2)).setObjects(("SCTP-MIB", "sctpCurrEstab"), ("SCTP-MIB", "sctpActiveEstabs"), ("SCTP-MIB", "sctpPassiveEstabs"), ("SCTP-MIB", "sctpAborteds"), ("SCTP-MIB", "sctpShutdowns"), ("SCTP-MIB", "sctpOutOfBlues"), ("SCTP-MIB", "sctpChecksumErrors"), ("SCTP-MIB", "sctpOutCtrlChunks"), ("SCTP-MIB", "sctpOutOrderChunks"), ("SCTP-MIB", "sctpOutUnorderChunks"), ("SCTP-MIB", "sctpInCtrlChunks"), ("SCTP-MIB", "sctpInOrderChunks"), ("SCTP-MIB", "sctpInUnorderChunks"), ("SCTP-MIB", "sctpFragUsrMsgs"), ("SCTP-MIB", "sctpReasmUsrMsgs"), ("SCTP-MIB", "sctpOutSCTPPacks"), ("SCTP-MIB", "sctpInSCTPPacks"), ("SCTP-MIB", "sctpDiscontinuityTime"), ("SCTP-MIB", "sctpAssocT1expireds"), ("SCTP-MIB", "sctpAssocT2expireds"), ("SCTP-MIB", "sctpAssocRtxChunks"), ("SCTP-MIB", "sctpAssocRemAddrRtx"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpStatsGroup = sctpStatsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpStatsGroup.setDescription('Statistics group. It includes the objects to collect state\n       changes in the SCTP protocol local layer and flow control\n       statistics.')
sctpPerAssocParamsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 3)).setObjects(("SCTP-MIB", "sctpAssocRemHostName"), ("SCTP-MIB", "sctpAssocLocalPort"), ("SCTP-MIB", "sctpAssocRemPort"), ("SCTP-MIB", "sctpAssocRemPrimAddrType"), ("SCTP-MIB", "sctpAssocRemPrimAddr"), ("SCTP-MIB", "sctpAssocHeartBeatInterval"), ("SCTP-MIB", "sctpAssocState"), ("SCTP-MIB", "sctpAssocInStreams"), ("SCTP-MIB", "sctpAssocOutStreams"), ("SCTP-MIB", "sctpAssocMaxRetr"), ("SCTP-MIB", "sctpAssocPrimProcess"), ("SCTP-MIB", "sctpAssocStartTime"), ("SCTP-MIB", "sctpAssocDiscontinuityTime"), ("SCTP-MIB", "sctpAssocLocalAddrStartTime"), ("SCTP-MIB", "sctpAssocRemAddrActive"), ("SCTP-MIB", "sctpAssocRemAddrHBActive"), ("SCTP-MIB", "sctpAssocRemAddrRTO"), ("SCTP-MIB", "sctpAssocRemAddrMaxPathRtx"), ("SCTP-MIB", "sctpAssocRemAddrStartTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpPerAssocParamsGroup = sctpPerAssocParamsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpPerAssocParamsGroup.setDescription('The SCTP group of objects to manage per-association\n       parameters. These variables include all the SCTP basic\n       features.')
sctpPerAssocStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 4)).setObjects(("SCTP-MIB", "sctpAssocT1expireds"), ("SCTP-MIB", "sctpAssocT2expireds"), ("SCTP-MIB", "sctpAssocRtxChunks"), ("SCTP-MIB", "sctpAssocRemAddrRtx"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpPerAssocStatsGroup = sctpPerAssocStatsGroup.setStatus('current')
if mibBuilder.loadTexts: sctpPerAssocStatsGroup.setDescription('Per Association Statistics group. It includes the objects to\n       collect flow control statistics per association.')
sctpInverseGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 104, 2, 2, 5)).setObjects(("SCTP-MIB", "sctpLookupLocalPortStartTime"), ("SCTP-MIB", "sctpLookupRemPortStartTime"), ("SCTP-MIB", "sctpLookupRemHostNameStartTime"), ("SCTP-MIB", "sctpLookupRemPrimIPAddrStartTime"), ("SCTP-MIB", "sctpLookupRemIPAddrStartTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpInverseGroup = sctpInverseGroup.setStatus('current')
if mibBuilder.loadTexts: sctpInverseGroup.setDescription('Objects used in the inverse lookup tables.')
sctpMibCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 104, 2, 1, 1)).setObjects(("SCTP-MIB", "sctpLayerParamsGroup"), ("SCTP-MIB", "sctpPerAssocParamsGroup"), ("SCTP-MIB", "sctpStatsGroup"), ("SCTP-MIB", "sctpPerAssocStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sctpMibCompliance = sctpMibCompliance.setStatus('current')
if mibBuilder.loadTexts: sctpMibCompliance.setDescription('The compliance statement for SNMP entities which implement\n       this SCTP MIB Module.\n\n       There are a number of INDEX objects that cannot be represented\n       in the form of OBJECT clauses in SMIv2, but for which we have\n       the following compliance requirements, expressed in OBJECT\n       clause form in this description clause:\n\n-- OBJECT        sctpAssocLocalAddrType\n-- SYNTAX        InetAddressType {ipv4(1), ipv6(2)}\n-- DESCRIPTION\n--       It is only required to have IPv4 and IPv6 addresses without\n--       zone indices.\n--       The address with zone indices is required if an\n--       implementation can connect multiple zones.\n--\n-- OBJECT        sctpAssocLocalAddr\n-- SYNTAX        InetAddress (SIZE(4|16))\n-- DESCRIPTION\n--       An implementation is only required to support globally\n--       unique IPv4 and IPv6 addresses.\n--\n-- OBJECT        sctpAssocRemAddrType\n-- SYNTAX        InetAddressType {ipv4(1), ipv6(2)}\n-- DESCRIPTION\n--       It is only required to have IPv4 and IPv6 addresses without\n--       zone indices.\n--       The address with zone indices is required if an\n--       implementation can connect multiple zones.\n--\n-- OBJECT        sctpAssocRemAddr\n-- SYNTAX        InetAddress (SIZE(4|16))\n-- DESCRIPTION\n--       An implementation is only required to support globally\n--       unique IPv4 and IPv6 addresses.\n--\n       ')
mibBuilder.exportSymbols("SCTP-MIB", sctpRtoMin=sctpRtoMin, sctpMibConformance=sctpMibConformance, sctpAssocRemAddrEntry=sctpAssocRemAddrEntry, sctpOutOrderChunks=sctpOutOrderChunks, sctpOutSCTPPacks=sctpOutSCTPPacks, sctpStatsGroup=sctpStatsGroup, sctpAssocT2expireds=sctpAssocT2expireds, sctpAssocLocalAddrEntry=sctpAssocLocalAddrEntry, sctpAssocPrimProcess=sctpAssocPrimProcess, sctpChecksumErrors=sctpChecksumErrors, sctpAssocLocalAddrTable=sctpAssocLocalAddrTable, sctpInverseGroup=sctpInverseGroup, sctpInCtrlChunks=sctpInCtrlChunks, sctpShutdowns=sctpShutdowns, sctpLookupRemHostNameTable=sctpLookupRemHostNameTable, sctpMibGroups=sctpMibGroups, sctpRtoInitial=sctpRtoInitial, sctpLookupRemPortTable=sctpLookupRemPortTable, sctpAssocRemAddrRTO=sctpAssocRemAddrRTO, sctpActiveEstabs=sctpActiveEstabs, sctpFragUsrMsgs=sctpFragUsrMsgs, sctpAssocEntry=sctpAssocEntry, sctpAssocTable=sctpAssocTable, sctpLookupLocalPortStartTime=sctpLookupLocalPortStartTime, sctpAssocLocalPort=sctpAssocLocalPort, sctpObjects=sctpObjects, sctpInSCTPPacks=sctpInSCTPPacks, sctpAssocOutStreams=sctpAssocOutStreams, sctpLookupRemIPAddrTable=sctpLookupRemIPAddrTable, sctpInOrderChunks=sctpInOrderChunks, sctpAssocRemAddrType=sctpAssocRemAddrType, sctpAssocStartTime=sctpAssocStartTime, sctpAssocDiscontinuityTime=sctpAssocDiscontinuityTime, sctpParams=sctpParams, sctpLookupRemPortStartTime=sctpLookupRemPortStartTime, sctpLookupLocalPortEntry=sctpLookupLocalPortEntry, sctpAssocInStreams=sctpAssocInStreams, sctpPassiveEstabs=sctpPassiveEstabs, sctpAssocRemAddrMaxPathRtx=sctpAssocRemAddrMaxPathRtx, sctpInUnorderChunks=sctpInUnorderChunks, sctpPerAssocParamsGroup=sctpPerAssocParamsGroup, sctpAssocRemPrimAddr=sctpAssocRemPrimAddr, sctpLookupRemIPAddrEntry=sctpLookupRemIPAddrEntry, sctpAssocRemAddrStartTime=sctpAssocRemAddrStartTime, sctpAssocHeartBeatInterval=sctpAssocHeartBeatInterval, sctpAssocRemAddr=sctpAssocRemAddr, sctpOutUnorderChunks=sctpOutUnorderChunks, sctpValCookieLife=sctpValCookieLife, sctpAssocRemPrimAddrType=sctpAssocRemPrimAddrType, sctpLookupRemPortEntry=sctpLookupRemPortEntry, sctpRtoMax=sctpRtoMax, sctpAssocRemHostName=sctpAssocRemHostName, sctpAssocRemPort=sctpAssocRemPort, sctpAssocRemAddrHBActive=sctpAssocRemAddrHBActive, sctpAssocRtxChunks=sctpAssocRtxChunks, sctpAssocRemAddrRtx=sctpAssocRemAddrRtx, sctpLookupRemPrimIPAddrEntry=sctpLookupRemPrimIPAddrEntry, sctpPerAssocStatsGroup=sctpPerAssocStatsGroup, sctpMibCompliances=sctpMibCompliances, sctpAssocLocalAddrStartTime=sctpAssocLocalAddrStartTime, sctpMaxInitRetr=sctpMaxInitRetr, sctpStats=sctpStats, sctpAssocMaxRetr=sctpAssocMaxRetr, sctpCurrEstab=sctpCurrEstab, sctpMibCompliance=sctpMibCompliance, sctpAssocRemAddrActive=sctpAssocRemAddrActive, sctpRtoAlgorithm=sctpRtoAlgorithm, sctpLookupRemPrimIPAddrStartTime=sctpLookupRemPrimIPAddrStartTime, sctpLookupLocalPortTable=sctpLookupLocalPortTable, sctpLookupRemHostNameStartTime=sctpLookupRemHostNameStartTime, sctpAborteds=sctpAborteds, sctpDiscontinuityTime=sctpDiscontinuityTime, sctpLookupRemHostNameEntry=sctpLookupRemHostNameEntry, sctpAssocT1expireds=sctpAssocT1expireds, sctpLookupRemIPAddrStartTime=sctpLookupRemIPAddrStartTime, sctpLookupRemPrimIPAddrTable=sctpLookupRemPrimIPAddrTable, sctpLayerParamsGroup=sctpLayerParamsGroup, sctpMIB=sctpMIB, sctpAssocId=sctpAssocId, sctpAssocRemAddrTable=sctpAssocRemAddrTable, sctpOutCtrlChunks=sctpOutCtrlChunks, sctpAssocState=sctpAssocState, sctpOutOfBlues=sctpOutOfBlues, PYSNMP_MODULE_ID=sctpMIB, sctpMaxAssocs=sctpMaxAssocs, sctpAssocLocalAddr=sctpAssocLocalAddr, sctpAssocLocalAddrType=sctpAssocLocalAddrType, sctpReasmUsrMsgs=sctpReasmUsrMsgs)
