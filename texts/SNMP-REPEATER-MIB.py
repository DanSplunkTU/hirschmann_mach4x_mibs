#
# PySNMP MIB module SNMP-REPEATER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/SNMP-REPEATER-MIB
# Produced by pysmi-1.1.3 at Wed Dec  8 20:19:01 2021
# On host fv-az42-142 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, ModuleIdentity, Integer32, NotificationType, Bits, Counter64, MibIdentifier, Counter32, Gauge32, NotificationType, IpAddress, mib_2, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "ModuleIdentity", "Integer32", "NotificationType", "Bits", "Counter64", "MibIdentifier", "Counter32", "Gauge32", "NotificationType", "IpAddress", "mib-2", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
snmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 2, 1, 22))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

rptrBasicPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1))
rptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2))
rptrAddrTrackPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3))
rptrRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 1))
rptrGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 2))
rptrPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 3))
rptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 1))
rptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 2))
rptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 3))
rptrAddrTrackRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 1))
rptrAddrTrackGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 2))
rptrAddrTrackPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 3))
rptrGroupCapacity = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupCapacity.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aRepeaterGroupCapacity.')
if mibBuilder.loadTexts: rptrGroupCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupCapacity.setDescription('The rptrGroupCapacity is the number of groups\n               that can be contained within the repeater.  Within\n               each managed repeater, the groups are uniquely\n               numbered in the range from 1 to rptrGroupCapacity.\n\n               Some groups may not be present in the repeater, in\n               which case the actual number of groups present\n               will be less than rptrGroupCapacity.  The number\n               of groups present will never be greater than\n               rptrGroupCapacity.\n\n               Note:  In practice, this will generally be the\n               number of field-replaceable units (i.e., modules,\n               cards, or boards) that can fit in the physical\n               repeater enclosure, and the group numbers will\n               correspond to numbers marked on the physical\n               enclosure.')
rptrOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrOperStatus.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aRepeaterHealthState.')
if mibBuilder.loadTexts: rptrOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrOperStatus.setDescription("The rptrOperStatus object indicates the\n               operational state of the repeater.  The\n               rptrHealthText object may be consulted for more\n               specific information about the state of the\n               repeater's health.\n\n               In the case of multiple kinds of failures (e.g.,\n               repeater failure and port failure), the value of\n               this attribute shall reflect the highest priority\n               failure in the following order, listed highest\n               priority first:\n\n                   rptrFailure(3)\n                   groupFailure(4)\n                   portFailure(5)\n                   generalFailure(6).")
rptrHealthText = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrHealthText.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aRepeaterHealthText.')
if mibBuilder.loadTexts: rptrHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: rptrHealthText.setDescription('The health text object is a text string that\n               provides information relevant to the operational\n               state of the repeater.  Agents may use this string\n               to provide detailed information on current\n               failures, including how they were detected, and/or\n               instructions for problem resolution.  The contents\n               are agent-specific.')
rptrReset = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrReset.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.3,\n               acResetRepeater.')
if mibBuilder.loadTexts: rptrReset.setStatus('mandatory')
if mibBuilder.loadTexts: rptrReset.setDescription('Setting this object to reset(2) causes a\n               transition to the START state of Fig 9-2 in\n               section 9 [IEEE 802.3 Std].\n\n               Setting this object to noReset(1) has no effect.\n               The agent will always return the value noReset(1)\n               when this object is read.\n\n               After receiving a request to set this variable to\n               reset(2), the agent is allowed to delay the reset\n               for a short period.  For example, the implementor\n               may choose to delay the reset long enough to allow\n               the SNMP response to be transmitted.  In any\n               event, the SNMP response must be transmitted.\n\n               This action does not reset the management counters\n               defined in this document nor does it affect the\n               portAdminStatus parameters.  Included in this\n               action is the execution of a disruptive Self-Test\n               with the following characteristics:  a) The nature\n               of the tests is not specified.  b) The test resets\n               the repeater but without affecting management\n               information about the repeater.  c) The test does\n               not inject packets onto any segment.  d) Packets\n               received during the test may or may not be\n               transferred.  e) The test does not interfere with\n               management functions.\n\n               After performing this self-test, the agent will\n               update the repeater health information (including\n               rptrOperStatus and rptrHealthText), and send a\n               rptrHealth trap.')
rptrNonDisruptTest = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrNonDisruptTest.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.3,\n               acExecuteNonDisruptiveSelfTest.')
if mibBuilder.loadTexts: rptrNonDisruptTest.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNonDisruptTest.setDescription("Setting this object to selfTest(2) causes the\n               repeater to perform a agent-specific, non-\n               disruptive self-test that has the following\n               characteristics:  a) The nature of the tests is\n               not specified.  b) The test does not change the\n               state of the repeater or management information\n               about the repeater.  c) The test does not inject\n               packets onto any segment.  d) The test does not\n               prevent the relay of any packets.  e) The test\n               does not interfere with management functions.\n\n               After performing this test, the agent will update\n               the repeater health information (including\n               rptrOperStatus and rptrHealthText) and send a\n               rptrHealth trap.\n\n               Note that this definition allows returning an\n               'okay' result after doing a trivial test.\n\n               Setting this object to noSelfTest(1) has no\n               effect.  The agent will always return the value\n               noSelfTest(1) when this object is read.")
rptrTotalPartitionedPorts = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setDescription('This object returns the total number of ports in\n               the repeater whose current state meets all three\n               of the following criteria:  rptrPortOperStatus\n               does not have the value notPresent(3),\n               rptrPortAdminStatus is enabled(1), and\n               rptrPortAutoPartitionState is autoPartitioned(2).')
rptrGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 2, 1), )
if mibBuilder.loadTexts: rptrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupTable.setDescription('Table of descriptive and status information about\n               the groups of ports.')
rptrGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupEntry.setDescription('An entry in the table, containing information\n               about a single group of ports.')
rptrGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.5.2,\n               aGroupID.')
if mibBuilder.loadTexts: rptrGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupIndex.setDescription('This object identifies the group within the\n               repeater for which this entry contains\n               information.  This value is never greater than\n               rptrGroupCapacity.')
rptrGroupDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupDescr.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupDescr.setDescription("A textual description of the group.  This value\n               should include the full name and version\n               identification of the group's hardware type and\n               indicate how the group is differentiated from\n               other types of groups in the repeater.  Plug-in\n               Module, Rev A' or 'Barney Rubble 10BASE-T 4-port\n               SIMM socket Version 2.1' are examples of valid\n               group descriptions.\n\n               It is mandatory that this only contain printable\n               ASCII characters.")
rptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupObjectID.setDescription("The vendor's authoritative identification of the\n               group.  This value may be allocated within the SMI\n               enterprises subtree (1.3.6.1.4.1) and provides a\n               straight-forward and unambiguous means for\n               determining what kind of group is being managed.\n\n               For example, this object could take the value\n               1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones,\n               Inc.' was assigned the subtree 1.3.6.1.4.1.4242,\n               and had assigned the identifier\n               1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone\n               6-Port FOIRL Plug-in Module.'")
rptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupOperStatus.setDescription('An object that indicates the operational status\n               of the group.\n\n               A status of notPresent(4) indicates that the group\n               is temporarily or permanently physically and/or\n               logically not a part of the repeater.  It is an\n               implementation-specific matter as to whether the\n               agent effectively removes notPresent entries from\n               the table.\n\n               A status of operational(2) indicates that the\n               group is functioning, and a status of\n               malfunctioning(3) indicates that the group is\n               malfunctioning in some way.')
rptrGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setDescription("An object that contains the value of sysUpTime at\n               the time that the value of the rptrGroupOperStatus\n               object for this group last changed.\n\n               A value of zero indicates that the group's\n               operational status has not changed since the agent\n               last restarted.")
rptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupPortCapacity.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.5.2,\n               aGroupPortCapacity.')
if mibBuilder.loadTexts: rptrGroupPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupPortCapacity.setDescription('The rptrGroupPortCapacity is the number of ports\n               that can be contained within the group.  Valid\n               range is 1-1024.  Within each group, the ports are\n               uniquely numbered in the range from 1 to\n               rptrGroupPortCapacity.\n\n               Note:  In practice, this will generally be the\n               number of ports on a module, card, or board, and\n               the port numbers will correspond to numbers marked\n               on the physical embodiment.')
rptrPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 3, 1), )
if mibBuilder.loadTexts: rptrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortTable.setDescription('Table of descriptive and status information about\n               the ports.')
rptrPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrPortIndex"))
if mibBuilder.loadTexts: rptrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortEntry.setDescription('An entry in the table, containing information\n               about a single port.')
rptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortGroupIndex.setDescription('This object identifies the group containing the\n               port for which this entry contains information.')
rptrPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortID.')
if mibBuilder.loadTexts: rptrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortIndex.setDescription('This object identifies the port within the group\n               for which this entry contains information.  This\n               value can never be greater than\n               rptrGroupPortCapacity for the associated group.')
rptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrPortAdminStatus.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortAdminState and 19.2.6.3, acPortAdminControl.')
if mibBuilder.loadTexts: rptrPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAdminStatus.setDescription("Setting this object to disabled(2) disables the\n               port.  A disabled port neither transmits nor\n               receives.  Once disabled, a port must be\n               explicitly enabled to restore operation.  A port\n               which is disabled when power is lost or when a\n               reset is exerted shall remain disabled when normal\n               operation resumes.\n\n               The admin status takes precedence over auto-\n               partition and functionally operates between the\n               auto-partition mechanism and the AUI/PMA.\n\n               Setting this object to enabled(1) enables the port\n               and exerts a BEGIN on the port's auto-partition\n               state machine.\n\n               (In effect, when a port is disabled, the value of\n               rptrPortAutoPartitionState for that port is frozen\n               until the port is next enabled.  When the port\n               becomes enabled, the rptrPortAutoPartitionState\n               becomes notAutoPartitioned(1), regardless of its\n               pre-disabling state.)")
rptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aAutoPartitionState.')
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the\n               port is currently partitioned by the repeater's\n               auto-partition protection.\n\n               The conditions that cause port partitioning are\n               specified in partition state machine in Section 9\n               [IEEE 802.3 Std].  They are not differentiated\n               here.")
rptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortOperStatus.setDescription("This object indicates the port's operational\n               status.  The notPresent(3) status indicates the\n               port is physically removed (note this may or may\n               not be possible depending on the type of port.)\n               The operational(1) status indicates that the port\n               is enabled (see rptrPortAdminStatus) and working,\n               even though it might be auto-partitioned (see\n               rptrPortAutoPartitionState).\n\n               If this object has the value operational(1) and\n               rptrPortAdminStatus is set to disabled(2), it is\n               expected that this object's value will soon change\n               to notOperational(2).")
rptrMonitorTransmitCollisions = MibScalar((1, 3, 6, 1, 2, 1, 22, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aTransmitCollisions.')
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setDescription('This counter is incremented every time the\n               repeater state machine enters the TRANSMIT\n               COLLISION state from any state other than ONE PORT\n               LEFT (Ref: Fig 9-2, IEEE 802.3 Std).\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours.')
rptrMonitorGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 2, 1), )
if mibBuilder.loadTexts: rptrMonitorGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTable.setDescription('Table of performance and error statistics for the\n               groups.')
rptrMonitorGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorGroupIndex"))
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setDescription("An entry in the table, containing total\n               performance and error statistics for a single\n               group.  Regular retrieval of the information in\n               this table provides a means of tracking the\n               performance and health of the networked devices\n               attached to this group's ports.\n\n               The counters in this table are redundant in the\n               sense that they are the summations of information\n               already available through other objects.  However,\n               these sums provide a considerable optimization of\n               network management traffic over the otherwise\n               necessary retrieval of the individual counters\n               included in each sum.")
rptrMonitorGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setDescription('This object identifies the group within the\n               repeater for which this entry contains\n               information.')
rptrMonitorGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setDescription('The total number of frames of valid frame length\n               that have been received on the ports in this group\n               and for which the FCSError and CollisionEvent\n               signals were not asserted.  This counter is the\n               summation of the values of the\n               rptrMonitorPortReadableFrames counters for all of\n               the ports in the group.\n\n               This statistic provides one of the parameters\n               necessary for obtaining the packet error rate.\n               The approximate minimum time for rollover of this\n               counter is 80 hours.')
rptrMonitorGroupTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setDescription('The total number of octets contained in the valid\n               frames that have been received on the ports in\n               this group.  This counter is the summation of the\n               values of the rptrMonitorPortReadableOctets\n               counters for all of the ports in the group.\n\n               This statistic provides an indicator of the total\n               data transferred.  The approximate minimum time\n               for rollover of this counter is 58 minutes.')
rptrMonitorGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setDescription('The total number of errors which have occurred on\n               all of the ports in this group.  This counter is\n               the summation of the values of the\n               rptrMonitorPortTotalErrors counters for all of the\n               ports in the group.')
rptrMonitorPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 3, 1), )
if mibBuilder.loadTexts: rptrMonitorPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortTable.setDescription('Table of performance and error statistics for the\n               ports.')
rptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrMonitorPortIndex"))
if mibBuilder.loadTexts: rptrMonitorPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortEntry.setDescription('An entry in the table, containing performance and\n               error statistics for a single port.')
rptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setDescription('This object identifies the group containing the\n               port for which this entry contains information.')
rptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortID.')
if mibBuilder.loadTexts: rptrMonitorPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortIndex.setDescription('This object identifies the port within the group\n               for which this entry contains information.')
rptrMonitorPortReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aReadableFrames.')
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setDescription('This object is the number of frames of valid\n               frame length that have been received on this port.\n               This counter is incremented by one for each frame\n               received on this port whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: IEEE 802.3 Std,\n               4.4.2.1) and for which the FCSError and\n               CollisionEvent signals are not asserted.\n\n               This statistic provides one of the parameters\n               necessary for obtaining the packet error rate.\n               The approximate minimum time for rollover of this\n               counter is 80 hours.')
rptrMonitorPortReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aReadableOctets.')
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setDescription('This object is the number of octets contained in\n               valid frames that have been received on this port.\n               This counter is incremented by OctetCount for each\n               frame received on this port which has been\n               determined to be a readable frame (i.e., including\n               FCS octets but excluding framing bits and dribble\n               bits).\n\n               This statistic provides an indicator of the total\n               data transferred.  The approximate minimum time\n               for rollover of this counter is 58 minutes.')
rptrMonitorPortFCSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aFrameCheckSequenceErrors.')
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setDescription('This counter is incremented by one for each frame\n               received on this port with the FCSError signal\n               asserted and the FramingError and CollisionEvent\n               signals deasserted and whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3\n               Std).\n\n               The approximate minimum time for rollover of this\n               counter is 80 hours.')
rptrMonitorPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aAlignmentErrors.')
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setDescription('This counter is incremented by one for each frame\n               received on this port with the FCSError and\n               FramingError signals asserted and CollisionEvent\n               signal deasserted and whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: IEEE 802.3 Std,\n               4.4.2.1).  If rptrMonitorPortAlignmentErrors is\n               incremented then the rptrMonitorPortFCSErrors\n               Counter shall not be incremented for the same\n               frame.\n\n               The approximate minimum time for rollover of this\n               counter is 80 hours.')
rptrMonitorPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aFramesTooLong.')
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setDescription('This counter is incremented by one for each frame\n               received on this port whose OctetCount is greater\n               than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std).\n               If rptrMonitorPortFrameTooLongs is incremented\n               then neither the rptrMonitorPortAlignmentErrors\n               nor the rptrMonitorPortFCSErrors counter shall be\n               incremented for the frame.\n\n               The approximate minimum time for rollover of this\n               counter is 61 days.')
rptrMonitorPortShortEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aShortEvents.')
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setDescription('This counter is incremented by one for each\n               CarrierEvent on this port with ActivityDuration\n               less than ShortEventMaxTime.  ShortEventMaxTime is\n               greater than 74 bit times and less than 82 bit\n               times.  ShortEventMaxTime has tolerances included\n               to provide for circuit losses between a\n               conformance test point at the AUI and the\n               measurement point within the state machine.\n\n               Note:  shortEvents may indicate externally\n               generated noise hits which will cause the repeater\n               to transmit Runts to its other ports, or propagate\n               a collision (which may be late) back to the\n               transmitting DTE and damaged frames to the rest of\n               the network.\n\n               Implementors may wish to consider selecting the\n               ShortEventMaxTime towards the lower end of the\n               allowed tolerance range to accommodate bit losses\n               suffered through physical channel devices not\n               budgeted for within this standard.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours.')
rptrMonitorPortRunts = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortRunts.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aRunts.')
if mibBuilder.loadTexts: rptrMonitorPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortRunts.setDescription('This counter is incremented by one for each\n               CarrierEvent on this port that meets one of the\n               following two conditions.  Only one test need be\n               made.  a) The ActivityDuration is greater than\n               ShortEventMaxTime and less than ValidPacketMinTime\n               and the CollisionEvent signal is deasserted.  b)\n               The OctetCount is less than 64, the\n               ActivityDuration is greater than ShortEventMaxTime\n               and the CollisionEvent signal is deasserted.\n               ValidPacketMinTime is greater than or equal to 552\n               bit times and less than 565 bit times.\n\n               An event whose length is greater than 74 bit times\n               but less than 82 bit times shall increment either\n               the shortEvents counter or the runts counter but\n               not both.  A CarrierEvent greater than or equal to\n               552 bit times but less than 565 bit times may or\n               may not be counted as a runt.\n\n               ValidPacketMinTime has tolerances included to\n               provide for circuit losses between a conformance\n               test point at the AUI and the measurement point\n               within the state machine.\n\n               Runts usually indicate collision fragments, a\n               normal network event.  In certain situations\n               associated with large diameter networks a\n               percentage of collision fragments may exceed\n               ValidPacketMinTime.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours.')
rptrMonitorPortCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aCollisions.')
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setDescription('This counter is incremented by one for any\n               CarrierEvent signal on any port for which the\n               CollisionEvent signal on this port is also\n               asserted.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours.')
rptrMonitorPortLateEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aLateEvents.')
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setDescription('This counter is incremented by one for each\n               CarrierEvent on this port in which the CollIn(X)\n               variable transitions to the value SQE (Ref:\n               9.6.6.2, IEEE 802.3 Std) while the\n               ActivityDuration is greater than the\n               LateEventThreshold.  Such a CarrierEvent is\n               counted twice, as both a collision and as a\n               lateEvent.\n\n               The LateEventThreshold is greater than 480 bit\n               times and less than 565 bit times.\n               LateEventThreshold has tolerances included to\n               permit an implementation to build a single\n               threshold to serve as both the LateEventThreshold\n               and ValidPacketMinTime threshold.\n\n               The approximate minimum time for rollover of this\n               counter is 81 hours.')
rptrMonitorPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aVeryLongEvents.')
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setDescription('This counter is incremented by one for each\n               CarrierEvent on this port whose ActivityDuration\n               is greater than the MAU Jabber Lockup Protection\n               timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std).\n               Other counters may be incremented as appropriate.')
rptrMonitorPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aDataRateMismatches.')
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setDescription("This counter is incremented by one for each frame\n               received on this port that meets all of the\n               following conditions:  a) The CollisionEvent\n               signal is not asserted.  b) The ActivityDuration\n               is greater than ValidPacketMinTime.  c) The\n               frequency (data rate) is detectably mismatched\n               from the local transmit frequency.  The exact\n               degree of mismatch is vendor specific and is to be\n               defined by the vendor for conformance testing.\n\n               When this event occurs, other counters whose\n               increment conditions were satisfied may or may not\n               also be incremented, at the implementor's\n               discretion.  Whether or not the repeater was able\n               to maintain data integrity is beyond the scope of\n               this standard.")
rptrMonitorPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aAutoPartitions.')
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setDescription('This counter is incremented by one for each time\n               the repeater has automatically partitioned this\n               port.  The conditions that cause port partitioning\n               are specified in the partition state machine in\n               Section 9 [IEEE 802.3 Std].  They are not\n               differentiated here.')
rptrMonitorPortTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setDescription('The total number of errors which have occurred on\n               this port.  This counter is the summation of the\n               values of other error counters (for the same\n               port), namely:\n\n                   rptrMonitorPortFCSErrors,\n                   rptrMonitorPortAlignmentErrors,\n                   rptrMonitorPortFrameTooLongs,\n                   rptrMonitorPortShortEvents,\n                   rptrMonitorPortLateEvents,\n                   rptrMonitorPortVeryLongEvents, and\n                   rptrMonitorPortDataRateMismatches.\n\n               This counter is redundant in the sense that it is\n               the summation of information already available\n               through other objects.  However, it is included\n               specifically because the regular retrieval of this\n               object as a means of tracking the health of a port\n               provides a considerable optimization of network\n               management traffic over the otherwise necessary\n               retrieval of the summed counters.')
rptrAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 3, 1), )
if mibBuilder.loadTexts: rptrAddrTrackTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackTable.setDescription('Table of address mapping information about the\n               ports.')
rptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"))
if mibBuilder.loadTexts: rptrAddrTrackEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackEntry.setDescription('An entry in the table, containing address mapping\n               information about a single port.')
rptrAddrTrackGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setDescription('This object identifies the group containing the\n               port for which this entry contains information.')
rptrAddrTrackPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortID.')
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setDescription('This object identifies the port within the group\n               for which this entry contains information.')
rptrAddrTrackLastSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aLastSourceAddress.')
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setStatus('deprecated')
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setDescription('This object is the SourceAddress of the last\n               readable frame (i.e., counted by\n               rptrMonitorPortReadableFrames) received by this\n               port.\n\n               This object has been deprecated because its value\n               is undefined when no frames have been observed on\n               this port.  The replacement object is\n               rptrAddrTrackNewLastSrcAddress.')
rptrAddrTrackSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aSourceAddressChanges.')
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setDescription('This counter is incremented by one for each time\n               that the rptrAddrTrackLastSourceAddress attribute\n               for this port has changed.\n\n               This may indicate whether a link is connected to a\n               single DTE or another multi-user segment.\n\n               The approximate minimum time for rollover of this\n               counter is 81 hours.')
rptrAddrTrackNewLastSrcAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackNewLastSrcAddress.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aLastSourceAddress.')
if mibBuilder.loadTexts: rptrAddrTrackNewLastSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackNewLastSrcAddress.setDescription('This object is the SourceAddress of the last\n               readable frame (i.e., counted by\n               rptrMonitorPortReadableFrames) received by this\n               port.  If no frames have been received by this\n               port since the agent began monitoring the port\n               activity, the agent shall return a string of\n               length zero.')
rptrHealth = NotificationType((1, 3, 6, 1, 2, 1, 22) + (0,1)).setObjects(("SNMP-REPEATER-MIB", "rptrOperStatus"))
if mibBuilder.loadTexts: rptrHealth.setDescription("The rptrHealth trap conveys information related\n               to the operational status of the repeater.  This\n               trap is sent either when the value of\n               rptrOperStatus changes, or upon completion of a\n               non-disruptive test.\n\n               The rptrHealth trap must contain the\n               rptrOperStatus object.  The agent may optionally\n               include the rptrHealthText object in the varBind\n               list.  See the rptrOperStatus and rptrHealthText\n               objects for descriptions of the information that\n               is sent.\n\n               The agent must throttle the generation of\n               consecutive rptrHealth traps so that there is at\n               least a five-second gap between traps of this\n               type.  When traps are throttled, they are dropped,\n               not queued for sending at a future time.  (Note\n               that 'generating' a trap means sending to all\n               configured recipients.)")
if mibBuilder.loadTexts: rptrHealth.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.4,\n               hubHealth notification.')
rptrGroupChange = NotificationType((1, 3, 6, 1, 2, 1, 22) + (0,2)).setObjects(("SNMP-REPEATER-MIB", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupChange.setDescription("This trap is sent when a change occurs in the\n               group structure of a repeater.  This occurs only\n               when a group is logically or physically removed\n               from or added to a repeater.  The varBind list\n               contains the identifier of the group that was\n               removed or added.\n\n               The agent must throttle the generation of\n               consecutive rptrGroupChange traps for the same\n               group so that there is at least a five-second gap\n               between traps of this type.  When traps are\n               throttled, they are dropped, not queued for\n               sending at a future time.  (Note that 'generating'\n               a trap means sending to all configured\n               recipients.)")
if mibBuilder.loadTexts: rptrGroupChange.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.4,\n               groupMapChange notification.')
rptrResetEvent = NotificationType((1, 3, 6, 1, 2, 1, 22) + (0,3)).setObjects(("SNMP-REPEATER-MIB", "rptrOperStatus"))
if mibBuilder.loadTexts: rptrResetEvent.setDescription("The rptrResetEvent trap conveys information\n               related to the operational status of the repeater.\n               This trap is sent on completion of a repeater\n               reset action.  A repeater reset action is defined\n               as an a transition to the START state of Fig 9-2\n               in section 9 [IEEE 802.3 Std], when triggered by a\n               management command (e.g., an SNMP Set on the\n               rptrReset object).\n\n               The agent must throttle the generation of\n               consecutive rptrResetEvent traps so that there is\n               at least a five-second gap between traps of this\n               type.  When traps are throttled, they are dropped,\n               not queued for sending at a future time.  (Note\n               that 'generating' a trap means sending to all\n               configured recipients.)\n\n               The rptrResetEvent trap is not sent when the agent\n               restarts and sends an SNMP coldStart or warmStart\n               trap.  However, it is recommended that a repeater\n               agent send the rptrOperStatus object as an\n               optional object with its coldStart and warmStart\n               trap PDUs.\n\n               The rptrOperStatus object must be included in the\n               varbind list sent with this trap.  The agent may\n               optionally include the rptrHealthText object as\n               well.")
if mibBuilder.loadTexts: rptrResetEvent.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.4, hubReset\n               notification.')
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", rptrMonitorPortFCSErrors=rptrMonitorPortFCSErrors, rptrPortEntry=rptrPortEntry, rptrPortAdminStatus=rptrPortAdminStatus, rptrMonitorPortInfo=rptrMonitorPortInfo, rptrAddrTrackTable=rptrAddrTrackTable, rptrResetEvent=rptrResetEvent, rptrMonitorPortVeryLongEvents=rptrMonitorPortVeryLongEvents, rptrMonitorPortDataRateMismatches=rptrMonitorPortDataRateMismatches, rptrPortTable=rptrPortTable, rptrMonitorPortRunts=rptrMonitorPortRunts, rptrMonitorPortFrameTooLongs=rptrMonitorPortFrameTooLongs, rptrPortGroupIndex=rptrPortGroupIndex, rptrAddrTrackNewLastSrcAddress=rptrAddrTrackNewLastSrcAddress, rptrGroupChange=rptrGroupChange, rptrOperStatus=rptrOperStatus, rptrMonitorRptrInfo=rptrMonitorRptrInfo, rptrBasicPackage=rptrBasicPackage, rptrGroupOperStatus=rptrGroupOperStatus, rptrMonitorGroupTotalFrames=rptrMonitorGroupTotalFrames, rptrMonitorGroupTotalOctets=rptrMonitorGroupTotalOctets, rptrAddrTrackSourceAddrChanges=rptrAddrTrackSourceAddrChanges, rptrAddrTrackPortIndex=rptrAddrTrackPortIndex, rptrMonitorGroupIndex=rptrMonitorGroupIndex, rptrMonitorPortEntry=rptrMonitorPortEntry, rptrMonitorPortReadableFrames=rptrMonitorPortReadableFrames, rptrAddrTrackGroupInfo=rptrAddrTrackGroupInfo, rptrReset=rptrReset, rptrMonitorTransmitCollisions=rptrMonitorTransmitCollisions, rptrMonitorGroupTotalErrors=rptrMonitorGroupTotalErrors, rptrAddrTrackLastSourceAddress=rptrAddrTrackLastSourceAddress, rptrGroupDescr=rptrGroupDescr, rptrNonDisruptTest=rptrNonDisruptTest, rptrMonitorGroupEntry=rptrMonitorGroupEntry, rptrAddrTrackEntry=rptrAddrTrackEntry, rptrMonitorGroupInfo=rptrMonitorGroupInfo, rptrAddrTrackPackage=rptrAddrTrackPackage, rptrTotalPartitionedPorts=rptrTotalPartitionedPorts, MacAddress=MacAddress, rptrAddrTrackRptrInfo=rptrAddrTrackRptrInfo, rptrMonitorGroupTable=rptrMonitorGroupTable, rptrMonitorPortLateEvents=rptrMonitorPortLateEvents, rptrAddrTrackPortInfo=rptrAddrTrackPortInfo, rptrHealthText=rptrHealthText, rptrMonitorPortTotalErrors=rptrMonitorPortTotalErrors, rptrPortAutoPartitionState=rptrPortAutoPartitionState, rptrGroupInfo=rptrGroupInfo, rptrMonitorPortAutoPartitions=rptrMonitorPortAutoPartitions, rptrPortInfo=rptrPortInfo, rptrMonitorPortReadableOctets=rptrMonitorPortReadableOctets, rptrMonitorPackage=rptrMonitorPackage, rptrHealth=rptrHealth, rptrMonitorPortTable=rptrMonitorPortTable, rptrMonitorPortAlignmentErrors=rptrMonitorPortAlignmentErrors, rptrRptrInfo=rptrRptrInfo, rptrPortIndex=rptrPortIndex, rptrAddrTrackGroupIndex=rptrAddrTrackGroupIndex, rptrGroupEntry=rptrGroupEntry, rptrGroupObjectID=rptrGroupObjectID, rptrPortOperStatus=rptrPortOperStatus, rptrGroupIndex=rptrGroupIndex, rptrGroupPortCapacity=rptrGroupPortCapacity, rptrMonitorPortCollisions=rptrMonitorPortCollisions, snmpDot3RptrMgt=snmpDot3RptrMgt, rptrMonitorPortGroupIndex=rptrMonitorPortGroupIndex, rptrGroupLastOperStatusChange=rptrGroupLastOperStatusChange, rptrMonitorPortIndex=rptrMonitorPortIndex, rptrMonitorPortShortEvents=rptrMonitorPortShortEvents, rptrGroupCapacity=rptrGroupCapacity, rptrGroupTable=rptrGroupTable)
