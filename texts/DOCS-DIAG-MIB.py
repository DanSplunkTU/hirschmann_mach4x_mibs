#
# PySNMP MIB module DOCS-DIAG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/DOCS-DIAG-MIB
# Produced by pysmi-1.1.8 at Tue Jan 11 20:23:43 2022
# On host fv-az42-180 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
clabProjDocsis, = mibBuilder.importSymbols("CLAB-DEF-MIB", "clabProjDocsis")
docsDevEvLevel, docsDevEvId = mibBuilder.importSymbols("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel", "docsDevEvId")
CmtsCmRegState, docsIf3CmtsCmRegStatusId = mibBuilder.importSymbols("DOCS-IF3-MIB", "CmtsCmRegState", "docsIf3CmtsCmRegStatusId")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
IpAddress, ModuleIdentity, iso, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Unsigned32, NotificationType, TimeTicks, ObjectIdentity, MibIdentifier, Bits, Integer32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "ModuleIdentity", "iso", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Unsigned32", "NotificationType", "TimeTicks", "ObjectIdentity", "MibIdentifier", "Bits", "Integer32", "Gauge32")
TextualConvention, MacAddress, DisplayString, TruthValue, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "DisplayString", "TruthValue", "DateAndTime")
docsDiagMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9))
docsDiagMib.setRevisions(('2006-12-07 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: docsDiagMib.setRevisionsDescriptions(('Initial version, published as part of the CableLabs\n            OSSIv3.0 specification CM-SP-OSSIv3.0-I01-061207',))
if mibBuilder.loadTexts: docsDiagMib.setLastUpdated('200612070000Z')
if mibBuilder.loadTexts: docsDiagMib.setOrganization('Cable Television Laboratories, Inc.')
if mibBuilder.loadTexts: docsDiagMib.setContactInfo('\n\t\t    Postal:\n\t\t        Cable Television Laboratories \n\t\t        858 Coal Creek Circle Louisville, CO 80027-9750\n                U.S.A. \n                Phone: +1 303-661-9100 \n                Fax: +1 303-661-9199 \n                E-mail: mibs@cablelabs.com')
if mibBuilder.loadTexts: docsDiagMib.setDescription('This is the MIB Module for the Diagnostic Log for\n            DOCSIS-compliant Cable Modem Termination Systems (CMTS). \n\n            The purpose of the Diagnostic Log is to prevent service\n            interruptions by early detection of potential problems.\n            It can also be used for fault management and for\n            troubleshooting the cable network.\n\n            The Diagnostic Log contains Cable Modems that show certain\n            potential problematic behaviors, as determined by the CMTS.\n            These detection criteria are defined as diagnostictriggers. \n\n            The diagnostic trigger is an information filter to avoid\n            inundating a management agent with data which is less\n            meaningful as a function of size. \n\n            There are 2 diagnostic triggers defined. Each trigger\n            maintains a counter for each Cable Modem that is caught\n            by that trigger. \n\n            (1) Registration Trigger \n\n            (2) Ranging Retry Trigger\n\n            Copyright 1999-2007 Cable Television Laboratories, Inc.\n            All rights reserved.')
class TriggerFlag(TextualConvention, Bits):
    description = 'This type defines the Diagnostic Log Trigger Type.\n            Bit 0 selects the registration trigger.\n            Bit 1 selects the ranging retry trigger.'
    status = 'current'
    namedValues = NamedValues(("registration", 0), ("rangingRetry", 1))

class RegistrationDetailFlag(TextualConvention, Bits):
    description = "This type defines a union of CM states or processes for\n            operations related to the registration trigger. \n\n            'other'\n            any state other than the following \n\n            'initialRanging'\n            indicates the 'Initial Ranging' state \n\n            'rangingAutoAdjComplete'\n            indicates the 'Ranging Auto Adjustment Complete' state \n\n            'startEae'\n            indicates the 'Start EAE' state \n\n            'startDhcpv4'\n            indicates the 'Start DHCPv4' state \n\n            'startDhcpv6'\n            indicates the 'Start DHCPv6' state \n\n            'dhcpv4Complete'\n            indicates the 'DHCPv4 Complete' state \n\n            'dhcpv6Complete'\n            indicates the 'DHCPv6 Complete' state \n\n            'startConfigFileDownload'\n            indicates the 'Start Config File Download' state \n\n            'configFileDownloadComplete'\n            indicates the 'Config File Download Complete' state \n\n            'startRegistration' \n            indicates the 'Start Registration' state \n\n            'registrationComplete'\n            indicates the 'Registration Complete' state \n\n            'bpiInit'\n            indicates the 'BPI Initialization' state \n\n            'operational'\n            indicates the 'Operational' state."
    status = 'current'
    namedValues = NamedValues(("other", 0), ("initialRanging", 1), ("rangingAutoAdjComplete", 2), ("startEae", 3), ("startDhcpv4", 4), ("startDhcpv6", 5), ("dhcpv4Complete", 6), ("dhcpv6Complete", 7), ("startConfigFileDownload", 8), ("configFileDownloadComplete", 9), ("startRegistration", 10), ("registrationCmplete", 11), ("bpiInit", 12), ("operational", 13))

docsDiagLogNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0))
docsDiagLogMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1))
docsDiagLogGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1))
docsDiagLogTriggersCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2))
docsDiagLogMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(100)).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogMaxSize.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogMaxSize.setDescription('The maximum number of Cable Modem entries that \n            docsDiagLogTable can report.')
docsDiagLogCurrentSize = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogCurrentSize.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCurrentSize.setDescription('The total number of Cable Modem entries reported in the\n            docsDiagLogTable.\n            The maximum value possible will be docsDiagLogMaxSize.')
docsDiagLogNotifyLogSizeHighThrshld = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(80)).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeHighThrshld.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeHighThrshld.setDescription('If the number of entries in docsDiagLogTable exceeds\n            this value, CMTS will trigger the appropriate event.')
docsDiagLogNotifyLogSizeLowThrshld = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(60)).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeLowThrshld.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeLowThrshld.setDescription('If the number of entries in docsDiagLogTable exceeded\n            docsDiagLogNotifyLogSizeHighThrshld earlier and then drops\n            to this value, CMTS will trigger the appropriate event.')
docsDiagLogAging = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 86400)).clone(10080)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogAging.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogAging.setDescription('Aging threshold for the Diagnostic Log. Periodically, a\n            process scans through the Diagnostic log and removes those\n            Cable Modems from docsDiagLogTable and\n            docsDiagLogDetailTable that have no new detections for a\n            time interval longer than this threshold in minutes.')
docsDiagLogResetAll = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogResetAll.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogResetAll.setDescription("If set to 'true', all counter objects for\n            all entries in docsDiagLogTable and docsDiagLogDetailTable\n            are reset to zero. Reading this object always returns\n            'false'.")
docsDiagLogLastResetTime = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastResetTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastResetTime.setDescription("The last time that all the counters in the \n            docsDiagLogTable and docsDiagLogDetailTable are\n            reset to 0. The special value of all '00'Hs indicates\n            that the Entries in these tables have never been reset.")
docsDiagLogClearAll = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogClearAll.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogClearAll.setDescription("If set to 'true', all entries from the\n            docsDiagLogTable and docsDiagLogDetailTable are removed.\n            Reading this object always returns 'false'.")
docsDiagLogLastClearTime = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastClearTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastClearTime.setDescription("The last time that all the entries in the docsDiagLogTable\n            and docsDiagLogDetailTable are destroyed. The special\n            value of all '00'Hs indicates that the \n            entries in these tables have never been destroyed.")
docsDiagLogNotifCtrl = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 10), Bits().clone(namedValues=NamedValues(("highThresholdReached", 0), ("lowThresholdReached", 1), ("full", 2))).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogNotifCtrl.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotifCtrl.setDescription('Used to enable diagnostic log related notifications.\n\n            Setting bit 0 enables notification for reaching log size\n            high threshold, \n\n            Setting bit 1 enables notification for returning back to\n            log size low threshold after reaching log size high\n            threshold, \n\n            Setting bit 2 enables notification for diagnostic log size\n            full.')
docsDiagLogIncludeTriggers = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 1), TriggerFlag().clone(hexValue="C0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogIncludeTriggers.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogIncludeTriggers.setDescription("Turns individual diagnostic triggers on and off.\n            Multiple triggers can be turned on or off at a given time.\n            Setting a particular bit to '1' turns on correspon\n            dingdiagnostic trigger. Setting a particular bit to '0' turns\n            off corresponding diagnostic trigger.")
docsDiagLogEnableAgingTriggers = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 2), TriggerFlag().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogEnableAgingTriggers.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogEnableAgingTriggers.setDescription("Enables and disables the aging of triggers\n            based on the trigger type. Aging out can be enabled or\n            disabled for multiple triggers at a given time. Setting\n            a particular bit to '1' enables the aging out of log\n            entries that are created by corresponding diagnostic\n            trigger. Setting a particular bit to '0' disables the\n            aging out of log entries that are created by corresponding\n            diagnostic trigger.")
docsDiagLogRegTimeInterval = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400)).clone(90)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRegTimeInterval.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRegTimeInterval.setDescription('Configurable parameter for the Registration trigger.\n            The registration time interval is an empirically derived,\n            worst-case number of seconds which the Cable Modem requires\n            to complete registration. If the Cable Modem has not\n            completed the registration stage within this registration\n            time interval, the Cable Modem will be added to the\n            Diagnostic Log.')
docsDiagLogRegDetail = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 4), RegistrationDetailFlag().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRegDetail.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRegDetail.setDescription('Setting a bit representing a CM registration state will\n            enable counting the number of times the CMTS determines\n            that such CM reaches that state as the last state before \n            failing to proceed further in the registration process and\n            within the time interval considered for the CM \n            registration trigger detection.\n        ')
docsDiagLogRangingRetryType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("consecutiveMiss", 1), ("missRatio", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRangingRetryType.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryType.setDescription("Configuration parameter for the Ranging Retry Trigger.\n            When a Cable Modem failed to perform ranging when a ranging\n            opportunity is scheduled by CMTS, it is counted as ranging\n            miss. \n            Ranging retry trigger can be configured to either look at\n            consecutive ranging misses or ranging miss ratio over\n            total number of station maintenance opportunities for a\n            certain time period. \n\n            If set to '1', this will select consecutive ranging\n            misses as ranging retry trigger criteria. \n\n            If set to '2', this will select ranging miss ratio\n            as ranging retry trigger criteria.")
docsDiagLogRangingRetryThrhld = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 12)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRangingRetryThrhld.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryThrhld.setDescription('Configurable parameter for the Ranging Retry Trigger.\n            When the number of times a Cable Modem does not acknowledge\n            a MAC-layer station maintenance message from a CMTS exceeds\n            this threshold, the Cable Modem will be add to the\n            Diagnostic Log.\n            The value of docsDiagLogRangingRetryType, decides if\n            consecutive ranging miss or ranging miss ratio is used as\n            trigger.')
docsDiagLogRangingRetryStationMaintNum = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 65535)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRangingRetryStationMaintNum.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryStationMaintNum.setDescription('Number of station maintenance opportunities to monitor for\n            ranging retry trigger. This value implies time intervals\n            in a certain range. DOCSIS requires the CMTS to schedule\n            ranging opportunity to Cable Modem sufficiently smaller\n            than T4. \n            There is no fixed formula to derive at a fixed time \n            interval, how many ranging opportunities would be offered\n            to a Cable Modem by the CMTS, hence using the number of\n            station maintenance opportunities provides ratio with the\n            fixed denominators while also taking time factor into\n            consideration.')
docsDiagLogTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3), )
if mibBuilder.loadTexts: docsDiagLogTable.setReference('DOCSIS 3.0 Operation and Support System Interface\n            Specification CM-SP-OSSIv3.0-I01-061207, Diagnostic LogAnnex.')
if mibBuilder.loadTexts: docsDiagLogTable.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogTable.setDescription('This table keeps the Diagnostic Log of the Cable Modems,\n            it is indexed by docsIf3CmtsCmRegStatusId.')
docsDiagLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1), ).setIndexNames((0, "DOCS-IF3-MIB", "docsIf3CmtsCmRegStatusId"))
if mibBuilder.loadTexts: docsDiagLogEntry.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogEntry.setDescription('A conceptual row entry in this table is a per Cable Modem\n            summary of the diagnostic information detected by one or\n            more triggers.\n            There can be only one entry in this for a given Cable\n            Modem.')
docsDiagLogCmMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogCmMacAddr.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCmMacAddr.setDescription('MAC address of the Cable Modem.')
docsDiagLogLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastUpdateTime.setDescription('The time and date value when this entry was last updated.\n            When a Cable Modem is detected by one of the diagnostic\n            trigger, if this table already has an entry for that\n            Cable Modem, the entry will be updated.')
docsDiagLogCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogCreateTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCreateTime.setDescription('The time and date value that this entry was added to this\n            table. When a Cable Modem is detected by one of the\n            diagnostic triggers, if this table has no entry for that\n            cable mode, a new entry will be created. If an entry is\n            removed and then re-added, there can be a discontinuity in\n            the statistical objects associated with this entry.\n            This timestamp can be used to detect those discontinuities.')
docsDiagLogLastRegTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 4), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastRegTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastRegTime.setDescription('The last time this Cable Modem registered.')
docsDiagLogRegCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogRegCount.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRegCount.setDescription('The number of times the registration trigger condition was\n            detected for this Cable Modem.')
docsDiagLogRangingRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogRangingRetryCount.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryCount.setDescription('The number of times the ranging retry trigger condition was\n            detected for this Cable Modem.')
docsDiagLogDetailTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4), )
if mibBuilder.loadTexts: docsDiagLogDetailTable.setReference('DOCSIS 3.0 Operation and Support System Interface\n            Specification CM-SP-OSSIv3.0-I01-061207, Diagnostic Log\n            Annex.')
if mibBuilder.loadTexts: docsDiagLogDetailTable.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailTable.setDescription('This table contains detailed diagnostic information\n            for Cable Modems already in docsDiagLogTable.')
docsDiagLogDetailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1), ).setIndexNames((0, "DOCS-IF3-MIB", "docsIf3CmtsCmRegStatusId"), (0, "DOCS-DIAG-MIB", "docsDiagLogDetailTypeValue"))
if mibBuilder.loadTexts: docsDiagLogDetailEntry.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailEntry.setDescription('A conceptual row in this table contains one single type of\n            detailed diagnostic information for a Cable Modem. \n\n            This table shall be instantiated only if at least one\n            detail condition is enabled, via docsDiagLogRegDetail. \n\n            There can be multiple entries in this table for a given\n            cable modem, if more than one detail condition is enabled.')
docsDiagLogDetailTypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 1), CmtsCmRegState())
if mibBuilder.loadTexts: docsDiagLogDetailTypeValue.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailTypeValue.setDescription('The diagnostic detail type this entry represents.')
docsDiagLogDetailCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogDetailCount.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailCount.setDescription('The counter value of this Cable Modem that reached \n            this diagnostic detail state as the last state before\n            it failed to proceed further.')
docsDiagLogDetailLastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogDetailLastUpdate.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailLastUpdate.setDescription('Time and date value when this entry was last updated.')
docsDiagLogDetailLastErrorText = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogDetailLastErrorText.setReference('DOCSIS 3.0 Operation and Support System Interface\n            Specification CM-SP-OSSIv3.0-I01-061207, Format and Content\n            for Event, Syslog, and SNMP Notification. Annex.')
if mibBuilder.loadTexts: docsDiagLogDetailLastErrorText.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailLastErrorText.setDescription('Contains the Event ID and Event Text of the event condition \n            that triggers this entry. The format is: \n            <Event ID> Event Text')
docsDiagLogSizeHighThrshldReached = NotificationType((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0, 1)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogMaxSize"))
if mibBuilder.loadTexts: docsDiagLogSizeHighThrshldReached.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogSizeHighThrshldReached.setDescription('This notification indicates that the current size of \n            Diagnostic Log grows beyond\n            docsDiagLogNotifyLogSizeHighThrshld.')
docsDiagLogSizeLowThrshldReached = NotificationType((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0, 2)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogMaxSize"))
if mibBuilder.loadTexts: docsDiagLogSizeLowThrshldReached.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogSizeLowThrshldReached.setDescription('This notification indicates that the current size of \n            Diagnostic Log drops to docsDiagLogNotifyLogSizeLowThrshld\n            after it exceeded docsDiagLogNotifyLogSizeHighThrshld\n            earlier.')
docsDiagLogSizeFull = NotificationType((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0, 3)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogMaxSize"))
if mibBuilder.loadTexts: docsDiagLogSizeFull.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogSizeFull.setDescription('This notification indicates that the Diagnostic Log is\n            full.')
docsDiagLogConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2))
docsDiagLogCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 1))
docsDiagLogGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 2))
docsDiagLogCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 1, 1)).setObjects(("DOCS-DIAG-MIB", "docsDiagLogBaseGroup"), ("DOCS-DIAG-MIB", "docsDiagLogNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDiagLogCompliance = docsDiagLogCompliance.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCompliance.setDescription('The compliance statement for the diagnostic log MIB for\n            DOCSIS compliant Cable Modem Termination Systems')
docsDiagLogBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 2, 1)).setObjects(("DOCS-DIAG-MIB", "docsDiagLogMaxSize"), ("DOCS-DIAG-MIB", "docsDiagLogCurrentSize"), ("DOCS-DIAG-MIB", "docsDiagLogNotifyLogSizeHighThrshld"), ("DOCS-DIAG-MIB", "docsDiagLogNotifyLogSizeLowThrshld"), ("DOCS-DIAG-MIB", "docsDiagLogAging"), ("DOCS-DIAG-MIB", "docsDiagLogResetAll"), ("DOCS-DIAG-MIB", "docsDiagLogLastResetTime"), ("DOCS-DIAG-MIB", "docsDiagLogClearAll"), ("DOCS-DIAG-MIB", "docsDiagLogLastClearTime"), ("DOCS-DIAG-MIB", "docsDiagLogNotifCtrl"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogEnableAgingTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogRegTimeInterval"), ("DOCS-DIAG-MIB", "docsDiagLogRegDetail"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryType"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryThrhld"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryStationMaintNum"), ("DOCS-DIAG-MIB", "docsDiagLogCmMacAddr"), ("DOCS-DIAG-MIB", "docsDiagLogLastUpdateTime"), ("DOCS-DIAG-MIB", "docsDiagLogCreateTime"), ("DOCS-DIAG-MIB", "docsDiagLogLastRegTime"), ("DOCS-DIAG-MIB", "docsDiagLogRegCount"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryCount"), ("DOCS-DIAG-MIB", "docsDiagLogDetailCount"), ("DOCS-DIAG-MIB", "docsDiagLogDetailLastUpdate"), ("DOCS-DIAG-MIB", "docsDiagLogDetailLastErrorText"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDiagLogBaseGroup = docsDiagLogBaseGroup.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogBaseGroup.setDescription('CMTS is required to support objects in this group')
docsDiagLogNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 2, 2)).setObjects(("DOCS-DIAG-MIB", "docsDiagLogSizeHighThrshldReached"), ("DOCS-DIAG-MIB", "docsDiagLogSizeLowThrshldReached"), ("DOCS-DIAG-MIB", "docsDiagLogSizeFull"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDiagLogNotificationGroup = docsDiagLogNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotificationGroup.setDescription('CMTS is required to support objects in this group')
mibBuilder.exportSymbols("DOCS-DIAG-MIB", docsDiagLogDetailLastErrorText=docsDiagLogDetailLastErrorText, docsDiagLogClearAll=docsDiagLogClearAll, docsDiagLogSizeFull=docsDiagLogSizeFull, docsDiagLogNotifyLogSizeLowThrshld=docsDiagLogNotifyLogSizeLowThrshld, docsDiagLogNotifyLogSizeHighThrshld=docsDiagLogNotifyLogSizeHighThrshld, docsDiagLogRangingRetryThrhld=docsDiagLogRangingRetryThrhld, docsDiagLogRangingRetryStationMaintNum=docsDiagLogRangingRetryStationMaintNum, docsDiagLogMibObjects=docsDiagLogMibObjects, PYSNMP_MODULE_ID=docsDiagMib, docsDiagLogEnableAgingTriggers=docsDiagLogEnableAgingTriggers, docsDiagLogSizeLowThrshldReached=docsDiagLogSizeLowThrshldReached, docsDiagLogCmMacAddr=docsDiagLogCmMacAddr, docsDiagLogRangingRetryType=docsDiagLogRangingRetryType, docsDiagLogGlobal=docsDiagLogGlobal, docsDiagLogTable=docsDiagLogTable, docsDiagLogRegCount=docsDiagLogRegCount, docsDiagLogLastUpdateTime=docsDiagLogLastUpdateTime, docsDiagLogCompliances=docsDiagLogCompliances, docsDiagLogDetailLastUpdate=docsDiagLogDetailLastUpdate, docsDiagLogRegDetail=docsDiagLogRegDetail, docsDiagLogMaxSize=docsDiagLogMaxSize, docsDiagLogAging=docsDiagLogAging, docsDiagLogLastClearTime=docsDiagLogLastClearTime, docsDiagLogCurrentSize=docsDiagLogCurrentSize, docsDiagLogNotifications=docsDiagLogNotifications, docsDiagLogIncludeTriggers=docsDiagLogIncludeTriggers, docsDiagLogDetailCount=docsDiagLogDetailCount, docsDiagLogResetAll=docsDiagLogResetAll, docsDiagLogEntry=docsDiagLogEntry, docsDiagMib=docsDiagMib, docsDiagLogDetailTypeValue=docsDiagLogDetailTypeValue, docsDiagLogNotificationGroup=docsDiagLogNotificationGroup, docsDiagLogLastRegTime=docsDiagLogLastRegTime, docsDiagLogBaseGroup=docsDiagLogBaseGroup, docsDiagLogConformance=docsDiagLogConformance, docsDiagLogNotifCtrl=docsDiagLogNotifCtrl, docsDiagLogRangingRetryCount=docsDiagLogRangingRetryCount, docsDiagLogRegTimeInterval=docsDiagLogRegTimeInterval, RegistrationDetailFlag=RegistrationDetailFlag, docsDiagLogCreateTime=docsDiagLogCreateTime, docsDiagLogCompliance=docsDiagLogCompliance, docsDiagLogSizeHighThrshldReached=docsDiagLogSizeHighThrshldReached, docsDiagLogDetailTable=docsDiagLogDetailTable, docsDiagLogLastResetTime=docsDiagLogLastResetTime, docsDiagLogTriggersCfg=docsDiagLogTriggersCfg, TriggerFlag=TriggerFlag, docsDiagLogDetailEntry=docsDiagLogDetailEntry, docsDiagLogGroups=docsDiagLogGroups)
