#
# PySNMP MIB module LAN-EMULATION-ELAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/LAN-EMULATION-ELAN-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 05:10:50 2022
# On host fv-az42-839 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
LecDataFrameFormat, VciInteger, LecDataFrameSize, atmfLanEmulation, VpiInteger = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "LecDataFrameFormat", "VciInteger", "LecDataFrameSize", "atmfLanEmulation", "VpiInteger")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, NotificationType, iso, IpAddress, TimeTicks, ModuleIdentity, Counter64, Unsigned32, Bits, Gauge32, ObjectIdentity, MibIdentifier, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "iso", "IpAddress", "TimeTicks", "ModuleIdentity", "Counter64", "Unsigned32", "Bits", "Gauge32", "ObjectIdentity", "MibIdentifier", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
elanMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2))
class Integer(Integer32):
    pass

class RowStatus(Integer32):
    pass

class AutonomousType(ObjectIdentifier):
    pass

class TIMESTAMP(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class AtmLaneAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class IfIndexOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class ElanLocalIndex(Integer32):
    pass

class AtmLaneMask(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class TlvSelectorIndexType(Integer32):
    pass

class PolicySelectorIndexType(Integer32):
    pass

class LecsErrLogIndexType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

elanAdminGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1))
elanConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2))
elanLecsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3))
elanLecsConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1))
elanLecsFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2))
elanLecsStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3))
elanAdminPolicyVal = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1))
byAtmAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 1))
byMacAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 2))
byRouteDescriptor = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 3))
byLanType = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 4))
byPktSize = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 5))
byElanName = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 6))
elanConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 1), ElanLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: elanConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfNextId.setDescription('The next available ELAN index provided\n                            by the agent.  The value of this object \n                            can be used as the index to the \n                            elanConfTable during creation.')
elanConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2), )
if mibBuilder.loadTexts: elanConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfTable.setDescription('This table contains all Emulated LANs\n                           (ELANs) this agent manages.  An ELAN\n                           is defined by the ELAN name, a set of\n                           TLVs, and other parameters.  After an\n                           ELAN is created, members of the ELAN\n                           such as the LAN Emulation Server (LES)\n                           or Client (LEC) can be added to this\n                           ELAN entry in their repective tables.\n                           There are four memebers to an ELAN and\n                           they are LECS, LES, BUS (Broadcast and\n                           Unknown Server ) and LEC.  The support\n                           of LECS is optional.  The addition and\n                           deletion of LECS is done in the \n                           elanLecsConfGroup defined in this MIB.\n                           The addition and deletion of the LEC\n                           are done in the LEC Assignment tables\n                           defined in this ELAN Configuration group.\n                           The addition and deletion of the LES\n                           are also defined in this group.  The\n                           addition and deletion of the BUS are\n                           done in the LES MIB due to the fact that\n                           LEC learns the BUS address only from\n                           the LES it corresponds to.')
elanConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"))
if mibBuilder.loadTexts: elanConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfEntry.setDescription('Each entry in this table represents an\n                           Emulated LAN.  Objects elanConfIndex\n                           and elanConfRowStatus are required\n                           during row creation and deletion. ')
elanConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 1), ElanLocalIndex())
if mibBuilder.loadTexts: elanConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfIndex.setDescription('A value which uniquely identifies a\n                             conceptual row in the elanConfTable.\n                               \n                             If the conceptual row identified by this value\n                             of elanConfIndex is recreated following an agent\n                             restart, the same value of elanConfIndex must be\n                             used to identify the recreated row.')
elanConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfName.setReference('LAN Emulation Over ATM Specification -\n                             version 1.0. C5.')
if mibBuilder.loadTexts: elanConfName.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfName.setDescription('The name of this Emulated LAN entry.\n                             When this object length is zero then the \n                             ELAN name is not specified.  The clients\n                             assigned to this ELAN will also have\n                             a zero length string as the ELAN name.\n                             \n                             The value of this object is used in the\n                             LE CONFIGURE response by the LECS if supported.\n\n                             Note that ELAN name may be used as cross\n                             reference to the LES MIB and BUS MIB \n                             though not required.  Multiple ELANs \n                             with no ELAN name specified will cause \n                             conflicts in reference to LES and BUS MIBs.')
elanConfTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 3), TlvSelectorIndexType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfTlvIndex.setDescription('The value of this object identifies\n                             one or more rows in the lecsTlvTable which\n                             applies to this ELAN.  This object is \n                             set to zero if 1) LECS is not supported.\n                             or 2) there is no TLV associated with \n                             this entry.')
elanConfLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 4), LecDataFrameFormat().clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfLanType.setReference('LAN Emulation Over ATM Specification -\n                               version 1.0. S2.')
if mibBuilder.loadTexts: elanConfLanType.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfLanType.setDescription('The LAN type of this ELAN entry.')
elanConfMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 5), LecDataFrameSize().clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfMaxFrameSize.setReference('LAN Emulation Over ATM Specification -\n                               version 1.0. S3.')
if mibBuilder.loadTexts: elanConfMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfMaxFrameSize.setDescription('The maximum data frame size of this\n                               ELAN entry.  The maximum AAL-5 SDU size\n                               of a data frame that this ELAN can support.\n                               The value of this object is returned to the\n                               LEC in the LE CONFIGURE response.')
elanConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanConfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfRowStatus.setDescription('This object is used to create or\n                                delete entries in the elanConfTable.')
elanLesTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3), )
if mibBuilder.loadTexts: elanLesTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesTable.setDescription('This table contains all LESs for each \n                              ELAN specified in the elanConfTable.\n                                  Each ELAN can have more than\n                                  one LES providing LAN Emulation \n                                  services.  Each LES can service only\n                              one ELAN.  The table is indexed by the\n                              elanConfIndex which points to the ELAN\n                              this LES is providing service to, and\n                              elanLesIndex which unquely identifies\n                              a LES.  This table is used for configuration\n                              of an ELAN only, that is, creating a\n                              LES in this table does not instantiate\n                              a LES in the network.  It is done in\n                              the LES MIB.')
elanLesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"))
if mibBuilder.loadTexts: elanLesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesEntry.setDescription('Each entry in this table represents \n                                a LES/Emulated LAN pair.  Object\n                                elanLesAtmAddress besides elanLesRowStatus\n                                is also required during row creation.')
elanLesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: elanLesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesIndex.setDescription('An arbitrary number which uniquely\n                               identifies the LES this entry pertains\n                               to.')
elanLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesAtmAddress.setDescription('The ATM address of the LES entry.\n                               If LECS is supported, the value of\n                               this object is the LES ATM address \n                               LECS returns to the LEC in the\n                               CONFIGURE response.  If LECS\n                               is not supported, the value of this\n                               object pertains to the LES ATM address\n                               network manager provides to the\n                               LEC.')
elanLesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLesRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesRowStatus.setDescription('This object is used to create or\n                                delete entries in the elanLesfTable.')
elanPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4), )
if mibBuilder.loadTexts: elanPolicyTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyTable.setDescription("This table contains all policies this\n                                 agent supports for assigning a LEC to\n                                 an ELAN. \n                                 A set of policies with the same or\n                                 different priorities can be selected\n                                 by the entity which provides ELAN\n                                 configuration service such\n                                 as the LECS.  The policy with the\n                                 highest priority or with the smallest\n                                 elanPolicyPriority , is evaluated\n                                 first.  The policies with the same\n                                 elanPolicyPriority are evaluated\n                                 at the same time with the AND operation.\n                                 When LECS receives a configure\n                                 request, it checks it's policies selected\n                                 from this table to determine which \n                                 ELAN and LES the LEC will join.\n                                 This table is indexed by a selector\n                                 index and a policy index.  The policy\n                                 index unquely identifies a policy and\n                                 the selector index allows multiple\n                                 policies be selected by one LECS or\n                                 an entity that is providing ELAN\n                                 configuration service.")
elanPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanPolicySelectorIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanPolicyIndex"))
if mibBuilder.loadTexts: elanPolicyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyEntry.setDescription('Each entry in this table represents a\n                                policy supported by the entity which \n                                provides ELAN configuration \n                                services.  Each policy can be used to\n                                evaluate the CONFIGURE request from\n                                the LEC in determining which ELAN it\n                                belongs to. ')
elanPolicySelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 1), PolicySelectorIndexType())
if mibBuilder.loadTexts: elanPolicySelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicySelectorIndex.setDescription('The value of this object indicates\n                               a group of policies that can be selected\n                               by the ELAN configuration service\n                                   provider such as the LECS.')
elanPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000)))
if mibBuilder.loadTexts: elanPolicyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyIndex.setDescription('The value of this object uniquely\n                              identifies a single policy entry in\n                              this table. ')
elanPolicyPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyPriority.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyPriority.setDescription('The priority of this policy entry. \n                               Policies are evaluated by the \n                               entity which provides ELAN configuration\n                               service (LECS) by their\n                               priorities.  Policies with the\n                               same priority values should be\n                               evludated at the same time with\n                               an AND operation.  That is, if\n                               one of the policy with the same\n                               priority is not met,\n                               the evluation should fail.\n                               The value 1 has the highest priority. ')
elanPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 4), AutonomousType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyType.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyType.setDescription('\n                              The value of this object must\n                              reference a definition of a type\n                              of policy.  Some of such definition\n                              exist within the elanAdminPolicyVal\n                              subtree.  Others may be defined \n                              within enterprise specific subtrees.\n                              The agent is not required to \n                              support every types defined\n                              within the elanAdminPolicyVal subtree.')
elanPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                             for version 2 of the Simple Network Management \n                             Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanPolicyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyRowStatus.setDescription('This object is used to create or\n                             delete entries in the elanPolicyTable.')
elanLecAtmAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5), )
if mibBuilder.loadTexts: elanLecAtmAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddrTable.setDescription("This table is used to assign a LEC\n                                 to an ELAN by ATM address.\n                                 When the by ATM address policy is \n                                 used, this table is used to specify\n                                 the LEC's ATM address or portion of an ATM\n                                 address.  The ATM address is used by\n                                 the LECS or other entity which serves\n                                 the LANE configuration function to\n                                 determine the ELAN membership.\n\n                                 This table is indexed\n                                 by the elanConfIndex which points\n                                 to the ELAN this LEC belongs, the\n                                 elanLesIndex which points to the\n                                 LES this LEC should join, the\n                                 LEC's ATM address and an ATM address\n                                 mask.  Portions of ATM address\n                                 can be used in dertermining ELAN\n                                 membership by using both the ATM\n                                 address and the mask.")
elanLecAtmAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecAtmAddress"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecAtmMask"))
if mibBuilder.loadTexts: elanLecAtmAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddrEntry.setDescription('Each entry represents a LEC to ELAN\n                               binding.')
elanLecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 1), AtmLaneAddress())
if mibBuilder.loadTexts: elanLecAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddress.setDescription('The value of this object is the\n                               ATM address of a LAN Emulation\n                               client.  This object and the\n                               object elanLecAtmMask are used\n                               to form an ATM address or portion\n                               of an ATM address to be used\n                               by the LECS in determining the\n                               ELAN membership when the policy\n                               of this LECS is by ATM address.')
elanLecAtmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 2), AtmLaneAddress())
if mibBuilder.loadTexts: elanLecAtmMask.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmMask.setDescription("The ATM address mask associated with\n                                the object elanLecAtmAddress.  The value\n                                of the mask is an ATM address with\n                                the don't care portion set to zero\n                                and the valid ATM address portion set to one.")
elanLecAtmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecAtmRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecAtmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmRowStatus.setDescription('This object is used to create or\n                               destroy entries in this table.')
elanLecMacAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6), )
if mibBuilder.loadTexts: elanLecMacAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddrTable.setDescription("This table is used to assign a LEC\n                                 to an ELAN by MAC address.\n                                 When the byMacAddress policy is \n                                 used, this table is used to specify\n                                 the LEC's ELAN membership by ATM\n                                 address.  This table is indexed\n                                 by the elanConfIndex which points\n                                 to the ELAN this LEC belongs, the\n                                 elanLesIndex which points to the\n                                 LES this LEC should join, and the\n                                 LEC's MAC address.")
elanLecMacAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecMacAddress"))
if mibBuilder.loadTexts: elanLecMacAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddrEntry.setDescription('Each entry represents a LEC to ELAN\n                               binding.')
elanLecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1, 1), MacAddress())
if mibBuilder.loadTexts: elanLecMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddress.setDescription('The value of this object is the\n                               MAC address of a LAN Emulation\n                               client.  When a CONFIGURE request\n                               is received with this MAC address,\n                               it will be assigned to the ELAN\n                               which elanConfIndex is pointing\n                               to.')
elanLecMacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecMacRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecMacRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacRowStatus.setDescription('This object is used to create or\n                               destroy entries in this table.')
elanLecRdTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7), )
if mibBuilder.loadTexts: elanLecRdTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdTable.setDescription("This table is used to assign a LEC\n                             to an ELAN by Route Descriptor.\n                                 When the by Route Descriptor policy is \n                             used, this table is used to specify\n                             the LEC's ELAN membership by Route\n                             Descriptor.  This table is indexed\n                             by the elanConfIndex which points\n                             to the ELAN this LEC belongs, the\n                             elanLesIndex which points to the\n                             LES this LEC should join, and the\n                             LEC's Route Descriptors.")
elanLecRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecRdSegId"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecRdBridgeNum"))
if mibBuilder.loadTexts: elanLecRdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdEntry.setDescription('Each entry represents a LEC to ELAN\n                               binding. ')
elanLecRdSegId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: elanLecRdSegId.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdSegId.setDescription('The LAN ID portion of the IEEE 802.5\n                               route descriptor associated with this\n                               conceptual row.')
elanLecRdBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: elanLecRdBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdBridgeNum.setDescription('The Bridge Number portion of the\n                                 IEEE 802.5 route descriptor associated\n                                 with this conceptual row.')
elanLecRdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecRdRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecRdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdRowStatus.setDescription('This object is used to create or\n                               destroy entries in this table.')
elanLecPktSizeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8), )
if mibBuilder.loadTexts: elanLecPktSizeTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecPktSizeTable.setDescription("This table is used to assign a LEC\n                              to an ELAN by Packet Size. When the by \n                              Packet Size policy is used, this table \n                              is used to specifythe LEC's ELAN \n                              membership by Packet Size.  This table \n                              is indexed by the elanConfIndex which \n                              points to the ELAN this LEC belongs, \n                              the elanLesIndex which points to the\n                              LES this LEC should join, and the\n                              LEC's Packet Size.")
elanLecPktSizeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecFrameSize"))
if mibBuilder.loadTexts: elanLecPktSizeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecPktSizeEntry.setDescription('Each entry represents a LEC to ELAN\n                               binding. ')
elanLecFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8, 1, 1), LecDataFrameSize())
if mibBuilder.loadTexts: elanLecFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecFrameSize.setDescription('The maximum AAL-5 SDU size this LEC \n                              can support. ')
elanLecPktSizeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 8, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecPktSizeRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecPktSizeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecPktSizeRowStatus.setDescription('This object is used to create or\n                               destroy entries in this table.')
elanLecNameTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9), )
if mibBuilder.loadTexts: elanLecNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecNameTable.setDescription("This table is used to assign a LEC\n                               to an ELAN by ELAN name. When the by \n                               ELAN name policy is used, this table \n                               is used to specifythe LEC's ELAN \n                               membership by ELAN name.  This table \n                               is indexed by the elanConfIndex which \n                               points to the ELAN this LEC belongs, \n                               the elanLesIndex which points to the\n                               LES this LEC should join, and the\n                               LEC's ELAN name.")
elanLecNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLesIndex"), (0, "LAN-EMULATION-ELAN-MIB", "elanLecElanName"))
if mibBuilder.loadTexts: elanLecNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecNameEntry.setDescription('Each entry represents a LEC to ELAN\n                               binding. ')
elanLecElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: elanLecElanName.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecElanName.setDescription('The name of the ELAN this LEC belongs.')
elanLecNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 9, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecNameRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: elanLecNameRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecNameRowStatus.setDescription('This object is used to create or\n                               destroy entries in this table.')
lecsConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 1), ElanLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfNextId.setDescription('The next available LECS index.  The\n                               value of this object can be used as\n                               the index to the lecsTable during\n                               creation.')
lecsConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2), )
if mibBuilder.loadTexts: lecsConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfTable.setDescription('This table contains the configuration \n                               information of all LECS this agent\n                               manages.  This table can also be\n                               used to create, delete or configure\n                               a LECS.')
lecsConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfEntry.setDescription('Each entry represents a LECS this\n                                agent maintains. \n                                Objects lecsAtmIfIndex, lecsAtmAddrSpec,\n                                and lecsAtmAddrMask cannot be modified\n                                unless the lecsAdminStatus is set to\n                                down(2).  And the change does not take\n                                effect until the lecsAdminStatus is set\n                                to up(1).')
lecsConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: lecsConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfIndex.setDescription('An arbitrary integer which represents\n                               a LECS this agent manages.  \n                               If the conceptual row identified by this value\n                               of lecsConfIndex is recreated following an agent\n                               restart, the same value of elanConfIndex must be\n                               used to identify the recreated row.')
lecsAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 2), IfIndexOrZero().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmIfIndex.setDescription('An ATM interface which the LECS receives \n                                CONFIGURE requests \n                                from.  This value must match an existing\n                                value  in the   ifTable.  This object\n                                is set to zero when the ATM interface\n                                is not specified or there is more than\n                                one ATM interface used by the LECS.')
lecsAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 3), AtmLaneAddress().clone(hexValue="4700790000000000000000000000A03E00000100")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrSpec.setDescription('An ATM  address specified by  the  \n                               network or local management that, \n                               with the ATM address mask, determines\n                               a  portion of  the  ATM address  that \n                               the  LECS on the designated ATM interface  \n                               will use  to derive the actual ATM\n                               address from the network or ILMI.  The derived\n                               ATM address is specified in the object\n                               lecsAtmAddrActual, which is used to\n                               receive CONFIGURE requests.\n                               The value of this object, if not\n                               specified, is defaulted to the \n                               well-known LECS ATM address specified\n                               in the LAN Emulation Spec. 1.0.')
lecsAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 4), AtmLaneMask().clone(hexValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrMask.setDescription("The ATM address mask associated with\n                                the object lecsAtmAddrSpec.  The value\n                                of the mask is an ATM address with\n                                the don't care portion set to zero\n                                and the valid ATM address portion set to one.")
lecsAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 5), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrActual.setDescription(" The resulting ATM address that the   \n                               LECS is accepting CONFIGURE    \n                               requests on the interface indicated\n                               by the object lecsAtmIfIndex.\n                               This  address is   the  result of  the \n                               specified   ATM address,  its   mask   and \n                               interaction through the ILMI  with  the  \n                               switch. Note  that   this object is only \n                               valid  when the corresponding lecsOperStatus \n                               is 'up'.")
lecsPolicySelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 6), PolicySelectorIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsPolicySelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsPolicySelIndex.setDescription('The set of policies used\n                               by this LECS in dertermining\n                               requesters ELAN membership.\n                               The policies are defined in\n                               the elanPolicyTable.  The value\n                               of this object must exist in the\n                               elanPolicyTable.')
lecsLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 7), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLastInitialized.setDescription('The value of the sysUpTime since\n                                LECS has last entered the state\n                                indicated by the object lecsOperStatus.')
lecsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsOperStatus.setDescription(" This  object reflects the actual  \n                                   state of  the LECS which  may differ  \n                                   from that   of the  lecsAdminStatus\n                                   object.   This     can occur    when    \n                                   the  interface ifOperStatus     is   \n                                   'down'   but the   corresponding\n                                   lecsAdminStatus is 'up'.")
lecsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAdminStatus.setDescription('The desired  state of the  LECS on \n                                   this interface as prescribed by the \n                                   operator.   The actions of the agent\n                                   will,  if  at all possible,  eventually  \n                                   result in the desired  state being \n                                   reflected in the lecsOperStatus.')
lecsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRowStatus.setDescription('This object is used to create or\n                               delete entries in this table.')
lecsElanTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3), )
if mibBuilder.loadTexts: lecsElanTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanTable.setDescription('This table contains the mapping between \n                           ELANs and LECS.\n\n                           When a LECS is deleted from the lecsConfTable, \n                           all entries associated with this entry will \n                           also be deleted.')
lecsElanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "elanConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsElanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanEntry.setDescription('Each entry represents an ELAN to LECS\n                                mapping.')
lecsElanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsElanRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                           for version 2 of the Simple Network Management \n                           Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsElanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanRowStatus.setDescription('This object is used to create or\n                           delete an entry from this table.')
lecsTlvTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4), )
if mibBuilder.loadTexts: lecsTlvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvTable.setDescription('This table contains mandatoryly configured\n                            sets of TLVs in this LECS. These sets can\n                            include not only the standard TLVs specified\n                            in the LAN Emulation Spec. 1.0 [1] but\n                            also the additional parameters\n                            exchanged between the LECS and LEC.\n                            This table is indexed by a selector\n                            index, which allows more than one\n                            TLV to be selected by an ELAN; and\n                            the TLV tag, which specified the type\n                            of the TLV; and a TLV index which\n                            is used to distinguish between different\n                            entries with the same TLV tag.\n                            How does the LECS treat the TLVs\n                            that are not specified in this table\n                            in the CONFIGURE requests are not\n                            defined in this MIB.')
lecsTlvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsTlvSelectorIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsTlvTag"), (0, "LAN-EMULATION-ELAN-MIB", "lecsTlvIndex"))
if mibBuilder.loadTexts: lecsTlvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvEntry.setDescription('Each entry represents a set of TLV \n                            encodings for an ELAN represented \n                            by the elanConfIndex.  Objects lecsTlvVal \n                            and lecsTlvRowStatus are required during \n                            row creation.')
lecsTlvSelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 1), TlvSelectorIndexType())
if mibBuilder.loadTexts: lecsTlvSelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvSelectorIndex.setDescription('The value of this object indicates \n                               a group of TLVs that can be selected.')
lecsTlvTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4))
if mibBuilder.loadTexts: lecsTlvTag.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvTag.setDescription('The value of this object represents the \n                               type of the contents of the lecsTlvVal \n                               field in the entry.  The OUI field\n                               in this object occupies the first\n                               ( or most significant )3 octets.  \n                               The OUI value 00-A0-3E is used for \n                               the standard values defined by the ATM \n                               Forum specification.')
lecsTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: lecsTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvIndex.setDescription('The index of this TLV encoding entry.  \n                                The value of this object can be used \n                                to distinguish between different entries \n                                with the same lecsTlvTag value.')
lecsTlvVal = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsTlvVal.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvVal.setDescription('The value of this TLV entry.  Note that\n                                the length is implied by the length of\n                                the OCTET STRING.')
lecsTlvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsTlvRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsTlvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvRowStatus.setDescription('This object is used to create or\n                               destroy entries in this table. ')
lecsVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5), )
if mibBuilder.loadTexts: lecsVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccTable.setDescription('This table contains all the CONFIG VCCs of the\n                             LECS.  The CONFIG VCC is used by the LEC to send/\n                             receive ATM LE CONFIGURE request/response to/from\n                             the LECS.  This table is writable if PVC is used\n                             and read only if SVC is used. ')
lecsVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsVccIfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsVccVpi"), (0, "LAN-EMULATION-ELAN-MIB", "lecsVccVci"))
if mibBuilder.loadTexts: lecsVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccEntry.setDescription('Each entry represents a CONFIG VCC\n                             between a pair of LEC and LECS.')
lecsVccIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 1), IfIndexOrZero())
if mibBuilder.loadTexts: lecsVccIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccIfIndex.setDescription('The ATM interface which the CONFIG VCC is \n                                established.\n                                This value must be an existing value in the \n                                ifTable.  The value of this object is set to zero\n                                when the ATM interface is an internal connection.')
lecsVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 2), VpiInteger())
if mibBuilder.loadTexts: lecsVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccVpi.setDescription('The VPI value of the CONFIG VCC.  The object\n                                lecsVccIfIndex, lecsVccVci and this object\n                                uniquely identifies a VCC within an ATM system.')
lecsVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 3), VciInteger())
if mibBuilder.loadTexts: lecsVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccVci.setDescription('The VCI value of the CONFIG VCC. The object\n                                lecsVccIfIndex, lecsVccVpi and this object\n                                uniquely identifies a VCC within an ATM system ')
lecsVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsVccRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                                for version 2 of the Simple Network Management \n                                Protocol (SNMPv2).')
if mibBuilder.loadTexts: lecsVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsVccRowStatus.setDescription('This object is used to create or\n                               destroy entries in this table. ')
lecsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1), )
if mibBuilder.loadTexts: lecsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatsTable.setDescription(' A (conceptual) table of statistics \n                                   associated with all\n                                   LECS instances on the device.')
lecsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatsEntry.setDescription(' A (conceptual) row in the \n                                   lecsStatsTable which corresponds \n                                   to the statistics kept by a particular\n                                   instance of a LECS.')
lecsStatSuccessful = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatSuccessful.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatSuccessful.setDescription('The number of CONFIGURE requests \n                                successfully granted since the agent \n                                was last initialized.')
lecsStatInBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInBadFrames.setDescription('The number of mal formed CONFIGURE\n                                requests dropped by the LECS.')
lecsStatInvalidParam = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidParam.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidParam.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidParam.setDescription('The number of CONFIGURE requests \n                                rejected due to the invalid request \n                                parameters error.')
lecsStatInsufRes = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInsufRes.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInsufRes.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInsufRes.setDescription('The number of CONFIGURE requests rejected due\n                                to the insufficent resources to grant request \n                                error.')
lecsStatAccDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatAccDenied.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatAccDenied.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatAccDenied.setDescription('The number of CONFIGURE requests rejected due\n                                to the access denied error.')
lecsStatInvalidReq = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidReq.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidReq.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidReq.setDescription('The number of CONFIGURE requests rejected due\n                                to the invalid requester-id error.')
lecsStatInvalidDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidDest.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidDest.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidDest.setDescription('The number of CONFIGURE requests rejected due\n                                to the invalid destination error.')
lecsStatInvalidAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidAddr.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInvalidAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidAddr.setDescription('The number of CONFIGURE requests rejected due\n                                to the invalid ATM address error.')
lecsStatNoConf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatNoConf.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatNoConf.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatNoConf.setDescription('The number of CONFIGURE requests rejected due\n                                to the LE Client is not recognized error.')
lecsStatConfError = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatConfError.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatConfError.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatConfError.setDescription('The number of CONFIGURE requests rejected due\n                                to the LE_CONFIGURE error.')
lecsStatInsufInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInsufInfo.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: lecsStatInsufInfo.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInsufInfo.setDescription('The number of CONFIGURE requests rejected due\n                                to the insufficient information error.')
lecsErrCtlTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1), )
if mibBuilder.loadTexts: lecsErrCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlTable.setDescription('This table contains error log control \n                               information of all LECS instances.\n                               This table is an extention to the\n                               lecsConfTable.  It is used to enable\n                               or disable error logs for a particular\n                               LECS entry.')
lecsErrCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsErrCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlEntry.setDescription('Each entry represents a LECS entry\n                             in the lecsConfTable.')
lecsErrCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlAdminStatus.setDescription('This object is used to enable/disable error \n                            logging for the LECS.')
lecsErrCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("outOfRes", 3), ("failed", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlOperStatus.setDescription('This object is used to indicate\n                          the result of a set operation to the\n                          object lecsErrCtlAdminStatus.\n                          If the error log was successfully\n                          started, it is in active(2) mode.\n                          Otherwise, it is set to either\n                          outOfRes(3) or failed(4) for\n                          the respective reasons.')
lecsErrCtlClearLog = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlClearLog.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlClearLog.setDescription('This object is used to clear the error log\n                            entries associated with this LECS.')
lecsErrCtlMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrCtlMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlMaxEntries.setDescription('The maximum entries of the error\n                          log a LECS can support.')
lecsErrCtlLastEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 5), LecsErrLogIndexType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlLastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlLastEntry.setDescription('The index to the last entry in the error\n                           log table associated with this LECS.')
lecsErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2), )
if mibBuilder.loadTexts: lecsErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogTable.setDescription('This table contains error logs\n                    of the LECS instances enabled\n                    in the lecsErrCtlTable.  This table\n                    is indexed by the LECS instance\n                    index and an arbitrary integer\n                    uniquely identifies an error\n                    log.')
lecsErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1), ).setIndexNames((0, "LAN-EMULATION-ELAN-MIB", "lecsConfIndex"), (0, "LAN-EMULATION-ELAN-MIB", "lecsErrLogIndex"))
if mibBuilder.loadTexts: lecsErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogEntry.setDescription('Each entry represents a LEC that\n                     was rejected due to a violation \n                     against the policies or an error.')
lecsErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 1), LecsErrLogIndexType())
if mibBuilder.loadTexts: lecsErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogIndex.setDescription('An arbitrary integer which uniquely\n                    identifies an error log entry. The first\n                    entry after reset or clearing the error\n                    log is an assigned value (2^32-1).  Succeding\n                    entries are assigned with descending values \n                    consecutively.  Entries after 1 are discarded.The \n                                                                                                                                                                                    enabling/disabling of\n                    the error log capability is done in\n                    the lecsErrCtlTable.')
lecsErrLogAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogAtmAddr.setDescription('The ATM address of the requester\n                    which sends the CONFIGURE request\n                    and causes the error to occur. \n                    The corresponding error code is\n                    specified in the object lecsErrLogErrCode.')
lecsErrLogErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogErrCode.setDescription('The Error code which indicates the\n                    cause of the error triggered by the\n                    CONFIGURE request sent by the\n                    requester indicated by the value of\n                    the object lecsErrLogAtmAddr.')
lecsErrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 4), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogTime.setDescription('The sysUpTime when this entry was logged by\n                     the LECS.')
mibBuilder.exportSymbols("LAN-EMULATION-ELAN-MIB", lecsVccVpi=lecsVccVpi, elanLecElanName=elanLecElanName, lecsStatInvalidAddr=lecsStatInvalidAddr, lecsStatAccDenied=lecsStatAccDenied, elanPolicyEntry=elanPolicyEntry, elanLecNameEntry=elanLecNameEntry, elanLecNameRowStatus=elanLecNameRowStatus, ElanLocalIndex=ElanLocalIndex, lecsElanEntry=lecsElanEntry, elanConfTlvIndex=elanConfTlvIndex, elanLesEntry=elanLesEntry, elanPolicyRowStatus=elanPolicyRowStatus, elanConfTable=elanConfTable, RowStatus=RowStatus, lecsErrCtlEntry=lecsErrCtlEntry, elanLecMacAddrEntry=elanLecMacAddrEntry, elanLecMacRowStatus=elanLecMacRowStatus, lecsTlvIndex=lecsTlvIndex, elanPolicyIndex=elanPolicyIndex, elanLecRdEntry=elanLecRdEntry, elanLesAtmAddress=elanLesAtmAddress, AutonomousType=AutonomousType, lecsStatInBadFrames=lecsStatInBadFrames, byMacAddr=byMacAddr, elanLecRdBridgeNum=elanLecRdBridgeNum, lecsConfTable=lecsConfTable, TIMESTAMP=TIMESTAMP, elanLecsGroup=elanLecsGroup, elanConfIndex=elanConfIndex, Integer=Integer, elanPolicySelectorIndex=elanPolicySelectorIndex, lecsVccVci=lecsVccVci, elanLecsFaultGroup=elanLecsFaultGroup, lecsVccRowStatus=lecsVccRowStatus, lecsVccTable=lecsVccTable, lecsTlvEntry=lecsTlvEntry, elanLecsStatGroup=elanLecsStatGroup, lecsErrLogTime=lecsErrLogTime, lecsErrCtlLastEntry=lecsErrCtlLastEntry, lecsStatSuccessful=lecsStatSuccessful, lecsErrLogErrCode=lecsErrLogErrCode, lecsStatNoConf=lecsStatNoConf, elanPolicyTable=elanPolicyTable, lecsStatInvalidReq=lecsStatInvalidReq, elanLecAtmAddress=elanLecAtmAddress, IfIndexOrZero=IfIndexOrZero, elanLecPktSizeRowStatus=elanLecPktSizeRowStatus, MacAddress=MacAddress, elanLecMacAddrTable=elanLecMacAddrTable, elanLecFrameSize=elanLecFrameSize, lecsStatInsufInfo=lecsStatInsufInfo, lecsStatInvalidDest=lecsStatInvalidDest, lecsErrLogAtmAddr=lecsErrLogAtmAddr, elanLesIndex=elanLesIndex, LecsErrLogIndexType=LecsErrLogIndexType, lecsConfNextId=lecsConfNextId, lecsErrCtlTable=lecsErrCtlTable, lecsTlvTag=lecsTlvTag, lecsRowStatus=lecsRowStatus, lecsConfEntry=lecsConfEntry, elanLecNameTable=elanLecNameTable, lecsVccIfIndex=lecsVccIfIndex, elanLecPktSizeTable=elanLecPktSizeTable, elanConfMaxFrameSize=elanConfMaxFrameSize, lecsStatConfError=lecsStatConfError, elanLesTable=elanLesTable, lecsAtmIfIndex=lecsAtmIfIndex, elanLecRdTable=elanLecRdTable, byLanType=byLanType, lecsStatsTable=lecsStatsTable, lecsErrCtlOperStatus=lecsErrCtlOperStatus, PolicySelectorIndexType=PolicySelectorIndexType, lecsErrLogIndex=lecsErrLogIndex, elanAdminGroup=elanAdminGroup, elanPolicyPriority=elanPolicyPriority, lecsConfIndex=lecsConfIndex, lecsAdminStatus=lecsAdminStatus, byPktSize=byPktSize, lecsErrLogEntry=lecsErrLogEntry, lecsOperStatus=lecsOperStatus, lecsAtmAddrSpec=lecsAtmAddrSpec, lecsElanTable=lecsElanTable, lecsErrLogTable=lecsErrLogTable, lecsStatsEntry=lecsStatsEntry, lecsAtmAddrActual=lecsAtmAddrActual, AtmLaneAddress=AtmLaneAddress, elanLecMacAddress=elanLecMacAddress, elanLecsConfGroup=elanLecsConfGroup, elanPolicyType=elanPolicyType, elanConfName=elanConfName, byRouteDescriptor=byRouteDescriptor, lecsTlvRowStatus=lecsTlvRowStatus, elanConfRowStatus=elanConfRowStatus, byElanName=byElanName, elanConfLanType=elanConfLanType, lecsVccEntry=lecsVccEntry, elanLecPktSizeEntry=elanLecPktSizeEntry, lecsErrCtlMaxEntries=lecsErrCtlMaxEntries, lecsStatInvalidParam=lecsStatInvalidParam, lecsPolicySelIndex=lecsPolicySelIndex, elanLesRowStatus=elanLesRowStatus, lecsStatInsufRes=lecsStatInsufRes, elanConfNextId=elanConfNextId, elanConfEntry=elanConfEntry, lecsTlvSelectorIndex=lecsTlvSelectorIndex, elanMIB=elanMIB, lecsTlvTable=lecsTlvTable, lecsTlvVal=lecsTlvVal, elanLecAtmMask=elanLecAtmMask, byAtmAddr=byAtmAddr, lecsLastInitialized=lecsLastInitialized, elanConfGroup=elanConfGroup, AtmLaneMask=AtmLaneMask, lecsAtmAddrMask=lecsAtmAddrMask, TlvSelectorIndexType=TlvSelectorIndexType, elanLecAtmRowStatus=elanLecAtmRowStatus, lecsElanRowStatus=lecsElanRowStatus, elanAdminPolicyVal=elanAdminPolicyVal, elanLecRdSegId=elanLecRdSegId, elanLecRdRowStatus=elanLecRdRowStatus, lecsErrCtlClearLog=lecsErrCtlClearLog, elanLecAtmAddrTable=elanLecAtmAddrTable, elanLecAtmAddrEntry=elanLecAtmAddrEntry, lecsErrCtlAdminStatus=lecsErrCtlAdminStatus)
