#
# PySNMP MIB module LAN-EMULATION-BUS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/LAN-EMULATION-BUS-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 15:09:17 2022
# On host fv-az42-180 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
atmfLanEmulation, VpiInteger, VciInteger = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "atmfLanEmulation", "VpiInteger", "VciInteger")
TIMESTAMP, AtmLaneMask, IfIndexOrZero, Integer = mibBuilder.importSymbols("LAN-EMULATION-ELAN-MIB", "TIMESTAMP", "AtmLaneMask", "IfIndexOrZero", "Integer")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, MibIdentifier, TimeTicks, ModuleIdentity, Counter32, Counter64, IpAddress, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, iso, NotificationType, ObjectIdentity, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "MibIdentifier", "TimeTicks", "ModuleIdentity", "Counter32", "Counter64", "IpAddress", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "iso", "NotificationType", "ObjectIdentity", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
busMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 4))
class RowStatus(Integer32):
    pass

class AtmLaneAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
busConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1))
busStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2))
busFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3))
busConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: busConfNextId.setDescription('The next available BUS index.  The\n                    value of this object can be used as\n                    the index by the network manager to\n                    create an entry in the busConfTable.')
busConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2), )
if mibBuilder.loadTexts: busConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: busConfTable.setDescription('This table contains all LAN Emulation\n                    Broadcast and Unknown Servers (BUS) this \n                    agent manages.  The BUS handles data sent\n                    by an LE Client to the broadcast MAC\n                    address, all multicast traffic, and initial unicast\n                    frames which are sent by a LEC before the data\n                    direct target ATM address has been resolved.\n                    There can be multiple BUSs per ELAN, but a\n                    BUS can service only one ELAN.')
busConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1), ).setIndexNames((0, "LAN-EMULATION-BUS-MIB", "busConfIndex"))
if mibBuilder.loadTexts: busConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busConfEntry.setDescription("Each entry in this table represents a\n                    BUS.  The parameters in each entry apply\n                    to one emulated LAN served by one BUS.\n                    Object busRowStatus is required during\n                    row creation and deletion.  Object busElanName\n                    is used to indicate the ELAN this BUS\n                    is servicing and is used to cross reference\n                    tables defined in the LAN Emulation Server MIB.\n                    Note that objects busAtmAddrSpec and busAtmAddrMask\n                    are used to configure the ATM address of a BUS.\n                    The BUS typically derives it's ATM address\n                    from the switch or the network and the actual\n                    ATM address used is indicated in the object\n                    busAtmAddrActual.")
busConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: busConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: busConfIndex.setDescription('A value which uniquely identifies a\n                  conceptual row in the busConfTable.\n\n                  If the conceptual row identified by this value\n                  of busConfIndex is recreated following an agent\n                  restart, the same value of busConfIndex must be\n                  used to identify the recreated row.')
busConfAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busConfAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: busConfAtmAddrSpec.setDescription('An ATM  address specified by  the  \n                  network or local management that, \n                  with the ATM address mask, determines\n                  a  portion of  the  ATM address  that \n                  the  BUS on the designated ATM interface  \n                  will use  to derive the actual ATM\n                  address from the network or ILMI.  The derived\n                  ATM address is specified in the object\n                  busAtmAddrActual, which is used to\n                  receive multicast or broadcast traffic.')
busConfAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 3), AtmLaneMask().clone(hexValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busConfAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: busConfAtmAddrMask.setDescription("The ATM address mask associated with\n                  the object busAtmAddrSpec.  The value\n                  of the mask is an ATM address with\n                  the don't care portion set to zero\n                  and the valid ATM address portion set to one.")
busConfAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 4), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busConfAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: busConfAtmAddrActual.setDescription(' The resultant ATM address  in use by  the BUS.  This\n                    object is a product of the specified ATM address, mask\n                    and  interaction  with  the network.  This object is\n                    created by the agent.')
busConfElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busConfElanName.setStatus('mandatory')
if mibBuilder.loadTexts: busConfElanName.setDescription('The name of the ELAN this BUS is providing service to.')
busConfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 6), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busConfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: busConfLastChange.setDescription('The  value of the sysUpTime  when  this BUS \n                        has entered the state indicated by the \n                        object busConfOperStatus.')
busConfMaxFrameAge = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busConfMaxFrameAge.setReference('LAN Emulation Over ATM Specification -\n                       version 1.0. S5.')
if mibBuilder.loadTexts: busConfMaxFrameAge.setStatus('mandatory')
if mibBuilder.loadTexts: busConfMaxFrameAge.setDescription('Time out period for a frame that has been\n                      received but not been transmitted by BUS\n                      to all relevant Multicast Send VCCs or\n                      Multicast Forward VCCs.')
busConfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: busConfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: busConfOperStatus.setDescription("The operational state of this BUS entry. \n                        When in 'up' state the BUS will forward\n                        LEC traffic.  Any other state the\n                        BUS is not available for service and may\n                        release all the existing VCCs and refuse\n                        service to all clients.")
busConfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("up", 2), ("down", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busConfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: busConfAdminStatus.setDescription('  The  desired  state   of  the  designated   BUS  as\n                        prescribed by the operator. The  actions of the  agent\n                        will, if at  all  possible, eventually  result  in the\n                        desired state being  reflected in  the busOperStatus.')
busConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 2, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busConfRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                    for version 2 of the Simple Network Management \n                    Protocol (SNMPv2).')
if mibBuilder.loadTexts: busConfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: busConfRowStatus.setDescription('This object is used to create or\n                        delete entries in the busConfTable.')
busVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 3), )
if mibBuilder.loadTexts: busVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: busVccTable.setDescription('This table contains all the Multicast Forward\n                    VCCs used by the BUS to forward multicast traffic\n                    to the participating LECs.  The Multicast Forward\n                    VCC can either be point-to-point or point-to-\n                    multipoint calls.  This table is read only if\n                    SVCs are used and writable if PVCs are used.')
busVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 3, 1), ).setIndexNames((0, "LAN-EMULATION-BUS-MIB", "busConfIndex"), (0, "LAN-EMULATION-BUS-MIB", "busVccAtmIfIndex"), (0, "LAN-EMULATION-BUS-MIB", "busVccMtFwdVpi"), (0, "LAN-EMULATION-BUS-MIB", "busVccMtFwdVci"))
if mibBuilder.loadTexts: busVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busVccEntry.setDescription('Each entry in this table represents a\n                     Multicast Forward VCC of the BUS.')
busVccAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 3, 1, 1), IfIndexOrZero())
if mibBuilder.loadTexts: busVccAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: busVccAtmIfIndex.setDescription('The ATM interface which the Multicast\n                      Forward VCC is running on.\n                      This value must match an existing\n                      value  in the   ifTable.  \n                      The value of this object is set\n                      to zero when the ATM interface is\n                      undefined.')
busVccMtFwdVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 3, 1, 2), VpiInteger())
if mibBuilder.loadTexts: busVccMtFwdVpi.setStatus('mandatory')
if mibBuilder.loadTexts: busVccMtFwdVpi.setDescription('The VPI value of the Multicast\n                      Forward VCC.  The object\n                      busVccAtmIfIndex, busVccMtFwdVci\n                      and the value of this object uniquely\n                      identfies a VCC within a ATM host.')
busVccMtFwdVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 3, 1, 3), VciInteger())
if mibBuilder.loadTexts: busVccMtFwdVci.setStatus('mandatory')
if mibBuilder.loadTexts: busVccMtFwdVci.setDescription('The VCI value of the Multicast\n                      Forward VCC.  The object\n                      busVccAtmIfIndex, busVccMtFwdVpi\n                      and the value of this object uniquely\n                      identfies a VCC within a ATM host.')
busVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 3, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busVccRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                        for version 2 of the Simple Network Management \n                        Protocol (SNMPv2).')
if mibBuilder.loadTexts: busVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: busVccRowStatus.setDescription('This object is used to create or\n                        delete entries in the busConfTable.')
busLecTableLastChange = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 4), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busLecTableLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: busLecTableLastChange.setDescription('The value of sysUpTime when an entry of the\n                        busLecTable was created/deleted.')
busLecTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 5), )
if mibBuilder.loadTexts: busLecTable.setStatus('mandatory')
if mibBuilder.loadTexts: busLecTable.setDescription(' This table contains the BUS and the \n                        actual LECs being serviced by the BUS.\n                        It can be used as the actual mapping\n                        between BUS and LEC.\n\n                        This table provides information\n                        for Multicast send VCCs\n                        between BUS and clients.  Objects\n                        busLecMcastSendAtmIfIndex, busLecMcastSendVpi,\n                        and busLecMcstSendVci can only be modified\n                        if PVC is used.')
busLecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 5, 1), ).setIndexNames((0, "LAN-EMULATION-BUS-MIB", "busConfIndex"), (0, "LAN-EMULATION-BUS-MIB", "busLecAtmAddr"))
if mibBuilder.loadTexts: busLecEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busLecEntry.setDescription('Each entry represents a BUS to LEC\n                    mapping.')
busLecAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 5, 1, 1), AtmLaneAddress())
if mibBuilder.loadTexts: busLecAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: busLecAtmAddr.setDescription('The ATM address of the LEC.  This\n                        is the primary ATM address of the LEC.')
busLecMcastSendAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 5, 1, 2), IfIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busLecMcastSendAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: busLecMcastSendAtmIfIndex.setDescription('The  ATM  interface  index this BUS uses for \n                        Multicast Send traffic.  The value of this\n                        object has to exist in the ifTable in MIB II\n                        unless an internal connection is used.  When\n                        an internal connection is used, this object\n                        is set to zero.')
busLecMcastSendVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 5, 1, 4), VpiInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busLecMcastSendVpi.setStatus('mandatory')
if mibBuilder.loadTexts: busLecMcastSendVpi.setDescription(' The   virtual  path  identifier used to receive\n                        multicast traffic by this BUS.')
busLecMcastSendVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 5, 1, 5), VciInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busLecMcastSendVci.setStatus('mandatory')
if mibBuilder.loadTexts: busLecMcastSendVci.setDescription(' The   virtual  channel  identifier used to receive\n                        multicast traffic by this BUS.')
busLecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 1, 5, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busLecRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: busLecRowStatus.setDescription(' This object provides a way for the network manager\n                        to selectively remove a LE Client from the designated\n                        BUS.  Or in a system where PVCs are used, this table\n                        is used to create Multicast Send VCCs between BUS\n                        and LEC.')
busStatTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1), )
if mibBuilder.loadTexts: busStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: busStatTable.setDescription('This table contains all counters the\n                    BUS maintain.  This table is an extention\n                    to the busConfTable.')
busStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1), ).setIndexNames((0, "LAN-EMULATION-BUS-MIB", "busConfIndex"))
if mibBuilder.loadTexts: busStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busStatEntry.setDescription('Each entry in this table contains a\n                    BUS and its counters.')
busStatInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busStatInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: busStatInDiscards.setDescription('  The number of frames discarded due to resource\n                        error.')
busStatInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busStatInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: busStatInOctets.setDescription('  The number of  octets that  this  BUS has received\n                        since its initialization.')
busStatInUcastFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busStatInUcastFrms.setStatus('mandatory')
if mibBuilder.loadTexts: busStatInUcastFrms.setDescription(' The number  of  frames that  the BUS  has  received\n                        which were  unicast data frames  and all control\n                        frames (i.e. they were flooded from the client).')
busStatInMcastFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busStatInMcastFrms.setStatus('mandatory')
if mibBuilder.loadTexts: busStatInMcastFrms.setDescription('  The number of  frames  that  the BUS has  received\n                        which were multicast frames.')
busStatFrmTimeOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busStatFrmTimeOuts.setStatus('mandatory')
if mibBuilder.loadTexts: busStatFrmTimeOuts.setDescription(' The number of frames dropped by \n                        the BUS due to time out.')
busStatMcastSendRefused = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busStatMcastSendRefused.setStatus('mandatory')
if mibBuilder.loadTexts: busStatMcastSendRefused.setDescription('  The number of  multicast send VCCconnection setup \n                        attempts to the BUS which were refused.')
busStatMcastFwdFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busStatMcastFwdFailure.setStatus('mandatory')
if mibBuilder.loadTexts: busStatMcastFwdFailure.setDescription('  The number of  multicast forward VCCconnection setup \n                        attempts from the BUS which were unsuccessful\n                        for any reason.')
busLecStatTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 2), )
if mibBuilder.loadTexts: busLecStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: busLecStatTable.setDescription('This table contains all LEC counters\n                    the BUS maintains.  This table can also\n                    be used to retrieve all LECs a BUS\n                    is providing service to.')
busLecStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 2, 1), ).setIndexNames((0, "LAN-EMULATION-BUS-MIB", "busConfIndex"), (0, "LAN-EMULATION-BUS-MIB", "busLecAtmAddr"))
if mibBuilder.loadTexts: busLecStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busLecStatEntry.setDescription('Each entry in this table represents a\n                    LEC and its counters.')
busLecRecvs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busLecRecvs.setStatus('mandatory')
if mibBuilder.loadTexts: busLecRecvs.setDescription('Number of Multicast, Broadcast and\n                       Unknown Forward requests received by\n                       the BUS from this LEC.')
busLecForwards = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busLecForwards.setStatus('mandatory')
if mibBuilder.loadTexts: busLecForwards.setDescription('Number of Multicast, Broadcast and\n                       Unkown Forward requests forwarded by\n                       the BUS from this LEC.  The value\n                       of this object indicate how many requests\n                       have been forwarded by the BUS.')
busLecDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busLecDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: busLecDiscards.setDescription('Number of Multicast, Broadcast and\n                       Unkown Forward requests discarded by\n                       the BUS from this LEC.  The value\n                       of this object indicate how many requests\n                       have been discarded by the BUS.')
busErrCtlTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 1), )
if mibBuilder.loadTexts: busErrCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: busErrCtlTable.setDescription('This table contains error log control \n                        information of all BUS instances.\n                        This table is an extention to the\n                        busConfTable.  It is used to enable\n                        or disable error logs for a particular\n                        BUS entry.')
busErrCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 1, 1), ).setIndexNames((0, "LAN-EMULATION-BUS-MIB", "busConfIndex"))
if mibBuilder.loadTexts: busErrCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busErrCtlEntry.setDescription('Each entry represents a BUS entry\n                      in the busConfTable.')
busErrCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busErrCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: busErrCtlAdminStatus.setDescription('This object is used to enable/disable error \n                        logging for the BUS.')
busErrCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("outOfRes", 3), ("failed", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: busErrCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: busErrCtlOperStatus.setDescription('This object is used to indicate\n                   the result of a set operation to the\n                   object busErrCtlAdminStatus.\n                   If the error log was successfully\n                   started, it is in active(2) mode.\n                   Otherwise, it is set to either\n                   outOfRes(3) or failed(4) for\n                   the respective reasons.')
busErrCtlClearLog = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busErrCtlClearLog.setStatus('mandatory')
if mibBuilder.loadTexts: busErrCtlClearLog.setDescription('This object is used to clear the error log\n                     entries associated with this BUS.')
busErrCtlMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: busErrCtlMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: busErrCtlMaxEntries.setDescription('The maximum entries of the error\n                   log a BUS can support.')
busErrCtlLastEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busErrCtlLastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busErrCtlLastEntry.setDescription('The index to the last entry in the error\n                     log table for this BUS.')
busErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 2), )
if mibBuilder.loadTexts: busErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: busErrLogTable.setDescription('This table contains error logs\n                    of the BUS instances enabled\n                    in the busErrCtlTable.  This table\n                    is indexed by the BUS instance\n                    index and an arbitrary integer\n                    uniquely identifies an error\n                    log.')
busErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 2, 1), ).setIndexNames((0, "LAN-EMULATION-BUS-MIB", "busConfIndex"), (0, "LAN-EMULATION-BUS-MIB", "busErrLogIndex"))
if mibBuilder.loadTexts: busErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busErrLogEntry.setDescription('Each entry represents aan error detected by the BUS.')
busErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: busErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: busErrLogIndex.setDescription('An arbitrary integer which uniquely\n                    identifies an error log entry. The first\n                    entry after reset or clearing the error\n                    log is an assigned value (2^32-1).  Succeding\n                    entries are assigned with descending values \n                    consecutively.  Entries after 1 are discarded.The \n                    enabling/disabling of\n                    the error log capability is done in\n                    the busErrCtlTable.')
busErrLogAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busErrLogAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: busErrLogAtmAddr.setDescription('The primary ATM address of the LE Client on whose Multicast\n                    Send VCC the error occured. \n                    The corresponding error code is\n                    specified in the object busErrLogErrCode.')
busErrLogErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("outOfRes", 1), ("badCtlFrame", 2), ("badDataFrame", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: busErrLogErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: busErrLogErrCode.setDescription('The Error code which indicates the\n                    cause of the error.')
busErrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 4, 3, 2, 1, 4), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busErrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: busErrLogTime.setDescription('The sysUpTime when this entry was logged by\n                     the BUS.')
mibBuilder.exportSymbols("LAN-EMULATION-BUS-MIB", busConfOperStatus=busConfOperStatus, busErrCtlAdminStatus=busErrCtlAdminStatus, busErrLogIndex=busErrLogIndex, busStatEntry=busStatEntry, busConfAtmAddrSpec=busConfAtmAddrSpec, busVccAtmIfIndex=busVccAtmIfIndex, busVccTable=busVccTable, busConfAtmAddrMask=busConfAtmAddrMask, busConfTable=busConfTable, busErrLogErrCode=busErrLogErrCode, busStatGroup=busStatGroup, busLecMcastSendAtmIfIndex=busLecMcastSendAtmIfIndex, busLecDiscards=busLecDiscards, busLecTableLastChange=busLecTableLastChange, busLecAtmAddr=busLecAtmAddr, busStatInUcastFrms=busStatInUcastFrms, busLecForwards=busLecForwards, busConfAtmAddrActual=busConfAtmAddrActual, busErrCtlClearLog=busErrCtlClearLog, busConfIndex=busConfIndex, busLecTable=busLecTable, busMIB=busMIB, busLecEntry=busLecEntry, busConfLastChange=busConfLastChange, busStatTable=busStatTable, busVccMtFwdVci=busVccMtFwdVci, RowStatus=RowStatus, busStatMcastSendRefused=busStatMcastSendRefused, busErrLogAtmAddr=busErrLogAtmAddr, AtmLaneAddress=AtmLaneAddress, busLecStatTable=busLecStatTable, busConfGroup=busConfGroup, busConfNextId=busConfNextId, busConfEntry=busConfEntry, busLecStatEntry=busLecStatEntry, busLecMcastSendVci=busLecMcastSendVci, busConfMaxFrameAge=busConfMaxFrameAge, busConfRowStatus=busConfRowStatus, busVccMtFwdVpi=busVccMtFwdVpi, busStatMcastFwdFailure=busStatMcastFwdFailure, busVccRowStatus=busVccRowStatus, busErrCtlLastEntry=busErrCtlLastEntry, busFaultGroup=busFaultGroup, busLecRowStatus=busLecRowStatus, busStatInDiscards=busStatInDiscards, busVccEntry=busVccEntry, busStatInOctets=busStatInOctets, busErrLogTable=busErrLogTable, busLecMcastSendVpi=busLecMcastSendVpi, busStatFrmTimeOuts=busStatFrmTimeOuts, busErrCtlTable=busErrCtlTable, busErrLogEntry=busErrLogEntry, busStatInMcastFrms=busStatInMcastFrms, busErrLogTime=busErrLogTime, busErrCtlEntry=busErrCtlEntry, busErrCtlOperStatus=busErrCtlOperStatus, busLecRecvs=busLecRecvs, busErrCtlMaxEntries=busErrCtlMaxEntries, busConfElanName=busConfElanName, busConfAdminStatus=busConfAdminStatus)
