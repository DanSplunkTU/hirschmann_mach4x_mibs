#
# PySNMP MIB module PRVT-CFM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binox/PRVT-CFM-MIB
# Produced by pysmi-1.1.3 at Wed Dec  8 19:07:16 2021
# On host fv-az39-899 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
switch, = mibBuilder.importSymbols("PRVT-SWITCH-MIB", "switch")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Counter64, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, iso, NotificationType, MibIdentifier, Bits, ModuleIdentity, Integer32, IpAddress, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Counter64", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "iso", "NotificationType", "MibIdentifier", "Bits", "ModuleIdentity", "Integer32", "IpAddress", "Unsigned32", "TimeTicks")
TextualConvention, MacAddress, RowStatus, TDomain, DisplayString, TAddress, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "RowStatus", "TDomain", "DisplayString", "TAddress", "TimeStamp", "TruthValue")
prvtCfmMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 10, 5, 131))
prvtCfmMIB.setRevisions(('2014-04-17 00:00', '2011-04-11 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtCfmMIB.setRevisionsDescriptions(('Increased the number of profiles to 64', 'Initial',))
if mibBuilder.loadTexts: prvtCfmMIB.setLastUpdated('201404170000Z')
if mibBuilder.loadTexts: prvtCfmMIB.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtCfmMIB.setContactInfo('BATM/Telco Systems Support team\n         Email:\n         For North America: techsupport@telco.com\n         For North Europe: support@batm.de, info@batm.de\n         For the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtCfmMIB.setDescription('Prvt extension of Connectivity Fault Management module for managing IEEE 802.1ag')
class LldpChassisIdSubtype(TextualConvention, Integer32):
    description = "This TC describes the source of a chassis identifier.\n         The enumeration 'chassisComponent(1)' represents a chassis\n         identifier based on the value of entPhysicalAlias object\n         (defined in IETF RFC 2737) for a chassis component (i.e.,\n         an entPhysicalClass value of 'chassis(3)').\n         The enumeration 'interfaceAlias(2)' represents a chassis\n         identifier based on the value of ifAlias object (defined in\n         IETF RFC 2863) for an interface on the containing chassis.\n         The enumeration 'portComponent(3)' represents a chassis\n         identifier based on the value of entPhysicalAlias object\n         (defined in IETF RFC 2737) for a port or backplane\n         component (i.e., entPhysicalClass value of 'port(10)' or\n         'backplane(4)'), within the containing chassis.\n         The enumeration 'macAddress(4)' represents a chassis\n         identifier based on the value of a unicast source address\n         (encoded in network byte order and IEEE 802.3 canonical bit\n         order), of a port on the containing chassis as defined in\n         IEEE Std 802-2001.\n         The enumeration 'networkAddress(5)' represents a chassis\n         identifier based on a network address, associated with\n         a particular chassis. The encoded address is actually\n         composed of two fields. The first field is a single octet,\n         representing the IANA AddressFamilyNumbers value for the\n         specific address type, and the second field is the network\n         address value.\n         The enumeration 'interfaceName(6)' represents a chassis\n         identifier based on the value of ifName object (defined in\n         IETF RFC 2863) for an interface on the containing chassis.\n         The enumeration 'local(7)' represents a chassis identifier\n         based on a locally defined value."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("notSet", 0), ("chassisComponent", 1), ("interfaceAlias", 2), ("portComponent", 3), ("macAddress", 4), ("networkAddress", 5), ("interfaceName", 6), ("local", 7))

class LldpChassisId(TextualConvention, OctetString):
    description = "This TC describes the format of a chassis identifier string.\n         Objects of this type are always used with an associated\n         LldpChassisIdSubtype object, which identifies the format of\n         the particular LldpChassisId object instance.\n         If the associated LldpChassisIdSubtype object has a value of\n         'chassisComponent(1)', then the octet string identifies\n         a particular instance of the entPhysicalAlias object\n         (defined in IETF RFC 2737) for a chassis component (i.e.,\n         an entPhysicalClass value of 'chassis(3)').\n         If the associated LldpChassisIdSubtype object has a value\n         of 'interfaceAlias(2)', then the octet string identifies\n         a particular instance of the ifAlias object (defined in\n         IETF RFC 2863) for an interface on the containing chassis.\n         If the particular ifAlias object does not contain any values,\n         another chassis identifier type should be used.\n         If the associated LldpChassisIdSubtype object has a value\n         of 'portComponent(3)', then the octet string identifies a\n         particular instance of the entPhysicalAlias object (defined\n         in IETF RFC 2737) for a port or backplane component within\n         the containing chassis.\n         If the associated LldpChassisIdSubtype object has a value of\n         'macAddress(4)', then this string identifies a particular\n         unicast source address (encoded in network byte order and\n         IEEE 802.3 canonical bit order), of a port on the containing\n         chassis as defined in IEEE Std 802-2001.\n         If the associated LldpChassisIdSubtype object has a value of\n         'networkAddress(5)', then this string identifies a particular\n         network address, encoded in network byte order, associated\n         with one or more ports on the containing chassis. The first\n         octet contains the IANA Address Family Numbers enumeration\n         value for the specific address type, and octets 2 through\n         N contain the network address value in network byte order.\n         If the associated LldpChassisIdSubtype object has a value\n         of 'interfaceName(6)', then the octet string identifies\n         a particular instance of the ifName object (defined in\n         IETF RFC 2863) for an interface on the containing chassis.\n         If the particular ifName object does not contain any values,\n         another chassis identifier type should be used.\n         If the associated LldpChassisIdSubtype object has a value of\n         'local(7)', then this string identifies a locally assigned\n         Chassis ID."
    status = 'current'
    displayHint = '250a'

class LldpPortIdSubtype(TextualConvention, Integer32):
    description = "This TC describes the source of a particular type of port\n         identifier used in the LLDP MIB.\n         The enumeration 'interfaceAlias(1)' represents a port\n         identifier based on the ifAlias MIB object, defined in IETF\n         RFC 2863.\n         The enumeration 'portComponent(2)' represents a port\n         identifier based on the value of entPhysicalAlias (defined in\n         IETF RFC 2737) for a port component (i.e., entPhysicalClass\n         value of 'port(10)'), within the containing chassis.\n         The enumeration 'macAddress(3)' represents a port identifier\n         based on a unicast source address (encoded in network\n         byte order and IEEE 802.3 canonical bit order), which has\n         been detected by the agent and associated with a particular\n         port (IEEE Std 802-2001).\n         The enumeration 'networkAddress(4)' represents a port\n         identifier based on a network address, detected by the agent\n         and associated with a particular port.\n         The enumeration 'interfaceName(5)' represents a port\n         identifier based on the ifName MIB object, defined in IETF\n         RFC 2863.\n         The enumeration 'agentCircuitId(6)' represents a port\n         identifier based on the agent-local identifier of the circuit\n         (defined in RFC 3046), detected by the agent and associated\n         with a particular port.\n         The enumeration 'local(7)' represents a port identifier\n         based on a value locally assigned."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("notSet", 0), ("interfaceAlias", 1), ("portComponent", 2), ("macAddress", 3), ("networkAddress", 4), ("interfaceName", 5), ("agentCircuitId", 6), ("local", 7))

class LldpPortId(TextualConvention, OctetString):
    description = "This TC describes the format of a port identifier string.\n         Objects of this type are always used with an associated\n         LldpPortIdSubtype object, which identifies the format of the\n         particular LldpPortId object instance.\n         If the associated LldpPortIdSubtype object has a value of\n         'interfaceAlias(1)', then the octet string identifies a\n         particular instance of the ifAlias object (defined in IETF\n         RFC 2863). If the particular ifAlias object does not contain\n         any values, another port identifier type should be used.\n         If the associated LldpPortIdSubtype object has a value of\n         'portComponent(2)', then the octet string identifies a\n         particular instance of the entPhysicalAlias object (defined\n         in IETF RFC 2737) for a port or backplane component.\n         If the associated LldpPortIdSubtype object has a value of\n         'macAddress(3)', then this string identifies a particular\n         unicast source address (encoded in network byte order\n         and IEEE 802.3 canonical bit order) associated with the port\n         (IEEE Std 802-2001).\n         If the associated LldpPortIdSubtype object has a value of\n         'networkAddress(4)', then this string identifies a network\n         address associated with the port. The first octet contains\n         the IANA AddressFamilyNumbers enumeration value for the\n         specific address type, and octets 2 through N contain the\n         networkAddress address value in network byte order.\n         If the associated LldpPortIdSubtype object has a value of\n         'interfaceName(5)', then the octet string identifies a\n         particular instance of the ifName object (defined in IETF\n         RFC 2863). If the particular ifName object does not contain\n         any values, another port identifier type should be used.\n         If the associated LldpPortIdSubtype object has a value of\n         'agentCircuitId(6)', then this string identifies a agent-local\n         identifier of the circuit (defined in RFC 3046).\n         If the associated LldpPortIdSubtype object has a value of\n         'local(7)', then this string identifies a locally\n         assigned port ID."
    status = 'current'
    displayHint = '250a'

class PrvtCfmMaintAssocName(TextualConvention, OctetString):
    reference = '802.1ag clauses 21.6.5.4, 21.6.5.5, 21.6.5.6'
    description = "Denotes a generic Maintenance Association Name. It is the\n         part of the Maintenance Association Identifier which is\n         unique within the Maintenance Domain Name and is appended\n         to the Maintenance Domain Name to form the Maintenance\n         Association Identifier (MAID).\n         \n         A PrvtCfmMaintAssocName value is always interpreted within\n         the context of a PrvtCfmMaintAssocNameType value. Every\n         usage of the PrvtCfmMaintAssocName textual convention is\n         required to specify the PrvtCfmMaintAssocNameType object\n         that provides the context. It is suggested that the\n         PrvtCfmMaintAssocNameType object be logically registered\n         before the object(s) that use the PrvtCfmMaintAssocName\n         textual convention, if they appear in the same logical row.\n         \n         The value of a PrvtCfmMaintAssocName object must\n         always be consistent with the value of the associated\n         PrvtCfmMaintAssocNameType object. Attempts to set\n         an PrvtCfmMaintAssocName object to a value inconsistent\n         with the associated PrvtCfmMaintAssocNameType must fail\n         with an inconsistentValue error.\n         \n         When this textual convention is used as the syntax of an\n         index object, there may be issues with the limit of 128\n         sub-identifiers specified in SMIv2, IETF STD 58. In this\n         case, the object definition MUST include a 'SIZE' clause\n         to limit the number of potential instance sub-identifiers;\n         otherwise the applicable constraints MUST be stated in\n         the appropriate conceptual row DESCRIPTION clauses, or\n         in the surrounding documentation if there is no single\n         DESCRIPTION clause that is appropriate."
    status = 'current'
    displayHint = '45a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 22)

class PrvtCfmMaintAssocNameOrNone(TextualConvention, OctetString):
    description = 'Same as PrvtCfmMaintAssocName except that zero\n         length string represents no association name. '
    status = 'current'
    displayHint = '22a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 22)

class PrvtCfmMhfCreation(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.5.1.3:c and 22.2.3'
    description = 'Indicates if the Management Entity can create MHFs.\n         The valid values are:\n         \n         defMHFnone(1) No MHFs can be created for this VID.\n         defMHFdefault(2) MHFs can be created on this VID on any\n         Bridge port through which this VID can\n         pass.\n         defMHFexplicit(3) MHFs can be created for this VID only on\n         Bridge ports through which this VID can\n         pass, and only if a MEP is created at some\n         lower MD Level.\n         defMHFdefer(4) The creation of MHFs is determined by the\n         corresponding Maintenance Domain variable\n         (prvtCfmMaMhfCreation).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3), ("defMHFdefer", 4))

class PrvtCfmMhfCreationDef(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.5.1.3:c and 22.2.3'
    description = 'Indicates if the Management Entity can create MHFs.\n         The valid values are:\n         \n         defMHFnone(1) No MHFs can be created for this VID.\n         defMHFdefault(2) MHFs can be created on this VID on any\n         Bridge port through which this VID can\n         pass.\n         defMHFexplicit(3) MHFs can be created for this VID only on\n         Bridge ports through which this VID can\n         pass, and only if a MEP is created at some\n         lower MD Level.\n         defMHFdefer(4) The creation of MHFs is determined by the\n         corresponding Maintenance Domain variable\n         (prvtCfmMaMhfCreation).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3))

class PrvtCfmIdPermission(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.6.1.3:d and 21.5.3'
    description = 'Indicates what, if anything, is to be included in the Sender\n         ID TLV transmitted in CCMs, LBMs, LTMs, and LTRs. The valid\n         values are:\n         \n         sendIdNone(1) The Sender ID TLV is not to be sent.\n         sendIdChassis(2) The Chassis ID Length, Chassis ID\n         Subtype, and Chassis ID fields of the\n         Sender ID TLV are to be sent.\n         sendIdManage(3) The Management Address Length and\n         Management Address of the Sender ID TLV\n         are to be sent.\n         sendIdChassisManage(4) The Chassis ID Length, Chassis ID\n         Subtype, Chassis ID, Management Address\n         Length and Management Address fields are\n         all to be sent.\n         sendIdDefer(5) The contents of the Sender ID TLV are\n         determined by the corresponding\n         Maintenance Domain variable\n         (prvtCfmMaIdPermission).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4), ("sendIdDefer", 5))

class PrvtCfmIdPermissionDef(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.6.1.3:d and 21.5.3'
    description = 'Indicates what, if anything, is to be included in the Sender\n         ID TLV transmitted in CCMs, LBMs, LTMs, and LTRs. The valid\n         values are:\n         \n         sendIdNone(1) The Sender ID TLV is not to be sent.\n         sendIdChassis(2) The Chassis ID Length, Chassis ID\n         Subtype, and Chassis ID fields of the\n         Sender ID TLV are to be sent.\n         sendIdManage(3) The Management Address Length and\n         Management Address of the Sender ID TLV\n         are to be sent.\n         sendIdChassisManage(4) The Chassis ID Length, Chassis ID\n         Subtype, Chassis ID, Management Address\n         Length and Management Address fields are\n         all to be sent.\n         sendIdDefer(5) The contents of the Sender ID TLV are\n         determined by the corresponding\n         Maintenance Domain variable\n         (prvtCfmMaIdPermission).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4))

class PrvtCfmMaintAssocNameType(TextualConvention, Integer32):
    reference = '802.1ag clause 21.6.5.4, Table 21-20'
    description = 'A value that represents a type (and thereby the format)\n         of a PrvtCfmMaintAssocName. The value can be one of\n         the following:\n         \n         ieeeReserved(0) Reserved for definition by IEEE 802.1\n         recommend to not use zero unless\n         absolutely needed.\n         primaryVid(1) Primary VLAN ID.\n         12 bits represented in a 2-octet integer:\n         - 4 least significant bits of the first\n         byte contains the 4 most significant\n         bits of the 12 bits primary VID\n         - second byte contains the 8 least\n         significant bits of the primary VID\n         \n         0 1 2 3 4 5 6 7 8\n         +-+-+-+-+-+-+-+-+\n         |0 0 0 0| (MSB) |\n         +-+-+-+-+-+-+-+-+\n         | VID LSB |\n         +-+-+-+-+-+-+-+-+\n         \n         charString(2) RFC2579 DisplayString, except that the\n         character codes 0-31 (decimal) are not\n         used. (1..45) octets\n         unsignedInt16 (3) 2-octet integer/big endian\n         rfc2865VpnId(4) RFC 2685 VPN ID\n         3 octet VPN authority Organizationally\n         Unique Identifier followed by 4 octet VPN\n         index identifying VPN according to the OUI:\n         \n         0 1 2 3 4 5 6 7 8\n         +-+-+-+-+-+-+-+-+\n         | VPN OUI (MSB) |\n         +-+-+-+-+-+-+-+-+\n         | VPN OUI |\n         +-+-+-+-+-+-+-+-+\n         | VPN OUI (LSB) |\n         +-+-+-+-+-+-+-+-+\n         |VPN Index (MSB)|\n         +-+-+-+-+-+-+-+-+\n         | VPN Index |\n         +-+-+-+-+-+-+-+-+\n         | VPN Index |\n         +-+-+-+-+-+-+-+-+\n         |VPN Index (LSB)|\n         +-+-+-+-+-+-+-+-+\n         \n         ieeeReserved(xx) Reserved for definition by IEEE 802.1\n         xx values can be [5..31] and [64..255]\n         ituReserved(xx) Reserved for definition by ITU-T Y.1731\n         xx values range from [32..63]\n         \n         To support future extensions, the PrvtCfmMaintAssocNameType\n         textual convention SHOULD NOT be sub-typed in object type\n         definitions. It MAY be sub-typed in compliance statements in\n         order to require only a subset of these address types for a\n         compliant implementation.\n         \n         Implementations must ensure that PrvtCfmMaintAssocNameType\n         objects and any dependent objects (e.g.,\n         PrvtCfmMaintAssocName objects) are consistent. An\n         inconsistentValue error must be generated if an attempt to\n         change an PrvtCfmMaintAssocNameType object would, for\n         example, lead to an undefined PrvtCfmMaintAssocName value.\n         In particular,\n         PrvtCfmMaintAssocNameType/PrvtCfmMaintAssocName pairs\n         must be changed together if the nameType changes.\n         \n         The Maintenance Domain name and Maintenance Association name,\n         when put together into the CCM PDU, MUST total 48 octets or\n         less. If the PrvtCfmMaintDomainNameType object contains\n         none(1), then the PrvtCfmMaintAssocName object MUST be\n         45 octets or less in length. Otherwise, the length of\n         the PrvtCfmMaintDomainName object plus the length of the\n         PrvtCfmMaintAssocName object, added together, MUST total\n         less than or equal to 44 octets.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 32))
    namedValues = NamedValues(("primaryVid", 1), ("charString", 2), ("icc", 32))

class PrvtCfmCcmInterval(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.1.3:e, 20.8.1 and 21.6.1.3'
    description = "Indicates the interval at which CCMs are sent by a MEP.\n         The possible values are:\n         -- intervalInvalid(0) No CCMs are sent (disabled).\n         interval300Hz(1) CCMs are sent every 3 1/3 milliseconds\n         (300Hz).\n         interval10ms(2) CCMs are sent every 10 milliseconds.\n         interval100ms(3) CCMs are sent every 100 milliseconds.\n         interval1s(4) CCMs are sent every 1 second.\n         interval10s(5) CCMs are sent every 10 seconds.\n         interval1min(6) CCMs are sent every minute.\n         interval10min(7) CCMs are sent every 10 minutes.\n         \n         Note: enumerations start at zero to match the 'CCM Interval\n         field' protocol field."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("interval300Hz", 1), ("interval10ms", 2), ("interval100ms", 3), ("interval1s", 4), ("interval10s", 5), ("interval1min", 6), ("interval10min", 7))

class PrvtCfmIndexIntegerNextFree(TextualConvention, Unsigned32):
    description = 'An integer which may be used as a new Index in a table.\n         \n         The special value of 0 indicates that no more new entries can\n         be created in the relevant table.\n         \n         When a MIB is used for configuration, an object with this\n         SYNTAX always contains a legal value (if non-zero) for an\n         index that is not currently used in the relevant table. The\n         Command Generator (Network Management Application) reads this\n         variable and uses the (non-zero) value read when creating a\n         new row with an SNMP SET. When the SET is performed, the\n         Command Responder (agent) must determine whether the value is\n         indeed still unused; Two Network Management Applications may\n         attempt to create a row (configuration entry) simultaneously\n         and use the same value. If it is currently unused, the SET\n         succeeds and the Command Responder (agent) changes the value\n         of this object, according to an implementation-specific\n         algorithm. If the value is in use, however, the SET fails.\n         The Network Management Application must then re-read this\n         variable to obtain a new usable value.\n         \n         An OBJECT-TYPE definition using this SYNTAX MUST specify the\n         relevant table for which the object is providing this\n         functionality.'
    status = 'current'
    displayHint = 'd'

class PrvtCfmMaintDomainNameType(TextualConvention, Integer32):
    reference = '802.1ag clause 21.6.5, Table 21-19'
    description = 'A value that represents a type (and thereby the format)\n         of a PrvtCfmMaintDomainName. The value can be one of\n         the following:\n         \n         ieeeReserved(0) Reserved for definition by IEEE 802.1\n         recommend to not use zero unless\n         absolutely needed.\n         none(1) No format specified, usually because\n         there is not (yet) a Maintenance\n         Domain Name. In this case, a zero\n         length OCTET STRING for the Domain\n         Name field is acceptable.\n         dnsLikeName(2) Domain Name like string, globally unique\n         text string derived from a DNS name.\n         macAddrAndUint(3) MAC address + 2-octet (unsigned) integer.\n         charString(4) RFC2579 DisplayString, except that the\n         character codes 0-31 (decimal) are not\n         used.\n         ieeeReserved(xx) Reserved for definition by IEEE 802.1\n         xx values can be [5..31] and [64..255]\n         ituReserved(xx) Reserved for definition by ITU-T Y.1731\n         xx values range from [32..63]\n         \n         To support future extensions, the PrvtCfmMaintDomainNameType\n         textual convention SHOULD NOT be sub-typed in object type\n         definitions. It MAY be sub-typed in compliance statements in\n         order to require only a subset of these address types for a\n         compliant implementation.\n         \n         Implementations must ensure that PrvtCfmMaintDomainNameType\n         objects and any dependent objects (e.g.,\n         PrvtCfmMaintDomainName objects) are consistent. An\n         inconsistentValue error must be generated if an attempt to\n         change an PrvtCfmMaintDomainNameType object would, for\n         example, lead to an undefined PrvtCfmMaintDomainName value.\n         In particular,\n         PrvtCfmMaintDomainNameType/PrvtCfmMaintDomainName pairs\n         must be changed together if the nameType changes.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 4))
    namedValues = NamedValues(("none", 1), ("charString", 4))

class PrvtCfmMaintDomainName(TextualConvention, OctetString):
    reference = '802.1ag clause 21.6.5'
    description = "Denotes a generic Maintenance Domain Name.\n         \n         A PrvtCfmMaintDomainName value is always interpreted within\n         the context of a PrvtCfmMaintDomainNameType value. Every\n         usage of the PrvtCfmMaintDomainName textual convention is\n         required to specify the PrvtCfmMaintDomainNameType object\n         that provides the context. It is suggested that the\n         PrvtCfmMaintDomainNameType object be logically registered\n         before the object(s) that use the PrvtCfmMaintDomainName\n         textual convention, if they appear in the same logical row.\n         \n         The value of a PrvtCfmMaintDomainName object must always\n         be consistent with the value of the associated\n         PrvtCfmMaintDomainNameType object. Attempts to set\n         an PrvtCfmMaintDomainName object to a value inconsistent\n         with the associated PrvtCfmMaintDomainNameType must fail\n         with an inconsistentValue error.\n         \n         When this textual convention is used as the syntax of an\n         index object, there may be issues with the limit of 128\n         sub-identifiers specified in SMIv2, IETF STD 58. In this\n         case, the object definition MUST include a 'SIZE' clause\n         to limit the number of potential instance sub-identifiers;\n         otherwise the applicable constraints MUST be stated in\n         the appropriate conceptual row DESCRIPTION clauses, or\n         in the surrounding documentation if there is no single\n         DESCRIPTION clause that is appropriate.\n         \n         A value of none(1) in the associated\n         PrvtCfmMaintDomainNameType object means that no Maintenance\n         Domain name is present, and the contents of the\n         PrvtCfmMaintDomainName object are meaningless.\n         \n         See the DESCRIPTION of the PrvtCfmMaintAssocNameType\n         TEXTUAL-CONVENTION for a discussion of the length limits on\n         the Maintenance Domain name and Maintenance Association name."
    status = 'current'
    displayHint = '43a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 22)

class PrvtCfmMaintDomainNameOrNone(TextualConvention, OctetString):
    description = 'Same as PrvtCfmMaintDomainName except that zero\n         length string represents no domain name.'
    status = 'current'
    displayHint = '22a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 22)

class PrvtCfmMDLevelTC(TextualConvention, Integer32):
    reference = '802.1ag clauses 18.3, 21.4.1'
    description = "Integer identifying the Maintenance Domain Level (MD Level).\n         Higher numbers correspond to higher Maintenance Domains,\n         those with the greatest physical reach, with the highest\n         values for customers' CFM PDUs. Lower numbers correspond\n         to lower Maintenance Domains, those with more limited\n         physical reach, with the lowest values for CFM PDUs\n         protecting single bridges or physical links."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class PrvtCfmMpDirection(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.3.2:c'
    description = 'Indicates the direction in which the Maintenance\n         association (MEP or MIP) faces on the bridge port:\n         \n         down(1) Sends Continuity Check Messages away from the\n         MAC Relay Entity.\n         up(2) Sends Continuity Check Messages towards the\n         MAC Relay Entity.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("down", 1), ("up", 2))

class PrvtCfmMepIdOrZero(TextualConvention, Unsigned32):
    reference = '802.1ag clause 19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\n         integer, unique over a given Maintenance Association,\n         identifying a specific MEP.\n         \n         The special value 0 is allowed to indicate special cases, for\n         example that no MEPID is configured.\n         \n         Whenever an object is defined with this SYNTAX, then the\n         DESCRIPTION clause of such an object MUST specify what the\n         special value of 0 means.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 8191)

class PrvtCfmMepId(TextualConvention, Unsigned32):
    reference = '802.1ag clauses 3.19 and 19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\n         integer, unique over a given Maintenance Association,\n         identifying a specific MEP.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 8191)

class PrvtCfmFngState(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.1.3:f and 20.35'
    description = 'Indicates the diferent states of the MEP Fault Notification\n         Generator State Machine.\n         \n         fngReset(1) No defect has been present since the\n         prvtCfmMepFngResetTime timer\n         expired, or since the state machine\n         was last reset.\n         \n         fngDefect(2) A defect is present, but not for a\n         long enough time to be reported\n         (prvtCfmMepFngAlarmTime).\n         \n         fngReportDefect(3) A momentary state during which the\n         defect is reported by sending a\n         prvtCfmFaultAlarm notification,\n         if that action is enabled.\n         \n         fngDefectReported(4) A defect is present, and some defect\n         has been reported.\n         \n         fngDefectClearing(5) No defect is present, but the\n         prvtCfmMepFngResetTime timer has\n         not yet expired.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("fngReset", 1), ("fngDefect", 2), ("fngReportDefect", 3), ("fngDefectReported", 4), ("fngDefectClearing", 5))

class PrvtCfmLowestAlarmPri(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.1.3:k and 20.9.5'
    description = 'An integer value specifying the lowest priority defect\n         that is allowed to generate a Fault Alarm (20.9.5), either:\n         \n         allDef(1) DefRDICCM, DefMACstatus, DefRemoteCCM,\n         DefErrorCCM, and DefXconCCM;\n         macRemErrXcon(2) Only DefMACstatus, DefRemoteCCM,\n         DefErrorCCM, and DefXconCCM (default);\n         remErrXcon(3) Only DefRemoteCCM, DefErrorCCM,\n         and DefXconCCM;\n         errXcon(4) Only DefErrorCCM and DefXconCCM;\n         xcon(5) Only DefXconCCM; or\n         noXcon(6) No defects DefXcon or lower are to be\n         reported;'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("allDef", 1), ("macRemErrXcon", 2), ("remErrXcon", 3), ("errXcon", 4), ("xcon", 5), ("noXcon", 6))

class PrvtCfmHighestDefectPri(TextualConvention, Integer32):
    reference = '802.1ag clause 20.1.2, 12.14.7.7.2:c and 20.33.9'
    description = 'An enumerated value, equal to the contents of the variable\n         highestDefect (20.33.9 and Table 20-1), indicating the\n         highest-priority defect that has been present since the MEP\n         Fault Notification Generator State Machine was last in the\n         FNG_RESET state, either:\n         \n         none(0) no defects since FNG_RESET\n         defRDICCM(1) DefRDICCM\n         defMACstatus(2) DefMACstatus\n         defRemoteCCM(3) DefRemoteCCM\n         defErrorCCM(4) DefErrorCCM\n         defXconCCM(5) DefXconCCM\n         \n         The value 0 is used for no defects so that additional higher\n         priority values can be added, if needed, at a later time, and\n         so that these values correspond with those in\n         PrvtCfmLowestAlarmPri.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("defRDICCM", 1), ("defMACstatus", 2), ("defRemoteCCM", 3), ("defErrorCCM", 4), ("defXconCCM", 5))

class PrvtCfmRelayActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.5, 21.9.5, and\n         Table 21-27'
    description = 'Possible values the Relay action field can take.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("rlyHit", 1), ("rlyFdb", 2), ("rlyMpdb", 3))

class PrvtCfmIngressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.6, 21.9.8.1, and\n         Table 21-30'
    description = 'Possible values returned in the ingress action field.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("ingOk", 1), ("ingDown", 2), ("ingBlocked", 3), ("ingVid", 4))

class PrvtCfmEgressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:o, 20.36.2.10, 21.9.9.1, and\n         Table 21-32'
    description = 'Possible values returned in the egress action field'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("notSet", 0), ("egrOK", 1), ("egrDown", 2), ("egrBlocked", 3), ("egrVid", 4))

class PrvtCfmRemoteMepState(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.6.3:b, 20.22'
    description = 'Operational state of the remote MEP state machine. This\n         state machine monitors the reception of valid CCMs from a\n         remote MEP with a specific MEPID. It uses a timer that\n         expires in 3.5 times the length of time indicated by the\n         PrvtCfmMaCcmInterval object.\n         \n         rMepIdle(1) Momentary state during reset.\n         \n         rMepStart(2) The timer has not expired since the\n         state machine was reset, and no valid\n         CCM has yet been received.\n         \n         rMepFailed(3) The timer has expired, both since the\n         state machine was reset, and since a\n         valid CCM was received.\n         \n         rMepOk(4) The timer has not expired since a\n         valid CCM was received.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("rMepIdle", 1), ("rMepStart", 2), ("rMepFailed", 3), ("rMepOk", 4))

class PrvtCfmPortStatus(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.6.3:f, 20.19.3 and 21.5.4'
    description = 'An enumerated value from he Port Status TLV from the last CCM\n         received from the last MEP. It indicates the ability of the\n         Bridge Port on which the transmitting MEP resides to pass\n         ordinary data, regardless of the status of the MAC\n         (Table 21-10).\n         \n         psNoPortStateTLV(0) Indicates either that no CCM has been\n         received or that no port status TLV was\n         present in the last CCM received.\n         \n         psBlocked(1) Ordinary data cannot pass freely through\n         the port on which the remote MEP resides.\n         Value of enableRmepDefect is equal to\n         false.\n         \n         psUp(2): Ordinary data can pass freely through\n         the port on which the remote MEP resides.\n         Value of enableRmepDefect is equal to\n         true.\n         \n         NOTE: A 0 value is used for psNoPortStateTLV, so that\n         additional code points can be added in a manner\n         consistent with the PrvtCfmInterfaceStatus textual\n         convention.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("psNoPortStateTLV", 0), ("psBlocked", 1), ("psUp", 2))

class PrvtCfmInterfaceStatus(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.6.3:g, 20.19.4 and 21.5.5'
    description = 'An enumerated value from the Interface Status TLV from the\n         last CCM received from the last MEP. It indicates the status\n         of the Interface within which the MEP transmitting the CCM\n         is configured, or the next lower Interface in the Interface\n         Stack, if the MEP is not configured within an Interface.\n         \n         isNoInterfaceStatusTLV(0) Indicates either that no CCM has been\n         received or that no interface status TLV\n         was present in the last CCM received.\n         \n         isUp(1) The interface is ready to pass packets.\n         \n         isDown(2) The interface cannot pass packets\n         \n         isTesting(3) The interface is in some test mode.\n         \n         isUnknown(4) The interface status cannot be determined\n         for some reason.\n         \n         isDormant(5) The interface is not in a state to pass\n         packets but is in a pending state, waiting\n         for some external event.\n         \n         isNotPresent(6) Some component of the interface is missing\n         \n         isLowerLayerDown(7) The interface is down due to state of the\n         lower layer interfaces\n         \n         NOTE: A 0 value is used for isNoInterfaceStatusTLV, so that\n         these code points can be kept consistent with new code\n         points added to ifOperStatus in the IF-MIB.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("isNoInterfaceStatusTLV", 0), ("isUp", 1), ("isDown", 2), ("isTesting", 3), ("isUnknown", 4), ("isDormant", 5), ("isNotPresent", 6), ("isLowerLayerDown", 7))

prvtCfmMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0))
prvtCfmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1))
prvtCfmUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prvtCfmUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: prvtCfmUpdateInterval.setDescription('Time between monitoring parameters update (in seconds).\n         A value of 0 suspends the monitoring task and a\n         value different from 0 resumes it. Default is 20 seconds.')
prvtCfmShutdown = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prvtCfmShutdown.setStatus('current')
if mibBuilder.loadTexts: prvtCfmShutdown.setDescription("Set to 'true' to disable CFM, or to 'false', to enable.")
prvtCfmStack = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3))
prvtCfmStackTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1), )
if mibBuilder.loadTexts: prvtCfmStackTable.setReference('802.1ag clauses 12.14.2')
if mibBuilder.loadTexts: prvtCfmStackTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackTable.setDescription('There is one CFM Stack table per bridge. It permits\n         the retrieval of information about the Maintenance Points\n         configured on any given interface.')
prvtCfmStackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmStackInterfaceIndex"), (0, "PRVT-CFM-MIB", "prvtCfmStackServiceIdOrNone"), (0, "PRVT-CFM-MIB", "prvtCfmStackMdLevel"), (0, "PRVT-CFM-MIB", "prvtCfmStackDirection"))
if mibBuilder.loadTexts: prvtCfmStackEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackEntry.setDescription('The Stack table entry')
prvtCfmStackInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: prvtCfmStackInterfaceIndex.setReference('802.1ag clause 12.14.2.1.2:a')
if mibBuilder.loadTexts: prvtCfmStackInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackInterfaceIndex.setDescription('This object represents the Bridge Port or aggregated port\n         on which MEPs or MHFs might be configured.\n         \n         Upon a restart of the system, the system SHALL, if necessary,\n         change the value of this variable, and rearrange the\n         prvtCfmStackTable, so that it indexes the entry in the\n         interface table with the same value of ifAlias that it\n         indexed before the system restart. If no such entry exists,\n         then the system SHALL delete all entries in the\n         prvtCfmStackTable with the interface index.')
prvtCfmStackServiceIdOrNone = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: prvtCfmStackServiceIdOrNone.setReference('802.1ag clause 12.14.2.1.2:d')
if mibBuilder.loadTexts: prvtCfmStackServiceIdOrNone.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackServiceIdOrNone.setDescription('VLAN ID to which the MP is attached, or 0, if none.')
prvtCfmStackMdLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 3), PrvtCfmMDLevelTC())
if mibBuilder.loadTexts: prvtCfmStackMdLevel.setReference('802.1ag clause 12.14.2.1.2:b')
if mibBuilder.loadTexts: prvtCfmStackMdLevel.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackMdLevel.setDescription('MD Level of the Maintenance Point.')
prvtCfmStackDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 4), PrvtCfmMpDirection())
if mibBuilder.loadTexts: prvtCfmStackDirection.setReference('802.1ag clause 12.14.2.1.2:c')
if mibBuilder.loadTexts: prvtCfmStackDirection.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackDirection.setDescription('Direction in which the MP faces on the Bridge Port')
prvtCfmStackMdName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 5), PrvtCfmMaintDomainNameOrNone()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmStackMdName.setReference('802.1ag clause 12.14.2.1.3:b')
if mibBuilder.loadTexts: prvtCfmStackMdName.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackMdName.setDescription('The index of the Maintenance Domain in the prvtCfmMdTable\n         to which the MP is associated, or zero-length, if none.')
prvtCfmStackMaName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 6), PrvtCfmMaintAssocNameOrNone()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmStackMaName.setReference('802.1ag clause 12.14.2.1.3:c')
if mibBuilder.loadTexts: prvtCfmStackMaName.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackMaName.setDescription('The index of the MA in the prvtCfmMaTable\n         to which the MP is associated, or zero-length, if none.')
prvtCfmStackMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmStackMepId.setReference('802.1ag clause 12.14.2.1.3:d')
if mibBuilder.loadTexts: prvtCfmStackMepId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackMepId.setDescription('If an MEP is configured, the MEPID, else 0')
prvtCfmStackMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 3, 1, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmStackMacAddress.setReference('802.1ag clause 12.14.2.1.3:e')
if mibBuilder.loadTexts: prvtCfmStackMacAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmStackMacAddress.setDescription('MAC address of the MP.')
prvtCfmMd = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4))
prvtCfmMdTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2), )
if mibBuilder.loadTexts: prvtCfmMdTable.setReference('802.1ag clauses 3.22 and 18.1')
if mibBuilder.loadTexts: prvtCfmMdTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdTable.setDescription('The Maintenance Domain table. Each row in the table\n         represents a different Maintenance Domain.\n         \n         A Maintenance Domain is described in 802.1ag (3.22) as the\n         network or the part of the network for which faults in\n         connectivity are to be managed. The boundary of a Maintenance\n         Domain is defined by a set of DSAPs, each of which can become\n         a point of connectivity to a service instance.')
prvtCfmMdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"))
if mibBuilder.loadTexts: prvtCfmMdEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdEntry.setDescription('The Maintenance Domain table entry. This entry is not lost\n         upon reboot. It is backed up by stable storage.')
prvtCfmMdName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2, 1, 1), PrvtCfmMaintDomainName())
if mibBuilder.loadTexts: prvtCfmMdName.setReference('802.1ag clauses 3.24, 12.14.5, and 21.6.5.3')
if mibBuilder.loadTexts: prvtCfmMdName.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdName.setDescription('The Maintenance Domain name.\n         \n         Each Maintenance Domain has unique name amongst all those\n         used or available to a service provider or operator. It\n         facilitates easy identification of administrative\n         responsibility for each Maintenance Domain.\n         \n         Clause 3.24 defines a Maintenance Domain name as the\n         identifier, unique over the domain for which CFM is to\n         protect against accidental concatenation of Service\n         Instances, of a particular Maintenance Domain.')
prvtCfmMdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMdRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdRowStatus.setDescription('The status of the row.\n         \n         The writable columns in a row can not be changed if the row\n         is active. All columns must have a valid value before a row\n         can be activated.')
prvtCfmMdLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2, 1, 4), PrvtCfmMDLevelTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMdLevel.setReference('802.1ag clause 12.14.5.1.3:b')
if mibBuilder.loadTexts: prvtCfmMdLevel.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdLevel.setDescription('The Maintenance Domain Level.')
prvtCfmMdFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2, 1, 5), PrvtCfmMaintDomainNameType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMdFormat.setReference('802.1ag clause 21.6.5.1')
if mibBuilder.loadTexts: prvtCfmMdFormat.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdFormat.setDescription('The type (and thereby format) of the Maintenance Domain Name.')
prvtCfmMdMhfCreation = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2, 1, 6), PrvtCfmMhfCreationDef()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMdMhfCreation.setReference('802.1ag clause 12.14.5.1.3:c')
if mibBuilder.loadTexts: prvtCfmMdMhfCreation.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdMhfCreation.setDescription('Enumerated value indicating whether the management entity can\n         create MHFs (MIP Half Function) for this Maintenance Domain.\n         Since, in this variable, there is no encompassing Maintenance\n         Domain, the value defMHFdefer is not allowed.')
prvtCfmMdMhfIdPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 4, 2, 1, 7), PrvtCfmIdPermissionDef()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMdMhfIdPermission.setReference('802.1ag clause 12.14.5.1.3:d')
if mibBuilder.loadTexts: prvtCfmMdMhfIdPermission.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMdMhfIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\n         included in the Sender ID TLV (21.5.3) transmitted by MPs\n         configured in this Maintenance Domain. Since, in this\n         variable, there is no encompassing Maintenance Domain, the\n         value sendIdDefer is not allowed.')
prvtCfmMa = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5))
prvtCfmMaTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1), )
if mibBuilder.loadTexts: prvtCfmMaTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaTable.setDescription('The Maintenance Association table. Each row in the table\n         represents an MA. An MA is a set of MEPs, each configured\n         with a single service instance.\n         \n         The writable objects in this table need to be persistent\n         upon reboot or restart of a device.\n         \n         Table includes extra variables needed for Y.1731\n         support and service awareness')
prvtCfmMaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"))
if mibBuilder.loadTexts: prvtCfmMaEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaEntry.setDescription('prvtCfmMaEntry')
prvtCfmMaName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 1), PrvtCfmMaintAssocName())
if mibBuilder.loadTexts: prvtCfmMaName.setReference('802.1ag clauses 21.6.5.6, and Table 21-20')
if mibBuilder.loadTexts: prvtCfmMaName.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaName.setDescription('The Short Maintenance Association name.\n         \n         This name must be unique within a maintenance domain.')
prvtCfmMaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaRowStatus.setDescription('The status of the row.\n         The writable columns in a row can not be changed if the row\n         is active. All columns must have a valid value before a row\n         can be activated.')
prvtCfmMaServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967294))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaServiceId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaServiceId.setDescription('The primary service ID attached to this MA')
prvtCfmMaVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaVlanId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaVlanId.setDescription('The primary vlan ID attached to this MA')
prvtCfmMaMhfCreation = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 6), PrvtCfmMhfCreation()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaMhfCreation.setReference('802.1ag clause 12.14.6.1.3:c')
if mibBuilder.loadTexts: prvtCfmMaMhfCreation.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaMhfCreation.setDescription('Indicates if the Management entity can create MHFs\n         (MIP Half Function) for this MA.')
prvtCfmMaPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 7), PrvtCfmIdPermission()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaPermission.setReference('802.1ag clause 12.14.6.1.3:d')
if mibBuilder.loadTexts: prvtCfmMaPermission.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaPermission.setDescription('Enumerated value indicating what, if anything, is to be\n         included in the Sender ID TLV (21.5.3) transmitted by MPs\n         configured in this MA.')
prvtCfmMaFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 8), PrvtCfmMaintAssocNameType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaFormat.setReference('802.1ag clauses 21.6.5.4')
if mibBuilder.loadTexts: prvtCfmMaFormat.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaFormat.setDescription('The type (and thereby format) of the\n         Maintenance Association Name.')
prvtCfmMaCcmInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 9), PrvtCfmCcmInterval()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaCcmInterval.setReference('802.1ag clause 12.14.6.1.3:e')
if mibBuilder.loadTexts: prvtCfmMaCcmInterval.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaCcmInterval.setDescription('Interval between CCM transmissions to be\n         used by all MEPs in the MA.')
prvtCfmMaAisLckReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaAisLckReceive.setReference('ITU-T Recommendation Y.1731 clauses 7.4 and 7.6')
if mibBuilder.loadTexts: prvtCfmMaAisLckReceive.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckReceive.setDescription('Turn the AIS & LCK features on/off.')
prvtCfmMaAisLckLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaAisLckLevel.setReference('ITU-T Recommendation Y.1731 clauses 7.4 and 7.6')
if mibBuilder.loadTexts: prvtCfmMaAisLckLevel.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckLevel.setDescription('The MD level at which AIS & LCK frames will be sent.')
prvtCfmMaAisLckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("interval1s", 1), ("interval1min", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaAisLckInterval.setReference('ITU-T Recommendation Y.1731 clauses 7.4 and 7.6')
if mibBuilder.loadTexts: prvtCfmMaAisLckInterval.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckInterval.setDescription('The time interval at which AIS and LCK frames will be sent')
prvtCfmMaAisLckPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaAisLckPriority.setReference('ITU-T Recommendation Y.1731 clauses 7.4 and 7.6')
if mibBuilder.loadTexts: prvtCfmMaAisLckPriority.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckPriority.setDescription('COS parameter for the outgoing AIS & LCK frames.')
prvtCfmMaClearConnectivity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 5, 1, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaClearConnectivity.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaClearConnectivity.setDescription('The ID of the MEP to be cleared from the MEP table, or 0 for all')
prvtCfmMep = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6))
prvtCfmMepTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1), )
if mibBuilder.loadTexts: prvtCfmMepTable.setReference('802.1ag clauses 12.14.7 and 19.2')
if mibBuilder.loadTexts: prvtCfmMepTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTable.setDescription('The Maintenance Association End Point (MEP) table.\n         \n         Each row in the table represents a different MEP. A MEP is\n         an actively managed CFM entity, associated with a specific\n         DSAP of a Service Instance, which can generate and receive\n         CFM PDUs and track any responses. It is an end point of a\n         single Maintenance Association, and is an endpoint of a\n         separate Maintenance Entity for each of the other MEPs in\n         the same Maintenance Association (802.1ag clause 3.18).\n         \n         This table uses three indices. The first two indices are the\n         indices of the Maintenance Domain and MA tables, the reason\n         being that a MEP is always related to an MA and Maintenance\n         Domain.\n         \n         The MEP table also stores all the managed objects for sending\n         LBM and LTM.\n         \n         *LBM Managed objects\n         \n         LBM Managed objects in the MEP table\n         enables the management entity to initiate\n         transmission of Loopback messages. It will signal the MEP\n         that it should transmit some number of Loopback messages\n         and detect the detection (or lack thereof) of the\n         corresponding Loopback messages.\n         \n         Steps to use entries in this table:\n         \n         1) Set prvtCfmMepTransmitLbmStatus to true\n         2) Set the target by:\n         a) target mep - configue prvtCfmMepTransmitLbmDestIsMepId\n         on true and then configure prvtCfmMepTransmitLbmDestMepId with\n         the remote mep id\n         b) target mac - configue prvtCfmMepTransmitLbmDestIsMepId\n         on false and then configure prvtCfmMepTransmitLbmDestMacAddress\n         with the remote device mac address\n         3) Setup the different data to be sent (number of messages,\n         optional TLVs,...).\n         4) Record the current values of prvtCfmMepLbrIn,\n         prvtCfmMepLbrInOutOfOrder, and prvtCfmMepLbrBadMsdu.\n         6) Change prvtCfmMepTransmitLbmStatus value to false\n         to initiate transmission of Loopback messages.\n         7) Check the value of prvtCfmMepTransmitLbmResultOK to\n         find out if the operation was successfully initiated or\n         not.\n         8) If prvtCfmMepTransmitLbmInfinite is set to false you can\n         monitor the value of prvtCfmMepTransmitLbmRemainingMessages.\n         When it reaches 0, the last LBM has been transmitted and\n         the operation is finished.\n         Wait an additional 5 seconds to ensure that all LBRs have\n         been returned.\n         9) If prvtCfmMepTransmitLbmInfinite is set to true you must stop\n         the operation yourself by setting prvtCfmMepTransmitLbmStatus to true.\n         10) Compare prvtCfmMepLbrIn, prvtCfmMepLbrInOutOfOrder,\n         and prvtCfmMepLbrBadMsdu to their old values from step\n         4, above, to get the results of the test.\n         \n         \n         *LTM Managed objects\n         The LTM Managed objects in the MEP table are used in a manner\n         similar to that described for LBM transmission, above. Upon\n         successfully initiating the transmission, the variables\n         pvrtCfmMepTransmitLtmSeqNumber and\n         prvtCfmMepTransmitLtmEgressIdentifier return the information\n         required to recover the results of the LTM from the\n         prvtCfmLtrTable.')
prvtCfmMepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"), (0, "PRVT-CFM-MIB", "prvtCfmMepIdentifier"))
if mibBuilder.loadTexts: prvtCfmMepEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepEntry.setDescription('prvtCfmMepEntry')
prvtCfmMepIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 1), PrvtCfmMepId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepIdentifier.setReference('802.1ag clauses 3.19, 19.2 and 12.14.7')
if mibBuilder.loadTexts: prvtCfmMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepIdentifier.setDescription('Integer that is unique among all the MEPs in the same MA.\n         Other definition is: a small integer, unique over a given\n         Maintenance Association, identifying a specific Maintenance\n         association End Point (3.19).\n         \n         MEP Identifier is also known as the MEPID.')
prvtCfmMepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepRowStatus.setDescription('The status of the row.\n         \n         The writable columns in a row can not be changed if the row\n         is active. All columns must have a valid value before a row\n         can be activated.')
prvtCfmMepInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 3), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepInterfaceIndex.setReference('802.1ag clause 12.14.7.1.3:b')
if mibBuilder.loadTexts: prvtCfmMepInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepInterfaceIndex.setDescription('This object is the interface index (from ifTable) of either\n         a bridge port, or an aggregated IEEE 802.1 link,\n         to which the MEP is attached.')
prvtCfmMepDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 4), PrvtCfmMpDirection()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepDirection.setReference('802.1ag clauses 12.14.7.1.3:c and 19.2')
if mibBuilder.loadTexts: prvtCfmMepDirection.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDirection.setDescription('The direction in which the MEP faces on the Bridge port.')
prvtCfmMepShutdown = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepShutdown.setReference('802.1ag clauses 12.14.7.1.3:e and 20.9.1')
if mibBuilder.loadTexts: prvtCfmMepShutdown.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepShutdown.setDescription("Administrative state of the MEP\n         The value 'true' will shutdown/disable the MEP.\n         The value 'false' will enable the MEP.")
prvtCfmMepFngState = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 6), PrvtCfmFngState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepFngState.setReference('802.1ag clauses 12.14.7.1.3:f and 20.35')
if mibBuilder.loadTexts: prvtCfmMepFngState.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepFngState.setDescription('Current state of the MEP Fault Notification Generator\n         State Machine.')
prvtCfmMepCciEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepCciEnabled.setReference('802.1ag clauses 12.14.7.1.3:g and 20.10.1')
if mibBuilder.loadTexts: prvtCfmMepCciEnabled.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepCciEnabled.setDescription('If set to true, the MEP will generate CCM messages.')
prvtCfmMepCcmLtmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepCcmLtmPriority.setReference('802.1ag clause 12.14.7.1.3:h')
if mibBuilder.loadTexts: prvtCfmMepCcmLtmPriority.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepCcmLtmPriority.setDescription('The priority value for CCMs and LTMs transmitted by the MEP.\n         Default Value is the highest priority value allowed to pass\n         through the bridge port for any of this MEPs VIDs.\n         The management entity can obtain the default value for this\n         variable from the priority regeneration table by extracting the\n         highest priority value in this table on this MEPs bridge port.\n         (1 is lowest, then 2, then 0, then 3-7).')
prvtCfmMepMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepMacAddress.setReference('802.1ag clause 12.14.7.1.3:i and 19.4')
if mibBuilder.loadTexts: prvtCfmMepMacAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepMacAddress.setDescription('MAC address of the MEP.')
prvtCfmMepLowPrDef = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 10), PrvtCfmLowestAlarmPri()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepLowPrDef.setReference('802.1ag clause 12.14.7.1.3:k and 20.9.5 and Table 20-1')
if mibBuilder.loadTexts: prvtCfmMepLowPrDef.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLowPrDef.setDescription('An integer value specifying the lowest priority defect\n         that is allowed to generate fault alarm.')
prvtCfmMepHighestPrDefect = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 11), PrvtCfmHighestDefectPri()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepHighestPrDefect.setReference('802.1ag clause 12.14.7.1.3:n 20.33.9 and Table 21-1')
if mibBuilder.loadTexts: prvtCfmMepHighestPrDefect.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepHighestPrDefect.setDescription('The highest priority defect that has been present since the\n         MEPs Fault Notification Generator State Machine was last in\n         the FNG_RESET state.')
prvtCfmMepDefects = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 12), Bits().clone(namedValues=NamedValues(("bDefRDICCM", 0), ("bDefMACstatus", 1), ("bDefRemoteCCM", 2), ("bDefErrorCCM", 3), ("bDefXconCCM", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDefects.setReference('.1ag clauses 12.14.7.1.3:o, 12.14.7.1.3:p, 12.14.7.1.3:q,\n         12.14.7.1.3:r, 12.14.7.1.3:s, 20.21.3, 20.23.3, 20.33.5,\n         20.33.6, 20.33.7.')
if mibBuilder.loadTexts: prvtCfmMepDefects.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDefects.setDescription('A vector of Boolean error conditions from Table 20-1, any of\n         which may be true.')
prvtCfmMepErrorCcmLastFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepErrorCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:t and 20.21.2')
if mibBuilder.loadTexts: prvtCfmMepErrorCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepErrorCcmLastFailure.setDescription('The last-received CCM that triggered an DefErrorCCM fault.')
prvtCfmMepXconCcmLastFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepXconCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:u and 20.23.2')
if mibBuilder.loadTexts: prvtCfmMepXconCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepXconCcmLastFailure.setDescription('The last-received CCM that triggered a DefXconCCM fault.')
prvtCfmMepCcmSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepCcmSequenceErrors.setReference('802.1ag clauses 12.14.7.1.3:v and 20.16.12')
if mibBuilder.loadTexts: prvtCfmMepCcmSequenceErrors.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepCcmSequenceErrors.setDescription('The total number of out-of-sequence CCMs received from all\n         remote MEPs.')
prvtCfmMepCciSentCcms = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepCciSentCcms.setReference('802.1ag clauses 12.14.7.1.3:w and 20.10.2')
if mibBuilder.loadTexts: prvtCfmMepCciSentCcms.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepCciSentCcms.setDescription('Total number of Continuity Check messages transmitted.')
prvtCfmMepNextLbmTransId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepNextLbmTransId.setReference('802.1ag clauses 12.14.7.1.3:x and 20.28.2')
if mibBuilder.loadTexts: prvtCfmMepNextLbmTransId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepNextLbmTransId.setDescription('Next sequence number/transaction identifier to be sent in a\n         Loopback message. This sequence number can be zero because\n         it wraps around.')
prvtCfmMepLbrIn = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepLbrIn.setReference('802.1ag clause 12.14.7.1.3:y and 20.31.1')
if mibBuilder.loadTexts: prvtCfmMepLbrIn.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLbrIn.setDescription('Total number of valid, in-order Loopback Replies received.')
prvtCfmMepLbrInOutOfOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepLbrInOutOfOrder.setReference('802.1ag clause 12.14.7.1.3:z and 20.31.1')
if mibBuilder.loadTexts: prvtCfmMepLbrInOutOfOrder.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLbrInOutOfOrder.setDescription('The total number of valid, out-of-order Loopback Replies\n         received.')
prvtCfmMepLbrBadMsdu = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepLbrBadMsdu.setReference('802.1ag clause 12.14.7.1.3:aa 20.2.3')
if mibBuilder.loadTexts: prvtCfmMepLbrBadMsdu.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLbrBadMsdu.setDescription('The total number of LBRs received whose\n         mac_service_data_unit did not match (except for the OpCode)\n         that of the corresponding LBM (20.2.3).')
prvtCfmMepLtmNextSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepLtmNextSeqNumber.setReference('802.1ag clause 12.14.7.1.3:ab and 20.36.1')
if mibBuilder.loadTexts: prvtCfmMepLtmNextSeqNumber.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLtmNextSeqNumber.setDescription('Next transaction identifier/sequence number to be sent in a\n         Linktrace message. This sequence number can be zero because\n         it wraps around.')
prvtCfmMepUnexpLtrIn = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepUnexpLtrIn.setReference('802.1ag clause 12.14.7.1.3:ac 20.39.1')
if mibBuilder.loadTexts: prvtCfmMepUnexpLtrIn.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepUnexpLtrIn.setDescription('The total number of unexpected LTRs received (20.39.1).')
prvtCfmMepLbrOut = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepLbrOut.setReference('802.1ag clause 12.14.7.1.3:ad and 20.26.2')
if mibBuilder.loadTexts: prvtCfmMepLbrOut.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLbrOut.setDescription('Total number of Loopback Replies transmitted.')
prvtCfmMepTransmitLbmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 24), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\n         that another LBM may be transmitted.\n         Reset to false by the MEP Loopback Initiator State Machine.')
prvtCfmMepTransmitLbmDestMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 25), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestMacAddress.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestMacAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\n         destination MAC address.\n         This address will be used if the value of the column\n         prvtCfmMepTransmitLbmDestIsMepId is 'false'.")
prvtCfmMepTransmitLbmDestMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 26), PrvtCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestMepId.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestMepId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestMepId.setDescription("The Maintenance association End Point Identifier of another\n         MEP in the same Maintenance Association to which the LBM is\n         to be sent.\n         This address will be used if the value of the column\n         prvtCfmMepTransmitLbmDestIsMepId is 'true'.")
prvtCfmMepTransmitLbmDestIsMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 27), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestIsMepId.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestIsMepId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDestIsMepId.setDescription('True indicates that MEPID of the target MEP is used for\n         Loopback transmission.\n         False indicates that unicast destination MAC address of the\n         target MEP is used for Loopback transmission.')
prvtCfmMepTransmitLbmMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmMessages.setReference('802.1ag clause 12.14.7.3.2:c')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmMessages.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmMessages.setDescription('The number of Loopback messages to be transmitted.')
prvtCfmMepTransmitLbmDataTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1462))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDataTlv.setReference('802.1ag clause 12.14.7.3.2:d')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDataTlv.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDataTlv.setDescription('An arbitrary amount of data to be included in the Data TLV,\n         if the Data TLV is selected to be sent.')
prvtCfmMepTransmitLbmVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmVlanPriority.setReference('802.1ag clause 12.14.7.3.2:e')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmVlanPriority.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmVlanPriority.setDescription('Priority. 3 bit value to be used in the VLAN tag, if present\n         in the transmitted frame.\n         \n         The default value is CCM priority.')
prvtCfmMepTransmitLbmVlanDropEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 31), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmVlanDropEnable.setReference('802.1ag clause 12.14.7.3.2:e')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmVlanDropEnable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmVlanDropEnable.setDescription('Drop Enable bit value to be used in the VLAN tag, if present\n         in the transmitted frame.\n         \n         For more information about VLAN Drop Enable, please check\n         IEEE 802.1ad.')
prvtCfmMepTransmitLbmResultOK = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 32), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmResultOK.setReference('802.1ag clause 12.14.7.3.3:a')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmResultOK.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmResultOK.setDescription('Indicates the result of the operation:\n         \n         - true The Loopback Message(s) will be\n         (or has been) sent.\n         - false The Loopback Message(s) will not\n         be sent.')
prvtCfmMepTransmitLbmSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 33), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmSeqNumber.setReference('802.1ag clause 12.14.7.3.3:a')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmSeqNumber.setDescription('The Loopback Transaction Identifier\n         (prvtCfmMepNextLbmTransId) of the first LBM (to be) sent.\n         The value returned is undefined if\n         prvtCfmMepTransmitLbmResultOK is false.')
prvtCfmMepTransmitLtmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 34), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\n         that another LTM may be transmitted.\n         In order to start linktrace following step should be executed:\n         1.Verify CFM connectivity\n         2.Set prvtCfmMepTransmitLtmTargetIsMepId to TRUE (if using target Mep)\n         3.Set prvtCfmMepTransmitLtmTargetMepId with the remote Mep Id\n         4.Set prvtCfmMepTransmitLtmTimeout (timeout for LTM packets)\n         5.Set prvtCfmMepTransmitLtmStatus to TRUE')
prvtCfmMepTransmitLtmFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 35), Bits().clone(namedValues=NamedValues(("useFDBonly", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmFlags.setReference('802.1ag clause 12.14.7.4.2:b and 20.37.1')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmFlags.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmFlags.setDescription('The flags field for LTMs transmitted by the MEP.')
prvtCfmMepTransmitLtmTargetMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 36), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetMacAddress.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetMacAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\n         destination MAC address.\n         This address will be used if the value of the column\n         prvtCfmMepTransmitLtmTargetIsMepId is 'false'.")
prvtCfmMepTransmitLtmTargetMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 37), PrvtCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetMepId.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetMepId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetMepId.setDescription("An indication of the Target MAC Address Field to be\n         transmitted:\n         The Maintenance association End Point Identifier of\n         another MEP in the same Maintenance Association\n         This address will be used if the value of the column\n         prvtCfmMepTransmitLtmTargetIsMepId is 'true'.")
prvtCfmMepTransmitLtmTargetIsMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 38), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetIsMepId.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetIsMepId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTargetIsMepId.setDescription('True indicates that MEPID of the target MEP is used for\n         Linktrace transmission.\n         False indicates that unicast destination MAC address of the\n         target MEP is used for Loopback transmission.')
prvtCfmMepTransmitLtmTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 39), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTtl.setReference('802.1ag clause 12.14.7.4.2:d and 21.8.4')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTtl.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTtl.setDescription('The LTM TTL field. Default value, if not specified, is 64.\n         The TTL field indicates the number of hops remaining to the\n         LTM. Decremented by 1 by each Linktrace Responder that\n         handles the LTM. The value returned in the LTR is one less\n         than that received in the LTM. If the LTM TTL is 0 or 1, the\n         LTM is not forwarded to the next hop, and if 0, no LTR is\n         generated.')
prvtCfmMepTransmitLtmResult = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 40), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmResult.setReference('802.1ag clause 12.14.7.4.3:a')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmResult.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmResult.setDescription('Indicates the result of the operation:\n         \n         - true The Linktrace Message will be (or has been) sent.\n         - false The Linktrace Message will not be sent')
prvtCfmMepTransmitLtmSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 41), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmSeqNumber.setReference('802.1ag clause 12.14.7.4.3:a')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmSeqNumber.setDescription('The LTM Transaction Identifier\n         (prvtCfmMepLtmNextSeqNumber) of the LTM sent.\n         The value returned is undefined if\n         prvtCfmMepTransmitLtmResult is false.')
prvtCfmMepTransmitLtmEgressIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 42), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmEgressIdentifier.setReference('802.1ag clause 12.14.7.4.3:b and 21.8.8')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmEgressIdentifier.setDescription('Identifies the MEP Linktrace Initiator that is originating,\n         or the Linktrace Responder that is forwarding, this LTM.\n         The low-order six octets contain a 48-bit IEEE MAC address\n         unique to the system in which the MEP Linktrace Initiator\n         or Linktrace Responder resides. The high-order two octets\n         contain a value sufficient to uniquely identify the MEP\n         Linktrace Initiator or Linktrace Responder within that system.\n         \n         For most Bridges, the address of any MAC attached to the\n         Bridge will suffice for the low-order six octets, and 0 for\n         the high-order octets. In some situations, e.g. if multiple\n         virtual Bridges utilizing emulated LANs are implemented in a\n         single physical system, the high-order two octets can be used\n         to differentiate among the transmitting entities.\n         \n         The value returned is undefined if\n         prvtCfmMepTransmitLtmResult is false.')
prvtCfmMepAlarmSupressed = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 43), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepAlarmSupressed.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepAlarmSupressed.setDescription('A boolean showing if an AIS or LCK packet\n         was received from a lower level')
prvtCfmMepAisCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 44), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepAisCondition.setReference('ITU-T Recommendation Y.1731 APPENDIX I Defect Conditions,\n         I.7 AIS Condition')
if mibBuilder.loadTexts: prvtCfmMepAisCondition.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepAisCondition.setDescription("AIS condition\n         Is true by detection of signal\n         fail condition at a Server layer or reception of AIS at a\n         server (sub-) layer MEP [AIS condition/Rec. ITU-T Y.1731]\n         Respectively AIS condition Exit criteria:\n         'During an interval equal to 3.5 times the AIS transmission\n         period indicated in the AIS frames received earlier,\n         the MEP does not receive AIS frames or,\n         when ETH-CC is used, upon clearing of LOC defect at\n         MEP' /Appendix I/Rec. ITU-T Y.1731\n         \n         If prvtCfmMaAisLckLevel is configured the MEP should send AIS packets")
prvtCfmMepLckCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 45), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepLckCondition.setReference('ITU-T Recommendation Y.1731 APPENDIX I Defect Conditions,\n         I.9 LCK Condition')
if mibBuilder.loadTexts: prvtCfmMepLckCondition.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLckCondition.setDescription('A boolean showing if the MEP should lock the service\n         towards the client and send LCK packets')
prvtCfmMepAisLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("lifetime35s", 1), ("lifetime35min", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepAisLifetime.setReference('ITU-T Recommendation Y.1731 APPENDIX I Defect Conditions,\n         I.7 AIS Condition')
if mibBuilder.loadTexts: prvtCfmMepAisLifetime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepAisLifetime.setDescription('The lifetime of the last received AIS packet')
prvtCfmMepLckLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("lifetime35s", 1), ("lifetime35min", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepLckLifetime.setReference('ITU-T Recommendation Y.1731 APPENDIX I Defect Conditions,\n         I.9 LCK Condition')
if mibBuilder.loadTexts: prvtCfmMepLckLifetime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepLckLifetime.setDescription('The lifetime of the last received LCK packet')
prvtCfmMepTransmitMcastLbm = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 48), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitMcastLbm.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitMcastLbm.setDescription('A boolean to control sending Y.1731 multicast loopback.')
prvtCfmMepTransmitLbmInfinite = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 49), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmInfinite.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmInfinite.setDescription('A boolean to control sending LBMs continuously until the\n         operation is explicitly stopped by setting this back to false')
prvtCfmMepTransmitLbmDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDelay.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmDelay.setDescription('An amount of time to wait between sent LBMs (in seconds).')
prvtCfmMepTransmitLbmTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 51), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmTimeout.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmTimeout.setDescription('An amount of time to wait after the last sent LBM if no\n         LBR is received (in seconds).')
prvtCfmMepTransmitLtmTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 52), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTimeout.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLtmTimeout.setDescription('An amount of time to wait after the last sent LTM if no\n         LTR is received (in seconds).')
prvtCfmMepTransmitLbmSentPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 53), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmSentPkts.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmSentPkts.setDescription('Number of successfully sent packets in the current LBM\n         session.')
prvtCfmMepTransmitLbmSuccessRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 54), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmSuccessRate.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmSuccessRate.setDescription('Success rate of the current LBM session (in percentage*100).')
prvtCfmMepTransmitLbmMinTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 55), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmMinTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmMinTime.setDescription('Minimum LBR response time (in msec).')
prvtCfmMepTransmitLbmAvgTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 56), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmAvgTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmAvgTime.setDescription('Average LBR response time (in msec).')
prvtCfmMepTransmitLbmMaxTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 57), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmMaxTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmMaxTime.setDescription('Maximum LBR response time (in msec).')
prvtCfmMepFngAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 58), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(250, 1000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepFngAlarmTime.setReference('802.1ag clauses 12.14.7.1.3:l and 20.33.3')
if mibBuilder.loadTexts: prvtCfmMepFngAlarmTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepFngAlarmTime.setDescription('The time that defects must be present before a Fault Alarm is\n         issued (fngAlarmTime. 20.33.3) (default 2.5s).')
prvtCfmMepFngResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 59), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(250, 1000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMepFngResetTime.setReference('802.1ag clauses 12.14.7.1.3:m and 20.33.4')
if mibBuilder.loadTexts: prvtCfmMepFngResetTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepFngResetTime.setDescription('The time that defects must be absent before re-enabling a\n         Fault Alarm (fngResetTime, 20.33.4) (default 10s).')
prvtCfmMepTransmitLbmRemainingMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmRemainingMessages.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmRemainingMessages.setDescription('The number of LBMs (Loopback messages) to be transmitted')
prvtCfmMepTransmitLbmCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 1, 1, 61), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmCurrentStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepTransmitLbmCurrentStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\n         that another LBM may be transmitted.\n         Reset to false by the MEP Loopback Initiator State Machine.')
prvtCfmMepDbTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2), )
if mibBuilder.loadTexts: prvtCfmMepDbTable.setReference('802.1ag clause 19.2.15')
if mibBuilder.loadTexts: prvtCfmMepDbTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbTable.setDescription('The MEP Database. A database, maintained by every MEP, that\n         maintains received information about other MEPs in the\n         Maintenance Domain.\n         \n         The SMI does not allow to state in a MIB that an object in\n         a table is an array. The solution is to take the index (or\n         indices) of the first table and add one or more indices.')
prvtCfmMepDbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"), (0, "PRVT-CFM-MIB", "prvtCfmMepIdentifier"), (0, "PRVT-CFM-MIB", "prvtCfmMepDbRMepIdentifier"))
if mibBuilder.loadTexts: prvtCfmMepDbEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbEntry.setDescription('The MEP Database table entry.')
prvtCfmMepDbRMepIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: prvtCfmMepDbRMepIdentifier.setReference('802.1ag clause 12.14.7.6.2:b')
if mibBuilder.loadTexts: prvtCfmMepDbRMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbRMepIdentifier.setDescription('Maintenance association End Point Identifier of a remote MEP\n         whose information from the MEP Database is to be returned.')
prvtCfmMepDbRMepState = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 2), PrvtCfmRemoteMepState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbRMepState.setReference('802.1ag clause 12.14.7.6.3:b and 20.22')
if mibBuilder.loadTexts: prvtCfmMepDbRMepState.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbRMepState.setDescription('The operational state of the remote MEP IFF State machines.')
prvtCfmMepDbRMepFailedOkTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbRMepFailedOkTime.setReference('802.1ag clause 12.14.7.6.3:c')
if mibBuilder.loadTexts: prvtCfmMepDbRMepFailedOkTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbRMepFailedOkTime.setDescription('The time (SysUpTime) at which the IFF Remote MEP state machine\n         last entered either the RMEP_FAILED or RMEP_OK state.')
prvtCfmMepDbMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbMacAddress.setReference('802.1ag clause 12.14.7.6.3:d and 20.19.7')
if mibBuilder.loadTexts: prvtCfmMepDbMacAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbMacAddress.setDescription('The MAC address of the remote MEP.')
prvtCfmMepDbRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbRdi.setReference('802.1ag clauses 12.14.7.6.3:e and 20.19.2')
if mibBuilder.loadTexts: prvtCfmMepDbRdi.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbRdi.setDescription('State of the RDI bit in the last received CCM (true for\n         RDI=1), or false if none has been received.')
prvtCfmMepDbPortStatusTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 6), PrvtCfmPortStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbPortStatusTlv.setReference('802.1ag clause 12.14.7.6.3:f and 20.19.3')
if mibBuilder.loadTexts: prvtCfmMepDbPortStatusTlv.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbPortStatusTlv.setDescription('An enumerated value of the Port status TLV received in the\n         last CCM from the remote MEP or the default value\n         psNoPortStateTLV indicating either no CCM has been received,\n         or that nor port status TLV was received in the last CCM.')
prvtCfmMepDbInterfaceStatusTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 7), PrvtCfmInterfaceStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbInterfaceStatusTlv.setReference('802.1ag clause 12.14.7.6.3:g and 20.19.4')
if mibBuilder.loadTexts: prvtCfmMepDbInterfaceStatusTlv.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbInterfaceStatusTlv.setDescription('An enumerated value of the Interface status TLV received\n         in the last CCM from the remote MEP or the default value\n         isNoInterfaceStatus TLV indicating either no CCM has been\n         received, or that no interface status TLV was received in\n         the last CCM.')
prvtCfmMepDbChassisIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 8), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbChassisIdSubtype.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.2')
if mibBuilder.loadTexts: prvtCfmMepDbChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID received\n         in the last CCM.')
prvtCfmMepDbChassisId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 9), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbChassisId.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.3')
if mibBuilder.loadTexts: prvtCfmMepDbChassisId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbChassisId.setDescription('The Chassis ID. The format of this object is determined by the\n         value of the prvtCfmLtrChassisIdSubtype object.')
prvtCfmMepDbManAddressDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 10), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbManAddressDomain.setReference('802.1ag clauses 12.14.7.6.3:h, 21.5.3.5, 21.6.7')
if mibBuilder.loadTexts: prvtCfmMepDbManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbManAddressDomain.setDescription("The TDomain that identifies the type and format of\n         the related prvtCfmMepDbManAddress object, used to access\n         the SNMP agent of the system transmitting the CCM. Received\n         in the CCM Sender ID TLV from that system.\n         \n         Typical values will be one of (not all inclusive) list:\n         \n         snmpUDPDomain (from SNMPv2-TM, RFC3417)\n         snmpIeee802Domain (from SNMP-IEEE802-TM-MIB, RFC4789)\n         \n         The value 'zeroDotZero' (from RFC2578) indicates 'no LTR\n         Sender ID TLV received', in which case the related object\n         prvtCfmMepDbManAddress must have a zero-length OCTET STRING\n         as a value.")
prvtCfmMepDbManAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 2, 1, 11), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmMepDbManAddress.setReference('802.1ag clauses 12.14.7.6.3:h, 21.5.3.7, 21.6.7')
if mibBuilder.loadTexts: prvtCfmMepDbManAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMepDbManAddress.setDescription("The TAddress that can be used to access the SNMP\n         agent of the system transmitting the CCM, received in the CCM\n         Sender ID TLV from that system.\n         \n         If the related object prvtCfmMepDbManAddressDomain contains\n         the value 'zeroDotZero', this object prvtCfmMepDbManAddress\n         must have a zero-length OCTET STRING as a value.")
prvtCfmLtrTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3), )
if mibBuilder.loadTexts: prvtCfmLtrTable.setReference('802.1ag clause 12.14.7.5')
if mibBuilder.loadTexts: prvtCfmLtrTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrTable.setDescription('This table extends the MEP table and contains a list of\n         Linktrace replies received by a specific MEP in response to\n         a linktrace message.\n         \n         SNMP SMI does not allow to state in a MIB that an object in\n         a table is an array. The solution is to take the index (or\n         indices) of the first table and add one or more indices.')
prvtCfmLtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"), (0, "PRVT-CFM-MIB", "prvtCfmMepIdentifier"), (0, "PRVT-CFM-MIB", "prvtCfmLtrSeqNumber"), (0, "PRVT-CFM-MIB", "prvtCfmLtrReceiveOrder"))
if mibBuilder.loadTexts: prvtCfmLtrEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrEntry.setDescription('The Linktrace Reply table entry.')
prvtCfmLtrSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: prvtCfmLtrSeqNumber.setReference('802.1ag clause 12.14.7.5.2:b')
if mibBuilder.loadTexts: prvtCfmLtrSeqNumber.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrSeqNumber.setDescription("Transaction identifier/Sequence number returned by a previous\n         transmit linktrace message command, indicating which LTM's\n         response is going to be returned.")
prvtCfmLtrReceiveOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: prvtCfmLtrReceiveOrder.setReference('802.1ag clause 12.14.7.5.2:c')
if mibBuilder.loadTexts: prvtCfmLtrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrReceiveOrder.setDescription('An index to distinguish among multiple LTRs with the same LTR\n         Transaction Identifier field value. prvtCfmLtrReceiveOrder\n         are assigned sequentially from 1, in the order that the\n         Linktrace Initiator received the LTRs.')
prvtCfmLtrTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrTtl.setReference('802.1ag clause 12.14.7.5 and 20.36.2.2')
if mibBuilder.loadTexts: prvtCfmLtrTtl.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrTtl.setDescription('TTL field value for a returned LTR.')
prvtCfmLtrForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrForwarded.setReference('802.1ag clauses 12.14.7.5.3:c and 20.36.2.1')
if mibBuilder.loadTexts: prvtCfmLtrForwarded.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrForwarded.setDescription("Indicates if a LTM was forwarded by the responding MP, as\n         returned in the 'FwdYes' flag of the flags field.")
prvtCfmLtrTerminalMep = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrTerminalMep.setReference('802.1ag clauses 12.14.7.5.3:d and 20.36.2.1')
if mibBuilder.loadTexts: prvtCfmLtrTerminalMep.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrTerminalMep.setDescription('A boolean value stating whether the forwarded LTM reached a\n         MEP enclosing its MA, as returned in the Terminal MEP flag of\n         the Flags field.')
prvtCfmLtrLastEgressIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrLastEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:e and 20.36.2.3')
if mibBuilder.loadTexts: prvtCfmLtrLastEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrLastEgressIdentifier.setDescription('An octet field holding the Last Egress Identifier returned\n         in the LTR Egress Identifier TLV of the LTR.\n         The Last Egress Identifier identifies the MEP Linktrace\n         Initiator that originated, or the Linktrace Responder that\n         forwarded, the LTM to which this LTR is the response. This\n         is the same value as the Egress Identifier TLV of that LTM.')
prvtCfmLtrNextEgressIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrNextEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:f and 20.36.2.4')
if mibBuilder.loadTexts: prvtCfmLtrNextEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrNextEgressIdentifier.setDescription('An octet field holding the Next Egress Identifier returned\n         in the LTR Egress Identifier TLV of the LTR. The Next Egress\n         Identifier Identifies the Linktrace Responder that\n         transmitted this LTR, and can forward the LTM to the next\n         hop. This is the same value as the Egress Identifier TLV of\n         the forwarded LTM, if any. If the FwdYes bit of the Flags\n         field is false, the contents of this field are undefined,\n         i.e. any value can be transmitted, and the field is ignored\n         by the receiver.')
prvtCfmLtrRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 8), PrvtCfmRelayActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrRelay.setReference('802.1ag clauses 12.14.7.5.3:g and 20.36.2.5')
if mibBuilder.loadTexts: prvtCfmLtrRelay.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrRelay.setDescription('Value returned in the Relay Action field.')
prvtCfmLtrChassisIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 9), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrChassisIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:h and 21.5.3.2')
if mibBuilder.loadTexts: prvtCfmLtrChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID returned\n         in the Sender ID TLV of the LTR, if any. This value is\n         meaningless if the prvtCfmLtrChassisId has a length of 0.')
prvtCfmLtrChassisId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 10), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrChassisId.setReference('802.1ag clauses 12.14.7.5.3:i and 21.5.3.3')
if mibBuilder.loadTexts: prvtCfmLtrChassisId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrChassisId.setDescription('The Chassis ID returned in the Sender ID TLV of the LTR, if\n         any. The format of this object is determined by the\n         value of the prvtCfmLtrChassisIdSubtype object.')
prvtCfmLtrManAddressDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 11), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrManAddressDomain.setReference('802.1ag clauses 12.14.7.5.3:j, 21.5.3.5, 21.9.6')
if mibBuilder.loadTexts: prvtCfmLtrManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrManAddressDomain.setDescription("The TDomain that identifies the type and format of\n         the related prvtCfmLtrManAddress object, used to access\n         the SNMP agent of the system transmitting the LTR. Received\n         in the LTR Sender ID TLV from that system.\n         \n         Typical values will be one of (not all inclusive) list:\n         \n         \n         snmpUDPDomain (from SNMPv2-TM, RFC3417)\n         snmpIeee802Domain (from SNMP-IEEE802-TM-MIB, RFC4789)\n         \n         The value 'zeroDotZero' (from RFC2578) indicates 'no LTR\n         Sender ID TLV received', in which case the related object\n         prvtCfmLtrManAddress must have a zero-length OCTET STRING\n         as a value.")
prvtCfmLtrManAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 12), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrManAddress.setReference('802.1ag clauses 12.14.7.5.3:j, 21.5.3.7, 21.9.6')
if mibBuilder.loadTexts: prvtCfmLtrManAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrManAddress.setDescription("The TAddress that can be used to access the SNMP\n         agent of the system transmitting the CCM, received in the CCM\n         Sender ID TLV from that system.\n         \n         If the related object prvtCfmLtrManAddressDomain contains\n         the value 'zeroDotZero', this object prvtCfmLtrManAddress\n         must have a zero-length OCTET STRING as a value.")
prvtCfmLtrIngress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 13), PrvtCfmIngressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrIngress.setReference('802.1ag clauses 12.14.7.5.3:k and 20.36.2.6')
if mibBuilder.loadTexts: prvtCfmLtrIngress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrIngress.setDescription('The value returned in the Ingress Action Field of the LTM.')
prvtCfmLtrIngressMac = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 14), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrIngressMac.setReference('802.1ag clauses 12.14.7.5.3:l and 20.36.2.7')
if mibBuilder.loadTexts: prvtCfmLtrIngressMac.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrIngressMac.setDescription('MAC address returned in the ingress MAC address field.')
prvtCfmLtrIngressPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 15), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrIngressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:m and 20.36.2.8')
if mibBuilder.loadTexts: prvtCfmLtrIngressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrIngressPortIdSubtype.setDescription('Format of the Ingress Port ID.')
prvtCfmLtrIngressPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 16), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrIngressPortId.setReference('802.1ag clauses 12.14.7.5.3:n and 20.36.2.9')
if mibBuilder.loadTexts: prvtCfmLtrIngressPortId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrIngressPortId.setDescription('Ingress Port ID. The format of this object is determined by\n         the value of the prvtCfmLtrIngressPortIdSubtype object.')
prvtCfmLtrEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 17), PrvtCfmEgressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrEgress.setReference('802.1ag clauses 12.14.7.5.3:o and 20.36.2.10')
if mibBuilder.loadTexts: prvtCfmLtrEgress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrEgress.setDescription('The value returned in the Egress Action Field of the LTM.')
prvtCfmLtrEgressMac = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 18), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrEgressMac.setReference('802.1ag clauses 12.14.7.5.3:p and 20.36.2.11')
if mibBuilder.loadTexts: prvtCfmLtrEgressMac.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrEgressMac.setDescription('MAC address returned in the egress MAC address field.')
prvtCfmLtrEgressPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 19), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrEgressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:q and 20.36.2.12')
if mibBuilder.loadTexts: prvtCfmLtrEgressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrEgressPortIdSubtype.setDescription('Format of the egress Port ID.')
prvtCfmLtrEgressPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 20), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrEgressPortId.setReference('802.1ag clauses 12.14.7.5.3:r and 20.36.2.13')
if mibBuilder.loadTexts: prvtCfmLtrEgressPortId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrEgressPortId.setDescription('Egress Port ID. The format of this object is determined by\n         the value of the prvtCfmLtrEgressPortIdSubtype object.')
prvtCfmLtrOrganizationSpecificTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrOrganizationSpecificTlv.setReference('802.1ag clauses 12.14.7.5.3:s, 21.5.2')
if mibBuilder.loadTexts: prvtCfmLtrOrganizationSpecificTlv.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrOrganizationSpecificTlv.setDescription('All Organization specific TLVs returned in the LTR, if\n         any. Includes all octets including and following the TLV\n         Length field of each TLV, concatenated together.')
prvtCfmLtrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrTime.setDescription('Remote MPs response time in milliseconds.')
prvtCfmLtrSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 3, 1, 23), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLtrSourceMac.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLtrSourceMac.setDescription('MAC address that originated the LTR.')
prvtCfmLbrTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 4), )
if mibBuilder.loadTexts: prvtCfmLbrTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLbrTable.setDescription('Table contains loopback results following the last loopback operation.')
prvtCfmLbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 4, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"), (0, "PRVT-CFM-MIB", "prvtCfmMepIdentifier"), (0, "PRVT-CFM-MIB", "prvtCfmLbrSeqNumber"), (0, "PRVT-CFM-MIB", "prvtCfmLbrReceiveOrder"))
if mibBuilder.loadTexts: prvtCfmLbrEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLbrEntry.setDescription('prvtCfmLbrEntry')
prvtCfmLbrSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: prvtCfmLbrSeqNumber.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLbrSeqNumber.setDescription('Transaction identifier/Sequence number of the received LBR.')
prvtCfmLbrReceiveOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 4, 1, 2), Unsigned32())
if mibBuilder.loadTexts: prvtCfmLbrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLbrReceiveOrder.setDescription('An index to distinguish among multiple LBRs with the same LBR\n         Transaction Identifier field value. This situation can appear\n         in the case of multicast loopback.')
prvtCfmLbrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 4, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLbrTime.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLbrTime.setDescription('Remote MEPs response time in milliseconds.')
prvtCfmLbrMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 4, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLbrMacAddress.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLbrMacAddress.setDescription('Remote MEPs mac address. For unicast loopback\n         this is the same as prvtCfmMepTransmitLbmDestMacAddress,\n         but for multicast loopback there will be different entries.')
prvtCfmLbrBadMsdu = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 6, 4, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmLbrBadMsdu.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLbrBadMsdu.setDescription('Result of the Data TLV verification.')
prvtCfmProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7))
prvtCfmProfileTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 1), PrvtCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmProfileTableNextIndex.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileTableNextIndex.setDescription('This object contains an unused value\n         for prvtCfmProfileIndex in the prvtCfmProfileTable\n         or a zero to indicate that none exist.')
prvtCfmProfileTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2), )
if mibBuilder.loadTexts: prvtCfmProfileTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileTable.setDescription('Table contains loopback results from all remote MEPs in the MA.')
prvtCfmProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmProfileIndex"))
if mibBuilder.loadTexts: prvtCfmProfileEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileEntry.setDescription('Entry in profile table')
prvtCfmProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: prvtCfmProfileIndex.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileIndex.setDescription('Table index.')
prvtCfmProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileRowStatus.setDescription('The status of the row.\n         The writable columns in a row can not be changed if the row\n         is active. All columns must have a valid value before a row\n         can be activated.')
prvtCfmProfileDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileDescr.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileDescr.setDescription('A description for this profile.\n         This field must be unique among all profiles.')
prvtCfmProfilePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfilePriority.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfilePriority.setDescription('802.1p class-of-service setting.')
prvtCfmProfileRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileRate.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileRate.setDescription('Number of Request packets to send each time.')
prvtCfmProfileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1462))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileSize.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileSize.setDescription('Size of data TLV included in probe packets (in octets).')
prvtCfmProfileBucketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileBucketSize.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileBucketSize.setDescription('Number of the results to save for results calculation.')
prvtCfmProfile1wJitterError = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfile1wJitterError.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfile1wJitterError.setDescription('Specifies one-way jitter error values\n         to monitor in milliseconds.')
prvtCfmProfile1wJitterWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfile1wJitterWarning.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfile1wJitterWarning.setDescription('Specifies one-way jitter warning values\n         to monitor in milliseconds.')
prvtCfmProfileJitterError = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileJitterError.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileJitterError.setDescription('Specifies round-trip jitter error values\n         to monitor in milliseconds.')
prvtCfmProfileJitterErrorPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileJitterErrorPeriod.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileJitterErrorPeriod.setDescription('Specifies the duration jitter occurs in seconds.')
prvtCfmProfileJitterWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileJitterWarning.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileJitterWarning.setDescription('Specifies round-trip jitter warning values\n         to monitor in milliseconds. If set value is greater than the\n         jitter-error it means that the warning is disabled.')
prvtCfmProfileJitterWarningPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileJitterWarningPeriod.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileJitterWarningPeriod.setDescription('Specifies the duration jitter occurs in seconds.')
prvtCfmProfileFrameLossError = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileFrameLossError.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileFrameLossError.setDescription('Specifies round-trip frame-loss error\n         values to monitor. The default is\n         frame-loss of 10% is reported.')
prvtCfmProfileFrameLossWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileFrameLossWarning.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileFrameLossWarning.setDescription('Specifies round-trip frame-loss warning\n         values to monitor. The default is frame-loss\n         of 8% is reported. If set value is greater\n         than the frame-loss-error it means\n         that the warning is disable.')
prvtCfmProfileLatencyError = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileLatencyError.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileLatencyError.setDescription('Specifies round-trip latency error values\n         to monitor in milliseconds.')
prvtCfmProfileLatencyErrorPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileLatencyErrorPeriod.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileLatencyErrorPeriod.setDescription('Specifies the duration latency increase\n         occurs in seconds.')
prvtCfmProfileLatencyWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileLatencyWarning.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileLatencyWarning.setDescription('Specifies round-trip latency error\n         values to monitor in milliseconds.\n         If set value is greater than the\n         latency-error it means that the\n         warning is disabled.')
prvtCfmProfileLatencyWarningPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileLatencyWarningPeriod.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileLatencyWarningPeriod.setDescription('Specifies the duration latency increase occurs.')
prvtCfmProfileOneWayJitterEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 20), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileOneWayJitterEnabled.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileOneWayJitterEnabled.setDescription('Specify if one-way jitter is monitored.')
prvtCfmProfileTwoWayJitterEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 21), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileTwoWayJitterEnabled.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileTwoWayJitterEnabled.setDescription('Specify if two-way jitter is monitored.')
prvtCfmProfileFramelossEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 22), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileFramelossEnabled.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileFramelossEnabled.setDescription('Specify if frame-loss is monitored.')
prvtCfmProfileLatencyEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 7, 2, 1, 23), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProfileLatencyEnabled.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProfileLatencyEnabled.setDescription('Specify if two-way latency is monitored.')
prvtCfmProcess = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8))
prvtCfmProcessTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1), )
if mibBuilder.loadTexts: prvtCfmProcessTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessTable.setDescription("Private extension of prvtCfmMaTable.\n         Controls the two-way monitoring process\n         for MEP's in the MA.")
prvtCfmProcessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmProcessIndex"), (0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"))
if mibBuilder.loadTexts: prvtCfmProcessEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessEntry.setDescription('prvtCfmProcessEntry')
prvtCfmProcessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)))
if mibBuilder.loadTexts: prvtCfmProcessIndex.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessIndex.setDescription('Table index.')
prvtCfmProcessRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProcessRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessRowStatus.setDescription('The status of the row.\n         The writable columns in a row can not be\n         changed if the row is active. All columns\n         must have a valid value before a row can\n         be activated.')
prvtCfmProcessProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProcessProfileIndex.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessProfileIndex.setDescription('Index of the monitoring profile to be used.')
prvtCfmProcessName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmProcessName.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessName.setDescription('The name of the process. Should be unique per domain/MA')
prvtCfmProcessShutdown = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProcessShutdown.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessShutdown.setDescription("The value 'true' will disable two-way monitoring process\n         for MEP's in the MA.")
prvtCfmProcessRepeatInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 420))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProcessRepeatInterval.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessRepeatInterval.setDescription('Repeating frequency of the monitoring process.')
prvtCfmProcessPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cfm", 1), ("y1731", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmProcessPacketType.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessPacketType.setDescription('Use CFM Loopback or Y.1731 LMMs and DMMs packets.')
prvtCfmProcessUnreturnedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmProcessUnreturnedPkts.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessUnreturnedPkts.setDescription("Number of requests for which a reply\n         hasn't been received. These packets\n         will be counted as lost when they\n         enter timeout.")
prvtCfmProcessResultTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 2), )
if mibBuilder.loadTexts: prvtCfmProcessResultTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessResultTable.setDescription('Table contains process results.')
prvtCfmProcessResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 2, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"), (0, "PRVT-CFM-MIB", "prvtCfmProcessIndex"), (0, "PRVT-CFM-MIB", "prvtCfmMepDbRMepIdentifier"))
if mibBuilder.loadTexts: prvtCfmProcessResultEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessResultEntry.setDescription('prvtCfmProcessResultEntry')
prvtCfmProcessResultOneWayJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmProcessResultOneWayJitter.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessResultOneWayJitter.setDescription('One way jitter calculated for\n         a specific remote MEP in milliseconds')
prvtCfmProcessResultTwoWayJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmProcessResultTwoWayJitter.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessResultTwoWayJitter.setDescription('Two way jitter calculated for a specific\n         remote MEP in milliseconds')
prvtCfmProcessResultLatency = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmProcessResultLatency.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessResultLatency.setDescription('Two way latency calculated for a specific\n         remote MEP in milliseconds')
prvtCfmProcessResultFrameloss = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 8, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtCfmProcessResultFrameloss.setStatus('current')
if mibBuilder.loadTexts: prvtCfmProcessResultFrameloss.setDescription('Two way frameloss calculated for a specific\n         remote MEP in units of hundredths of percent.\n         Note: When prvtCfmProcessResultFrameloss has\n         value of 10000, all the values of\n         prvtCfmProcessResultOneWayJitter,\n         prvtCfmProcessResultTwoWayJitter and\n         prvtCfmProcessResultLatency are irrelevant.')
prvtCfmMaAisLckVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 9))
prvtCfmMaAisLckVlanTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 9, 1), )
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanTable.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanTable.setDescription('Table includes extra variables needed for AIS/LCK configurable vlans')
prvtCfmMaAisLckVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 9, 1, 1), ).setIndexNames((0, "PRVT-CFM-MIB", "prvtCfmMdName"), (0, "PRVT-CFM-MIB", "prvtCfmMaName"), (0, "PRVT-CFM-MIB", "prvtCfmMaAisLckVlanId"))
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanEntry.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanEntry.setDescription('Table includes extra variables needed for AIS/LCK configurable vlans')
prvtCfmMaAisLckVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanId.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanId.setDescription('Vlan ID (towards customer level) that the generated AIS/LCK packets should use.')
prvtCfmMaAisLckVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 1, 9, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtCfmMaAisLckVlanRowStatus.setDescription('The status of the row.')
prvtCfm1wJitterThreshold = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 1)).setObjects(("PRVT-CFM-MIB", "prvtCfmProcessResultOneWayJitter"), ("PRVT-CFM-MIB", "prvtCfmProfile1wJitterWarning"), ("PRVT-CFM-MIB", "prvtCfmProfile1wJitterError"))
if mibBuilder.loadTexts: prvtCfm1wJitterThreshold.setStatus('current')
if mibBuilder.loadTexts: prvtCfm1wJitterThreshold.setDescription('This trap should be sent whenever the one way jitter\n         on a CFM test will surpass one of the 2 defined thresholds.')
prvtCfmJitterThreshold = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 2)).setObjects(("PRVT-CFM-MIB", "prvtCfmProcessResultTwoWayJitter"), ("PRVT-CFM-MIB", "prvtCfmProfileJitterWarning"), ("PRVT-CFM-MIB", "prvtCfmProfileJitterWarningPeriod"), ("PRVT-CFM-MIB", "prvtCfmProfileJitterError"), ("PRVT-CFM-MIB", "prvtCfmProfileJitterErrorPeriod"))
if mibBuilder.loadTexts: prvtCfmJitterThreshold.setStatus('current')
if mibBuilder.loadTexts: prvtCfmJitterThreshold.setDescription('This trap should be sent whenever the two way jitter\n         on a CFM test will surpass one of the 2 defined thresholds.')
prvtCfmFrameLossThreshold = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 3)).setObjects(("PRVT-CFM-MIB", "prvtCfmProcessResultFrameloss"), ("PRVT-CFM-MIB", "prvtCfmProfileFrameLossWarning"), ("PRVT-CFM-MIB", "prvtCfmProfileFrameLossError"))
if mibBuilder.loadTexts: prvtCfmFrameLossThreshold.setStatus('current')
if mibBuilder.loadTexts: prvtCfmFrameLossThreshold.setDescription('This trap should be sent whenever the frame loss\n         on a CFM test will surpass one of the 2 defined\n         thresholds.')
prvtCfmLatencyThreshold = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 4)).setObjects(("PRVT-CFM-MIB", "prvtCfmProcessResultLatency"), ("PRVT-CFM-MIB", "prvtCfmProfileLatencyWarning"), ("PRVT-CFM-MIB", "prvtCfmProfileLatencyWarningPeriod"), ("PRVT-CFM-MIB", "prvtCfmProfileLatencyError"), ("PRVT-CFM-MIB", "prvtCfmProfileLatencyErrorPeriod"))
if mibBuilder.loadTexts: prvtCfmLatencyThreshold.setStatus('current')
if mibBuilder.loadTexts: prvtCfmLatencyThreshold.setDescription('This trap should be sent whenever the latency\n         on a CFM test will surpass one of the 2 defined\n         thresholds.')
prvtCfmUnexpectedPriority = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 5)).setObjects(("PRVT-CFM-MIB", "prvtCfmMepDirection"), ("PRVT-CFM-MIB", "prvtCfmMepDbMacAddress"), ("PRVT-CFM-MIB", "prvtCfmMepInterfaceIndex"))
if mibBuilder.loadTexts: prvtCfmUnexpectedPriority.setStatus('current')
if mibBuilder.loadTexts: prvtCfmUnexpectedPriority.setDescription('References to in the [G.8021/Y.1341] :\n         Unexpected Priority defect (dUNPr)\n         The Unexpected Priority defect is calculated at the ETH layer.\n         It detects the configuration of different Priorities\n         for CCM at different MEPs belonging to the same MEG.')
prvtCfmFaultAlarm = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 6)).setObjects(("PRVT-CFM-MIB", "prvtCfmMepDirection"), ("PRVT-CFM-MIB", "prvtCfmMepHighestPrDefect"), ("PRVT-CFM-MIB", "prvtCfmMepInterfaceIndex"))
if mibBuilder.loadTexts: prvtCfmFaultAlarm.setStatus('current')
if mibBuilder.loadTexts: prvtCfmFaultAlarm.setDescription("A MEP has a persistent defect condition. A notification\n         (fault alarm) is sent to the management entity with the OID\n         of the MEP that has detected the fault.\n         \n         Whenever a MEP has a persistent defect,\n         it may or may not generate a Fault Alarm to warn the system\n         administrator of the problem, as controlled by the MEP\n         Fault Notification Generator State Machine and associated\n         Managed Objects. Only the highest-priority defect, as shown\n         in Table 20-1, is reported in the Fault Alarm.\n         \n         If a defect with a higher priority is raised after a Fault\n         Alarm has been issued, another Fault Alarm is issued.\n         \n         The management entity receiving the notification can identify\n         the system from the network source address of the\n         notification, and can identify the MEP reporting the defect\n         by the indices in the OID of the prvtCfmMepHighestPrDefect\n         variable in the notification:\n         \n         prvtCfmMdName  - Also the index of the MEP's\n                            Maintenance Domain table entry\n                            (prvtCfmMdTable).\n         prvtCfmMaName  - Also an index (with the MD table index)\n                            of the MEP's Maintenance Association\n                            table entry\n                            (prvtCfmMaTable),\n         prvtCfmMepIdentifier - MEP Identifier and final index\n                            into the MEP table (prvtCfmMepTable).")
if mibBuilder.loadTexts: prvtCfmFaultAlarm.setReference('802.1ag clause 12.14.7.7')
prvtCfmAisLckRecieved = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 7)).setObjects(("PRVT-CFM-MIB", "prvtCfmMepAisCondition"))
if mibBuilder.loadTexts: prvtCfmAisLckRecieved.setStatus('current')
if mibBuilder.loadTexts: prvtCfmAisLckRecieved.setDescription('A MEP may generate a AIS/LCK notification each time its\n         AIS/LCK condition is activated.')
if mibBuilder.loadTexts: prvtCfmAisLckRecieved.setReference('ITU-T Recommendation Y.1731 APPENDIX I Defect Conditions\n         I.7 AIS Condition, I.9 LCK Condition')
prvtCfmAisLckCleared = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 8)).setObjects(("PRVT-CFM-MIB", "prvtCfmMepAisCondition"))
if mibBuilder.loadTexts: prvtCfmAisLckCleared.setStatus('current')
if mibBuilder.loadTexts: prvtCfmAisLckCleared.setDescription('The notification is sent each time\n         AIS/LCK condition is cleared.')
if mibBuilder.loadTexts: prvtCfmAisLckCleared.setReference('ITU-T Recommendation Y.1731 APPENDIX I Defect Conditions\n         I.7 AIS Condition, I.9 LCK Condition')
prvtCfmFaultAlarmCleared = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 5, 131, 0, 9)).setObjects(("PRVT-CFM-MIB", "prvtCfmMepDirection"), ("PRVT-CFM-MIB", "prvtCfmMepFngState"))
if mibBuilder.loadTexts: prvtCfmFaultAlarmCleared.setStatus('current')
if mibBuilder.loadTexts: prvtCfmFaultAlarmCleared.setDescription("A MEP's persistent defect condition has cleared. A notification\n         is sent to the management entity with the OID\n         of the MEP that has cleared the fault.\n         \n         The management entity receiving the notification can identify\n         the system from the network source address of the\n         notification, and can identify the MEP by the indices in the\n         OID of the prvtCfmMepIdentifier variable in the notification:\n         \n           prvtCfmMdName  - Also the index of the MEP's\n                              Maintenance Domain table entry\n                              (prvtCfmMdTable).\n           prvtCfmMaName  - Also an index (with the MD table index)\n                              of the MEP's Maintenance Association\n                              table entry\n                              (prvtCfmMaTable),\n           prvtCfmMepIdentifier - MEP Identifier and final index\n                              into the MEP table (prvtCfmMepTable).")
mibBuilder.exportSymbols("PRVT-CFM-MIB", prvtCfmLbrEntry=prvtCfmLbrEntry, prvtCfmProfileLatencyErrorPeriod=prvtCfmProfileLatencyErrorPeriod, prvtCfmMaAisLckReceive=prvtCfmMaAisLckReceive, prvtCfmMepTransmitLbmTimeout=prvtCfmMepTransmitLbmTimeout, prvtCfmMaPermission=prvtCfmMaPermission, prvtCfmMep=prvtCfmMep, prvtCfmLtrIngressPortId=prvtCfmLtrIngressPortId, prvtCfmProfileDescr=prvtCfmProfileDescr, prvtCfmProfileSize=prvtCfmProfileSize, LldpChassisIdSubtype=LldpChassisIdSubtype, prvtCfmProfileLatencyWarning=prvtCfmProfileLatencyWarning, prvtCfmProcessResultEntry=prvtCfmProcessResultEntry, prvtCfmLatencyThreshold=prvtCfmLatencyThreshold, prvtCfmMepTransmitLbmDestMepId=prvtCfmMepTransmitLbmDestMepId, prvtCfmJitterThreshold=prvtCfmJitterThreshold, PrvtCfmRelayActionFieldValue=PrvtCfmRelayActionFieldValue, prvtCfmMdLevel=prvtCfmMdLevel, prvtCfmMepInterfaceIndex=prvtCfmMepInterfaceIndex, prvtCfmMepLbrBadMsdu=prvtCfmMepLbrBadMsdu, prvtCfmLtrSeqNumber=prvtCfmLtrSeqNumber, prvtCfmLtrRelay=prvtCfmLtrRelay, prvtCfmMepDbManAddress=prvtCfmMepDbManAddress, prvtCfmProcessTable=prvtCfmProcessTable, prvtCfmMepTransmitLbmMessages=prvtCfmMepTransmitLbmMessages, prvtCfmProfileOneWayJitterEnabled=prvtCfmProfileOneWayJitterEnabled, prvtCfmLtrEgressPortId=prvtCfmLtrEgressPortId, PrvtCfmFngState=PrvtCfmFngState, prvtCfmProcessPacketType=prvtCfmProcessPacketType, prvtCfmMdEntry=prvtCfmMdEntry, prvtCfmLtrTable=prvtCfmLtrTable, prvtCfmLtrChassisIdSubtype=prvtCfmLtrChassisIdSubtype, prvtCfmMepTransmitLtmTtl=prvtCfmMepTransmitLtmTtl, prvtCfmMepCciEnabled=prvtCfmMepCciEnabled, prvtCfmLtrIngress=prvtCfmLtrIngress, prvtCfmMepTransmitLbmAvgTime=prvtCfmMepTransmitLbmAvgTime, PrvtCfmInterfaceStatus=PrvtCfmInterfaceStatus, PrvtCfmIngressActionFieldValue=PrvtCfmIngressActionFieldValue, prvtCfmMepDbRdi=prvtCfmMepDbRdi, prvtCfmMepAlarmSupressed=prvtCfmMepAlarmSupressed, prvtCfmMepDbPortStatusTlv=prvtCfmMepDbPortStatusTlv, PrvtCfmMaintAssocNameOrNone=PrvtCfmMaintAssocNameOrNone, prvtCfmMepLowPrDef=prvtCfmMepLowPrDef, prvtCfmMepTransmitLbmSeqNumber=prvtCfmMepTransmitLbmSeqNumber, prvtCfmProfileLatencyWarningPeriod=prvtCfmProfileLatencyWarningPeriod, prvtCfmFaultAlarm=prvtCfmFaultAlarm, prvtCfmFaultAlarmCleared=prvtCfmFaultAlarmCleared, prvtCfmProcessProfileIndex=prvtCfmProcessProfileIndex, prvtCfmMaRowStatus=prvtCfmMaRowStatus, prvtCfmMepDbRMepState=prvtCfmMepDbRMepState, prvtCfmMaMhfCreation=prvtCfmMaMhfCreation, prvtCfmProfileBucketSize=prvtCfmProfileBucketSize, prvtCfmMdName=prvtCfmMdName, prvtCfmStackMaName=prvtCfmStackMaName, prvtCfmLtrTtl=prvtCfmLtrTtl, prvtCfmLtrEgressPortIdSubtype=prvtCfmLtrEgressPortIdSubtype, prvtCfmProfileTable=prvtCfmProfileTable, prvtCfmMepCcmLtmPriority=prvtCfmMepCcmLtmPriority, prvtCfmFrameLossThreshold=prvtCfmFrameLossThreshold, prvtCfmProfile=prvtCfmProfile, prvtCfmMaAisLckVlanRowStatus=prvtCfmMaAisLckVlanRowStatus, PrvtCfmMepIdOrZero=PrvtCfmMepIdOrZero, PrvtCfmMhfCreation=PrvtCfmMhfCreation, PrvtCfmRemoteMepState=PrvtCfmRemoteMepState, prvtCfmMepTransmitLtmTargetIsMepId=prvtCfmMepTransmitLtmTargetIsMepId, prvtCfmMaAisLckVlanId=prvtCfmMaAisLckVlanId, prvtCfmMepTransmitLtmResult=prvtCfmMepTransmitLtmResult, prvtCfmMepDbEntry=prvtCfmMepDbEntry, prvtCfmProfileFrameLossWarning=prvtCfmProfileFrameLossWarning, prvtCfmProcessResultTable=prvtCfmProcessResultTable, prvtCfmLtrTerminalMep=prvtCfmLtrTerminalMep, prvtCfmMaFormat=prvtCfmMaFormat, prvtCfmProfileTwoWayJitterEnabled=prvtCfmProfileTwoWayJitterEnabled, prvtCfmMdMhfIdPermission=prvtCfmMdMhfIdPermission, prvtCfmStackMdLevel=prvtCfmStackMdLevel, prvtCfmMaAisLckVlan=prvtCfmMaAisLckVlan, PrvtCfmMepId=PrvtCfmMepId, prvtCfmUpdateInterval=prvtCfmUpdateInterval, prvtCfmMepTable=prvtCfmMepTable, prvtCfmMepDbChassisId=prvtCfmMepDbChassisId, prvtCfmProfile1wJitterError=prvtCfmProfile1wJitterError, PrvtCfmMaintDomainNameType=PrvtCfmMaintDomainNameType, prvtCfmProfileEntry=prvtCfmProfileEntry, prvtCfmMepTransmitLbmSentPkts=prvtCfmMepTransmitLbmSentPkts, prvtCfmMepDirection=prvtCfmMepDirection, PrvtCfmIndexIntegerNextFree=PrvtCfmIndexIntegerNextFree, prvtCfmMepTransmitLbmMaxTime=prvtCfmMepTransmitLbmMaxTime, prvtCfmMepTransmitLtmFlags=prvtCfmMepTransmitLtmFlags, prvtCfmMaAisLckLevel=prvtCfmMaAisLckLevel, prvtCfmLtrSourceMac=prvtCfmLtrSourceMac, prvtCfmMepLbrInOutOfOrder=prvtCfmMepLbrInOutOfOrder, prvtCfmProfileJitterWarning=prvtCfmProfileJitterWarning, prvtCfmProcessUnreturnedPkts=prvtCfmProcessUnreturnedPkts, prvtCfmMaTable=prvtCfmMaTable, prvtCfmProcessRowStatus=prvtCfmProcessRowStatus, prvtCfmMdMhfCreation=prvtCfmMdMhfCreation, prvtCfmLtrTime=prvtCfmLtrTime, prvtCfmStackMacAddress=prvtCfmStackMacAddress, PrvtCfmLowestAlarmPri=PrvtCfmLowestAlarmPri, prvtCfmMaEntry=prvtCfmMaEntry, prvtCfmMIBObjects=prvtCfmMIBObjects, prvtCfmMepErrorCcmLastFailure=prvtCfmMepErrorCcmLastFailure, PrvtCfmPortStatus=PrvtCfmPortStatus, prvtCfmStackEntry=prvtCfmStackEntry, prvtCfmUnexpectedPriority=prvtCfmUnexpectedPriority, prvtCfmMepTransmitLtmSeqNumber=prvtCfmMepTransmitLtmSeqNumber, prvtCfmProcessName=prvtCfmProcessName, prvtCfmProcess=prvtCfmProcess, prvtCfmMaAisLckInterval=prvtCfmMaAisLckInterval, prvtCfmMepTransmitMcastLbm=prvtCfmMepTransmitMcastLbm, prvtCfmLtrEntry=prvtCfmLtrEntry, prvtCfmLtrManAddress=prvtCfmLtrManAddress, prvtCfmMaClearConnectivity=prvtCfmMaClearConnectivity, prvtCfmMepTransmitLbmDestIsMepId=prvtCfmMepTransmitLbmDestIsMepId, prvtCfmProfileLatencyEnabled=prvtCfmProfileLatencyEnabled, prvtCfmProcessEntry=prvtCfmProcessEntry, prvtCfmProfilePriority=prvtCfmProfilePriority, prvtCfmLbrTable=prvtCfmLbrTable, PrvtCfmIdPermission=PrvtCfmIdPermission, prvtCfmLtrEgressMac=prvtCfmLtrEgressMac, prvtCfmMepTransmitLtmTargetMepId=prvtCfmMepTransmitLtmTargetMepId, prvtCfmMepTransmitLbmStatus=prvtCfmMepTransmitLbmStatus, prvtCfmMa=prvtCfmMa, prvtCfmLtrIngressMac=prvtCfmLtrIngressMac, prvtCfmMepLtmNextSeqNumber=prvtCfmMepLtmNextSeqNumber, prvtCfmMepTransmitLbmVlanPriority=prvtCfmMepTransmitLbmVlanPriority, prvtCfmLtrForwarded=prvtCfmLtrForwarded, prvtCfmMepShutdown=prvtCfmMepShutdown, prvtCfmMepXconCcmLastFailure=prvtCfmMepXconCcmLastFailure, prvtCfmMepTransmitLbmDelay=prvtCfmMepTransmitLbmDelay, PrvtCfmCcmInterval=PrvtCfmCcmInterval, prvtCfmMepLckLifetime=prvtCfmMepLckLifetime, prvtCfmMdTable=prvtCfmMdTable, prvtCfmMepIdentifier=prvtCfmMepIdentifier, prvtCfmProfileTableNextIndex=prvtCfmProfileTableNextIndex, prvtCfmProfileRate=prvtCfmProfileRate, prvtCfmProfileFrameLossError=prvtCfmProfileFrameLossError, prvtCfmProcessRepeatInterval=prvtCfmProcessRepeatInterval, LldpPortIdSubtype=LldpPortIdSubtype, PrvtCfmMaintDomainNameOrNone=PrvtCfmMaintDomainNameOrNone, prvtCfmStack=prvtCfmStack, prvtCfmMepCciSentCcms=prvtCfmMepCciSentCcms, prvtCfmMepDbManAddressDomain=prvtCfmMepDbManAddressDomain, PrvtCfmMDLevelTC=PrvtCfmMDLevelTC, prvtCfmMIBNotifications=prvtCfmMIBNotifications, prvtCfmStackMepId=prvtCfmStackMepId, prvtCfmMepTransmitLbmResultOK=prvtCfmMepTransmitLbmResultOK, prvtCfmLtrIngressPortIdSubtype=prvtCfmLtrIngressPortIdSubtype, prvtCfmMepTransmitLbmDataTlv=prvtCfmMepTransmitLbmDataTlv, prvtCfmLbrSeqNumber=prvtCfmLbrSeqNumber, prvtCfmProfileIndex=prvtCfmProfileIndex, PrvtCfmHighestDefectPri=PrvtCfmHighestDefectPri, prvtCfmLtrNextEgressIdentifier=prvtCfmLtrNextEgressIdentifier, prvtCfmMaCcmInterval=prvtCfmMaCcmInterval, prvtCfm1wJitterThreshold=prvtCfm1wJitterThreshold, prvtCfmMepTransmitLbmRemainingMessages=prvtCfmMepTransmitLbmRemainingMessages, prvtCfmMaAisLckVlanEntry=prvtCfmMaAisLckVlanEntry, prvtCfmMepCcmSequenceErrors=prvtCfmMepCcmSequenceErrors, prvtCfmMdFormat=prvtCfmMdFormat, prvtCfmMaName=prvtCfmMaName, prvtCfmMepLbrOut=prvtCfmMepLbrOut, prvtCfmProfileJitterError=prvtCfmProfileJitterError, PrvtCfmIdPermissionDef=PrvtCfmIdPermissionDef, prvtCfmMepTransmitLtmStatus=prvtCfmMepTransmitLtmStatus, prvtCfmMepTransmitLtmTimeout=prvtCfmMepTransmitLtmTimeout, prvtCfmMepMacAddress=prvtCfmMepMacAddress, prvtCfmProfileFramelossEnabled=prvtCfmProfileFramelossEnabled, prvtCfmProfileLatencyError=prvtCfmProfileLatencyError, prvtCfmProfileJitterWarningPeriod=prvtCfmProfileJitterWarningPeriod, prvtCfmMepTransmitLbmCurrentStatus=prvtCfmMepTransmitLbmCurrentStatus, prvtCfmMepTransmitLbmDestMacAddress=prvtCfmMepTransmitLbmDestMacAddress, prvtCfmStackInterfaceIndex=prvtCfmStackInterfaceIndex, prvtCfmLbrMacAddress=prvtCfmLbrMacAddress, prvtCfmMepDbRMepFailedOkTime=prvtCfmMepDbRMepFailedOkTime, prvtCfmMaServiceId=prvtCfmMaServiceId, prvtCfmAisLckRecieved=prvtCfmAisLckRecieved, prvtCfmMepHighestPrDefect=prvtCfmMepHighestPrDefect, prvtCfmLtrManAddressDomain=prvtCfmLtrManAddressDomain, prvtCfmMaAisLckVlanTable=prvtCfmMaAisLckVlanTable, prvtCfmMepFngResetTime=prvtCfmMepFngResetTime, prvtCfmMepRowStatus=prvtCfmMepRowStatus, prvtCfmMepFngAlarmTime=prvtCfmMepFngAlarmTime, prvtCfmLtrChassisId=prvtCfmLtrChassisId, prvtCfmMIB=prvtCfmMIB, prvtCfmMepDefects=prvtCfmMepDefects, prvtCfmMepTransmitLbmInfinite=prvtCfmMepTransmitLbmInfinite, prvtCfmLbrTime=prvtCfmLbrTime, LldpChassisId=LldpChassisId, prvtCfmMepTransmitLbmVlanDropEnable=prvtCfmMepTransmitLbmVlanDropEnable, prvtCfmStackDirection=prvtCfmStackDirection, prvtCfmMepTransmitLtmEgressIdentifier=prvtCfmMepTransmitLtmEgressIdentifier, prvtCfmMepAisCondition=prvtCfmMepAisCondition, prvtCfmMepTransmitLbmSuccessRate=prvtCfmMepTransmitLbmSuccessRate, prvtCfmMepEntry=prvtCfmMepEntry, prvtCfmMdRowStatus=prvtCfmMdRowStatus, prvtCfmProfile1wJitterWarning=prvtCfmProfile1wJitterWarning, prvtCfmLbrBadMsdu=prvtCfmLbrBadMsdu, prvtCfmProcessResultTwoWayJitter=prvtCfmProcessResultTwoWayJitter, prvtCfmMepDbMacAddress=prvtCfmMepDbMacAddress, prvtCfmMepDbInterfaceStatusTlv=prvtCfmMepDbInterfaceStatusTlv, prvtCfmProcessResultLatency=prvtCfmProcessResultLatency, prvtCfmMaVlanId=prvtCfmMaVlanId, prvtCfmMepUnexpLtrIn=prvtCfmMepUnexpLtrIn, prvtCfmStackServiceIdOrNone=prvtCfmStackServiceIdOrNone, PrvtCfmMaintDomainName=PrvtCfmMaintDomainName, PYSNMP_MODULE_ID=prvtCfmMIB, prvtCfmMepFngState=prvtCfmMepFngState, prvtCfmLtrReceiveOrder=prvtCfmLtrReceiveOrder, prvtCfmMepLbrIn=prvtCfmMepLbrIn, prvtCfmStackTable=prvtCfmStackTable, prvtCfmProcessResultOneWayJitter=prvtCfmProcessResultOneWayJitter, prvtCfmLtrLastEgressIdentifier=prvtCfmLtrLastEgressIdentifier, prvtCfmMepAisLifetime=prvtCfmMepAisLifetime, PrvtCfmEgressActionFieldValue=PrvtCfmEgressActionFieldValue, PrvtCfmMaintAssocNameType=PrvtCfmMaintAssocNameType, LldpPortId=LldpPortId, prvtCfmMaAisLckPriority=prvtCfmMaAisLckPriority, PrvtCfmMaintAssocName=PrvtCfmMaintAssocName, prvtCfmMepLckCondition=prvtCfmMepLckCondition, prvtCfmMd=prvtCfmMd, prvtCfmMepDbTable=prvtCfmMepDbTable, prvtCfmMepTransmitLbmMinTime=prvtCfmMepTransmitLbmMinTime, prvtCfmMepDbRMepIdentifier=prvtCfmMepDbRMepIdentifier, prvtCfmMepTransmitLtmTargetMacAddress=prvtCfmMepTransmitLtmTargetMacAddress, PrvtCfmMhfCreationDef=PrvtCfmMhfCreationDef, prvtCfmProfileRowStatus=prvtCfmProfileRowStatus, prvtCfmProcessShutdown=prvtCfmProcessShutdown, prvtCfmAisLckCleared=prvtCfmAisLckCleared, prvtCfmShutdown=prvtCfmShutdown, prvtCfmProfileJitterErrorPeriod=prvtCfmProfileJitterErrorPeriod, prvtCfmProcessResultFrameloss=prvtCfmProcessResultFrameloss, prvtCfmLtrEgress=prvtCfmLtrEgress, prvtCfmMepDbChassisIdSubtype=prvtCfmMepDbChassisIdSubtype, prvtCfmProcessIndex=prvtCfmProcessIndex, PrvtCfmMpDirection=PrvtCfmMpDirection, prvtCfmLbrReceiveOrder=prvtCfmLbrReceiveOrder, prvtCfmLtrOrganizationSpecificTlv=prvtCfmLtrOrganizationSpecificTlv, prvtCfmStackMdName=prvtCfmStackMdName, prvtCfmMepNextLbmTransId=prvtCfmMepNextLbmTransId)
