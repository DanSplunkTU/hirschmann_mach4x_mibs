#
# PySNMP MIB module RTM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/RTM-MIB
# Produced by pysmi-1.1.8 at Thu Jan 13 22:40:13 2022
# On host fv-az83-250 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
stratacom, = mibBuilder.importSymbols("CISCOWAN-SMI", "stratacom")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Bits, Counter64, NotificationType, iso, Gauge32, ObjectIdentity, Unsigned32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, TimeTicks, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Bits", "Counter64", "NotificationType", "iso", "Gauge32", "ObjectIdentity", "Unsigned32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "TimeTicks", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
rtm = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 120))
trapsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 120, 1))
trapConfigTable = MibTable((1, 3, 6, 1, 4, 1, 351, 120, 1, 1), )
if mibBuilder.loadTexts: trapConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapConfigTable.setDescription('The trap configuration table. This table\n        is used for registering SNMP managers with the system.\n        The system will send traps only to the registered\n        SNMP mangers.')
trapConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1), ).setIndexNames((0, "RTM-MIB", "managerIPaddress"))
if mibBuilder.loadTexts: trapConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapConfigEntry.setDescription('An entry for each of the SNMP Manager registered.\n        Each SNMP Manager is identified by its IP Address\n        specified in managerIPAddress object.')
managerIPaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerIPaddress.setStatus('mandatory')
if mibBuilder.loadTexts: managerIPaddress.setDescription('A unique index value representing the SNMP manager.')
managerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: managerPortNumber.setDescription('The UDP Port number on which the manager\n        receives traps from a system.')
managerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("addRow", 1), ("delRow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: managerRowStatus.setDescription("This object is used for adding(registering) and\n        deleting(de-registering) SNMP managers in the system.\n        By setting this object to 'addRow' snmp manager will be\n        registered with the system.\n\n        By setting this object to 'delRow' snmp manager will be\n        registered with the system.\n\n        In some systems, the SNMP Manager will be de-registered\n        automatically by the agent (to allow other SNMP managers\n        to register), if manager is idle for long time(\n        This time is called aging interval time).\n        In order to avoid Managers being de-registered automatically\n        it is expected that the SNMP Managers keep sending\n        keep-alive requests(SNMP GET on this object)\n        to the system for predefined interval(Choosen by\n        SNMP Manager). The keep-alive requests need to be \n        sent few minutes before the aging interval expires.\n\n        The aging value of the Registered Managers are in the \n        order of minutes(system dependent or user configured).\n        The value supported for the aging value \n        is system dependent. The system might support\n        aging value per manager basis or per node basis\n        (applicable to all the registered managers).\n        ")
readingTrapsFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: readingTrapsFlag.setStatus('mandatory')
if mibBuilder.loadTexts: readingTrapsFlag.setDescription("An entry for the state of the manager.\n        The value 'false' indicates that SNMP manager is not\n        in the middle of uploading traps(via trapUploadTable).\n\n        The value 'true' indicates that SNMP manager is in the\n        middle of uploading traps(via trapUploadTable).\n\n        When the value is 'true' the system will not send traps\n        to the corresponding manager identified by\n        managerIPAddress object.")
nextTrapSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nextTrapSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: nextTrapSeqNum.setDescription('Set by the manager to indicate the first trap(identified\n        by this sequence number) it is interested in uploading.\n        The agent increments this value when readingTrapsFlag is\n        set to true(1) and SNMP Get is performed on trapUploadTable.\n        The trapUploadTable entries returned depends upon this\n        value. If there are no traps in the system with the \n        the sequence number, the agent will set the value for\n        this object to the head of FIFO(Saved traps)\n        and return an error response.')
managerNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 120, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managerNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: managerNumOfValidEntries.setDescription('The number of entries in trapConfigTable.')
lastSequenceNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 120, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lastSequenceNumber.setDescription('The sequence number of the last trap generated by\n        the system. This object is used in each of the \n        RTM Compliant trap definitions. The manager can \n        figure out whether any trap is lost(missing) by comparing\n        the lastSequenceNumber values received in last 2 traps.')
trapUploadTable = MibTable((1, 3, 6, 1, 4, 1, 351, 120, 1, 4), )
if mibBuilder.loadTexts: trapUploadTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapUploadTable.setDescription('The trapUploadTable is used by the manager to retrieve\n        missing(lost) traps using robust trap mechanism.\n        The manager does a Get request on this table.')
trapUploadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1), ).setIndexNames((0, "RTM-MIB", "trapManagerIPaddress"))
if mibBuilder.loadTexts: trapUploadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapUploadEntry.setDescription('Manager does a Get request on the elements of this entry\n        to upload missing traps.')
trapManagerIPaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapManagerIPaddress.setStatus('mandatory')
if mibBuilder.loadTexts: trapManagerIPaddress.setDescription('IP address of the manager used as an index to the table.\n        The value of this object must match with the value\n        in the managerIPaddress object.')
trapSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapSequenceNum.setStatus('mandatory')
if mibBuilder.loadTexts: trapSequenceNum.setDescription('The sequence number associated with the trap.\n        This sequence number has to match with the\n        value in lastSequenceNumber object embedded\n        in trapPduString.')
trapPduString = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapPduString.setStatus('mandatory')
if mibBuilder.loadTexts: trapPduString.setDescription('Trap description string. This contains the Trap PDU\n        that is stored in the system.')
endOfQueueFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endOfQueueFlag.setStatus('mandatory')
if mibBuilder.loadTexts: endOfQueueFlag.setDescription("Flag indicating the last trap saved in the\n        system's FIFO queue.")
recoverTrapTable = MibTable((1, 3, 6, 1, 4, 1, 351, 120, 1, 5), )
if mibBuilder.loadTexts: recoverTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: recoverTrapTable.setDescription('A table containing information about the traps\n         sent from the system/switch. The total number of\n         traps stored in the switch is implementation\n         specific.\n         It is expected that systems supporting RTM Mechanism\n         save atleast least 500 traps , so that NMS\n         applications can recover the traps if they\n         determined it to be lost.')
recoverTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 120, 1, 5, 1), ).setIndexNames((0, "RTM-MIB", "recoverTrapSequenceNum"))
if mibBuilder.loadTexts: recoverTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: recoverTrapEntry.setDescription('The entry for each of the traps stored in the switch.')
recoverTrapSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: recoverTrapSequenceNum.setStatus('mandatory')
if mibBuilder.loadTexts: recoverTrapSequenceNum.setDescription("The sequence number associated with the trap.\n         The system tries to find a matching entry\n         in the list of traps stored.\n         If there is a match, an valid entry returned \n         with value for 'recoverTrapPduString' object.")
recoverTrapPduString = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 120, 1, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: recoverTrapPduString.setStatus('mandatory')
if mibBuilder.loadTexts: recoverTrapPduString.setDescription('Trap description string. This contains the Trap PDU\n         that is stored in the system.')
mibBuilder.exportSymbols("RTM-MIB", recoverTrapSequenceNum=recoverTrapSequenceNum, readingTrapsFlag=readingTrapsFlag, trapsConfig=trapsConfig, lastSequenceNumber=lastSequenceNumber, trapUploadEntry=trapUploadEntry, managerIPaddress=managerIPaddress, managerNumOfValidEntries=managerNumOfValidEntries, trapPduString=trapPduString, trapConfigEntry=trapConfigEntry, rtm=rtm, trapConfigTable=trapConfigTable, endOfQueueFlag=endOfQueueFlag, recoverTrapEntry=recoverTrapEntry, nextTrapSeqNum=nextTrapSeqNum, trapSequenceNum=trapSequenceNum, recoverTrapPduString=recoverTrapPduString, recoverTrapTable=recoverTrapTable, trapUploadTable=trapUploadTable, managerRowStatus=managerRowStatus, trapManagerIPaddress=trapManagerIPaddress, managerPortNumber=managerPortNumber)
