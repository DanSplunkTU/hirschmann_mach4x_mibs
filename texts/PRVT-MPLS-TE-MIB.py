#
# PySNMP MIB module PRVT-MPLS-TE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-MPLS-TE-MIB
# Produced by pysmi-1.1.3 at Sat Nov 20 17:22:42 2021
# On host fv-az121-977 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressIPv4, InetAddress, InetAddressType, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4", "InetAddress", "InetAddressType", "InetAddressPrefixLength")
MplsPathIndex, MplsExtendedTunnelId, MplsBurstSize, TeHopAddress, TeHopAddressUnnum, MplsPathIndexOrZero, MplsTunnelAffinity, MplsBitRate, MplsOwner, TeHopAddressType, MplsLSPID, TeHopAddressAS, MplsTunnelInstanceIndex, MplsTunnelIndex = mibBuilder.importSymbols("MPLS-TC-PRIV-STDEXT-MIB", "MplsPathIndex", "MplsExtendedTunnelId", "MplsBurstSize", "TeHopAddress", "TeHopAddressUnnum", "MplsPathIndexOrZero", "MplsTunnelAffinity", "MplsBitRate", "MplsOwner", "TeHopAddressType", "MplsLSPID", "TeHopAddressAS", "MplsTunnelInstanceIndex", "MplsTunnelIndex")
mpls, = mibBuilder.importSymbols("PRVT-CR-LDP-MIB", "mpls")
prvtMplsTeMibEntityIndex, = mibBuilder.importSymbols("PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, IpAddress, Counter32, zeroDotZero, ObjectIdentity, MibIdentifier, TimeTicks, Unsigned32, NotificationType, Gauge32, transmission, Integer32, Bits, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "IpAddress", "Counter32", "zeroDotZero", "ObjectIdentity", "MibIdentifier", "TimeTicks", "Unsigned32", "NotificationType", "Gauge32", "transmission", "Integer32", "Bits", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64")
RowPointer, StorageType, TruthValue, TextualConvention, TimeStamp, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "StorageType", "TruthValue", "TextualConvention", "TimeStamp", "RowStatus", "DisplayString")
mplsTeMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2))
mplsTeMIB.setRevisions(('2009-02-17 00:00', '2008-11-20 00:00', '2008-08-28 00:00', '2008-03-03 00:00', '2007-12-06 00:00', '2007-12-02 09:59',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsTeMIB.setRevisionsDescriptions(('Removed references to undefined OBJECT-GROUPs.', 'Added additional timer (mplsTunnelMBBTimeOut) in the tunnel mib.', 'mplsTunnelReoptimized notification updates.', 'mplsTunnelRebuildTimer updates.', 'Minor TC updates.', 'The attribute for guarded destination has IPv4 TC.',))
if mibBuilder.loadTexts: mplsTeMIB.setLastUpdated('200902170000Z')
if mibBuilder.loadTexts: mplsTeMIB.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: mplsTeMIB.setContactInfo(' BATM/Telco Systems Support team\n\t\t\t\t\tEmail: \n\t\t\t\tFor North America: techsupport@telco.com\n\t\t\t\tFor North Europe: support@batm.de, info@batm.de\n\t\t\t\tFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: mplsTeMIB.setDescription("This MIB module contains managed object definitions\n          for MPLS Traffic Engineering (TE) as defined in:\n          Extensions to RSVP for LSP Tunnels, Awduche et al,\n          Internet Draft <draft-ietf-mpls-rsvp-lsp-tunnel-\n          07.txt>, August 2000; Constraint-Based LSP Setup\n          using LDP, B. Jamoussi, Internet Draft <draft-ietf-\n          mpls-cr-ldp-04.txt>, July 2000; Requirements for\n          Traffic Engineering Over MPLS, Awduche, D., J.\n          Malcolm, J., Agogbua, J., O'Dell, M., J. McManus,\n          <rfc2702.txt>, September 1999.")
class MplsTunnelIndexSyntax(TextualConvention, Integer32):
    description = 'Index into mplsTunnelTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class MplsLsrId(TextualConvention, Unsigned32):
    description = 'A unique identifier for an MPLS LSR. This MAY\n          represent an IpV4 address.'
    status = 'current'

class MplsGeneralizedLabelType(TextualConvention, Integer32):
    description = 'The  label  types that are defined  for  Generalized\n        MPLS.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("mplsLabel", 1), ("generalizedLabel", 2), ("wavebandLabel", 3))

class MplsTunnelPrivateDataSyntax(TextualConvention, OctetString):
    description = 'Represents private data field.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 8)

class MplsTunnelTNAAddress(TextualConvention, OctetString):
    description = 'TNA address of a tunnel.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 20)

class MplsGeneralizedLabel(TextualConvention, OctetString):
    description = 'This value represents a generalized MPLS Label.\n        The label contents are specific to the label being\n        represented.\n\n        Wherever an MplsGeneralizedLabel is copied to or from\n        a signaling protocol message, it is copied byte for\n        byte as is.  Therefore, if the octet string is\n        intended to represent multibyte values, it encodes\n        those values in network (big-endian) byte order.\n        This interpretation applies in particular to the\n        non-generalized MPLS labels (32 bits) used in ATM, FR\n        and generic MPLS networks.'
    status = 'current'
    displayHint = '255x'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

mplsTeObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1))
mplsTeNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 2))
mplsTeNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 2, 0))
mplsTeConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3))
mplsTunnelIndexNextTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 1), )
if mibBuilder.loadTexts: mplsTunnelIndexNextTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndexNextTable.setDescription('This table contains the next available values of\n        mplsTunnelIndex for all entities.')
mplsTunnelIndexNextEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 1, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: mplsTunnelIndexNextEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndexNextEntry.setDescription('An entry in this table represents the next available\n        mplsTunnelIndex for a specific TE-MIB entity.\n        This MIB table is indexed by the PRVT-TE-MIB entity Index.')
mplsTunnelIndexNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIndexNextIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndexNextIndex.setDescription('This object contains the next appropriate value\n        to be used for mplsTunnelIndex when creating\n        entries in the mplsTunnelTable. If the number of\n        unassigned entries is exhausted, this object\n        will take on the value of 0.  To obtain the\n        mplsTunnelIndex value for a new entry, the\n        manager must first issue a management protocol\n        retrieval operation to obtain the current value\n        of this object. The agent should modify the\n        value to reflect the next unassigned index after\n        each retrieval operation. After a manager\n        retrieves a value the agent will determine\n        through its local policy when this index value\n        will be made available for reuse.')
mplsTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2), )
if mibBuilder.loadTexts: mplsTunnelTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTable.setDescription('The mplsTunnelTable allows new MPLS tunnels to be\n          created between an LSR and a remote endpoint, and\n          existing tunnels to be reconfigured or removed.\n          Note that only point-to-point tunnel segments are\n          supported, although multi-point-to-point and point-\n          to-multi-point connections are supported by an LSR\n          acting as a cross-connect.  Each MPLS tunnel can\n          thus have one out-segment originating at this LSR\n          and/or one in-segment terminating at this LSR.\n\n          To configure tunnels where the ingress and egress routers\n          are identified by IPv6 addresses, the following approach is\n          used.\n\n          - The mplsTunnelIngressLSRId and mplsTunnelEgressLSRId\n            fields are set to 32-bit identifiers for the ingress and\n            egress routers.\n\n          - mplsTunnelHopTableIndex must be set to a non-zero value.\n\n          - The first hop in the hop table for the tunnel path must be\n            set to a global scope IPv6 address of the local router.\n\n          - The last entry in the hop table must be set to a global\n            scope IPv6 address of the egress router.')
mplsTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelInstance"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelIngressLSRId"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: mplsTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEntry.setDescription('An entry in this table represents an MPLS tunnel.\n          An entry can be created by a network administrator\n          or by an SNMP agent as instructed by an MPLS\n          signaling protocol. Whenever a new entry is created\n          with mplsTunnelIsIf set to true(1), then a\n          corresponding entry is created in ifTable as well\n          (see RFC 2233). The ifType of this entry is\n          mplsTunnel(150).')
mplsTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 1), MplsTunnelIndexSyntax())
if mibBuilder.loadTexts: mplsTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndex.setDescription('Uniquely identifies this row.')
mplsTunnelInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 2), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: mplsTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstance.setDescription('Uniquely identifies an instance of a tunnel. It is\n          useful to identify multiple instances of tunnels\n          for the purposes of backup and parallel tunnels.')
mplsTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 3), MplsExtendedTunnelId())
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n          Awduche et al, RFC 3209, December 2001\n         2. Constraint-Based LSP Setup using LDP, Jamoussi\n          (Editor), RFC 3212, January 2002')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setDescription('Identity of the ingress LSR associated with this\n          tunnel instance. When the MPLS signalling protocol\n          is rsvp(2) this value SHOULD be equal to the Tunnel\n          Sender Address in the Sender Template object and MAY\n          be equal to the Extended Tunnel Id field in the\n          SESSION object. When the MPLS signalling protocol is\n          crldp(3) this value SHOULD be equal to the Ingress\n          LSR Router ID field in the LSPID TLV object.')
mplsTunnelEgressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 4), MplsExtendedTunnelId())
if mibBuilder.loadTexts: mplsTunnelEgressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEgressLSRId.setDescription('Identity of the egress LSR associated with this\n          tunnel instance.')
mplsTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelName.setReference('RFC 2863 - The Interfaces Group MIB, McCloghrie, K.,\n          and F. Kastenholtz, June 2000')
if mibBuilder.loadTexts: mplsTunnelName.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelName.setDescription('The canonical name assigned to the tunnel. This name\n          can be used to refer to the tunnel on the LSRs\n          console port.  If mplsTunnelIsIf is set to true\n          then the ifName of the interface corresponding to\n          this tunnel should have a value equal to\n          mplsTunnelName.  Also see the description of ifName\n          in RFC 2863.')
mplsTunnelDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 6), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDescr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDescr.setDescription('A textual string containing information about the\n          tunnel.  If there is no description this object\n          contains a zero length string. This object is may\n          not be signaled by MPLS signaling protocols,\n          consequentally the value of this object at transit\n          and egress LSRs MAY be automatically generated or\n          absent.')
mplsTunnelIsIf = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsIf.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIf.setDescription('Denotes whether or not this tunnel corresponds to an\n          interface represented in the interfaces group\n          table. Note that if this variable is set to true\n          then the ifName of the interface corresponding to\n          this tunnel should have a value equal to\n          mplsTunnelName.  Also see the description of ifName\n          in RFC 2233.')
mplsTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIfIndex.setReference('RFC 2863 - The Interfaces Group MIB, McCloghrie, K.,\n          and F. Kastenholtz, June 2000')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setDescription('If mplsTunnelIsIf is set to true, then this value\n          contains the LSR-assigned ifIndex which corresponds\n          to an entry in the interfaces table.  Otherwise\n          this variable should contain the value of zero\n          indicating that a valid ifIndex was not assigned to\n          this tunnel interface.')
mplsTunnelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 9), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelOwner.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOwner.setDescription('Denotes the entity that created and is responsible\n          for managing this tunnel. This column is\n          automatically filled by the agent on creation of a\n          row.')
mplsTunnelRole = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("head", 1), ("transit", 2), ("tail", 3), ("headTail", 4))).clone('head')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRole.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRole.setDescription('This value signifies the role that this tunnel\n          entry/instance represents. This value MUST be set\n          to head(1) at the originating point of the tunnel.\n          This value MUST be set to transit(2) at transit\n          points along the tunnel, if transit points are\n          supported. This value MUST be set to tail(3) at the\n          terminating point of the tunnel if tunnel tails are\n          supported.\n\n         The value headTail(4) is provided for tunnels that\n          begin and end on the same LSR.')
mplsTunnelXCPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 11), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelXCPointer.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau,\n          Multiprotocol Label Switching (MPLS) Label Switching\n          Router (LSR) Management Information Base (MIB), RFC 3813,\n          June 2004')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setDescription('This variable points to a row in the mplsXCTable.\n          This table identifies the segments that compose\n          this tunnel, their characteristics, and\n          relationships to each other. A value of zeroDotZero\n          indicates that no LSP has been associated with this\n          tunnel yet.\n\n          The array of longs specified here is configured as\n          the OID array for the lmgr entity cross connect row.\n          This consists of the length, family, lmgr entity\n          index and row index values.  Only the\n          AMB_MPLS_XC_INDEX_IDX index is referenced by the\n          TE-MIB.')
mplsTunnelSignallingProto = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("rsvp", 2), ("crldp", 3), ("other", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setDescription('The signalling protocol, if any, used to setup this\n          tunnel.')
mplsTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n          Awduche et al, RFC 3209, December 2001\n         2. Constraint-Based LSP Setup using LDP, Jamoussi\n          (Editor), RFC 3212, January 2002')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setDescription('Indicates the setup priority of this tunnel.')
mplsTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n          Awduche et al, RFC 3209, December 2001\n\n         2. Constraint-Based LSP Setup using LDP, Jamoussi\n          (Editor), RFC 3212, January 2002')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setDescription('Indicates the holding priority for this tunnel.')
mplsTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 15), Bits().clone(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("isPinned", 3), ("recordRoute", 4), ("reserved5", 5), ("bandwidthProtect", 6), ("nodeProtect", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n          Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setDescription('This bitmask indicates optional session values for\n          this tunnel. The following describes these bit\n          fields:\n\n         fastReroute This flag indicates that any tunnel\n          hop may choose to reroute this tunnel without\n          tearing it down.  This flag permits transit routers\n          to use a local repair mechanism which may result in\n          violation of the explicit routing of this tunnel.\n          When a fault is detected on an adjacent downstream\n          link or node, a transit router can reroute traffic\n          for fast service restoration.\n\n         mergingPermitted This flag permits transit routers\n          to merge this session with other RSVP sessions for\n          the purpose of reducing resource overhead on\n          downstream transit routers, thereby providing\n          better network scalability.\n\n        isPersistent  Indicates whether this tunnel should\n          be restored automatically after a failure occurs.\n\n        isPinned   This flag indicates whether the loose-\n          routed hops of this tunnel are to be pinned.\n\n        recordRoute This flag indicates if the\n          signaling protocol should remember the tunnel path\n          after it has been signaled.\n\n--        recordLabels This flag indicates if the\n--          signaling protocol should record labels as well as\n--          the tunnel path.\n\n        bandwidthProtect This flag indicates whether fast reroute\n          bandwidth protection is desired.\n\n        nodeProtect This flag indicates whether fast reroute\n          node protection is desired.')
mplsTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setDescription('Indicates that the local repair mechanism is in use\n          to maintain this tunnel (usually in the face of an\n          outage of the link it was previously routed over).')
mplsTunnelResourcePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 17), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setDescription('This variable represents a pointer to the traffic\n          parameter specification for this tunnel.  This\n          value may point at an entry in the\n          mplsTunnelResourceEntry to indicate which\n          mplsTunnelResourceEntry is to be assigned to this\n          LSP instance.  This value may optionally point at\n          an externally defined traffic parameter\n          specification table.  A value of zeroDotZero\n          indicates best-effort treatment.  By having the\n          same value of this object, two or more LSPs can\n          indicate resource sharing.\n\n          In this implementation of the mplsTunnelTable, the row must either\n          be set to zeroDotZero, or must point at an entry in the\n          mplsTunnelResourceTable.\n\n          If a value other than zeroDotZero is used, then\n          mplsTunnelExtraParamsPtr must be set to zeroDotZero.')
mplsTunnelPrimaryInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 18), MplsTunnelInstanceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryInstance.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPrimaryInstance.setDescription('Specifies the instance index of the primary instance\n          of this tunnel.')
mplsTunnelInstancePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 19), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setDescription('This value indicates which priority, in descending\n          order, with 0 indicating the lowest priority,\n          within a group of tunnel instances.  A group of\n          tunnel instances is defined as a set of LSPs with\n          the same mplsTunnelIndex in this table, but with a\n          different mplsTunnelInstance. Tunnel instance\n          priorities are used to denote the priority at which\n          a particular tunnel instance will supercede\n          another.  Instances of tunnels containing the same\n          mplsTunnelInstancePriority will be used for load\n          sharing.')
mplsTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 20), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setDescription('Index into the mplsTunnelHopTable entry that\n          specifies the explicit route hops for this tunnel.\n          This object is meaningful only at the head-end of\n          the tunnel.\n\n          For UNI tunnels, this field should be set to 0.\n\n          For tunnels with no configured explicit route hops, this\n          field should be set to 0.  In this case, the tunnel is\n          routed using mplsTunnelEgressLSRId.')
mplsTunnelPathInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 21), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelPathInUse.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPathInUse.setDescription('This value denotes the configured path that was\n          chosen for this tunnel. This value reflects the\n          secondary index into mplsTunnelHopTable. This path\n          may not exactly match the one in\n          mplsTunnelARHopTable due to the fact that some CSPF\n          modification may have taken place. See\n          mplsTunnelARHopTable for the actual path being\n          taken by the tunnel. A value of zero denotes that\n          no path is currently in use or available.\n\n          For UNI tunnels, this field should be set to 0.\n\n          For tunnels with no configued explicit route hops,\n          this field should be set to 0.')
mplsTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 22), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setDescription('Index into the mplsTunnelARHopTable entry that\n          specifies the actual hops traversed by the tunnel.\n          This is automatically updated by the agent when the\n          actual hops becomes available.')
mplsTunnelCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 23), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopTableIndex.setDescription('Index into the mplsTunnelCHopTable entry that\n          specifies the computed hops traversed by the\n          tunnel. This is automatically updated by the agent\n          when computed hops become available or when\n          computed hops get modified.')
mplsTunnelIncludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 24), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n          Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setDescription('A link satisfies the include-any constraint if and\n          only if the constraint is zero, or the link and the\n          constraint have a resource class in common.\n          \n          The field is a bitmask. Every request does not overwrite \n          the previous one. 0 value resets the field.\n        ')
mplsTunnelIncludeAllAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 25), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n          Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setDescription('A link satisfies the include-all constraint if and\n          only if the link contains all of the administrative\n          groups specified in the constraint.\n          \n          The field is a bitmask. Every request does not overwrite \n          the previous one. 0 value resets the field.\n        ')
mplsTunnelExcludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 26), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelExcludeAnyAffinity.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n          Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsTunnelExcludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelExcludeAnyAffinity.setDescription('A link satisfies the exclude-any constraint if and\n          only if the link contains none of the\n          administrative groups specified in the constraint.\n          \n          The field is a bitmask. Every request does not overwrite \n          the previous one. 0 value resets the field.\n        ')
mplsTunnelTotalUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 27), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelTotalUpTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTotalUpTime.setDescription('This value represents the aggregate up time for all\n          instances of this tunnel, if available. If this\n          value is unavailable, it MUST return a value of 0.')
mplsTunnelInstanceUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 28), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelInstanceUpTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstanceUpTime.setDescription("This value identifies the total time that this\n          tunnel instance's operStatus has been Up(1).")
mplsTunnelPrimaryUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 29), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryUpTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPrimaryUpTime.setDescription('Specifies the total time the primary instance of\n          this tunnel has been active. The primary instance\n          of this tunnel is defined in\n          mplsTunnelPrimaryInstance.')
mplsTunnelPathChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPathChanges.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPathChanges.setDescription('Specifies the number of times the actual path for\n         this tunnel instance has changed.')
mplsTunnelLastPathChange = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 31), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelLastPathChange.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLastPathChange.setDescription('Specifies the time since the last change to the\n         actual path for this tunnel instance.')
mplsTunnelCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 32), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCreationTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCreationTime.setDescription('Specifies the value of SysUpTime when the first\n          instance of this tunnel came into existence.\n          That is, when the value of mplsTunnelOperStatus\n          was first set to up(1).')
mplsTunnelStateTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelStateTransitions.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelStateTransitions.setDescription('Specifies the number of times the state\n          (mplsTunnelOperStatus) of this tunnel instance has\n          changed.')
mplsTunnelAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setDescription('Indicates the desired operational status of this\n          tunnel.')
mplsTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOperStatus.setDescription('Indicates the actual operational status of this\n          tunnel, which is typically but not limited to, a\n          function of the state of individual segments of\n          this tunnel.')
mplsTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 36), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRowStatus.setDescription('This variable is used to create, modify, and/or\n          delete a row in this table.  When a row in this\n          table is in active(1) state, no objects in that row\n          can be modified by the agent except\n          mplsTunnelAdminStatus, mplsTunnelRowStatus and\n          mplsTunnelStorageType.')
mplsTunnelStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 37), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelStorageType.setDescription("The storage type for this tunnel entry.\n                 Conceptual rows having the value 'permanent'\n                 need not allow write-access to any columnar\n                 objects in the row.")
mplsTunnelUnnumIf = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 38), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUnnumIf.setReference('Signalling Unnumbered Links in RSVP-TE, Kompella, K.\n      and Rekhter, Y., RFC 3477, January 2003.')
if mibBuilder.loadTexts: mplsTunnelUnnumIf.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUnnumIf.setDescription("Denotes whether or not this tunnel corresponds to an unnumbered\n      interface represented in the interfaces group table.\n\n      This object is only used if mplsTunnelIsIf is set to 'true'.\n\n      If both this object and the mplsTunnelIsIf object are set to\n      'true', the originating LSR adds an LSP_TUNNEL_INTERFACE_ID\n      object to the outgoing Path message.\n\n      This object contains information that is only used by the\n      terminating LSR.")
mplsTunnelAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 39), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("reserved1", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("labelRecordingDesired", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAttributes.setReference('RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al.,\n        RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsTunnelAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAttributes.setDescription('This bitmask indicates optional parameters for this tunnel.\n        These bits should be taken in addition to those defined in\n        mplsTunnelSessionAttributes in order to determine the full set\n        of options to be signaled (for example SESSION_ATTRIBUTES flags\n        in RSVP-TE). The following describes these bitfields:\n\n        labelRecordingDesired\n          This flag indicates that label information should be included\n          when doing a route record. This bit is not valid unless the\n          recordRoute bit is set in the mplsTunnelSessionAttributes object.')
mplsTunnelLSPEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5, 7, 8, 9, 11))).clone(namedValues=NamedValues(("notInUse", 0), ("tunnelLspPacket", 1), ("tunnelLspEthernet", 2), ("tunnelLspAnsiEtsiPdh", 3), ("tunnelLspSdhSonet", 5), ("tunnelLspDigitalWrapper", 7), ("tunnelLspLambda", 8), ("tunnelLspFiber", 9), ("tunnelLspFiberChannel", 11))).clone('notInUse')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLSPEncoding.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLSPEncoding.setDescription('This object indicates the encoding of the LSP being requested.\n         It is only required when a generalized label request will be used\n         for this LSP.   A value of 0 in this object indicates that a\n         generalized label request will not be used to set up this LSP.\n\n         If this object indicates Sonet / SDH LSP encoding, then\n         the choice of QOS to use is controlled by the\n         mplsTunnelResourcePointer object.  If\n         mplsTunnelResourcePointer is 0.0, then a Sonet/SDH QOS\n         format is used, else an Intserv QOS is used.')
mplsTunnelSwitchingType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 41), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSwitchingType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSwitchingType.setDescription('Indicates the type of switching that should be performed on\n      a particular link. This field is needed for links that\n                 advertise more than one type of switching capability.\n                 Values of this field are as in the Switching Capability\n                 field defined in rfc3471.\n\n                 It is only used when mplsTunnelLSPEncoding is non-zero.')
mplsTunnelLinkProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 42), Bits().clone(namedValues=NamedValues(("extraTraffic", 0), ("unprotected", 1), ("shared", 2), ("dedicatedOneToOne", 3), ("dedicatedOnePlusOne", 4), ("enhanced", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLinkProtection.setReference('Berger, L., et al., Generalized Multi-Protocol\n       Label Switching (GMPLS) Signaling Functional\n       Description, RFC 3471, January 2003.')
if mibBuilder.loadTexts: mplsTunnelLinkProtection.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLinkProtection.setDescription("This bitmask indicates the level of link protection required. A\n      value of zero (no bits set) indicates that any protection may be\n      used. The following describes these bitfields:\n\n      extraTraffic\n        Indicates that the LSP should use links that are protecting\n        other (primary) traffic. Such LSPs may be preempted when the\n        links carrying the (primary) traffic being protected fail.\n\n      unprotected\n        Indicates that the LSP should not use any link layer\n        protection.\n\n      shared\n        Indicates that a shared link layer protection scheme, such as\n        1:N protection, should be used to support the LSP.\n\n      dedicatedOneToOne\n        Indicates that a dedicated link layer protection scheme,\n        i.e., 1:1 protection, should be used to support the LSP.\n\n      dedicatedOnePlusOne\n        Indicates that a dedicated link layer protection scheme,\n        i.e., 1+1 protection, should be used to support the LSP.\n\n      enhanced\n        Indicates that a protection scheme that is more reliable than\n        Dedicated 1+1 should be used, e.g., 4 fiber BLSR/MS-SPRING.\n\n      This object is only meaningful if mplsTunnelLSPEncoding is\n      not set to 'tunnelLspNotGmpls'.")
mplsTunnelGPid = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 56))).clone(namedValues=NamedValues(("unknown", 0), ("ds1SF", 1), ("ds1ESF", 2), ("ds3M23", 3), ("ds3Cbit", 4), ("asyncE4", 5), ("asyncDS3", 6), ("asyncE3", 7), ("bitSyncE3", 8), ("byteSyncE3", 9), ("asyncDS2", 10), ("bitSyncDS2", 11), ("byteSyncDS2", 12), ("asyncE1", 13), ("byteSyncE1", 14), ("byteSync31DS0", 15), ("asyncDS1", 16), ("bitSyncDS1", 17), ("byteSyncDS1", 18), ("vcByteSyncDS2", 19), ("vcAsyncE1", 20), ("vcByteSyncE1", 21), ("ds1SFAsync", 22), ("ds1ESFAsync", 23), ("ds3M23Async", 24), ("ds3CbitAsync", 25), ("vt", 26), ("sts", 27), ("pos16CRC", 28), ("pos32CRC", 29), ("posScrambling16CRC", 30), ("posScrambling32CRC", 31), ("atmMapping", 32), ("ethernet", 33), ("sdh", 34), ("sonet", 35), ("digitalWrapper", 36), ("lambda", 37), ("etsiPdh", 38), ("ansiPdh", 39), ("laps", 40), ("fddi", 41), ("dqdb", 42), ("fiberch3", 43), ("hdlc", 44), ("etherV2di", 45), ("ether8023", 46), ("etherGfpSonet", 56)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelGPid.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelGPid.setDescription('This object indicates the payload carried by the LSP.It is only\n      required when GMPLS will be used for this LSP.\n\n        Only valid if Generalized Label Request is in use as specified\n        by mplsTunnelLSPEncodingType.\n        This object is only meaningful if mplsTunnelLSPEncoding is not\n        set to 0')
mplsTunnelSecondary = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 44), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSecondary.setReference('Berger, L., et al., Generalized Multi-Protocol\n      Label Switching (GMPLS) Signaling Functional\n      Description, RFC 3471, January 2003.')
if mibBuilder.loadTexts: mplsTunnelSecondary.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSecondary.setDescription('Indicates that the requested LSP is a secondary LSP.\n\n        This is a GMPLS feature, and should only be used when GMPLS will be\n        be used for this LSP.\n\n       This object is only meaningful if mplsTunnelLSPEncoding is not\n       set to 0.')
mplsTunnelDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("out", 0), ("outbidir", 1), ("in", 2), ("hwbidir", 3), ("inbidir", 4), ("transuni", 5), ("transbi", 6), ("transbih", 7))).clone('out')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDirection.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDirection.setDescription("Whether   this  tunnel  is  unidirectional-incoming,\n        unidirectional-outgoing, bidirectional in hardware,\n        the terminator end of a signalled bidirectional\n        tunnel, the initiator end of a signalled\n        bidirectional tunnel, unidirectional at transit,\n        signalled bidirectional at transit, or bidirectional\n        in hardware at transit.\n\n      Values of this object other than 'out' are meaningful\n      only if mplsTunnelLSPEncoding is not set to 0.")
mplsTunnelPathComp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dynamicFull", 1), ("explicit", 2), ("dynamicPartial", 3))).clone('dynamicFull')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelPathComp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPathComp.setDescription('This value instructs the source node on how to perform path\n      computation on the explicit route specified by the associated\n      entries in the mplsTunnelHopTable.\n\n        dynamicFull\n        The user specifies at least the source and\n        destination of the path and expects that the CSPF\n        will calculate the remainder of the path.\n\n        explicit\n        The user specifies the entire path for the tunnel to\n        take. This path may contain strict or loose hops.\n        Evaluation of the explicit route will be performed\n        hop by hop through the network.\n\n        dynamicPartial\n        The user specifies at least the source and\n        destination of the path and expects that the CSPF\n        will calculate the remainder of the path. The path\n        computed by CSPF is allowed to be only partially\n        computed allowing the remainder of the path to be\n        filled in across the network.\n\n      This object deprecates mplsTunnelHopEntryPathComp.')
mplsTunnelUpNotRecipType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 101), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUpNotRecipType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUpNotRecipType.setDescription('Type of upstream notify recipient address for this tunnel.')
mplsTunnelUpNotRecip = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 47), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUpNotRecip.setReference('Generalized MPLS Signaling - RSVP-TE Extensions, Berger,\n      L. (Editor), RFC 3473, January 2003.')
if mibBuilder.loadTexts: mplsTunnelUpNotRecip.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUpNotRecip.setDescription('Indicates the address of the upstream recipient for Notify\n      messages relating to this tunnel.\n\n      This object is only valid when signaling a tunnel using RSVP. It\n      is also not valid at the tail end of the tunnel.\n\n      If set to 0, no Notify Request object will be included in\n      outgoing Path messages.')
mplsTunnelDownNotRecipType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 102), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDownNotRecipType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDownNotRecipType.setDescription('Type of downstream notify recipient address for this tunnel.')
mplsTunnelDownNotRecip = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 48), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDownNotRecip.setReference('Generalized MPLS Signaling - RSVP-TE Extensions, Berger, L.\n      (Editor), RFC 3473, January 2003.')
if mibBuilder.loadTexts: mplsTunnelDownNotRecip.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDownNotRecip.setDescription('Indicates the address of the downstream recipient for Notify\n      messages relating to this tunnel.\n\n      This object is only valid when signaling a tunnel using RSVP. It\n      is also not valid at the head end of the tunnel.\n\n      If set to 0, no Notify Request object will be included in\n      outgoing Resv messages.')
mplsTunnelAdminStatusFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 49), Bits().clone(namedValues=NamedValues(("delInProgress", 0), ("adminDown", 1), ("testing", 2), ("reserved3", 3), ("reserved4", 4), ("reserved5", 5), ("reserved6", 6), ("reserved7", 7), ("reserved8", 8), ("reserved9", 9), ("reserved10", 10), ("reserved11", 11), ("reserved12", 12), ("reserved13", 13), ("reserved14", 14), ("reserved15", 15), ("reserved16", 16), ("reserved17", 17), ("reserved18", 18), ("reserved19", 19), ("reserved20", 20), ("reserved21", 21), ("reserved22", 22), ("reserved23", 23), ("reserved24", 24), ("reserved25", 25), ("reserved26", 26), ("reserved27", 27), ("reserved28", 28), ("reserved29", 29), ("reserved30", 30), ("reflect", 31)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAdminStatusFlags.setReference('Berger, L., et al., Generalized Multi-Protocol Label Switching\n      (GMPLS) Signaling Functional Description, RFC 3471,\n      January 2003.')
if mibBuilder.loadTexts: mplsTunnelAdminStatusFlags.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAdminStatusFlags.setDescription('Determines the setting of the Admin Status flags in the\n       Admin Status object or TLV, as described in RFC 3471. Setting\n       this field to a non-zero value will result in the inclusion of\n       the admin status object on signaling messages.\n\n         If the prvtMplsTeMibAllowGracefulDeletion product MIB field\n         is set, then the delInProgress flag is\n         not writable.  Instead, Use the deletion_mode setting to\n         indicate whether Graceful deletion should be used for\n         the tunnel.\n\n       This value of this object can be modified when the\n       corresponding mplsTunnelRowStatus and mplsTunnelAdminStatus\n       is active(1). By doing so, a new signaling message will be\n       triggered including the requested Admin Status object or\n       TLV.')
mplsTunnelExtraParamsPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 50), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelExtraParamsPtr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelExtraParamsPtr.setDescription('Some Tunnels will run over transports that can usefully support\n      technology-specific additional parameters (for example, SONET\n      resource usage). Such parameters can be supplied in an external\n      table and referenced from here.\n\n      In this implementation of the mplsTunnelTable, the row must either\n      be set to zeroDotZero, or must point at an entry in the\n      mplsTunnelSonetResTable.\n\n      If a value other than zeroDotZero is used, then\n      mplsTunnelResourcePointer must be set to zeroDotZero.')
mplsTunnelUseEgressLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 51), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUseEgressLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUseEgressLabel.setDescription('Whether or not to use an explicit route Label subobject as\n       configured in mplsTunnelEgressLabel.')
mplsTunnelEgressLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 52), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelEgressLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEgressLabel.setDescription('The egress control Label in the explicit route, and its\n      length.\n\n      At ingress, this value must be inserted as the last hop of the\n      explicit route.\n\n      At egress this is the value of the received Label subobject.\n      Since 0 is a valid value, the validity of this field is\n      indicated by mplsTunnelUseEgressLabel.\n\n      When this label is used in signaling protocol messages,\n      it is copied byte for byte as is.  Therefore, if the label\n      octet string is intended to represent multibyte values, it\n      should encode those values in network (big-endian) byte\n      order.  This interpretation applies in particular to the\n      non-generalized MPLS labels (32 bits) used in ATM, FR and\n      generic MPLS networks.')
mplsTunnelEgressLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 53), MplsGeneralizedLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelEgressLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEgressLabelType.setDescription('The C-Type of the egress control Label configured in\n        mplsTunnelEgressLabel.')
mplsTunnelOmitEROIfOneHop = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 54), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelOmitEROIfOneHop.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOmitEROIfOneHop.setDescription("Indicates whether the explicit route object should be\n        omitted from the Path message when the tunnel consists of\n        just one loose hop.\n\n        Note that if mplsTunnelHopTableIndex is set to 0, the\n        tunnel is routed to the address configured in\n        mplsTunnelEgressLSRId.  This avoids the need to configure\n        a single loose hop containing the tunnel's destination\n        address and setting this field to true.")
mplsTunnelPrivateData = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 55), MplsTunnelPrivateDataSyntax()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelPrivateData.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPrivateData.setDescription('This object contains the customer defined private data for\n        the forward signaling direction.  At ingress it is\n        filled in with the private data present on the MIB SET\n        message.  Note that this field can be updated even when\n        the Tunnel is OperUp.\n        At egress it is filled in with the decoded forward private\n        data.\n        Note that there is a separate MIB field for the reverse\n        signaling direction private data,\n        mplsTunnelReversePrivateData.')
mplsTunnelSrcTNAAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ipv4", 1), ("ipv6", 2), ("nsap", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSrcTNAAddressType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSrcTNAAddressType.setDescription('Type of the source TNA address of this tunnel.  This field\n       is used for UNI.  For standard MPLS and GMPLS, this field\n       must be set to none.')
mplsTunnelSrcTNAAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 57), MplsTunnelTNAAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSrcTNAAddress.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSrcTNAAddress.setDescription('Source TNA address of this tunnel.  This field is only\n       valid if mplsTunnelSrcTNAAddressType is not none.')
mplsTunnelDestTNAAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ipv4", 1), ("ipv6", 2), ("nsap", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDestTNAAddressType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDestTNAAddressType.setDescription('Type of the destination TNA address of this tunnel.  This\n       field is used for UNI.  For standard MPLS and GMPLS, this\n       field must be set to none.')
mplsTunnelDestTNAAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 59), MplsTunnelTNAAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDestTNAAddress.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDestTNAAddress.setDescription('Destination TNA address of this tunnel.  This field is only\n       valid if mplsTunnelDestTNAAddressType is not none.')
mplsTunnelEndToEndRerouting = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 60), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelEndToEndRerouting.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEndToEndRerouting.setDescription("Indicates that Crankback End to End rerouting should be\n        enabled on this LSP.  Setting this flag will cause Rerouting\n        information to be returned to the ingress node on PathErrs\n        and Notifications.\n\n        No Rerouting information will be included if the Path\n        Message does not contain an ERO.  Rerouting\n        information will be limited to 'Node' errors unless a\n        switch managed label space is used.")
mplsTunnelIsUni = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 62), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsUni.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsUni.setDescription('This flag indicates whether the tunnel is to conform to\n        UNI 1.0.')
mplsTunnelUniServiceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 63), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniServiceLevel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniServiceLevel.setDescription('Indicates the UNI service level.  It is only valid when\n        _is_uni_ is set to true.')
mplsTunnelUniEgressLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 64), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniEgressLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniEgressLabel.setDescription('The label to be used at the destination UNI in the\n                 forward direction.\n\n                 This field is only valid if one of mplsTunnelIsUni or\n                 mplsTunnelIsSpc is set, and must be filled in if\n                 mplsTunnelIsSpc is set.')
mplsTunnelUniEgressLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 65), MplsGeneralizedLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniEgressLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniEgressLabelType.setDescription('The C-Type of the forward label to be used at the\n                 destination UNI.\n\n                 This field is only valid if one of mplsTunnelIsUni or\n                 mplsTunnelIsSpc is set, and must be filled in if\n                 mplsTunnelIsSpc is set.')
mplsTunnelUniEgressLabelPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 66), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniEgressLabelPort.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniEgressLabelPort.setDescription('The logical port identifier used to uniquely identify and\n                 select a (forward) data link at the destination UNI.\n\n                 This port identifier is relative to the destination UNI-C\n                 for UNI-initiated connections, but is relative to the\n                 destination UNI-N for connections that are initiated by\n                 management at the source UNI-N.\n\n                 This field is only valid if one of mplsTunnelIsUni or\n                 mplsTunnelIsSpc is set, and must be filled in if\n                 mplsTunnelIsSpc is set.')
mplsTunnelUniRvsEgressLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 67), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniRvsEgressLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniRvsEgressLabel.setDescription('The label to be used at the destination UNI in the\n                 reverse direction.\n\n                 This field is only valid if one of mplsTunnelIsUni or\n                 mplsTunnelIsSpc is set, and must be filled in if\n                 mplsTunnelIsSpc is set and the tunnel is bi-directional.')
mplsTunnelUniRvsEgressLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 68), MplsGeneralizedLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniRvsEgressLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniRvsEgressLabelType.setDescription('The C-Type of the reverse label to be used at the\n                 destination UNI.\n\n                 This field is only valid if one of mplsTunnelIsUni or\n                 mplsTunnelIsSpc is set, and must be filled in if\n                 mplsTunnelIsSpc is set and the tunnel is bi-directional.')
mplsTunnelUniRvsEgressLabelPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 69), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniRvsEgressLabelPort.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniRvsEgressLabelPort.setDescription('The logical port identifier used to uniquely identify and\n                 select a (reverse) data link at the destination UNI.\n\n                 This port identifier is relative to the destination UNI-C\n                 for UNI-initiated connections, but is relative to the\n                 destination UNI-N for connections that are initiated by\n                 management at the source UNI-N.\n\n                 This field is only valid if one of mplsTunnelIsUni or\n                 mplsTunnelIsSpc is set, and must be filled in if\n                 mplsTunnelIsSpc is set and the tunnel is bi-directional.')
mplsTunnelDeletionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forced", 1), ("graceful", 2))).clone('forced')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDeletionMode.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDeletionMode.setDescription('Whether to use forced or graceful deletion to delete this\n                 LSP.  This field is ignored if graceful deletion is not\n                 allowed in the TE-MIB entity MIB.')
mplsTunnelUniDiversityListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 71), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniDiversityListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniDiversityListIndex.setDescription('UNI specific.  This field references a\n                 prvtMplsTunnelUNIDivListIndex in the\n                 mplsTunnelUNIDiversityTable, and defines this list of\n                 tunnels to be diverse from.  A value of zero indicates\n                 that no diversity is configured.\n\n                 Note that if the diversity requirements specified in the\n                 referenced diversity list cannot be satisfied by\n                 signaling, this tunnel will fail to move to oper_status\n                 up.  See the Description in the\n                 mplsTunnelUNIDiversityTable for more information.')
mplsTunnelDiffServIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 72), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDiffServIndex.setReference('Le Faucher, et. al, MPLS Support of Differentiated\n          Services, Internet Draft <draft-ietf-mpls-diff-\n          ext-09.txt>, April 2001.')
if mibBuilder.loadTexts: mplsTunnelDiffServIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDiffServIndex.setDescription('Index into the mplsDiffServTable entry that\n          specifies the L-LSP or E-LSP parameters to signal\n          when setting up the tunnel.  If this field is not filled\n          in or is assigned the value zero then no DiffServ\n          parameters are signalled.')
mplsTunnelReversePrivateData = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 73), MplsTunnelPrivateDataSyntax()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelReversePrivateData.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelReversePrivateData.setDescription('This object contains the customer defined private data for\n         the reverse signaling direction.  At egress it is\n         initially set by the RRR_EGRESS_TRANSLATE_PRIV_DATA user exit and\n         subsequently may be altered via MIB operations.\n         At ingress it is filled in with the decoded reverse\n         private data.\n         Note that there is a separate MIB field for the forward\n         signaling direction private data, mplsTunnelPrivateData.')
mplsTunnelFastRerouteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noFastReroute", 0), ("detourFastReroute", 1), ("facilityFastReroute", 2))).clone('noFastReroute')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelFastRerouteMode.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelFastRerouteMode.setDescription('Indicates whether or not this tunnel should be protected\n          by a fast reroute mechanism, and if so which method should\n          be used.\n          noFastReroute       - no fast reroute protection.\n          detourFastReroute   - fast reroute protection using the\n                                one-to-one detour backup method.\n          facilityFastReroute - fast reroute protection using the\n                                facility backup method.\n          Fast reroute is only available for uni-directional LSPs.')
mplsTunnelBackupSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 75), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelBackupSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupSetupPrio.setDescription('Setup priority for backup tunnels set up to protect this\n         tunnel.  This field is only valid if the mplsTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsTunnelBackupHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 76), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelBackupHoldingPriority.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupHoldingPriority.setDescription('Holding priority for backup tunnels set up to protect this\n         tunnel.  This field is only valid if the mplsTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsTunnelBackupIncAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 77), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelBackupIncAny.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupIncAny.setDescription('Include-any resource affinity for backup tunnels set up to\n         protect this tunnel.\n         A link satisfies the include-any constraint if and only if\n         the constraint is zero, or the link and the constraint\n         have a resource class in common.\n         This field is only valid if the mplsTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsTunnelBackupIncAll = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 78), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelBackupIncAll.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupIncAll.setDescription('Include-all resource affinity for backup tunnels set up to\n         protect this tunnel.\n         A link satisfies the include-all constraint if and only if\n         the link contains all of the adminstrative groups\n         specified in the constraint.\n         This field is only valid if the mplsTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsTunnelBackupExcAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 79), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelBackupExcAny.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupExcAny.setDescription('Exclude-any resource affinity for backup tunnels set up to\n         protect this tunnel.\n         A link satisfies the exclude-any constraint if and only if\n         the constraint is zero, or the link and the constraint\n         have a resource class in common.\n         This field is only valid if the mplsTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsTunnelBackupBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 80), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelBackupBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupBandwidth.setDescription('The estimated bandwidth required for backup tunnels, in\n         units of 1000 bits/second.  A value of zero indicates\n         best-effort.\n         This field is only valid if the mplsTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsTunnelBackupMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 81), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelBackupMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupMaxHops.setDescription('The maximum number of extra hops the backup path is\n         allowed to take, from a Point of Local Repair (PLR) to a\n         Merge Point (MP), with PLR and MP excluded in counting.\n         A hop-limit of 0 means only direct links between PLR and MP\n         can be used.\n         This field is only valid if the mplsTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsTunnelIsSpc = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 84), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsSpc.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsSpc.setDescription('This flag indicates whether the tunnel is an OIF soft\n        permanent connection (SPC).')
mplsTunnelUniIngressLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 85), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniIngressLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniIngressLabel.setDescription('The label to be used for the in-segment at the source\n                 UNI-N in the forward direction.\n\n                 This field is only valid if the mplsTunnelIsSpc field\n                 is true.')
mplsTunnelUniIngressLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 86), MplsGeneralizedLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniIngressLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniIngressLabelType.setDescription('The C-Type of the forward label to be used for the\n                 in-segment at the source UNI-N.\n\n                 This field is only valid if the mplsTunnelIsSpc field\n                 is true.')
mplsTunnelUniIngressLabelPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 87), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniIngressLabelPort.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniIngressLabelPort.setDescription('The logical port identifier used to uniquely identify and\n                 select a (forward) data link for the in-segment at the\n                 source UNI-N.\n\n                 This field is only valid if the mplsTunnelIsSpc field\n                 is true.')
mplsTunnelUniRvsIngrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 88), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniRvsIngrLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniRvsIngrLabel.setDescription('The label to be used at the source UNI-N for the\n                 out-segment in the reverse direction.\n\n                 This field is only valid if the mplsTunnelIsSpc field\n                 is true.')
mplsTunnelUniRvsIngrLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 89), MplsGeneralizedLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniRvsIngrLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniRvsIngrLabelType.setDescription('The C-Type of the reverse label to be used for the\n                 out-segment at the source UNI-N.\n\n                 This field is only valid if the mplsTunnelIsSpc field\n                 is true.')
mplsTunnelUniRvsIngrLabelPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 90), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelUniRvsIngrLabelPort.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniRvsIngrLabelPort.setDescription('The logical port identifier used to uniquely identify and\n                 select a data link for the reverse out-segment at the\n                 source UNI-N.\n\n                 This field is only valid if the mplsTunnelIsSpc field\n                 is true.')
mplsTunnelDiffServClassType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 91), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDiffServClassType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDiffServClassType.setDescription('DiffServ Class-Type of the LSP as defined in\n                  draft-ietf-tewg-diff-te-proto-03.')
mplsTunnelExtendedProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 92), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelExtendedProtection.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelExtendedProtection.setDescription('Indicates that the requested LSP should use the extended PROTECTION\n        object as defined in draft-lang-ccamp-gmpls-recovery-e2e-signaling.\n        This is a GMPLS feature, and should only be used when GMPLS will\n        be used for this LSP.')
mplsTunnelProtecting = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 93), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelProtecting.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelProtecting.setDescription('Indicates that the requested LSP is a protecting LSP and not a\n        working LSP.\n        This field is only valid if mplsTunnelExtendedProtection is true.')
mplsTunnelNotification = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 94), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelNotification.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelNotification.setDescription('Indicates that the control plane message exchange is only used for\n        notification during protection switching.\n        This field is only valid if mplsTunnelExtendedProtection is true.')
mplsTunnelLspProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 95), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLspProtection.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLspProtection.setDescription('This field indicates the level of end-to-end protection\n        for this LSP.\n        This field is only valid if mplsTunnelExtendedProtection is true.\n        A value  of zero indicates that no protection is provided for the\n        tunnel.\n\n        This field is not a bitmask; only one LSP protection may be selected.\n        See draft-lang-ccamp-gmpls-recovery-e2e-signaling for a\n        description of the possible values.')
mplsTunnelAssociatedLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 96), MplsTunnelInstanceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAssociatedLspId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAssociatedLspId.setDescription('The mplsTunnelInstance of an associated tunnel between the\n        same ingress and egress and with the same mplsTunnelIndex.\n        If this field is zero, the associated LSP ID is not known,\n        or there are multiple.\n        This field is only valid if mplsTunnelExtendedProtection is true.')
mplsTunnelCallIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 97), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operatorSpecific", 1), ("globallyUnique", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCallIdType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCallIdType.setDescription('The C-Type of the following CALL ID.  This field is\n        insignificant if the mplsTunnelCallId has zero length.\n        This field can only be changed when the Admin Status is down.')
mplsTunnelCallId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 98), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCallId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCallId.setDescription('The CALL ID to be used on this tunnel, including the\n        address type, International and National segment (if applicable),\n        source transport network element address, and Local\n        Identifier as defined in G.7713.2 (version 0.8).\n        This field can only be changed when the Admin Status is down.')
mplsTunnelIsIpv6 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 100), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsIpv6.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIpv6.setDescription('Flag indicating whether this tunnel uses IPv6 addresses.\n        If this flag is set, the tunnel may only be activated if\n        - TE-MIB is configured to allow IPv6 tunnels\n        - the hop path index is non-zero\n        - all hops in the hop path have IPv6 addresses\n        - the first and last hops in the hop path have global\n          scope addresses.')
mplsTunnelMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 103), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelMtu.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelMtu.setDescription('Maximal transfer unit of the tunnel')
mplsTunnelRebuildTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 104), TimeTicks().clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRebuildTimer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRebuildTimer.setDescription('Defines a period in minutes (0..1440), after which the tunnel will be unconditionally\n        rebuild. The maximal valid value is 1440 minutes (24 hours)')
mplsTunnelOperStatusFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 105), Bits().clone(namedValues=NamedValues(("empty", 0), ("tunnelResignalling", 1), ("tunnelSuppressed", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelOperStatusFlags.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOperStatusFlags.setDescription('Flags to extend the information of the tunnel state\nFor the behaviour - bits meaning:\ntunnelResignalling (1) - This status shows that currently the tunnel \nhas been resignalled. The resignalling state of a tunnel \nshould be considered together with the mplsTunnelOperStatus \nattribute value of the same tunnel.\ntunnelSuppressed (2) - This status shows that the tunnel has \nbeen established, but higher priority tunnel is active \nand in use. This tunnel can be activated, once the higher \nprotocol tunnel fails by any reason, and in this case \nthe tunnelSuppressed status will be cleared.\n\t\t ')
mplsTunnelGuardedDest = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 106), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelGuardedDest.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelGuardedDest.setDescription('The guarded destination object specifies which IP destination address the current\n        tunnel protects used with the fast reroute feature.\n       The tunnel must not be fast reroute enabled.')
mplsTunnelMBBTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 2, 1, 107), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelMBBTimeOut.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelMBBTimeOut.setDescription('Specifies the timer configuration (in minutes) for Make-before-break (MBB).\n        The default value of this object is 10 minutes.')
mplsTunnelHopIndexNextTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 3), )
if mibBuilder.loadTexts: mplsTunnelHopIndexNextTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndexNextTable.setDescription('This table contains the next available values of\n        mplsTunnelHopIndex for all entities.')
mplsTunnelHopIndexNextEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 3, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: mplsTunnelHopIndexNextEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndexNextEntry.setDescription('An entry in this table represents the next available\n        mplsTunnelHopIndex for a specific TE-MIB entity.\n        This MIB table is indexed by the PRVT-TE-MIB entity Index.')
mplsTunnelHopIndexNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelHopIndexNextIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndexNextIndex.setDescription('This object contains an appropriate value to be used\n          for mplsTunnelHopListIndex when creating entries in\n          the mplsTunnelHopTable.  If the number of\n          unassigned entries is exhausted, a retrival\n          operation will return a value of 0.  This object\n          may also return a value of 0 when the LSR is unable\n          to accept conceptual row creation, for example, if\n          the mplsTunnelHopTable is implemented as read-only.\n          To obtain the value of mplsTunnelHopListIndex for a\n          new entry in the mplsTunnelHopTable, the manager\n          issues a management protocol retrieval operation to\n          obtain the current value of mplsTunnelHopIndex.\n          After each retrieval operation, the agent should\n          modify the value to reflect the next unassigned\n          index.  After a manager retrieves a value the agent\n          will determine through its local policy when this\n          index value will be made available for reuse.')
mplsTunnelHopTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4), )
if mibBuilder.loadTexts: mplsTunnelHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTable.setDescription('The mplsTunnelHopTable is used to indicate the hops,\n          strict or loose, for an MPLS tunnel defined in\n          mplsTunnelTable, when it is established via\n          signaling, for the outgoing direction of the\n          tunnel.  Each row in this table is indexed by\n          mplsTunnelHopListIndex.  Each row also has a\n          secondary index mplsTunnelHopIndex corresponding to\n          the next hop that this row corresponds to.  The\n          first row in the table is the first hop after the\n          origination point of the tunnel.  In case we want\n          to specify a particular interface on the\n          originating LSR of an outgoing tunnel by which we\n          want packets to exit the LSR, we specify this as\n          the first hop for this tunnel in\n          mplsTunnelHopTable.')
mplsTunnelHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelHopListIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelHopPathOptionIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelHopIndex"))
if mibBuilder.loadTexts: mplsTunnelHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopEntry.setDescription('An entry in this table represents a tunnel hop.  An\n          entry is created by a network administrator for\n          signaled ERLSP set up by an MPLS signaling\n          protocol.')
mplsTunnelHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setDescription('Primary index into this table identifying a\n          particular explicit route object.')
mplsTunnelHopPathOptionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelHopPathOptionIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopPathOptionIndex.setDescription('Secondary index into this table identifying a\n          particular group of hops representing a particular\n          configured path. This is otherwise known as a path\n          option.')
mplsTunnelHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 3), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndex.setDescription('Secondary index into this table identifying a\n          particular hop.')
mplsTunnelHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 4), TeHopAddressType().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setDescription("The Hop Address Type of this tunnel hop.\n\n                  The value of this object cannot be changed\n                  if the value of the corresponding\n                  mplsTunnelHopRowStatus object is 'active'.\n\n                  Note that lspid(5) is a valid option only\n                  for tunnels signaled via CRLDP.\n                 ")
mplsTunnelHopIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 5), TeHopAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpAddr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpAddr.setDescription("The Tunnel Hop Address for this tunnel hop.\n\n                  The type of this address is determined by the\n                  value of the corresponding mplsTunnelHopAddrType.\n\n                  The value of this object cannot be changed\n                  if the value of the corresponding\n                  mplsTunnelHopRowStatus object is 'active'.\n                 ")
mplsTunnelHopIpPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 6), Unsigned32().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpPrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpPrefixLen.setDescription('If mplsTunnelHopAddrType is set to ipv4(1) or\n                  ipv6(2), then this value will contain an\n                  appropriate prefix length for the IP address in\n                  object mplsTunnelHopIpAddr. Otherwise this value\n                  is irrelevant and should be ignored.\n                 ')
mplsTunnelHopAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 7), TeHopAddressAS()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setDescription('If mplsTunnelHopAddrType is set to asnumber(3), then\n          this value will contain the AS number of this hop.\n          Otherwise the agent should set this object to zero-\n          length string and the manager should ignore this.')
mplsTunnelHopAddrUnnum = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 8), TeHopAddressUnnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAddrUnnum.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAddrUnnum.setDescription('If mplsTunnelHopAddrType is set to unnum(4) or\n          unnumv6(6), then this value will contain the interface\n          identifier of the unnumbered interface for this hop.\n          This object should be used in conjunction with\n          mplsTunnelHopIpAddress which would contain the LSR\n          Router ID in this case. Otherwise the agent should\n          set this object to zero-length string and the\n          manager should ignore this.')
mplsTunnelHopLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 9), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopLspId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopLspId.setDescription('If mplsTunnelHopAddrType is set to lspid(5), then\n          this value will contain the LSPID of a tunnel of\n          this hop. The present tunnel being configured is\n          tunneled through this hop (using label stacking).\n          This object is otherwise insignificant and should\n          contain a value of 0 to indicate this fact.')
mplsTunnelHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2))).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopType.setDescription("Denotes whether this tunnel hop is routed in a\n          strict or loose fashion. The value of this object\n          has no meaning if the mplsTunnelHopInclude object\n          is set to 'false'.")
mplsTunnelHopInclude = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 11), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopInclude.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopInclude.setDescription("If this value is set to true, then this indicates\n          that this hop must be included in the tunnel's\n          path. If this value is set to 'false', then this hop\n          must be avoided when calculating the path for this\n          tunnel. The default value of this object is 'true',\n          so that by default all indicated hops are included\n          in the CSPF path computation. If this object is set\n          to 'false' the value of mplsTunnelHopType should be\n          ignored.")
mplsTunnelHopPathOptionName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 12), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopPathOptionName.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopPathOptionName.setDescription('The description of this series of hops as they\n          relate to the specified path option. The\n          value of this object SHOULD be the same for\n          each hop in the series that comprises a\n          path option.')
mplsTunnelHopEntryPathComp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("explicit", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopEntryPathComp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopEntryPathComp.setDescription('If this value is set to dynamic, then the user\n          should only specify the source and destination of\n          the path and expect that the CSPF will calculate\n          the remainder of the path.  If this value is set to\n          explicit, the user should specify the entire path\n          for the tunnel to take.  This path may contain\n          strict or loose hops.  Each hop along a specific\n          path SHOULD have this object set to the same value.')
mplsTunnelHopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setDescription('This variable is used to create, modify, and/or\n          delete a row in this table.  When a row in this\n          table is in active(1) state, no objects in that row\n          can be modified by the agent except\n          mplsTunnelHopRowStatus and\n          mplsTunnelHopStorageType.')
mplsTunnelHopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 15), StorageType().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setDescription("The storage type for this Hop entry. Conceptual\n         rows having the value 'permanent' need not\n         allow write-access to any columnar objects\n         in the row.")
mplsTunnelHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 16), Bits().clone(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelHopLabelStatuses.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopLabelStatuses.setDescription('This bitmask indicates the presence of labels indicated by the\n      mplsTunnelHopExpLabel and mplsTunnelHopExpRvrsLabel\n      objects.\n\n      For the Present bits, a set bit indicates that a label is\n      present for this hop in the route. This allows zero to be a\n      valid label value.')
mplsTunnelHopExpLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 17), MplsGeneralizedLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopExpLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopExpLabelType.setDescription('Denotes   the  type  of  the  label  configured  in\n        mplsTunnelHopExpLabel.')
mplsTunnelHopExpLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 18), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopExpLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopExpLabel.setDescription('If mplsTunnelHopLabelStatuses object indicates that a forward\n      label is present then the label to use on this hop is found in\n      this object.')
mplsTunnelHopExpRvrsLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 19), MplsGeneralizedLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopExpRvrsLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopExpRvrsLabelType.setDescription('Denotes   the  type  of  the  label  configured  in\n        mplsTunnelHopExpRvrsLabel.')
mplsTunnelHopExpRvrsLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 4, 1, 20), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopExpRvrsLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopExpRvrsLabel.setDescription('If the mplsTunnelHopLabelStatuses object indicates that a\n      reverse label is present then the label to use on this\n      hop is found in this object.')
mplsTunnelResourceIndexNextTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 5), )
if mibBuilder.loadTexts: mplsTunnelResourceIndexNextTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndexNextTable.setDescription('This table contains the next available values of\n        mplsTunnelResourceIndex for all entities.')
mplsTunnelResourceIndexNextEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 5, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: mplsTunnelResourceIndexNextEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndexNextEntry.setDescription('An entry in this table represents the next available\n        mplsTunnelResourceIndex for a specific TE-MIB entity.\n        This MIB table is indexed by the PRVT-TE-MIB entity Index.')
mplsTunnelResourceIndexNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelResourceIndexNextIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndexNextIndex.setDescription('This object contains the next appropriate value to\n          be used for mplsTunnelResourceIndex when creating\n          entries in the mplsTunnelResourceTable. If the\n          number of unassigned entries is exhausted, a\n          retrival operation will return a value of 0.  This\n          object may also return a value of 0 when the LSR is\n          unable to accept conceptual row creation, for\n          example, if the mplsTunnelTable is implemented as\n          read-only.  To obtain the mplsTunnelResourceIndex\n          value for a new entry, the manager must first issue\n          a management protocol retrieval operation to obtain\n          the current value of this object. The agent should\n          modify the value to reflect the next unassigned\n          index after each retrieval operation. After a\n          manager retrieves a value the agent will determine\n          through its local policy when this index value will\n          be made available for reuse.')
mplsTunnelResourceTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6), )
if mibBuilder.loadTexts: mplsTunnelResourceTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceTable.setDescription('The mplsTunnelResourceTable allows a manager to\n          specify which resources are desired for an MPLS\n          tunnel.  This table also allows several tunnels to\n          point to a single entry in this table, implying\n          that these tunnels should share resources.')
mplsTunnelResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setDescription('An entry in this table represents a set of resources\n          for an MPLS tunnel.  An entry can be created by a\n          network administrator or by an SNMP agent as\n          instructed by any MPLS signaling protocol.')
mplsTunnelResourceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setDescription('Uniquely identifies this row.')
mplsTunnelResourceMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 2), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setDescription('The maximum rate in units of 1000 bits/second.\n\n         Note that setting mplsTunnelResourceMaxRate,\n          mplsTunnelResourceMeanRate, and\n          mplsTunnelResourceMaxBurstSize to 0 indicates best-effort\n          treatment.  This object is copied to an instance of\n          mplsTrafficParamMaxRate in mplsTrafficParamTable the OID\n          of which is copied into the corresponding\n          mplsInSegmentTrafficParamPtr.\n\n         If the ingress node sets a maximum rate of positive\n          infinity, the egress node will return a value of\n          positive infinity on the MIB GET response.  This\n          special value may not be used when setting the maximum\n          rate with this MIB.')
mplsTunnelResourceMeanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 3), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setDescription('The mean rate in units of 1000 bits/second.\n\n         This object is copied into an instance of\n          mplsTrafficParamMeanRate in the\n          mplsTrafficParamTable. The OID of this table entry\n          is then copied into the corresponding\n          mplsInSegmentTrafficParamPtr.\n\n         When resource allocation is performed as requested\n          by this TSpec object, it is copied into an entry in\n          mplsTrafficParamTable [LSRMIB]:\n          mplsTunnelInMeanRate to mplsTrafficParamMeanRate.\n          The OID of this entry is copied to\n          mplsInSegmentTrafficParamPtr of the corresponding\n          in-segment entry.')
mplsTunnelResourceMaxBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setDescription('The maximum burst size in bytes.  This object is\n          copied to mplsInSegmentMaxBurstSize of the\n          corresponding in-segment.\n\n         When resource allocation is performed as requested\n          by this TSpec object, it is copied into an entry in\n          mplsTrafficParamTable [LSRMIB]:\n          mplsTunnelInMaxBurstSize to\n          mplsTrafficParamMaxBurstSize. The OID of this entry\n          is copied to mplsInSegmentTrafficParamPtr of the\n          corresponding in-segment entry.')
mplsTunnelResourceMeanBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 5), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMeanBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMeanBurstSize.setDescription('The mean burst size in bytes.  The implementations\n          which do not implement this variable must return 0\n          for this value and must not allow a user to set\n          this value.')
mplsTunnelResourceExBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 6), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceExBurstSize.setReference('CR-LDP Specification, Section 4.3.')
if mibBuilder.loadTexts: mplsTunnelResourceExBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceExBurstSize.setDescription('The Excess burst size in bytes.  The implementations\n          which do not implement this variable must return\n          noSuchObject(0) exception for this object and must\n          not allow a user to set this value.')
mplsTunnelResourceFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 1), ("frequent", 2), ("veryFrequent", 3))).clone('unspecified')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceFrequency.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceFrequency.setDescription('The granularity of the availability of committed\n          rate.  The implementations which do not implement\n          this variable must return unspecified(1) for this\n          value and must not allow a user to set this value.')
mplsTunnelResourceWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceWeight.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceWeight.setDescription('The relative weight for using excess bandwidth above\n          its committed rate.  The value of 0 means that\n          weight is not applicable for the CR-LSP.')
mplsTunnelResourceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setDescription('This variable is used to create, modify, and/or\n          delete a row in this table.')
mplsTunnelResourceStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 6, 1, 10), StorageType().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setDescription('This variable indicates the storage type for this\n          object.')
mplsTunnelARHopTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7), )
if mibBuilder.loadTexts: mplsTunnelARHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTable.setDescription('The mplsTunnelARHopTable is used to indicate the\n          hops, strict or loose, for an MPLS tunnel defined\n          in mplsTunnelTable, as reported by the MPLS\n          signaling protocol, for the outgoing direction of\n          the tunnel.  Each row in this table is indexed by\n          mplsTunnelARHopListIndex.  Each row also has a\n          secondary index mplsTunnelARHopIndex, corresponding\n          to the next hop that this row corresponds to.  The\n          first row in the table is the first hop after the\n          origination point of the tunnel.  In case we want\n          to specify a particular interface on the\n          originating LSR of an outgoing tunnel by which we\n          want packets to exit the LSR, we specify this as\n          the first hop for this tunnel in\n          mplsTunnelARHopTable.\n\n         Please note that since the information necessary to\n          build entries within this table are not provided by\n          some MPLS signaling protocols, implementation of\n          this table is optional. Furthermore, since the\n          information in this table is actually provided by\n          the MPLS signaling protocol after the path has been\n          set-up, the entries in this table are provided only\n          for observation, and hence, all variables in this\n          table are accessible exclusively as read-only.')
mplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelARHopListIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setDescription('An entry in this table represents a tunnel hop.  An\n          entry is created by a network administrator for\n          signaled ERLSP set up by an MPLS signaling\n          protocol.')
mplsTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setDescription('Primary index into this table identifying a\n          particular recorded hop list.')
mplsTunnelARHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setDescription('Secondary index into this table identifying the\n          particular hop.')
mplsTunnelARHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 3), TeHopAddressType().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setDescription('The Hop Address Type of this tunnel hop.\n\n         If the type value is set to ipv4(1) or ipv6(2). The tunnel path \n         can be determin using mplsTunnelARHopIpAddr object.  \n         mplsTunnelARHopAddrUnnum and mplsTunnelARHopLspId \n         should not be used.\n         \n         If the type value is set to unnum(4) or unnumv6(6). The tunnel path \n         can be determin using mplsTunnelARHopAddrUnnum object.  \n         mplsTunnelARHopIpAddr and mplsTunnelARHopLspId \n         should not be used.\n\n         Note that lspid(5) is a valid option only\n         for tunnels signaled via CRLDP. The tunnel path \n         can be determin using mplsTunnelARHopLspId object.  \n         mplsTunnelARHopIpAddr and mplsTunnelARHopAddrUnnum \n         should not be used.\n         \n         Currently only ipv4(1) type is supported')
mplsTunnelARHopIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 4), TeHopAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpAddr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpAddr.setDescription('The Tunnel Hop Address for this tunnel hop.\n\n         The type of this address is determined by the\n         value of the corresponding mplsTunnelARHopAddrType.\n         If mplsTunnelARHopAddrType is set to ipv4(1) or\n         ipv6(2), then this value contains the LSR Router\n         ID of the unnumbered interface. Otherwise the agent\n         SHOULD set this object to the zero-length string\n         and the manager should ignore this object.')
mplsTunnelARHopAddrUnnum = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 5), TeHopAddressUnnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrUnnum.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAddrUnnum.setDescription('If mplsTunnelARHopAddrType is set to unnum(4) or\n         unnumv6(6), then this value will contain the\n         interface identifier of the unnumbered interface\n         for this hop. This object should be used in\n         conjunction with mplsTunnelARHopIpAddr which would\n         contain the LSR Router ID in this case. Otherwise\n         the agent should set this object to zero-length\n         string and the manager should ignore this.')
mplsTunnelARHopLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 6), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopLspId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopLspId.setDescription('If mplsTunnelARHopAddrType is set to lspid(5), then\n          this value will contain the LSP ID of this hop.\n          This object is otherwise insignificant and should\n          contain a value of 0 to indicate this fact.')
mplsTunnelARHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 7), Bits().clone(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1), ("forwardGlobal", 2), ("reverseGlobal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopLabelStatuses.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopLabelStatuses.setDescription('This bitmask indicates the presence and status of labels\n      indicated by the mplsTunnelARHopExpLabel and\n      mplsTunnelARHopExpRvrsLabel objects.\n\n      For the Present bits, a set bit indicates that a label is\n      present for this hop in the route. For the Global bits, a set\n      bit indicates that the label comes from the Global Label Space.\n      A clear bit indicates that this is a Per- Interface label. A\n      Global bit only has meaning if the corresponding Present bit is\n                         set.')
mplsTunnelARHopExpLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 8), MplsGeneralizedLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopExpLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopExpLabelType.setDescription('The C-Type of the following hop label.  This field is\n        insignificant unless mplsTunnelARHopLabelStatuses has the\n        forwardPresent(0) or forwardGlobal(2) bits set.')
mplsTunnelARHopExpLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 9), MplsGeneralizedLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopExpLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopExpLabel.setDescription('If mplsTunnelARHopLabelStatus has the present(0) bit set,\n      then this value indicates the label value used for this hop.\n      This object is otherwise insignificant and should\n      contain a value of 0.\n\n      When this label is read from a signaling protocol message,\n      it is copied byte for byte as is.  Therefore, if the label\n      octet string is understood to represent multibyte values,\n      it encodes those values in network (big-endian) byte\n      order.  This interpretation applies in particular to the\n      non-generalized MPLS labels (32 bits) used in ATM, FR and\n      generic MPLS networks.')
mplsTunnelARHopExpRvrsLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 10), MplsGeneralizedLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopExpRvrsLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopExpRvrsLabelType.setDescription('The C-Type of the following hop label.  This field is\n        insignificant unless mplsTunnelARHopLabelStatuses has the\n        reversePresent(1) or reverseGlobal(3) bits set.')
mplsTunnelARHopExpRvrsLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 11), MplsGeneralizedLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopExpRvrsLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopExpRvrsLabel.setDescription('If the mplsTunnelARHopLabelStatuses object indicates that a\n      reverse label is present then the label in use on this\n      hop is found in this object.')
mplsTunnelARHopProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 7, 1, 12), Bits().clone(namedValues=NamedValues(("localAvailable", 0), ("localInUse", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopProtection.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopProtection.setDescription('Availability and usage of protection on the reported link.\n\n     localAvailable\n        Indicates that the link downstream of this node is protected\n        via a local repair mechanism.\n\n     localInUse\n        Indicates that a local repair mechanism is in use to maintain\n        this tunnel (usually in the face of an outage of the link it\n        was previously routed over).')
mplsTunnelCHopTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8), )
if mibBuilder.loadTexts: mplsTunnelCHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopTable.setDescription('The mplsTunnelCHopTable is used to indicate the\n          hops, strict or loose, for an MPLS tunnel defined\n          in mplsTunnelTable, as computed by a constraint-\n          based routing protocol, based on the\n          mplsTunnelHopTable for the outgoing direction of\n          the tunnel.  Each row in this table is indexed by\n          mplsTunnelCHopListIndex.  Each row also has a\n          secondary index mplsTunnelCHopIndex, corresponding\n          to the next hop that this row corresponds to.  The\n          first row in the table is the first hop after the\n          origination point of the tunnel.  In case we want\n          to specify a particular interface on the\n          originating LSR of an outgoing tunnel by which we\n          want packets to exit the LSR, we specify this as\n          the first hop for this tunnel in\n          mplsTunnelCHopTable.\n\n         Please note that since the information necessary to\n          build entries within this table may not be\n          supported by some LSRs, implementation of this\n          table is optional. Furthermore, since the\n          information in this table is actually provided by\n          routing protocol after the path has been computed,\n          the entries in this table are provided only for\n          observation, and hence, all variables in this table\n          are accessible exclusively as read-only.')
mplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelCHopListIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelCHopIndex"))
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setDescription('An entry in this table represents a tunnel hop.  An\n          entry in this table is created by a constraint-\n          based routing protocol based on the hops specified\n          in the corresponding mplsTunnelHopTable.')
mplsTunnelCHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setDescription('Primary index into this table identifying a\n          particular computed hop list.')
mplsTunnelCHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setDescription('Secondary index into this table identifying the\n          particular hop.')
mplsTunnelCHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 3), TeHopAddressType().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setDescription('The Hop Address Type of this tunnel hop.\n\n         Note that lspid(5) is a valid option only\n         for tunnels signaled via CRLDP.')
mplsTunnelCHopIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 4), TeHopAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpAddr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpAddr.setDescription('The Tunnel Hop Address for this tunnel hop.\n\n         The type of this address is determined by the\n          value of the corresponding mplsTunnelCHopAddrType.\n\n         If mplsTunnelCHopAddrType is set to unnum(4) or\n         unnumv6(6), then this value will contain the LSR\n         Router ID of the unnumbered interface. Otherwise\n         the agent should set this object to the zero-length\n         string and the manager SHOULD ignore this object.')
mplsTunnelCHopIpPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 5), Unsigned32().clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpPrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpPrefixLen.setDescription('If mplsTunnelCHopAddrType is set to ipv4(1) or\n           ipv6(2), then this value will contain an\n           appropriate prefix length for the IP address in\n           object mplsTunnelCHopIpAddr. Otherwise this value\n           is irrelevant and should be ignored.\n          ')
mplsTunnelCHopAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 6), TeHopAddressAS()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAsNumber.setDescription('If mplsTunnelCHopAddrType is set to asnumber(3),\n          then this value will contain the AS number of this\n          hop. Otherwise the agent should set this object to\n          zero-length string and the manager should ignore\n          this.')
mplsTunnelCHopAddrUnnum = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 7), TeHopAddressUnnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAddrUnnum.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAddrUnnum.setDescription('If mplsTunnelCHopAddrType is set to unnum(4) or\n          unnumv6(6), then this value will contain the unnumbered\n          interface identifier of this hop. This object should\n          be used in conjunction with mplsTunnelCHopIpAddr\n          which would contain the LSR Router ID in this case.\n          Otherwise the agent should set this object to zero-\n          length string and the manager should ignore this.')
mplsTunnelCHopLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 8), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopLspId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopLspId.setDescription('If mplsTunnelCHopAddrType is set to lspid(5), then\n          this value will contain the LSP ID of this hop.\n          This object is otherwise insignificant and should\n          contain a value of 0 to indicate this fact.')
mplsTunnelCHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopType.setDescription('Denotes whether this is tunnel hop is routed in a\n          strict or loose fashion.')
mplsTunnelCHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 11), Bits().clone(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopLabelStatuses.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopLabelStatuses.setDescription('This bitmask indicates the presence of labels indicated by the\n      mplsTunnelCHopExpLabel and mplsTunnelCHopExpRvrsLabel\n      objects.\n      A set bit indicates that a label is present for this hop in the\n      route thus allowing zero to be a valid label value.')
mplsTunnelCHopExpLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 12), MplsGeneralizedLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopExpLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopExpLabelType.setDescription('The C-Type of the following hop label. This field is\n        insignificant unless mplsTunnelCHopLabelStatuses has the\n        forwardPresent(0) bit set.')
mplsTunnelCHopExpLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 13), MplsGeneralizedLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopExpLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopExpLabel.setDescription('The  explicit  out-segment  label  to  use  on  the\n        forward path.\n\n        When this label is used in signaling protocol messages,\n        it is copied byte for byte as is.  Therefore, if the label\n        octet string is intended to represent multibyte values, it\n        should encode those values in network (big-endian) byte\n        order.  This interpretation applies in particular to the\n        non-generalized MPLS labels (32 bits) used in ATM, FR and\n        generic MPLS networks.')
mplsTunnelCHopExpRvrsLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 14), MplsGeneralizedLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopExpRvrsLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopExpRvrsLabelType.setDescription('The C-Type of the following hop label.  This field is\n         insignificant unless mplsTunnelCHopLabelStatuses has the\n         reversePresent(0) bit set.')
mplsTunnelCHopExpRvrsLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 8, 1, 15), MplsGeneralizedLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCHopExpRvrsLabel.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopExpRvrsLabel.setDescription('The   explicit  in-segment  label  to  use  on  the\n        reverse path.\n\n        When this label is used in signaling protocol messages,\n        it is copied byte for byte as is.  Therefore, if the label\n        octet string is intended to represent multibyte values, it\n        should encode those values in network (big-endian) byte\n        order.  This interpretation applies in particular to the\n        non-generalized MPLS labels (32 bits) used in ATM, FR and\n        generic MPLS networks.')
mplsTunnelPerfTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 9), )
if mibBuilder.loadTexts: mplsTunnelPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfTable.setDescription('This table provides per-tunnel MPLS performance\n          information.')
mplsTunnelPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 9, 1), )
mplsTunnelEntry.registerAugmentions(("PRVT-MPLS-TE-MIB", "mplsTunnelPerfEntry"))
mplsTunnelPerfEntry.setIndexNames(*mplsTunnelEntry.getIndexNames())
if mibBuilder.loadTexts: mplsTunnelPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfEntry.setDescription('An entry in this table is created by the LSR for\n          every tunnel.  Its is an extension to\n          mplsTunnelEntry.')
mplsTunnelPerfPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfPackets.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfPackets.setDescription('Number of packets forwarded by the tunnel.')
mplsTunnelPerfHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 9, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCPackets.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfHCPackets.setDescription('High capacity counter for number of packets\n          forwarded by the tunnel.')
mplsTunnelPerfErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfErrors.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfErrors.setDescription('Number of errored packets.')
mplsTunnelPerfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfBytes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfBytes.setDescription('Number of bytes forwarded by the tunnel.')
mplsTunnelPerfHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 9, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCBytes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfHCBytes.setDescription('High capacity counter for number of bytes forwarded\n          by the tunnel.')
mplsTunnelCRLDPResTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10), )
if mibBuilder.loadTexts: mplsTunnelCRLDPResTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResTable.setDescription('The mplsTunnelCRLDPResTable allows a manager to\n          specify which CR-LDP-specific resources are desired\n          for an MPLS tunnel if that tunnel is signaled using\n          CR-LDP. Note that these attributes are in addition\n          to those specified in mplsTunnelResourceTable. This\n          table also allows several tunnels to point to a\n          single entry in this table, implying that these\n          tunnels should share resources.')
mplsTunnelCRLDPResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelCRLDPResEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResEntry.setDescription('An entry in this table represents a set of resources\n          for an MPLS tunnel established using CRLDP\n          (mplsTunnelSignallingProto equal to crldp (3)). An\n          entry can be created by a network administrator or\n          by an SNMP agent as instructed by any MPLS\n          signaling protocol.')
mplsTunnelCRLDPResMeanBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1, 2), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResMeanBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResMeanBurstSize.setDescription('The mean burst size in bytes.')
mplsTunnelCRLDPResExBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1, 3), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResExBurstSize.setReference('CR-LDP Specification, Section 4.3.')
if mibBuilder.loadTexts: mplsTunnelCRLDPResExBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResExBurstSize.setDescription('The Excess burst size in bytes.')
mplsTunnelCRLDPResFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 1), ("frequent", 2), ("veryFrequent", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResFrequency.setReference('CR-LDP Specification, Section 4.3.')
if mibBuilder.loadTexts: mplsTunnelCRLDPResFrequency.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResFrequency.setDescription('The granularity of the availability of committed\n          rate.')
mplsTunnelCRLDPResWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResWeight.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResWeight.setDescription('The relative weight for using excess bandwidth above\n          its committed rate.  The value of 0 means that\n          weight is not applicable for the CR-LSP.')
mplsTunnelCRLDPResFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResFlags.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResFlags.setDescription('The value of the 1 byte Flags conveyed as part of\n          the traffic parameters during the establishment of\n          the CRLSP. The bits in this object are to be\n          interpreted as follows.\n\n          +==+==+==+==+==+==+==+==+\n          | Res |F6|F5|F4|F3|F2|F1|\n          +==+==+==+==+==+==+==+==+\n\n        Res - These bits are reserved. Zero on transmission.\n          Ignored on receipt.\n        F1 - Corresponds to the PDR.\n        F2 - Corresponds to the PBS.\n        F3 - Corresponds to the CDR.\n        F4 - Corresponds to the CBS.\n        F5 - Corresponds to the EBS.\n        F6 - Corresponds to the Weight.\n\n        Each flag if is a Negotiable Flag corresponding to a\n          Traffic Parameter. The Negotiable Flag value zero\n          denotes Not Negotiable and value one denotes\n          Negotiable.')
mplsTunnelCRLDPResRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResRowStatus.setDescription('This variable is used to create, modify, and/or\n          delete a row in this table.')
mplsTunnelCRLDPResStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 10, 1, 8), StorageType().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResStorageType.setDescription('This variable indicates the storage type for this\n          object.')
mplsDiffServIndexNextTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 11), )
if mibBuilder.loadTexts: mplsDiffServIndexNextTable.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServIndexNextTable.setDescription('This table contains the next available values of\n        mplsDiffServIndex for all entities.')
mplsDiffServIndexNextEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 11, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: mplsDiffServIndexNextEntry.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServIndexNextEntry.setDescription('An entry in this table represents the next available\n         mplsDiffServIndex for a specific TE-MIB entity.\n         This MIB table is indexed by the PRVT-TE-MIB entity\n         Index.')
mplsDiffServIndexNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDiffServIndexNextIndex.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServIndexNextIndex.setDescription('This object contains the next appropriate value\n         to be used for mplsDiffServIndex when creating\n         entries in the mplsDiffServTable. If the number of\n         unassigned entries is exhausted, this object\n         will take on the value of 0.  To obtain the\n         mplsDiffServIndex value for a new entry, the\n         manager must first issue a management protocol\n         retrieval operation to obtain the current value\n         of this object. The agent should modify the\n         value to reflect the next unassigned index after\n         each retrieval operation. After a manager\n         retrieves a value the agent will determine\n         through its local policy when this index value\n         will be made available for reuse.')
mplsDiffServTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12), )
if mibBuilder.loadTexts: mplsDiffServTable.setReference('Le Faucher, et. al, MPLS Support of Differentiated\n          Services, Internet Draft <draft-ietf-mpls-diff-\n          ext-09.txt>, April 2001.')
if mibBuilder.loadTexts: mplsDiffServTable.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServTable.setDescription('The mplsDiffServTable allows DiffServ parameters to be\n          configured for DiffServ enabled LSPs signalled by the\n          mplsTunnelTable.\n\n        If a tunnel is an E-LSP, then fields in this table must be\n          set to indicate 0 - 8 EXP->PHB maps, and the number\n          of such maps, to be used by LSRs in the E-LSP to\n          determine the PHB to apply to incoming packets.\n\n        If a tunnel is an L-LSP, then fields in this table must be\n          set to indicate the PHB Scheduling Class (PSC) to use\n          for incoming packets.')
mplsDiffServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsDiffServIndex"))
if mibBuilder.loadTexts: mplsDiffServEntry.setReference('Le Faucher, et. al, MPLS Support of Differentiated\n          Services, Internet Draft <draft-ietf-mpls-diff-\n          ext-09.txt>, April 2001.')
if mibBuilder.loadTexts: mplsDiffServEntry.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServEntry.setDescription('An entry in this table represents either a set of 0 -\n          8 EXP->PHB maps, and the number of such maps, for an\n          E-LSP or a PSC value for an L-LSP.')
mplsDiffServIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsDiffServIndex.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServIndex.setDescription('Uniquely identifies this row.')
mplsDiffServType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("elsp", 0), ("llsp", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServType.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServType.setDescription('This field must be set to indicate whether this row\n          contains parameters for an E-LSP or an L-LSP.')
mplsDiffServLLSPPSC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServLLSPPSC.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServLLSPPSC.setDescription('Valid only when mplsDiffServType takes the value l-lsp\n          (1), this field contains the16-bit encoding of the\n          PHB Scheduling Class (PSC) to be used for packets on\n          this LSP (RFC 3140).')
mplsDiffServELSPNumPHBs = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPNumPHBs.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPNumPHBs.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this value indicates the number of EXP->PHB\n          maps defined in this row.')
mplsDiffServELSPPHB0 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB0.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB0.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 0 in the EXP field of their MPLS\n          shim header.')
mplsDiffServELSPPHB1 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB1.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB1.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 1 in the EXP field of their MPLS\n          shim header.')
mplsDiffServELSPPHB2 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB2.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB2.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 2 in the EXP field of their MPLS\n          shim header.')
mplsDiffServELSPPHB3 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB3.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB3.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 3 in the EXP field of their MPLS\n          shim header.')
mplsDiffServELSPPHB4 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB4.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB4.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 4 in the EXP field of their MPLS\n          shim header.')
mplsDiffServELSPPHB5 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB5.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB5.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 5 in the EXP field of their MPLS\n          shim header.')
mplsDiffServELSPPHB6 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB6.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB6.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 6 in the EXP field of their MPLS\n          shim header.')
mplsDiffServELSPPHB7 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServELSPPHB7.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServELSPPHB7.setDescription('Valid only when mplsDiffServType takes the value e-lsp\n          (0), this field contains the 16-bit encoding of the\n          PHB (RFC 3140) which is assigned to packets on this\n          LSP with the value 7 in the EXP field of their MPLS\n          shim header.')
mplsDiffServRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 12, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsDiffServRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServRowStatus.setDescription('This variable is used to create, modify, and/or\n          delete a row in this table.')
prvtMplsTunnelUNIDvLstIdxNxtTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 13), )
if mibBuilder.loadTexts: prvtMplsTunnelUNIDvLstIdxNxtTable.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDvLstIdxNxtTable.setDescription('This table contains the next available values of\n        prvtMplsTunnelUNIDivListIdx for all entities.')
prvtMplsTunnelUNIDvLstIdxNxtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 13, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: prvtMplsTunnelUNIDvLstIdxNxtEntry.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDvLstIdxNxtEntry.setDescription('An entry in this table represents the next available\n        prvtMplsTunnelUNIDivListIdx for a specific TE-MIB entity.\n        This MIB table is indexed by the PRVT-TE-MIB entity Index.')
prvtMplsTunnelUNIDivListIdxNext = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivListIdxNext.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivListIdxNext.setDescription('This is the next available List Index in the\n         prvtMplsTunnelUNIDiversityTable.')
prvtMplsTunnelUNIDiversityTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14), )
if mibBuilder.loadTexts: prvtMplsTunnelUNIDiversityTable.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDiversityTable.setDescription('The prvtMplsTunnelUNIDiversityTable is used to indicate which\n         existing tunnels a new UNI Connection is to be diverse from.\n         This table is UNI specific.  Each\n         prvtMplsTunnelUNIDiversityTable is indexed using\n         prvtMplsTeMibEntityIndex, prvtMplsTunnelUNIDivListIdx,\n         prvtMplsTunnelUNIDivTnnlIdx.\n\n         To create a UNI tunnel to use Diversity, set up a row entry\n         in the prvtMplsTunnelUNIDiversityTable for each existing\n         tunnel that the new tunnel should be diverse from.\n\n         Then when creating the new UNI tunnel, set\n         prvtMplsTunnelUNIDiversityTableIndex in the mplsTunnelTable to\n         the list_index corresponding to the Diversity Table to be\n         used.\n\n         A diversity list is read-only if it is referenced by an\n         active row in the mplsTunnelTable that is admin_status up.\n         Under these circumstances, no individual rows/diversity\n         requirements making up the list can be added, modified or\n         deleted.\n\n         A list of diversity requirements can only be satisfied by\n         signaling if all of the referenced rows in the\n         mplsTunnelTable are oper_status up when signaling is\n         initiated.  If the requirements cannot be satisfied, any\n         tunnel attempting to use the list will remain oper_status\n         down.')
prvtMplsTunnelUNIDiversityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "prvtMplsTunnelUNIDivListIdx"), (0, "PRVT-MPLS-TE-MIB", "prvtMplsTunnelUNIDivIdx"))
if mibBuilder.loadTexts: prvtMplsTunnelUNIDiversityEntry.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDiversityEntry.setDescription('An entry in this table corresponds to an entry in the mplsTunnelTable.\n         A subsequent Tunnel that references this entry will be created Diverse\n         from the tunnel row entry specified here.')
prvtMplsTunnelUNIDivListIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivListIdx.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivListIdx.setDescription('Primary index into this table identifying a\n          particular list of Diversity requirements.')
prvtMplsTunnelUNIDivIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivIdx.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivIdx.setDescription('Secondary index into this table identifying a\n         Diversity requirement within the list.')
prvtMplsTunnelUNIDivRowPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1, 4), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivRowPointer.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivRowPointer.setDescription('This field represents a pointer to the entry in the\n         mplsTunnelTable to which the Diversity requirement\n         applies.  The array of longs specified here is configured\n         as the OID of the corresponding tunnel.')
prvtMplsTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelOperStatus.setDescription('The Oper Status of the mplsTunnelTable row referred to by\n         prvtMplsTunnelUNIDivPointer.  If this tunnel is removed\n         from the mplsTunnelTable then this is set to AMB_OPER_STATUS_DOWN.\n\n         This field is used to determine whether a diversity\n         requirement can currently be satisfied by signaling.')
prvtMplsTunnelUNIDivRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivRowStatus.setDescription('This variable is used to create or delete this row.')
prvtMplsTunnelUNIDivRequirement = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nodeDiverse", 1), ("linkDiverse", 2), ("srlg", 3), ("sharedPath", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivRequirement.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivRequirement.setDescription("This field indicates the Diversity Requirement for the\n         corresponding tunnel.  Once an row entry has been created\n         and is oper status 'up' for this tunnel this value cannot\n         be altered.")
prvtMplsTunnelUNIDivAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 14, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivAccess.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelUNIDivAccess.setDescription('This field indicates the access (read-only or writable)\n         that the user has over this row entry.\n\n         The circumstances under which a row is read-only are\n         described above.')
prvtMplsTunnelTrapEnableTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 15), )
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableTable.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableTable.setDescription('The prvtMplsTunnelTrapEnable Table allows a manager to\n         enable or disable TRAPs.')
prvtMplsTunnelTrapEnableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 15, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableEntry.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableEntry.setDescription('An entry in this table is used to configure trap support for this\n         instance of TE-MIB')
mplsTunnelTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 15, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setDescription('If this object is true, then it enables the\n          generation of mplsTunnelUp and mplsTunnelDown\n          traps, otherwise these traps are not emitted.')
mplsTunnelHoldTimer = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 19), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelHoldTimer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHoldTimer.setDescription('Defines a period in seconds needed to wait before rebuilding backup \n       or primary tunnels if a frr condition occurs\n       Currently no more than 10 seconds are allowed')
mplsTeMibEntityScalarTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 16), )
if mibBuilder.loadTexts: mplsTeMibEntityScalarTable.setStatus('current')
if mibBuilder.loadTexts: mplsTeMibEntityScalarTable.setDescription('The mplsTeMibEntityScalarTable contains all MPLS Tunnel\n          scalars.')
mplsTeMibEntityScalarEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 16, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: mplsTeMibEntityScalarEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTeMibEntityScalarEntry.setDescription('The mplsTeMibEntityScalarTable contains all MPLS Tunnel\n          scalars.')
mplsTunnelConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 16, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelConfigured.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelConfigured.setDescription('The number of tunnels configured on this device. A\n          tunnel is considered configured if the\n          mplsTunnelRowStatus is active(1).')
mplsTunnelActive = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 16, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelActive.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelActive.setDescription('The number of tunnels active on this device. A\n          tunnel is considered active if the\n          mplsTunnelOperStatus is up(1).')
mplsTunnelTEDistProto = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 16, 1, 4), Bits().clone(namedValues=NamedValues(("other", 0), ("ospf", 1), ("isis", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelTEDistProto.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTEDistProto.setDescription('The traffic engineering distribution protocol(s)\n          used by this LSR. Note that an LSR may support more\n          than one distribution protocol simultaneously.')
mplsTunnelMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 16, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelMaxHops.setDescription('The maximum number of hops that can be specified for\n          a tunnel on this device.')
mplsTunnelNotificationMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 16, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelNotificationMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelNotificationMaxRate.setDescription('This variable indicates the maximum number of\n          notifications issued per second. If events occur\n          more rapidly, the implementation may simply fail to\n          emit these notifications during that period, or may\n          queue them until an appropriate time. A value of 0\n          means no throttling is applied and events may be\n          notified at the rate at which they occur.')
mplsTunnelSonetResTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17), )
if mibBuilder.loadTexts: mplsTunnelSonetResTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResTable.setDescription('The mplsTunnelSonetResTable allows a manager to\n          specify which Sonet-specific resources are desired\n          for an MPLS tunnel. Note that these attributes are in addition\n          to those specified in mplsTunnelResourceTable. This\n          table also allows several tunnels to point to a\n          single entry in this table, implying that these\n          tunnels should share resources.')
mplsTunnelSonetResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelSonetResEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResEntry.setDescription('An entry in this table represents a set of Sonet resources\n          for an MPLS tunnel.  An entry can be created by a\n          network administrator or by an SNMP agent as\n          instructed by any MPLS signaling protocol.')
mplsTunnelSonetResRCC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSonetResRCC.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResRCC.setDescription('Requested Contiguous Concatenation.  Indicates the types\n        of contiguous concatenation requested for this LSP.  This\n        field is only valid if <lsp_encoding> is SDH or SONET, and the\n        <resource_pointer> is 0.0.')
mplsTunnelSonetResNCC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSonetResNCC.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResNCC.setDescription('Requested Number of Contiguous Components.  Indicates the\n        number of identical SDH/SONET SPEs/VCs that are\n        requested to be concatenated, as indicated in the <rcc>\n        field.  This field is only valid if <lsp_encoding> is SDH\n        or SONET, and the <resource_pointer> is 0.0.')
mplsTunnelSonetResNVC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSonetResNVC.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResNVC.setDescription('This field indicates the number of signals that are\n        requested to be virtually concatenated.  These signals\n        are all of the same type.  This field is valid only if\n        <lsp_encoding> is SDH or SONET, and the <resource_pointer> is 0.0.')
mplsTunnelSonetResMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSonetResMultiplier.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResMultiplier.setDescription('This field is a bit field indicating the number of\n        identical signals that are requested for the LSP.  This\n        field is valid only if <lsp_encoding> is SDH or SONET, and the\n        <resource_pointer> is 0.0.')
mplsTunnelSonetResTransparency = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSonetResTransparency.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResTransparency.setDescription('This field is a bit field indicating the type of\n        Transparency being requested.  Several flags can be\n        combined to provide different types of transparency.  Not\n        all combinations are necessarily valid.  This field is\n        valid only if <lsp_encoding> is SDH or SONET, and the\n        <resource_pointer> is 0.0.')
mplsTunnelSonetResRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSonetResRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResRowStatus.setDescription('This variable is used to create, modify, and/or\n          delete a row in this table.')
mplsTunnelSonetResSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 17, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSonetResSignalType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetResSignalType.setDescription('Indicates the overhead termination type and is interpreted\n        in relation to the LSP Encoding Type.')
mplsTunnelErrorTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18), )
if mibBuilder.loadTexts: mplsTunnelErrorTable.setReference('Multiprotocol Label Switching (MPLS) Traffic Engineering (TE)\n     Management Information Base (MIB), Srinivasan, C., Viswanathan,\n     A., Nadeau, T., RFC 3812, June 2004.')
if mibBuilder.loadTexts: mplsTunnelErrorTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorTable.setDescription("This table 'augments' the mplsTunnelTable.\n     This table provides per-tunnel information about errors. Errors\n     may be detected locally or reported through the signaling\n     protocol. Error reporting is not exclusive to GMPLS and this\n     table may be applied in MPLS systems.")
mplsTunnelErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1), )
mplsTunnelEntry.registerAugmentions(("PRVT-MPLS-TE-MIB", "mplsTunnelErrorEntry"))
mplsTunnelErrorEntry.setIndexNames(*mplsTunnelEntry.getIndexNames())
if mibBuilder.loadTexts: mplsTunnelErrorEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorEntry.setDescription('An entry in this table is created by the LSR for every tunnel\n     where error information is visible to the LSR.\n     Note that systems which read the objects in this table one at a\n     time may experience a discontinuity as the result of a new error\n     occurring in between object reads. Systems that are vulnerable\n     to this should read mplsTunnelErrorLastTime before and after\n     reading the other objects.')
mplsTunnelErrorLastErrorType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noError", 0), ("unknown", 1), ("protocol", 2), ("pathComputation", 3), ("localConfiguration", 4), ("localResources", 5), ("localOther", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorLastErrorType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorLastErrorType.setDescription('The nature of the last error. Provides interpretation context\n     for mplsTunnelErrorProtocolCode and mplsTunnelErrorProtocolSubcode.\n\n     A value of noError (0) shows that there is no error associated\n     with this tunnel and means that the other objects in this table\n     entry have no meaning.\n\n     A value of unknown (1) shows that there is an error but that no\n     additional information about the cause is known. The error may\n     have been received in a signaled message or generated locally.\n\n     A value of protocol (2) or pathComputation (3) indicates that\n     the cause of an error and identifies an error that has been\n     received through signaling or will itself be signaled.\n\n     A value of localConfiguration (4), localResources (5) or\n     localOther (6) identifies an error which has been detected\n     by the local node, but which will not be reported through\n     signaling.')
mplsTunnelErrorLastTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorLastTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorLastTime.setDescription('The time at which the last error occurred. This is presented as\n     the value of SysUpTime when the error occurred or was reported\n     to this node.\n     If mplsTunnelErrorLastErrorType has the value noError (0), then\n     this object is ignored.')
mplsTunnelErrorReporterType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorReporterType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorReporterType.setDescription('The address type of the error reported.\n      This object is used to aid in interpretation of\n      mplsTunnelErrorReporter.')
mplsTunnelErrorReporter = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorReporter.setReference('RFC3291, Textual Conventions for Internet Network Addresses,\n     Section 4. Usage Hints.')
if mibBuilder.loadTexts: mplsTunnelErrorReporter.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorReporter.setDescription('The address of the node reporting the last error, or the address\n     of the resource (such as an interface) associated with the\n     error.\n\n     If mplsTunnelErrorLastErrorType has the value noError (0), then\n     this object is ignored.\n\n     If mplsTunnelErrorLastErrorType has the value unknown (1),\n     localConfiguration (4), localResources (5), or localOther (6)\n     this object MAY contain a zero value.\n\n     This object should be interpreted in the context of the value of\n     the object mplsTunnelErrorReporterType.')
mplsTunnelErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorCode.setReference('1. Braden, R. (Ed.) et al., Resource ReserVation Protocol --\n        Version 1 Functional Specification, RFC 2205, September 1997.\n     2. RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al.,\n        RFC 3209, December 2001.\n     3. Generalized MPLS Signaling - RSVP-TE Extensions, Berger, L.\n        (Editor), RFC 3473, January 2003.')
if mibBuilder.loadTexts: mplsTunnelErrorCode.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorCode.setDescription('The primary error code associated with the last error.\n     The interpretation of this error code depends on the value of\n     mplsTunnelErrorLastErrorType. If the value of\n     mplsTunnelErrorLastErrorType is noError (0) the value of this\n     object should be 0 and should be ignored. If the value of\n     mplsTunnelErrorLastErrorType is protocol (2) the error should\n     be interpreted in the context of the signling protocol\n     identified by the mplsTunnelSignallingProto object.\n\n     Values in excess 32767 of are not used by signaling protocols\n     and may safely be used as implementation-specific error codes.')
mplsTunnelErrorSubcode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorSubcode.setReference('1. Braden, R. (Ed.) et al., Resource ReserVation Protocol --\n        Version 1 Functional Specification, RFC 2205, September 1997.\n     2. RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al.,\n        RFC 3209, December 2001.\n     3. Generalized MPLS Signaling - RSVP-TE Extensions, Berger, L.\n        (Editor), RFC 3473, January 2003.')
if mibBuilder.loadTexts: mplsTunnelErrorSubcode.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorSubcode.setDescription('The secondary error code associated with the last error and the\n     protocol used to signal this tunnel. This value is interpreted\n     in the context of the value of mplsTunnelErrorCode.\n     If the value of mplsTunnelErrorLastErrorType is noError (0) the\n     value of this object should be 0 and should be ignored.')
mplsTunnelErrorTLVs = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorTLVs.setReference('Generalized MPLS Signaling - RSVP-TE Extensions, Berger, L.\n     (Editor), RFC 3473, January 2003.')
if mibBuilder.loadTexts: mplsTunnelErrorTLVs.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorTLVs.setDescription('The sequence of interface identifier TLVs reported with the\n     error by the protocol code. The interpretation of the TLVs and\n     the encoding within the protocol are described in the\n     references. A value of zero in the first octet indicates that no\n     TLVs are present.')
mplsTunnelErrorHelpString = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 1, 18, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelErrorHelpString.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelErrorHelpString.setDescription('A textual string containing information about the last error,\n     recovery actions and support advice. If there is no help string\n     this object contains a zero length string.\n     If the value of mplsTunnelErrorLastErrorType is noError (0)\n     this object should contain a zero length string, but may contain\n     a help string indicating that there is no error.')
mplsTunnelUp = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 2, 0, 1)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelUp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUp.setDescription('This notification is generated when a\n          mplsTunnelOperStatus object for one of the\n          configured tunnels is about to leave the down state\n          and transition into some other state (but not into\n          the notPresent state).  This other state is\n          indicated by the included value of\n          mplsTunnelOperStatus.\n\n          This structure is the same as the generic\n          AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsTunnelDown = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 2, 0, 2)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelDown.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDown.setDescription('This notification is generated when a\n          mplsTunnelOperStatus object for one of the\n          configured tunnels is about to enter the down state\n          from some other state (but not from the notPresent\n          state).  This other state is indicated by the\n          included value of mplsTunnelOperStatus.\n\n          This structure is the same as the generic\n          AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsTunnelRerouted = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 2, 0, 3)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopTableIndex"))
if mibBuilder.loadTexts: mplsTunnelRerouted.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRerouted.setDescription('This notification is generated when a tunnel is\n          rerouted. If the actual path is used, then this\n          object MAY contain the new path for this tunnel\n          some time after this trap is issued by the agent.\n\n          This structure is the same as the generic\n          AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsTunnelReoptimized = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 2, 0, 4)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopTableIndex"))
if mibBuilder.loadTexts: mplsTunnelReoptimized.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelReoptimized.setDescription("This notification is generated when a tunnel is\n          reoptimized. If the mplsTunnelARHopTable is used,\n          then this tunnel instance's entry in the\n          mplsTunnelARHopTable MAY contain the new path for\n          this tunnel some time after this trap is issued by\n          the agent.\n\n          This structure is the same as the generic\n          AMB_MPLS_TUNNEL_TRAP_COMMON.")
mplsTeGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1))
mplsTeCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 2))
mplsTeModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 2, 1)).setObjects(("IF-MIB", "ifGeneralInformationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelScalarGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelManualGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSignaledGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIsNotIntfcGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIsIntfcGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResOptionalGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopGroup"), ("PRVT-MPLS-TE-MIB", "mplsDiffServGroup"), ("PRVT-MPLS-TE-MIB", "mplsTeNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeModuleFullCompliance = mplsTeModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsTeModuleFullCompliance.setDescription('Compliance statement for agents that provide full\n          support the MPLS-TE-STD-MIB module.')
mplsTeModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 2, 2)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelScalarGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelManualGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSignaledGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIsNotIntfcGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIsIntfcGroup"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResOptionalGroup"), ("PRVT-MPLS-TE-MIB", "mplsTeNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeModuleReadOnlyCompliance = mplsTeModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsTeModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only\n          provide read-only support for MPLS-TE-STD-MIB.\n          Such devices can then be monitored but cannot be\n          configured using this MIB modules.')
mplsTunnelGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 1)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelIndexNextIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelName"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDescr"), ("PRVT-MPLS-TE-MIB", "mplsTunnelOwner"), ("PRVT-MPLS-TE-MIB", "mplsTunnelXCPointer"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIfIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopTableIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopTableIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopTableIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelRowStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelStorageType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDirection"), ("PRVT-MPLS-TE-MIB", "mplsTunnelLSPEncoding"), ("PRVT-MPLS-TE-MIB", "mplsTunnelLinkProtection"), ("PRVT-MPLS-TE-MIB", "mplsTunnelGPid"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUseEgressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelEgressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelEgressLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelOmitEROIfOneHop"), ("PRVT-MPLS-TE-MIB", "mplsTunnelPrivateData"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSrcTNAAddressType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSrcTNAAddress"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDestTNAAddressType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDestTNAAddress"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSecondary"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUnnumIf"), ("PRVT-MPLS-TE-MIB", "mplsTunnelAttributes"), ("PRVT-MPLS-TE-MIB", "mplsTunnelEndToEndRerouting"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIsUni"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniServiceLevel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniEgressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniEgressLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniEgressLabelPort"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsEgressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsEgressLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsEgressLabelPort"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSwitchingType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDeletionMode"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniDiversityListIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDiffServIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelReversePrivateData"), ("PRVT-MPLS-TE-MIB", "mplsTunnelAdminStatusFlags"), ("PRVT-MPLS-TE-MIB", "mplsTunnelFastRerouteMode"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupSetupPrio"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupHoldingPriority"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupIncAny"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupIncAll"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupExcAny"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupBandwidth"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupMaxHops"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDownNotRecipType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDownNotRecip"), ("PRVT-MPLS-TE-MIB", "mplsTunnelPathComp"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUpNotRecipType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUpNotRecip"), ("PRVT-MPLS-TE-MIB", "mplsTunnelExtraParamsPtr"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIsSpc"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniIngressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniIngressLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniIngressLabelPort"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsIngrLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsIngrLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsIngrLabelPort"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDiffServClassType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelExtendedProtection"), ("PRVT-MPLS-TE-MIB", "mplsTunnelProtecting"), ("PRVT-MPLS-TE-MIB", "mplsTunnelNotification"), ("PRVT-MPLS-TE-MIB", "mplsTunnelLspProtection"), ("PRVT-MPLS-TE-MIB", "mplsTunnelAssociatedLspId"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCallIdType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCallId"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIsIpv6"), ("PRVT-MPLS-TE-MIB", "mplsTunnelConfigured"), ("PRVT-MPLS-TE-MIB", "mplsTunnelActive"), ("PRVT-MPLS-TE-MIB", "mplsTunnelPrimaryInstance"), ("PRVT-MPLS-TE-MIB", "mplsTunnelPrimaryUpTime"), ("PRVT-MPLS-TE-MIB", "mplsTunnelPathChanges"), ("PRVT-MPLS-TE-MIB", "mplsTunnelLastPathChange"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCreationTime"), ("PRVT-MPLS-TE-MIB", "mplsTunnelStateTransitions"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIncludeAnyAffinity"), ("PRVT-MPLS-TE-MIB", "mplsTunnelIncludeAllAffinity"), ("PRVT-MPLS-TE-MIB", "mplsTunnelExcludeAnyAffinity"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourcePointer"), ("PRVT-MPLS-TE-MIB", "mplsTunnelInstancePriority"), ("PRVT-MPLS-TE-MIB", "mplsTunnelPathInUse"), ("PRVT-MPLS-TE-MIB", "mplsTunnelRole"), ("PRVT-MPLS-TE-MIB", "mplsTunnelTotalUpTime"), ("PRVT-MPLS-TE-MIB", "mplsTunnelInstanceUpTime"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceMaxRate"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceMeanRate"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceMaxBurstSize"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceMeanBurstSize"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceExBurstSize"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceFrequency"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceWeight"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceRowStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceStorageType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelResourceIndexNextIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResRCC"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResNCC"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResNVC"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResMultiplier"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResTransparency"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResRowStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopAddrType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopIpAddr"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopAddrUnnum"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopLspId"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopAddrType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopIpAddr"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopIpPrefixLen"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopAsNumber"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopAddrUnnum"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopLspId"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelTrapEnable"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorLastErrorType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorLastTime"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorReporterType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorReporter"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorCode"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorSubcode"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorTLVs"), ("PRVT-MPLS-TE-MIB", "mplsTunnelErrorHelpString"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelGroup = mplsTunnelGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelGroup.setDescription('Necessary, but not sufficient, set of objects to\n          implement tunnels.  In addition, depending on the\n          type of the tunnels supported (for example,\n          manually configured or signaled, persistent or non-\n          persistent, etc.), the following other groups\n          defined below are mandatory: mplsTunnelManualGroup\n          and/or mplsTunnelSignaledGroup,\n          mplsTunnelIsNotIntfcGroup and/or\n          mplsTunnelIsIntfcGroup.')
mplsTunnelManualGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 2)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelSignallingProto"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelManualGroup = mplsTunnelManualGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManualGroup.setDescription('Object(s) needed to implement manually configured\n          tunnels.')
mplsTunnelSignaledGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 3)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelSetupPrio"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHoldingPrio"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSignallingProto"), ("PRVT-MPLS-TE-MIB", "mplsTunnelLocalProtectInUse"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSessionAttributes"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopAddrType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopIpAddr"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopIpPrefixLen"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopAddrUnnum"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopAsNumber"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopLspId"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopInclude"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopPathOptionName"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopEntryPathComp"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopRowStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopStorageType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopLabelStatuses"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopExpLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopExpLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopExpRvrsLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopExpRvrsLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelHopIndexNextIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelSignaledGroup = mplsTunnelSignaledGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignaledGroup.setDescription('Objects needed to implement signaled tunnels.')
mplsTunnelScalarGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 4)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelConfigured"), ("PRVT-MPLS-TE-MIB", "mplsTunnelActive"), ("PRVT-MPLS-TE-MIB", "mplsTunnelTEDistProto"), ("PRVT-MPLS-TE-MIB", "mplsTunnelMaxHops"), ("PRVT-MPLS-TE-MIB", "mplsTunnelNotificationMaxRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelScalarGroup = mplsTunnelScalarGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelScalarGroup.setDescription('Scalar object needed to implement MPLS tunnels.')
mplsTunnelIsIntfcGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 5)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsIntfcGroup = mplsTunnelIsIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIntfcGroup.setDescription('Objects needed to implement tunnels that are\n          interfaces.')
mplsTunnelIsNotIntfcGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 6)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsNotIntfcGroup = mplsTunnelIsNotIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsNotIntfcGroup.setDescription('Objects needed to implement tunnels that are not\n          interfaces.')
mplsTunnelCRLDPResOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 7)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResMeanBurstSize"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResExBurstSize"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResFrequency"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResWeight"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResFlags"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResRowStatus"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCRLDPResStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelCRLDPResOptionalGroup = mplsTunnelCRLDPResOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCRLDPResOptionalGroup.setDescription('Set of objects implemented for resources applicable\n          for tunnels signaled using CR-LDP.')
mplsTunnelSonetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 8)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResSignalType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResRCC"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResNCC"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResNVC"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResMultiplier"), ("PRVT-MPLS-TE-MIB", "mplsTunnelSonetResTransparency"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelSonetGroup = mplsTunnelSonetGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSonetGroup.setDescription('Set of objects needed to implement Sonet.\n          None of these objects are mandatory.')
mplsTunnelUniGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 9)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelIsUni"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniServiceLevel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniEgressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniEgressLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniEgressLabelPort"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsEgressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsEgressLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsEgressLabelPort"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniDiversityListIndex"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniIngressLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniIngressLabelPort"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniIngressLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsIngrLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsIngrLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelUniRvsIngrLabelPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelUniGroup = mplsTunnelUniGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUniGroup.setDescription('Set of objects needed to implement UNI.\n          None of these objects are mandatory.')
mplsTunnelBackupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 11)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelBackupSetupPrio"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupHoldingPriority"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupIncAny"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupIncAll"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupExcAny"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupBandwidth"), ("PRVT-MPLS-TE-MIB", "mplsTunnelBackupMaxHops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelBackupGroup = mplsTunnelBackupGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelBackupGroup.setDescription('Set of objects needed for backup tunnels.\n          None of these objects are mandatory.')
mplsTunnelARHopGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 12)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelARHopAddrType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopIpAddr"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopAddrUnnum"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopLspId"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopLabelStatuses"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopExpLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopExpLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopExpRvrsLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopExpRvrsLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelARHopProtection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelARHopGroup = mplsTunnelARHopGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopGroup.setDescription('Set of objects relating to ARHop.\n           None of these objects are mandatory.')
mplsTunnelCHopGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 13)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelCHopAddrType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopIpAddr"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopIpPrefixLen"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopAsNumber"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopAddrUnnum"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopLspId"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopLabelStatuses"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopExpLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopExpLabel"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopExpRvrsLabelType"), ("PRVT-MPLS-TE-MIB", "mplsTunnelCHopExpRvrsLabel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelCHopGroup = mplsTunnelCHopGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopGroup.setDescription('Set of objects relating to CHop.\n           None of these objects are mandatory.')
mplsDiffServGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 14)).setObjects(("PRVT-MPLS-TE-MIB", "mplsDiffServIndexNextIndex"), ("PRVT-MPLS-TE-MIB", "mplsDiffServType"), ("PRVT-MPLS-TE-MIB", "mplsDiffServLLSPPSC"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPNumPHBs"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB0"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB1"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB2"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB3"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB4"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB5"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB6"), ("PRVT-MPLS-TE-MIB", "mplsDiffServELSPPHB7"), ("PRVT-MPLS-TE-MIB", "mplsDiffServRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsDiffServGroup = mplsDiffServGroup.setStatus('current')
if mibBuilder.loadTexts: mplsDiffServGroup.setDescription('Set of objects relating to DiffServ.\n            None of these objects are mandatory.')
mplsTeNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 2, 3, 1, 15)).setObjects(("PRVT-MPLS-TE-MIB", "mplsTunnelUp"), ("PRVT-MPLS-TE-MIB", "mplsTunnelDown"), ("PRVT-MPLS-TE-MIB", "mplsTunnelRerouted"), ("PRVT-MPLS-TE-MIB", "mplsTunnelReoptimized"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeNotificationGroup = mplsTeNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTeNotificationGroup.setDescription('Set of notifications implemented in this module.\n          None is mandatory.')
mibBuilder.exportSymbols("PRVT-MPLS-TE-MIB", mplsTunnelCHopExpLabelType=mplsTunnelCHopExpLabelType, mplsTunnelInstanceUpTime=mplsTunnelInstanceUpTime, mplsTunnelUniRvsIngrLabelType=mplsTunnelUniRvsIngrLabelType, mplsTunnelErrorTable=mplsTunnelErrorTable, mplsTunnelEgressLabel=mplsTunnelEgressLabel, mplsTunnelUniEgressLabelType=mplsTunnelUniEgressLabelType, mplsTunnelCHopLspId=mplsTunnelCHopLspId, mplsTunnelIncludeAnyAffinity=mplsTunnelIncludeAnyAffinity, mplsTunnelUnnumIf=mplsTunnelUnnumIf, mplsTunnelCRLDPResFlags=mplsTunnelCRLDPResFlags, mplsTeModuleFullCompliance=mplsTeModuleFullCompliance, mplsTunnelProtecting=mplsTunnelProtecting, mplsTunnelAdminStatusFlags=mplsTunnelAdminStatusFlags, mplsTunnelSonetResNCC=mplsTunnelSonetResNCC, mplsTunnelSonetResNVC=mplsTunnelSonetResNVC, mplsDiffServELSPPHB4=mplsDiffServELSPPHB4, mplsTunnelGroup=mplsTunnelGroup, mplsTunnelIsSpc=mplsTunnelIsSpc, mplsTunnelHopAddrType=mplsTunnelHopAddrType, mplsTunnelCRLDPResEntry=mplsTunnelCRLDPResEntry, mplsDiffServELSPPHB0=mplsDiffServELSPPHB0, mplsTunnelExcludeAnyAffinity=mplsTunnelExcludeAnyAffinity, mplsTunnelSonetResRCC=mplsTunnelSonetResRCC, mplsTunnelARHopLabelStatuses=mplsTunnelARHopLabelStatuses, mplsTunnelFastRerouteMode=mplsTunnelFastRerouteMode, mplsTunnelCHopEntry=mplsTunnelCHopEntry, mplsTunnelHopExpLabel=mplsTunnelHopExpLabel, mplsTunnelEntry=mplsTunnelEntry, prvtMplsTunnelTrapEnableEntry=prvtMplsTunnelTrapEnableEntry, mplsTunnelHopLabelStatuses=mplsTunnelHopLabelStatuses, mplsTunnelInstance=mplsTunnelInstance, mplsTunnelRowStatus=mplsTunnelRowStatus, mplsTunnelHopEntryPathComp=mplsTunnelHopEntryPathComp, prvtMplsTunnelUNIDivListIdxNext=prvtMplsTunnelUNIDivListIdxNext, mplsTunnelLinkProtection=mplsTunnelLinkProtection, mplsTunnelErrorSubcode=mplsTunnelErrorSubcode, mplsTunnelARHopAddrType=mplsTunnelARHopAddrType, mplsTunnelCHopIndex=mplsTunnelCHopIndex, mplsTunnelResourceMaxRate=mplsTunnelResourceMaxRate, mplsTunnelIndex=mplsTunnelIndex, mplsTunnelCHopAddrType=mplsTunnelCHopAddrType, mplsTunnelPathChanges=mplsTunnelPathChanges, mplsTunnelResourceWeight=mplsTunnelResourceWeight, mplsTunnelARHopLspId=mplsTunnelARHopLspId, mplsTunnelDescr=mplsTunnelDescr, mplsDiffServELSPPHB3=mplsDiffServELSPPHB3, mplsTunnelUniIngressLabel=mplsTunnelUniIngressLabel, mplsTunnelOperStatus=mplsTunnelOperStatus, mplsTunnelResourceFrequency=mplsTunnelResourceFrequency, mplsTunnelEgressLabelType=mplsTunnelEgressLabelType, prvtMplsTunnelUNIDvLstIdxNxtTable=prvtMplsTunnelUNIDvLstIdxNxtTable, mplsTunnelUpNotRecip=mplsTunnelUpNotRecip, mplsTunnelBackupHoldingPriority=mplsTunnelBackupHoldingPriority, mplsTunnelHopIpAddr=mplsTunnelHopIpAddr, mplsTeConformance=mplsTeConformance, mplsTunnelErrorReporterType=mplsTunnelErrorReporterType, mplsTunnelIngressLSRId=mplsTunnelIngressLSRId, mplsTunnelHopInclude=mplsTunnelHopInclude, mplsTunnelMaxHops=mplsTunnelMaxHops, mplsDiffServELSPPHB1=mplsDiffServELSPPHB1, mplsTunnelEgressLSRId=mplsTunnelEgressLSRId, mplsTunnelHopPathOptionIndex=mplsTunnelHopPathOptionIndex, mplsTunnelARHopIndex=mplsTunnelARHopIndex, mplsDiffServELSPPHB6=mplsDiffServELSPPHB6, mplsTunnelErrorCode=mplsTunnelErrorCode, mplsTunnelAssociatedLspId=mplsTunnelAssociatedLspId, mplsTunnelOperStatusFlags=mplsTunnelOperStatusFlags, mplsDiffServIndexNextEntry=mplsDiffServIndexNextEntry, mplsDiffServELSPPHB2=mplsDiffServELSPPHB2, mplsTunnelCHopLabelStatuses=mplsTunnelCHopLabelStatuses, mplsTunnelHopIndexNextIndex=mplsTunnelHopIndexNextIndex, mplsTunnelGPid=mplsTunnelGPid, mplsTeMibEntityScalarEntry=mplsTeMibEntityScalarEntry, MplsTunnelIndexSyntax=MplsTunnelIndexSyntax, mplsTunnelRebuildTimer=mplsTunnelRebuildTimer, mplsTunnelResourceIndexNextIndex=mplsTunnelResourceIndexNextIndex, MplsGeneralizedLabel=MplsGeneralizedLabel, mplsTunnelSignallingProto=mplsTunnelSignallingProto, mplsTunnelMtu=mplsTunnelMtu, mplsTunnelCRLDPResRowStatus=mplsTunnelCRLDPResRowStatus, mplsTunnelDirection=mplsTunnelDirection, mplsTunnelCHopListIndex=mplsTunnelCHopListIndex, mplsTunnelPerfHCPackets=mplsTunnelPerfHCPackets, mplsDiffServIndexNextTable=mplsDiffServIndexNextTable, mplsTunnelBackupIncAll=mplsTunnelBackupIncAll, mplsTunnelUniRvsIngrLabel=mplsTunnelUniRvsIngrLabel, mplsTunnelDiffServClassType=mplsTunnelDiffServClassType, mplsTunnelResourceMaxBurstSize=mplsTunnelResourceMaxBurstSize, mplsTeGroups=mplsTeGroups, mplsTunnelIsIntfcGroup=mplsTunnelIsIntfcGroup, mplsTunnelErrorReporter=mplsTunnelErrorReporter, mplsTunnelSonetResTransparency=mplsTunnelSonetResTransparency, mplsTunnelLastPathChange=mplsTunnelLastPathChange, mplsTunnelLspProtection=mplsTunnelLspProtection, mplsTunnelARHopTable=mplsTunnelARHopTable, mplsTunnelUniRvsEgressLabelPort=mplsTunnelUniRvsEgressLabelPort, mplsTunnelUp=mplsTunnelUp, mplsTunnelUniIngressLabelPort=mplsTunnelUniIngressLabelPort, mplsTunnelResourceExBurstSize=mplsTunnelResourceExBurstSize, mplsTunnelSrcTNAAddress=mplsTunnelSrcTNAAddress, mplsTunnelCallId=mplsTunnelCallId, mplsTunnelHopEntry=mplsTunnelHopEntry, mplsTunnelHopStorageType=mplsTunnelHopStorageType, mplsTunnelIsIf=mplsTunnelIsIf, mplsTeObjects=mplsTeObjects, mplsTunnelPathComp=mplsTunnelPathComp, mplsTunnelIfIndex=mplsTunnelIfIndex, mplsTunnelDestTNAAddressType=mplsTunnelDestTNAAddressType, mplsTunnelCRLDPResOptionalGroup=mplsTunnelCRLDPResOptionalGroup, mplsTunnelHopIpPrefixLen=mplsTunnelHopIpPrefixLen, mplsTunnelIncludeAllAffinity=mplsTunnelIncludeAllAffinity, mplsTunnelTrapEnable=mplsTunnelTrapEnable, mplsTunnelOmitEROIfOneHop=mplsTunnelOmitEROIfOneHop, mplsTunnelUpNotRecipType=mplsTunnelUpNotRecipType, mplsTunnelAttributes=mplsTunnelAttributes, mplsTunnelHopListIndex=mplsTunnelHopListIndex, mplsTunnelCRLDPResFrequency=mplsTunnelCRLDPResFrequency, mplsTunnelUniRvsEgressLabel=mplsTunnelUniRvsEgressLabel, mplsTunnelCHopTable=mplsTunnelCHopTable, MplsLsrId=MplsLsrId, mplsTunnelIsIpv6=mplsTunnelIsIpv6, mplsTunnelSonetResRowStatus=mplsTunnelSonetResRowStatus, mplsTunnelHopExpRvrsLabel=mplsTunnelHopExpRvrsLabel, mplsTunnelStateTransitions=mplsTunnelStateTransitions, mplsTunnelCHopExpLabel=mplsTunnelCHopExpLabel, mplsTunnelDeletionMode=mplsTunnelDeletionMode, mplsTunnelPrivateData=mplsTunnelPrivateData, mplsTunnelARHopExpLabel=mplsTunnelARHopExpLabel, mplsTunnelIsUni=mplsTunnelIsUni, mplsTunnelCHopIpPrefixLen=mplsTunnelCHopIpPrefixLen, mplsTunnelNotificationMaxRate=mplsTunnelNotificationMaxRate, mplsTunnelHopAddrUnnum=mplsTunnelHopAddrUnnum, mplsTunnelUniEgressLabelPort=mplsTunnelUniEgressLabelPort, mplsTunnelScalarGroup=mplsTunnelScalarGroup, mplsTunnelCRLDPResStorageType=mplsTunnelCRLDPResStorageType, prvtMplsTunnelUNIDvLstIdxNxtEntry=prvtMplsTunnelUNIDvLstIdxNxtEntry, mplsTunnelUniEgressLabel=mplsTunnelUniEgressLabel, mplsTunnelCreationTime=mplsTunnelCreationTime, mplsTeNotifications=mplsTeNotifications, mplsDiffServELSPPHB7=mplsDiffServELSPPHB7, mplsTunnelHopExpRvrsLabelType=mplsTunnelHopExpRvrsLabelType, mplsTunnelSonetResMultiplier=mplsTunnelSonetResMultiplier, mplsTeNotificationGroup=mplsTeNotificationGroup, mplsTunnelHopIndex=mplsTunnelHopIndex, mplsTunnelLSPEncoding=mplsTunnelLSPEncoding, mplsTunnelARHopTableIndex=mplsTunnelARHopTableIndex, prvtMplsTunnelUNIDiversityEntry=prvtMplsTunnelUNIDiversityEntry, mplsTunnelARHopAddrUnnum=mplsTunnelARHopAddrUnnum, mplsTunnelResourceRowStatus=mplsTunnelResourceRowStatus, mplsTunnelARHopExpRvrsLabelType=mplsTunnelARHopExpRvrsLabelType, mplsTunnelTable=mplsTunnelTable, mplsTunnelPerfBytes=mplsTunnelPerfBytes, prvtMplsTunnelUNIDivAccess=prvtMplsTunnelUNIDivAccess, mplsTunnelPerfEntry=mplsTunnelPerfEntry, mplsTunnelSonetResSignalType=mplsTunnelSonetResSignalType, mplsTunnelGuardedDest=mplsTunnelGuardedDest, mplsTunnelBackupSetupPrio=mplsTunnelBackupSetupPrio, mplsTeNotifyPrefix=mplsTeNotifyPrefix, mplsTunnelPrimaryInstance=mplsTunnelPrimaryInstance, mplsTunnelHopAsNumber=mplsTunnelHopAsNumber, mplsTunnelCRLDPResWeight=mplsTunnelCRLDPResWeight, mplsTunnelHoldTimer=mplsTunnelHoldTimer, mplsTunnelReoptimized=mplsTunnelReoptimized, mplsTunnelCHopAddrUnnum=mplsTunnelCHopAddrUnnum, mplsTunnelIsNotIntfcGroup=mplsTunnelIsNotIntfcGroup, mplsTunnelSrcTNAAddressType=mplsTunnelSrcTNAAddressType, mplsTunnelErrorLastTime=mplsTunnelErrorLastTime, mplsTunnelHopLspId=mplsTunnelHopLspId, mplsTunnelCHopExpRvrsLabelType=mplsTunnelCHopExpRvrsLabelType, mplsTunnelActive=mplsTunnelActive, mplsDiffServELSPNumPHBs=mplsDiffServELSPNumPHBs, mplsTunnelCHopType=mplsTunnelCHopType, PYSNMP_MODULE_ID=mplsTeMIB, mplsTunnelCHopExpRvrsLabel=mplsTunnelCHopExpRvrsLabel, mplsTunnelErrorHelpString=mplsTunnelErrorHelpString, mplsTunnelPerfTable=mplsTunnelPerfTable, mplsTunnelUniRvsIngrLabelPort=mplsTunnelUniRvsIngrLabelPort, mplsTeMIB=mplsTeMIB, mplsTunnelSetupPrio=mplsTunnelSetupPrio, mplsTunnelCHopTableIndex=mplsTunnelCHopTableIndex, mplsTunnelSecondary=mplsTunnelSecondary, mplsTunnelResourceIndex=mplsTunnelResourceIndex, mplsTunnelPathInUse=mplsTunnelPathInUse, mplsTunnelEndToEndRerouting=mplsTunnelEndToEndRerouting, mplsTunnelPrimaryUpTime=mplsTunnelPrimaryUpTime, mplsTunnelCallIdType=mplsTunnelCallIdType, mplsTunnelResourceIndexNextTable=mplsTunnelResourceIndexNextTable, mplsTunnelPerfPackets=mplsTunnelPerfPackets, mplsTunnelDown=mplsTunnelDown, mplsTunnelSignaledGroup=mplsTunnelSignaledGroup, mplsTunnelDownNotRecipType=mplsTunnelDownNotRecipType, mplsTunnelSonetResTable=mplsTunnelSonetResTable, mplsTunnelRerouted=mplsTunnelRerouted, mplsTunnelCHopIpAddr=mplsTunnelCHopIpAddr, mplsDiffServIndexNextIndex=mplsDiffServIndexNextIndex, MplsTunnelTNAAddress=MplsTunnelTNAAddress, mplsTunnelRole=mplsTunnelRole, mplsTunnelTotalUpTime=mplsTunnelTotalUpTime, mplsTunnelExtendedProtection=mplsTunnelExtendedProtection, MplsTunnelPrivateDataSyntax=MplsTunnelPrivateDataSyntax, mplsTunnelExtraParamsPtr=mplsTunnelExtraParamsPtr, mplsTunnelUniDiversityListIndex=mplsTunnelUniDiversityListIndex, mplsTunnelPerfHCBytes=mplsTunnelPerfHCBytes, mplsTunnelARHopGroup=mplsTunnelARHopGroup, mplsTunnelARHopEntry=mplsTunnelARHopEntry, mplsTunnelDestTNAAddress=mplsTunnelDestTNAAddress, mplsTunnelUseEgressLabel=mplsTunnelUseEgressLabel, mplsTunnelDiffServIndex=mplsTunnelDiffServIndex, mplsTunnelBackupExcAny=mplsTunnelBackupExcAny, prvtMplsTunnelUNIDivRowPointer=prvtMplsTunnelUNIDivRowPointer, mplsTunnelBackupBandwidth=mplsTunnelBackupBandwidth, mplsTunnelConfigured=mplsTunnelConfigured, mplsTunnelHopTable=mplsTunnelHopTable, mplsTunnelCRLDPResExBurstSize=mplsTunnelCRLDPResExBurstSize, mplsTunnelResourcePointer=mplsTunnelResourcePointer, prvtMplsTunnelUNIDivRequirement=prvtMplsTunnelUNIDivRequirement, mplsTunnelResourceTable=mplsTunnelResourceTable, mplsDiffServTable=mplsDiffServTable, mplsDiffServEntry=mplsDiffServEntry, mplsTunnelSessionAttributes=mplsTunnelSessionAttributes, mplsTunnelErrorTLVs=mplsTunnelErrorTLVs, mplsTunnelSonetGroup=mplsTunnelSonetGroup, mplsTunnelErrorLastErrorType=mplsTunnelErrorLastErrorType, mplsTunnelDownNotRecip=mplsTunnelDownNotRecip, mplsTunnelUniServiceLevel=mplsTunnelUniServiceLevel, mplsTunnelARHopIpAddr=mplsTunnelARHopIpAddr, mplsTunnelARHopExpRvrsLabel=mplsTunnelARHopExpRvrsLabel, mplsTunnelHopIndexNextEntry=mplsTunnelHopIndexNextEntry, mplsTunnelCHopGroup=mplsTunnelCHopGroup, mplsTunnelIndexNextTable=mplsTunnelIndexNextTable, mplsTunnelStorageType=mplsTunnelStorageType, mplsTunnelIndexNextIndex=mplsTunnelIndexNextIndex, mplsDiffServIndex=mplsDiffServIndex, prvtMplsTunnelOperStatus=prvtMplsTunnelOperStatus, mplsTunnelCHopAsNumber=mplsTunnelCHopAsNumber, MplsGeneralizedLabelType=MplsGeneralizedLabelType, mplsTunnelNotification=mplsTunnelNotification, mplsTunnelResourceIndexNextEntry=mplsTunnelResourceIndexNextEntry, mplsDiffServELSPPHB5=mplsDiffServELSPPHB5, mplsTunnelTEDistProto=mplsTunnelTEDistProto, mplsTunnelManualGroup=mplsTunnelManualGroup, mplsTunnelUniGroup=mplsTunnelUniGroup, mplsTunnelSwitchingType=mplsTunnelSwitchingType, mplsDiffServRowStatus=mplsDiffServRowStatus, prvtMplsTunnelUNIDivListIdx=prvtMplsTunnelUNIDivListIdx, mplsTunnelHopRowStatus=mplsTunnelHopRowStatus, mplsTunnelBackupGroup=mplsTunnelBackupGroup, mplsTunnelHopPathOptionName=mplsTunnelHopPathOptionName, mplsTunnelIndexNextEntry=mplsTunnelIndexNextEntry, mplsTunnelName=mplsTunnelName, mplsTunnelErrorEntry=mplsTunnelErrorEntry, mplsTunnelHopExpLabelType=mplsTunnelHopExpLabelType, mplsTunnelResourceStorageType=mplsTunnelResourceStorageType, mplsTeCompliances=mplsTeCompliances)
mibBuilder.exportSymbols("PRVT-MPLS-TE-MIB", mplsTunnelLocalProtectInUse=mplsTunnelLocalProtectInUse, mplsTunnelARHopExpLabelType=mplsTunnelARHopExpLabelType, mplsTunnelSonetResEntry=mplsTunnelSonetResEntry, mplsTunnelResourceMeanBurstSize=mplsTunnelResourceMeanBurstSize, mplsTunnelUniIngressLabelType=mplsTunnelUniIngressLabelType, mplsTunnelCRLDPResTable=mplsTunnelCRLDPResTable, mplsTeModuleReadOnlyCompliance=mplsTeModuleReadOnlyCompliance, mplsTunnelBackupIncAny=mplsTunnelBackupIncAny, mplsTunnelInstancePriority=mplsTunnelInstancePriority, mplsTunnelMBBTimeOut=mplsTunnelMBBTimeOut, prvtMplsTunnelUNIDiversityTable=prvtMplsTunnelUNIDiversityTable, mplsDiffServLLSPPSC=mplsDiffServLLSPPSC, mplsTeMibEntityScalarTable=mplsTeMibEntityScalarTable, mplsTunnelResourceEntry=mplsTunnelResourceEntry, mplsTunnelAdminStatus=mplsTunnelAdminStatus, mplsTunnelHopTableIndex=mplsTunnelHopTableIndex, mplsTunnelCRLDPResMeanBurstSize=mplsTunnelCRLDPResMeanBurstSize, prvtMplsTunnelUNIDivIdx=prvtMplsTunnelUNIDivIdx, mplsTunnelARHopProtection=mplsTunnelARHopProtection, mplsTunnelBackupMaxHops=mplsTunnelBackupMaxHops, mplsTunnelOwner=mplsTunnelOwner, mplsTunnelHoldingPrio=mplsTunnelHoldingPrio, mplsTunnelUniRvsEgressLabelType=mplsTunnelUniRvsEgressLabelType, mplsTunnelARHopListIndex=mplsTunnelARHopListIndex, mplsTunnelReversePrivateData=mplsTunnelReversePrivateData, mplsDiffServType=mplsDiffServType, prvtMplsTunnelTrapEnableTable=prvtMplsTunnelTrapEnableTable, mplsTunnelResourceMeanRate=mplsTunnelResourceMeanRate, mplsTunnelXCPointer=mplsTunnelXCPointer, mplsDiffServGroup=mplsDiffServGroup, mplsTunnelHopType=mplsTunnelHopType, mplsTunnelPerfErrors=mplsTunnelPerfErrors, prvtMplsTunnelUNIDivRowStatus=prvtMplsTunnelUNIDivRowStatus, mplsTunnelHopIndexNextTable=mplsTunnelHopIndexNextTable)
