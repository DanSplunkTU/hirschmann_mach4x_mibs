#
# PySNMP MIB module PRVT-MPLS-TE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binox/PRVT-MPLS-TE-MIB
# Produced by pysmi-1.1.3 at Tue Dec  7 17:28:25 2021
# On host fv-az74-115 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
mpls, = mibBuilder.importSymbols("PRVT-SWITCH-MIB", "mpls")
prvtMplsTeMibEntityIndex, = mibBuilder.importSymbols("PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, iso, Bits, Gauge32, Counter32, IpAddress, TimeTicks, Integer32, Counter64, MibIdentifier, ObjectIdentity, ModuleIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "iso", "Bits", "Gauge32", "Counter32", "IpAddress", "TimeTicks", "Integer32", "Counter64", "MibIdentifier", "ObjectIdentity", "ModuleIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
RowStatus, TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "DisplayString")
prvtMplsTeMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2))
prvtMplsTeMIB.setRevisions(('2009-02-10 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtMplsTeMIB.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: prvtMplsTeMIB.setLastUpdated('200902100000Z')
if mibBuilder.loadTexts: prvtMplsTeMIB.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtMplsTeMIB.setContactInfo('BATM/Telco Systems Support team\n         Email:\n         For North America: techsupport@telco.com\n         For North Europe: support@batm.de, info@batm.de\n         For the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtMplsTeMIB.setDescription("This MIB module contains managed object definitions\n         for MPLS Traffic Engineering (TE) as defined in:\n         Extensions to RSVP for LSP Tunnels, Awduche et al,\n         Internet Draft <draft-ietf-mpls-rsvp-lsp-tunnel-\n         07.txt>, August 2000; Constraint-Based LSP Setup\n         using LDP, B. Jamoussi, Internet Draft <draft-ietf-\n         mpls-cr-ldp-04.txt>, July 2000; Requirements for\n         Traffic Engineering Over MPLS, Awduche, D., J.\n         Malcolm, J., Agogbua, J., O'Dell, M., J. McManus,\n         <rfc2702.txt>, September 1999.")
class MplsPathIndexOrZero(TextualConvention, Unsigned32):
    description = 'A unique identifier used to identify a specific\n         path used by a tunnel. A value of 0 (zero) means\n         that no path is in use.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class MplsTunnelInstanceIndex(TextualConvention, Unsigned32):
    description = 'The tunnel entry with instance index 0\n         should refer to the configured tunnel\n         interface (if one exists).\n         \n         Values greater than 0, but less than or\n         equal to 65535, should be used to indicate\n         signaled (or backup) tunnel LSP instances.\n         For tunnel LSPs signaled using RSVP,\n         this value should correspond to the\n         RSVP LSP ID used for the RSVP-TE\n         LSP.\n         \n         Values greater than 65535 apply to FRR\n         detour instances.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class TeHopAddressAS(TextualConvention, Unsigned32):
    reference = 'Textual Conventions for Internet Network\n         Addresses, [RFC3291].'
    description = 'Represents a two or four octet AS number.\n         The AS number is represented in network byte\n         order (MSB first). A two-octet AS number has\n         the two MSB octets set to zero.'
    status = 'current'
    displayHint = 'd'

class TeHopAddressUnnum(TextualConvention, Unsigned32):
    description = 'Represents an unnumbered interface:\n         \n         octets contents encoding\n         1-4 unnumbered interface network-byte order\n         \n         The corresponding TeHopAddressType value is\n         unnum(4).'
    status = 'current'
    displayHint = 'd'

class TeHopAddress(TextualConvention, OctetString):
    description = "Denotes a generic Tunnel hop address,\n         that is, the address of a node which\n         an LSP traverses, including the source\n         and destination nodes. An address may be\n         very concrete, for example, an IPv4 host\n         address (i.e., with prefix length 32);\n         if this IPv4 address is an interface\n         address, then that particular interface\n         must be traversed. An address may also\n         specify an 'abstract node', for example,\n         an IPv4 address with prefix length\n         less than 32, in which case, the LSP\n         can traverse any node whose address\n         falls in that range. An address may\n         also specify an Autonomous System (AS),\n         in which case the LSP can traverse any\n         node that falls within that AS.\n         \n         A TeHopAddress value is always interpreted within\n         the context of an TeHopAddressType value. Every\n         usage of the TeHopAddress TEXTUAL-CONVENTION\n         is required to specify the TeHopAddressType object\n         which provides the context. It is suggested that\n         the TeHopAddressType object is logically registered\n         before the object(s) which use the TeHopAddress\n         TEXTUAL-CONVENTION if they appear in the\n         same logical row.\n         \n         The value of a TeHopAddress object must always be\n         consistent with the value of the associated\n         TeHopAddressType object. Attempts to set a\n         TeHopAddress object to a value which is\n         inconsistent with the associated TeHopAddressType\n         must fail with an inconsistentValue error."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class TeHopAddressType(TextualConvention, Integer32):
    reference = 'TEXTUAL-CONVENTIONs for Internet Network\n         Addresses, RFC3291.\n         \n         Constraint-Based LSP Setup using LDP,\n         [RFC3212]'
    description = 'A value that represents a type of address for a\n         Traffic Engineered (TE) Tunnel hop.\n         \n         unknown(0) An unknown address type. This value\n         MUST be used if the value of the\n         corresponding TeHopAddress object is a\n         zero-length string. It may also be\n         used to indicate a TeHopAddress which\n         is not in one of the formats defined\n         below.\n         \n         ipv4(1) An IPv4 network address as defined by\n         the InetAddressIPv4 TEXTUAL-CONVENTION\n         [RFC3291].\n         \n         ipv6(2) A global IPv6 address as defined by\n         the InetAddressIPv6 TEXTUAL-CONVENTION\n         [RFC3291].\n         \n         asnumber(3) An Autonomous System (AS) number as\n         defined by the TeHopAddressAS\n         TEXTUAL-CONVENTION.\n         \n         unnum(4) An unnumbered interface index as\n         defined by the TeHopAddressUnnum\n         TEXTUAL-CONVENTION.\n         \n         lspid(5) An LSP ID for TE Tunnels\n         (RFC3212) as defined by the\n         MplsLSPID TEXTUAL-CONVENTION.\n         -- private Addition\n         unnumv6(6) An unnumbered IPv6 interface index as\n         defined by the TeHopAddressUnnumV6\n         TEXTUAL-CONVENTION.\n         \n         \n         -- End private Addition\n         \n         Each definition of a concrete TeHopAddressType\n         value must be accompanied by a definition\n         of a TEXTUAL-CONVENTION for use with that\n         TeHopAddress.\n         \n         To support future extensions, the TeHopAddressType\n         TEXTUAL-CONVENTION SHOULD NOT be sub-typed in\n         object type definitions. It MAY be sub-typed in\n         compliance statements in order to require only a\n         subset of these address types for a compliant\n         implementation.\n         \n         Implementations must ensure that TeHopAddressType\n         objects and any dependent objects\n         (e.g., TeHopAddress objects) are consistent.\n         An inconsistentValue error must be generated\n         if an attempt to change a TeHopAddressType\n         object would, for example, lead to an\n         undefined TeHopAddress value that is\n         not defined herein. In particular,\n         TeHopAddressType/TeHopAddress pairs\n         must be changed together if the address\n         type changes (e.g., from ipv6(2) to ipv4(1)).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("asnumber", 3), ("unnum", 4), ("lspid", 5), ("unnumv6", 6))

class MplsOwner(TextualConvention, Integer32):
    description = 'This object indicates the local network\n         management subsystem that originally created\n         the object(s) in question. The values of\n         this enumeration are defined as follows:\n         \n         unknown(1) - the local network management\n         subsystem cannot discern which\n         component created the object.\n         \n         other(2) - the local network management\n         subsystem is able to discern which component\n         created the object, but the component is not\n         listed within the following choices,\n         e.g., command line interface (cli).\n         \n         snmp(3) - The Simple Network Management Protocol\n         was used to configure this object initially.\n         \n         ldp(4) - The Label Distribution Protocol was\n         used to configure this object initially.\n         \n         crldp(5) - The Constraint-Based Label Distribution\n         Protocol was used to configure this object\n         initially.\n         \n         rsvpTe(6) - The Resource Reservation Protocol was\n         used to configure this object initially.\n         \n         policyAgent(7) - A policy agent (perhaps in\n         combination with one of the above protocols) was\n         used to configure this object initially.\n         \n         mplsVpn(8) - This label was configured for MPLS/BGP VPNs\n         as defined in RFC2547.\n         \n         cli(9) - The CLI was used to configure this object initially.\n         \n         dynamic(10) - The tunnel has been created dynamically.\n         \n         An object created by any of the above choices\n         MAY be modified or destroyed by the same or a\n         different choice.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("snmp", 3), ("ldp", 4), ("crldp", 5), ("rsvpTe", 6), ("policyAgent", 7), ("mplsVpn", 8), ("cli", 9), ("dynamic", 10))

class MplsPathIndex(TextualConvention, Unsigned32):
    description = 'A unique value to index (by Path number) an\n         entry in a table.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class MplsTunnelAffinity(TextualConvention, Unsigned32):
    reference = 'RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         RFC3209, Section 4.7.4.'
    description = 'Describes the configured 32-bit Include-any,\n         include-all, or exclude-all constraint for\n         constraint-based link selection.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class MplsLSPID(TextualConvention, OctetString):
    reference = 'RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         [RFC3209].\n         \n         Constraint-Based LSP Setup using LDP,\n         [RFC3212].'
    description = 'A unique identifier within an MPLS network that is\n         assigned to each LSP. This is assigned at the head\n         end of the LSP and can be used by all LSRs\n         to identify this LSP. This value is piggybacked by\n         the signaling protocol when this LSP is signaled\n         within the network. This identifier can then be\n         used at each LSR to identify which labels are\n         being swapped to other labels for this LSP. This\n         object can also be used to disambiguate LSPs that\n         share the same RSVP sessions between the same\n         source and destination.\n         \n         For LSPs established using CR-LDP, the LSPID is\n         composed of the ingress LSR Router ID (or any of\n         its own IPv4 addresses) and a locally unique\n         CR-LSP ID to that LSR. The first two bytes carry\n         the CR-LSPID, and the remaining 4 bytes carry\n         the Router ID. The LSPID is useful in network\n         management, in CR-LSP repair, and in using\n         an already established CR-LSP as a hop in\n         an ER-TLV.\n         \n         For LSPs signaled using RSVP-TE, the LSP ID is\n         defined as a 16-bit (2 byte) identifier used\n         in the SENDER_TEMPLATE and the FILTER_SPEC\n         that can be changed to allow a sender to\n         share resources with itself. The length of this\n         object should only be 2 or 6 bytes. If the length\n         of this octet string is 2 bytes, then it must\n         identify an RSVP-TE LSPID, or it is 6 bytes,\n         it must contain a CR-LDP LSPID.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(2, 2), ValueSizeConstraint(6, 6), ValueSizeConstraint(32, 32), )
class MplsBurstSize(TextualConvention, Unsigned32):
    description = 'The number of octets of MPLS data that the stream\n         may send back-to-back without concern for policing.\n         The value of zero indicates that an implementation\n         does not support Burst Size.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class MplsBitRate(TextualConvention, Unsigned32):
    description = "If the value of this object is greater than zero,\n         then this represents the bandwidth of this MPLS\n         interface (or Label Switched Path) in units of\n         '1,000 bits per second'.\n         \n         The value, when greater than zero, represents the\n         bandwidth of this MPLS interface (rounded to the\n         nearest 1,000) in units of 1,000 bits per second.\n         If the bandwidth of the MPLS interface is between\n         ((n * 1000) - 500) and ((n * 1000) + 499), the value\n         of this object is n, such that n > 0.\n         \n         If the value of this object is 0 (zero), this\n         means that the traffic over this MPLS interface is\n         considered to be best effort."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class MplsExtendedTunnelIdOctetType(TextualConvention, OctetString):
    reference = 'RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         [RFC3209].\n         \n         Constraint-Based LSP Setup using LDP, [RFC3212].'
    description = 'A unique identifier for an MPLS Tunnel. This\n         represents an IPv4 address of the ingress or egress\n         LSR for the tunnel. This value is derived from the\n         Extended Tunnel Id in RSVP or the Ingress Router ID\n         for CR-LDP. Currently, only octet string sizes of\n         4 are supported. String sizes of 16 are reserved for\n         future use.'
    status = 'current'
    displayHint = '1d.1d.1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )
class MplsTunnelStorageType(TextualConvention, Integer32):
    description = 'Same as StorageType from SNMPv2-TC, except with unknown(0).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("unknown", 0), ("other", 1), ("volatile", 2), ("nonVolatile", 3), ("permanent", 4), ("readOnly", 5))

class MplsTunnelInterfaceIndexOrZero(TextualConvention, Integer32):
    description = 'This textual convention is an extension of the\n         IF-MIB::InterfaceIndex convention. The latter defines a greater\n         than zero value used to identify an interface or interface\n         sub-layer in the managed system. This extension permits the\n         additional value of zero. The value zero is object-specific\n         and must therefore be defined as part of the description of\n         any object which uses this syntax. Examples of the usage of\n         zero might include situations where interface was unknown,\n         or when none or all interfaces need to be referenced.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class MplsGeneralizedLabelType(TextualConvention, Integer32):
    description = 'The label types that are defined for Generalized MPLS.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("notValid", 0), ("mplsLabel", 1), ("generalizedLabel", 2), ("wavebandLabel", 3))

class MplsTunnelPrivateDataSyntax(TextualConvention, OctetString):
    description = 'Represents private data field.'
    status = 'current'
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 24)

class MplsTunnelTNAAddress(TextualConvention, OctetString):
    description = 'TNA address of a tunnel.'
    status = 'current'
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 20)

class MplsGeneralizedLabel(TextualConvention, OctetString):
    description = 'This value represents a generalized MPLS Label.\n         The label contents are specific to the label being\n         represented.\n         \n         Wherever an MplsGeneralizedLabel is copied to or from\n         a signaling protocol message, it is copied byte for\n         byte as is. Therefore, if the octet string is\n         intended to represent multibyte values, it encodes\n         those values in network (big-endian) byte order.\n         This interpretation applies in particular to the\n         non-generalized MPLS labels (32 bits) used in ATM, FR\n         and generic MPLS networks.'
    status = 'current'
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class MplsTeObjectReservedTC(TextualConvention, Integer32):
    description = 'TC for mplsTeObjectReserved* objects.'
    status = 'current'
    displayHint = 'd'

mplsTeNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0))
mplsTeObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1))
mplsTeObjectReserved1 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 1), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved1.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved1.setDescription('This object is reserved for future use.')
mplsManTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2), )
if mibBuilder.loadTexts: mplsManTunnelTable.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelTable.setDescription('The mplsManTunnelTable allows new MPLS tunnels to be\n         created between an LSR and a remote endpoint, and\n         existing tunnels to be reconfigured or removed.\n         Note that only point-to-point tunnel segments are\n         supported, although multi-point-to-point and point-\n         to-multi-point connections are supported by an LSR\n         acting as a cross-connect. Each MPLS tunnel can\n         thus have one out-segment originating at this LSR\n         and/or one in-segment terminating at this LSR.\n         \n         To configure tunnels where the ingress and egress routers\n         are identified by IPv6 addresses, the following approach is\n         used.\n         \n         - The mplsManTunnelIngressLSRId and mplsManTunnelEgressLSRId\n         fields are set to 32-bit identifiers for the ingress and\n         egress routers.\n         \n         - mplsManTunnelHopTableIndex must be set to a non-zero value.\n         \n         - The first hop in the hop table for the tunnel path must be\n         set to a global scope IPv6 address of the local router.\n         \n         - The last entry in the hop table must be set to a global\n         scope IPv6 address of the egress router.')
mplsManTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsManTunnelIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsManTunnelInstance"))
if mibBuilder.loadTexts: mplsManTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelEntry.setDescription('An entry in this table represents an MPLS tunnel.\n         An entry can be created by a network administrator\n         or by an SNMP agent as instructed by an MPLS\n         signaling protocol. Whenever a new entry is created\n         with mplsManTunnelIsIf set to true(1), then a\n         corresponding entry is created in ifTable as well\n         (see RFC 2233). The ifType of this entry is\n         mplsTunnel(150).')
mplsManTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32638)))
if mibBuilder.loadTexts: mplsManTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelIndex.setDescription('Uniquely identifies this row.')
mplsManTunnelInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 2), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: mplsManTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelInstance.setDescription('Uniquely identifies an instance of a tunnel. It is\n         useful to identify multiple instances of tunnels\n         for the purposes of backup and parallel tunnels.')
mplsManTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelRowStatus.setDescription('This variable is used to create, modify, and/or\n         delete a row in this table. When a row in this\n         table is in active(1) state, no objects in that row\n         can be modified by the agent except\n         mplsManTunnelAdminStatus, mplsManTunnelRowStatus and\n         mplsManTunnelStorageType.')
mplsManTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 4), MplsExtendedTunnelIdOctetType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelIngressLSRId.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, RFC 3209, December 2001\n         2. Constraint-Based LSP Setup using LDP, Jamoussi\n         (Editor), RFC 3212, January 2002')
if mibBuilder.loadTexts: mplsManTunnelIngressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelIngressLSRId.setDescription('Identity of the ingress LSR associated with this\n         tunnel instance. When the MPLS signalling protocol\n         is rsvp(2) this value SHOULD be equal to the Tunnel\n         Sender Address in the Sender Template object and MAY\n         be equal to the Extended Tunnel Id field in the\n         SESSION object. When the MPLS signalling protocol is\n         crldp(3) this value SHOULD be equal to the Ingress\n         LSR Router ID field in the LSPID TLV object.')
mplsManTunnelEgressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 5), MplsExtendedTunnelIdOctetType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelEgressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelEgressLSRId.setDescription('Identity of the egress LSR associated with this\n         tunnel instance.')
mplsManTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelName.setReference('RFC 2863 - The Interfaces Group MIB, McCloghrie, K.,\n         and F. Kastenholtz, June 2000')
if mibBuilder.loadTexts: mplsManTunnelName.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelName.setDescription('The canonical name assigned to the tunnel. This name\n         can be used to refer to the tunnel on the LSRs\n         console port. Also see the description of ifName\n         in RFC 2863.')
mplsManTunnelDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelDescr.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelDescr.setDescription('A textual string containing information about the\n         tunnel. If there is no description this object\n         contains a zero length string. This object may\n         not be signaled by MPLS signaling protocols,\n         consequentally the value of this object at transit\n         and egress LSRs MAY be automatically generated or\n         absent.')
mplsManTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 8), MplsTunnelInterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsManTunnelIfIndex.setReference('RFC 2863 - The Interfaces Group MIB, McCloghrie, K.,\n         and F. Kastenholtz, June 2000')
if mibBuilder.loadTexts: mplsManTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelIfIndex.setDescription('If mplsManTunnelIsIf is set to true, then this value\n         contains the LSR-assigned ifIndex which corresponds\n         to an entry in the interfaces table. Otherwise\n         this variable should contain the value of zero\n         indicating that a valid ifIndex was not assigned to\n         this tunnel interface.')
mplsManTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelSetupPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, RFC 3209, December 2001\n         2. Constraint-Based LSP Setup using LDP, Jamoussi\n         (Editor), RFC 3212, January 2002')
if mibBuilder.loadTexts: mplsManTunnelSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelSetupPrio.setDescription('Indicates the setup priority of this tunnel.')
mplsManTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelHoldingPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, RFC 3209, December 2001\n         \n         2. Constraint-Based LSP Setup using LDP, Jamoussi\n         (Editor), RFC 3212, January 2002')
if mibBuilder.loadTexts: mplsManTunnelHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelHoldingPrio.setDescription('Indicates the holding priority for this tunnel.')
mplsManTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 11), Bits().clone(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("isPinned", 3), ("recordRoute", 4), ("reserved5", 5), ("bandwidthProtect", 6), ("nodeProtect", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelSessionAttributes.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsManTunnelSessionAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelSessionAttributes.setDescription('This bitmask indicates optional session values for\n         this tunnel. The following describes these bit\n         fields:\n         \n         fastReroute This flag indicates that any tunnel\n         hop may choose to reroute this tunnel without\n         tearing it down. This flag permits transit routers\n         to use a local repair mechanism which may result in\n         violation of the explicit routing of this tunnel.\n         When a fault is detected on an adjacent downstream\n         link or node, a transit router can reroute traffic\n         for fast service restoration.\n         \n         mergingPermitted This flag permits transit routers\n         to merge this session with other RSVP sessions for\n         the purpose of reducing resource overhead on\n         downstream transit routers, thereby providing\n         better network scalability.\n         \n         isPersistent Indicates whether this tunnel should\n         be restored automatically after a failure occurs.\n         \n         isPinned This flag indicates whether the loose-\n         routed hops of this tunnel are to be pinned.\n         \n         recordRoute This flag indicates if the\n         signaling protocol should remember the tunnel path\n         after it has been signaled.\n         \n         -- recordLabels This flag indicates if the\n         -- signaling protocol should record labels as well as\n         -- the tunnel path.\n         \n         bandwidthProtect This flag indicates whether fast reroute\n         bandwidth protection is desired.\n         \n         nodeProtect This flag indicates whether fast reroute\n         node protection is desired.')
mplsManTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsManTunnelLocalProtectInUse.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelLocalProtectInUse.setDescription('Indicates that the local repair mechanism is in use\n         to maintain this tunnel (usually in the face of an\n         outage of the link it was previously routed over).')
mplsManTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 13), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelHopTableIndex.setDescription('Index into the mplsTunnelManHopTable entry that\n         specifies the explicit route hops for this tunnel.\n         This object is meaningful only at the head-end of\n         the tunnel.\n         \n         For UNI tunnels, this field should be set to 0.\n         \n         For tunnels with no configured explicit route hops, this\n         field should be set to 0. In this case, the tunnel is\n         routed using mplsTunnelEgressLSRId.')
mplsManTunnelPathInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 14), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelPathInUse.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelPathInUse.setDescription('This value denotes the configured path that was\n         chosen for this tunnel. This value reflects the\n         secondary index into mplsTunnelManHopTable. This path\n         may not exactly match the one in\n         mplsTunnelARHopTable due to the fact that some CSPF\n         modification may have taken place. See\n         mplsTunnelARHopTable for the actual path being\n         taken by the tunnel. A value of zero denotes that\n         no path is currently in use or available.\n         \n         For UNI tunnels, this field should be set to 0.\n         \n         For tunnels with no configued explicit route hops,\n         this field should be set to 0.')
mplsManTunnelIncludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 15), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelIncludeAnyAffinity.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsManTunnelIncludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelIncludeAnyAffinity.setDescription('A link satisfies the include-any constraint if and\n         only if the constraint is zero, or the link and the\n         constraint have a resource class in common.\n         \n         The field is a bitmask. Every request does not overwrite\n         the previous one. 0 value resets the field.')
mplsManTunnelIncludeAllAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 16), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelIncludeAllAffinity.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsManTunnelIncludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelIncludeAllAffinity.setDescription('A link satisfies the include-all constraint if and\n         only if the link contains all of the administrative\n         groups specified in the constraint.\n         \n         The field is a bitmask. Every request does not overwrite\n         the previous one. 0 value resets the field.')
mplsManTunnelExcludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 17), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelExcludeAnyAffinity.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsManTunnelExcludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelExcludeAnyAffinity.setDescription('A link satisfies the exclude-any constraint if and\n         only if the link contains none of the\n         administrative groups specified in the constraint.\n         \n         The field is a bitmask. Every request does not overwrite\n         the previous one. 0 value resets the field.')
mplsManTunnelAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelAdminStatus.setDescription('Indicates the desired operational status of this\n         tunnel.')
mplsManTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7), ("resignaling", 8), ("suppressed", 9), ("preempted", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsManTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelOperStatus.setDescription('Indicates the actual operational status of this\n         tunnel, which is typically but not limited to, a\n         function of the state of individual segments of\n         this tunnel.')
mplsManTunnelAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 20), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("reserved1", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("labelRecordingDesired", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelAttributes.setReference('RSVP-TE: Extensions to RSVP for LSP Tunnels, Awduche et al.,\n         RFC 3209, December 2001.')
if mibBuilder.loadTexts: mplsManTunnelAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelAttributes.setDescription('This bitmask indicates optional parameters for this tunnel.\n         These bits should be taken in addition to those defined in\n         mplsManTunnelSessionAttributes in order to determine the full set\n         of options to be signaled (for example SESSION_ATTRIBUTES flags\n         in RSVP-TE). The following describes these bitfields:\n         \n         labelRecordingDesired\n         This flag indicates that label information should be included\n         when doing a route record. This bit is not valid unless the\n         recordRoute bit is set in the mplsManTunnelSessionAttributes object.')
mplsManTunnelPathComp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dynamicFull", 1), ("explicit", 2), ("dynamicPartial", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelPathComp.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelPathComp.setDescription('This value instructs the source node on how to perform path\n         computation on the explicit route specified by the associated\n         entries in the mplsTunnelManHopTable.\n         \n         dynamicFull\n         The user specifies at least the source and\n         destination of the path and expects that the CSPF\n         will calculate the remainder of the path.\n         \n         explicit\n         The user specifies the entire path for the tunnel to\n         take. This path may contain strict or loose hops.\n         Evaluation of the explicit route will be performed\n         hop by hop through the network.\n         \n         dynamicPartial\n         The user specifies at least the source and\n         destination of the path and expects that the CSPF\n         will calculate the remainder of the path. The path\n         computed by CSPF is allowed to be only partially\n         computed allowing the remainder of the path to be\n         filled in across the network.\n         \n         This object deprecates mplsTunnelManHopEntryPathComp.')
mplsManTunnelFastRerouteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noFastReroute", 0), ("detourFastReroute", 1), ("facilityFastReroute", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelFastRerouteMode.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelFastRerouteMode.setDescription('Indicates whether or not this tunnel should be protected\n         by a fast reroute mechanism, and if so which method should\n         be used.\n         noFastReroute - no fast reroute protection.\n         detourFastReroute - fast reroute protection using the\n         one-to-one detour backup method.\n         facilityFastReroute - fast reroute protection using the\n         facility backup method.\n         Fast reroute is only available for uni-directional LSPs.')
mplsManTunnelBackupSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelBackupSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelBackupSetupPrio.setDescription('Setup priority for backup tunnels set up to protect this\n         tunnel. This field is only valid if the mplsManTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsManTunnelBackupHoldingPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelBackupHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelBackupHoldingPrio.setDescription('Holding priority for backup tunnels set up to protect this\n         tunnel. This field is only valid if the mplsManTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsManTunnelBackupIncAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 25), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelBackupIncAny.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelBackupIncAny.setDescription('Include-any resource affinity for backup tunnels set up to\n         protect this tunnel.\n         A link satisfies the include-any constraint if and only if\n         the constraint is zero, or the link and the constraint\n         have a resource class in common.\n         This field is only valid if the mplsManTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsManTunnelBackupIncAll = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 26), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelBackupIncAll.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelBackupIncAll.setDescription('Include-all resource affinity for backup tunnels set up to\n         protect this tunnel.\n         A link satisfies the include-all constraint if and only if\n         the link contains all of the adminstrative groups\n         specified in the constraint.\n         This field is only valid if the mplsManTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsManTunnelBackupExcAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 27), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelBackupExcAny.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelBackupExcAny.setDescription('Exclude-any resource affinity for backup tunnels set up to\n         protect this tunnel.\n         A link satisfies the exclude-any constraint if and only if\n         the constraint is zero, or the link and the constraint\n         have a resource class in common.\n         This field is only valid if the mplsManTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsManTunnelBackupBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 28), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelBackupBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelBackupBandwidth.setDescription('The estimated bandwidth required for backup tunnels, in\n         units of 1000 bits/second. A value of zero indicates\n         best-effort.\n         This field is only valid if the mplsManTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsManTunnelBackupMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelBackupMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelBackupMaxHops.setDescription('The maximum number of extra hops the backup path is\n         allowed to take, from a Point of Local Repair (PLR) to a\n         Merge Point (MP), with PLR and MP excluded in counting.\n         A hop-limit of 0 means only direct links between PLR and MP\n         can be used.\n         This field is only valid if the mplsManTunnelFastRerouteMode\n         above is not noFastReroute.')
mplsManTunnelMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 12288))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelMtu.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelMtu.setDescription('Maximal transfer unit of the tunnel')
mplsManTunnelRebuildTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 31), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelRebuildTimer.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelRebuildTimer.setDescription('Defines a period in minutes (0..1440), after which the tunnel will be unconditionally\n         rebuild. The maximal valid value is 1440 minutes (24 hours)')
mplsManTunnelOperStatusFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 32), Bits().clone(namedValues=NamedValues(("empty", 0), ("tunnelResignalling", 1), ("tunnelSuppressed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsManTunnelOperStatusFlags.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelOperStatusFlags.setDescription('Flags to extend the information of the tunnel state\n         For the behaviour - bits meaning:\n         tunnelResignalling (1) - This status shows that currently the tunnel\n         has been resignalled. The resignalling state of a tunnel\n         should be considered together with the mplsManTunnelOperStatus\n         attribute value of the same tunnel.\n         tunnelSuppressed (2) - This status shows that the tunnel has\n         been established, but a higher priority tunnel is active\n         and in use. This tunnel can be activated, once the higher\n         protocol tunnel fails by any reason, and in this case\n         the tunnelSuppressed status will be cleared.')
mplsManTunnelGuardedDest = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 33), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelGuardedDest.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelGuardedDest.setDescription('The guarded destination object specifies which IP destination address the current\n         tunnel protects used with the fast reroute feature.\n         The tunnel must not be fast reroute enabled.')
mplsManTunnelMBBTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 34), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsManTunnelMBBTimeOut.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelMBBTimeOut.setDescription('Specifies the timer configuration (in minutes) for Make-before-break (MBB).\n         The default value of this object is 10 minutes.')
mplsManTunnelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 35), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsManTunnelOwner.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelOwner.setDescription('Denotes the entity that created and is responsible\n         for managing this tunnel. This column is\n         automatically filled by the agent on creation of a\n         row.')
mplsManTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 36), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsManTunnelARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelARHopTableIndex.setDescription('Index into the mplsTunnelARHopTable entry that\n         specifies the actual hops traversed by the tunnel.\n         This is automatically updated by the agent when the\n         actual hops becomes available.')
mplsManTunnelCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 2, 1, 37), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsManTunnelCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelCHopTableIndex.setDescription('Index into the mplsTunnelCHopTable entry that\n         specifies the computed hops traversed by the\n         tunnel. This is automatically updated by the agent\n         when computed hops become available or when\n         computed hops get modified.')
mplsTeObjectReserved3 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 3), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved3.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved3.setDescription('This object is reserved for future use.')
mplsAutoTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4), )
if mibBuilder.loadTexts: mplsAutoTunnelTable.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelTable.setDescription('Similar to mplsManTunnelTable but for automatic tunnels.')
mplsAutoTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsAutoTunnelIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsAutoTunnelInstance"))
if mibBuilder.loadTexts: mplsAutoTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelEntry.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32639, 32767)))
if mibBuilder.loadTexts: mplsAutoTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 2), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: mplsAutoTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelInstance.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsAutoTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelRowStatus.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 4), MplsExtendedTunnelIdOctetType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelIngressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelIngressLSRId.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelEgressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 5), MplsExtendedTunnelIdOctetType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelEgressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelEgressLSRId.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelName.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelName.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelDescr.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelDescr.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 8), MplsTunnelInterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelIfIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelSetupPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelHoldingPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 11), Bits().clone(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("isPinned", 3), ("recordRoute", 4), ("reserved5", 5), ("bandwidthProtect", 6), ("nodeProtect", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelSessionAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelSessionAttributes.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelLocalProtectInUse.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelLocalProtectInUse.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 14), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelHopTableIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelPathInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 15), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelPathInUse.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelPathInUse.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelIncludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 16), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelIncludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelIncludeAnyAffinity.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelIncludeAllAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 17), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelIncludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelIncludeAllAffinity.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelExcludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 18), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelExcludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelExcludeAnyAffinity.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7), ("resignaling", 8), ("suppressed", 9), ("preempted", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelOperStatus.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 20), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("reserved1", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("labelRecordingDesired", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelAttributes.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelPathComp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dynamicFull", 1), ("explicit", 2), ("dynamicPartial", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelPathComp.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelPathComp.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelFastRerouteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noFastReroute", 0), ("detourFastReroute", 1), ("facilityFastReroute", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelFastRerouteMode.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelFastRerouteMode.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelBackupSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelBackupSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelBackupSetupPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelBackupHoldingPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelBackupHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelBackupHoldingPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelBackupIncAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 25), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelBackupIncAny.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelBackupIncAny.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelBackupIncAll = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 26), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelBackupIncAll.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelBackupIncAll.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelBackupExcAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 27), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelBackupExcAny.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelBackupExcAny.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelBackupBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 28), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelBackupBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelBackupBandwidth.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelBackupMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelBackupMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelBackupMaxHops.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelMtu.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelMtu.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelRebuildTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelRebuildTimer.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelRebuildTimer.setDescription('The period, in seconds, after which the tunnel will be rebuilt.')
mplsAutoTunnelOperStatusFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 32), Bits().clone(namedValues=NamedValues(("empty", 0), ("tunnelResignalling", 1), ("tunnelSuppressed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelOperStatusFlags.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelOperStatusFlags.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelGuardedDest = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 33), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelGuardedDest.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelGuardedDest.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelMBBTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelMBBTimeOut.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelMBBTimeOut.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 35), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelOwner.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelOwner.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 36), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelARHopTableIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsAutoTunnelCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 4, 1, 37), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsAutoTunnelCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelCHopTableIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsTeObjectReserved5 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 5), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved5.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved5.setDescription('This object is reserved for future use.')
mplsDynTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6), )
if mibBuilder.loadTexts: mplsDynTunnelTable.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelTable.setDescription('Similar to mplsManTunnelTable but for dynamic tunnels.')
mplsDynTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsDynTunnelIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsDynTunnelInstance"))
if mibBuilder.loadTexts: mplsDynTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelEntry.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32768, 65535)))
if mibBuilder.loadTexts: mplsDynTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 2), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: mplsDynTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelInstance.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 3), MplsExtendedTunnelIdOctetType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelIngressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelIngressLSRId.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelEgressLSRId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 4), MplsExtendedTunnelIdOctetType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelEgressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelEgressLSRId.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelName.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelName.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelDescr.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelDescr.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 7), MplsTunnelInterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelIfIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelSetupPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelHoldingPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 10), Bits().clone(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("isPinned", 3), ("recordRoute", 4), ("reserved5", 5), ("bandwidthProtect", 6), ("nodeProtect", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelSessionAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelSessionAttributes.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelLocalProtectInUse.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelLocalProtectInUse.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 12), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelHopTableIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelPathInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 13), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelPathInUse.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelPathInUse.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelIncludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 14), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelIncludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelIncludeAnyAffinity.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelIncludeAllAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 15), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelIncludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelIncludeAllAffinity.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelExcludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 16), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelExcludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelExcludeAnyAffinity.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelAdminStatus.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7), ("resignaling", 8), ("suppressed", 9), ("preempted", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelOperStatus.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 19), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("reserved1", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("labelRecordingDesired", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelAttributes.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelPathComp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dynamicFull", 1), ("explicit", 2), ("dynamicPartial", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelPathComp.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelPathComp.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelFastRerouteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noFastReroute", 0), ("detourFastReroute", 1), ("facilityFastReroute", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelFastRerouteMode.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelFastRerouteMode.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelBackupSetupPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelBackupSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelBackupSetupPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelBackupHoldingPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelBackupHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelBackupHoldingPrio.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelBackupIncAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 24), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelBackupIncAny.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelBackupIncAny.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelBackupIncAll = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 25), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelBackupIncAll.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelBackupIncAll.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelBackupExcAny = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 26), MplsTunnelAffinity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelBackupExcAny.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelBackupExcAny.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelBackupBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 27), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelBackupBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelBackupBandwidth.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelBackupMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelBackupMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelBackupMaxHops.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelMtu.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelMtu.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelRebuildTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 30), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelRebuildTimer.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelRebuildTimer.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelOperStatusFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 31), Bits().clone(namedValues=NamedValues(("empty", 0), ("tunnelResignalling", 1), ("tunnelSuppressed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelOperStatusFlags.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelOperStatusFlags.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelGuardedDest = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 32), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelGuardedDest.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelGuardedDest.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelMBBTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelMBBTimeOut.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelMBBTimeOut.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 34), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelOwner.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelOwner.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 35), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelARHopTableIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsDynTunnelCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 6, 1, 36), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsDynTunnelCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelCHopTableIndex.setDescription('See similar object in mplsManTunnelTable.')
mplsTeObjectReserved7 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 7), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved7.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved7.setDescription('This object is reserved for future use.')
mplsTunnelManHopTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8), )
if mibBuilder.loadTexts: mplsTunnelManHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopTable.setDescription('The mplsTunnelManHopTable is used to indicate the\n         hops, strict or loose, for an MPLS tunnel defined\n         in mplsManTunnelTable, when it is established via\n         signaling, for the outgoing direction of the\n         tunnel. Each row in this table is indexed by\n         mplsTunnelManHopListIndex. Each row also has a\n         secondary index mplsTunnelManHopIndex corresponding\n         to the next hop that this row corresponds to. The\n         first row in the table is the first hop after the\n         origination point of the tunnel. In case we want\n         to specify a particular interface on the\n         originating LSR of an outgoing tunnel by which we\n         want packets to exit the LSR, we specify this as\n         the first hop for this tunnel in\n         mplsTunnelManHopTable.')
mplsTunnelManHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelManHopListIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelManHopPathOptionIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelManHopIndex"))
if mibBuilder.loadTexts: mplsTunnelManHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopEntry.setDescription('An entry in this table represents a tunnel hop. An\n         entry is created by a network administrator for\n         signaled ERLSP set up by an MPLS signaling\n         protocol.')
mplsTunnelManHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelManHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopListIndex.setDescription('Primary index into this table identifying a\n         particular explicit route object.')
mplsTunnelManHopPathOptionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelManHopPathOptionIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopPathOptionIndex.setDescription('Secondary index into this table identifying a\n         particular group of hops representing a particular\n         configured path. This is otherwise known as a path\n         option.')
mplsTunnelManHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 3), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelManHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopIndex.setDescription('Secondary index into this table identifying a\n         particular hop.')
mplsTunnelManHopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManHopRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopRowStatus.setDescription('This variable is used to create, modify, and/or\n         delete a row in this table. When a row in this\n         table is in active(1) state, no objects in that row\n         can be modified by the agent except\n         mplsTunnelManHopRowStatus and\n         mplsTunnelManHopStorageType.')
mplsTunnelManHopEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManHopEnable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopEnable.setDescription('Administratively enable or disable the hop.')
mplsTunnelManHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 6), TeHopAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopAddrType.setDescription("The Hop Address Type of this tunnel hop.\n         \n         The value of this object cannot be changed\n         if the value of the corresponding\n         mplsTunnelManHopRowStatus object is 'active'.\n         \n         Note that lspid(5) is a valid option only\n         for tunnels signaled via CRLDP.")
mplsTunnelManHopIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 7), TeHopAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManHopIpAddr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopIpAddr.setDescription("The Tunnel Hop Address for this tunnel hop.\n         \n         The type of this address is determined by the\n         value of the corresponding mplsTunnelManHopAddrType.\n         \n         The value of this object cannot be changed\n         if the value of the corresponding\n         mplsTunnelManHopRowStatus object is 'active'.")
mplsTunnelManHopIpPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManHopIpPrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopIpPrefixLen.setDescription('If mplsTunnelManHopAddrType is set to ipv4(1) or\n         ipv6(2), then this value will contain an\n         appropriate prefix length for the IP address in\n         object mplsTunnelManHopIpAddr. Otherwise this value\n         is irrelevant and should be ignored.')
mplsTunnelManHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopType.setDescription("Denotes whether this tunnel hop is routed in a\n         strict or loose fashion. The value of this object\n         has no meaning if the mplsTunnelManHopInclude object\n         is set to 'false'.")
mplsTunnelManHopInclude = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 8, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManHopInclude.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManHopInclude.setDescription("If this value is set to true, then this indicates\n         that this hop must be included in the tunnel's\n         path. If this value is set to 'false', then this hop\n         must be avoided when calculating the path for this\n         tunnel. The default value of this object is 'true',\n         so that by default all indicated hops are included\n         in the CSPF path computation. If this object is set\n         to 'false' the value of mplsTunnelManHopType should be\n         ignored.")
mplsTeObjectReserved9 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 9), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved9.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved9.setDescription('This object is reserved for future use.')
mplsTunnelAutoHopTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10), )
if mibBuilder.loadTexts: mplsTunnelAutoHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopTable.setDescription('Similar to mplsTunnelManHopTable but for automatic tunnels.')
mplsTunnelAutoHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelAutoHopListIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelAutoHopPathOptionIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelAutoHopIndex"))
if mibBuilder.loadTexts: mplsTunnelAutoHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopEntry.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelAutoHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopListIndex.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopPathOptionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelAutoHopPathOptionIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopPathOptionIndex.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 3), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelAutoHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopIndex.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 4), TeHopAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopAddrType.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 5), TeHopAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoHopIpAddr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopIpAddr.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopIpPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoHopIpPrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopIpPrefixLen.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopType.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTunnelAutoHopInclude = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 10, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoHopInclude.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoHopInclude.setDescription('See similar object in mplsTunnelManHopTable.')
mplsTeObjectReserved11 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 11), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved11.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved11.setDescription('This object is reserved for future use.')
mplsTunnelManResTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12), )
if mibBuilder.loadTexts: mplsTunnelManResTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResTable.setDescription('The mplsTunnelManResTable allows a manager to\n         specify which resources are desired for an MPLS\n         tunnel within the mplsManTunnelTable. This table\n         also allows several tunnels to\n         point to a single entry in this table, implying\n         that these tunnels should share resources.')
mplsTunnelManResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelManResIndex"))
if mibBuilder.loadTexts: mplsTunnelManResEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResEntry.setDescription('An entry in this table represents a set of resources\n         for an MPLS tunnel. An entry can be created by a\n         network administrator or by an SNMP agent as\n         instructed by any MPLS signaling protocol.')
mplsTunnelManResIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1073610751)))
if mibBuilder.loadTexts: mplsTunnelManResIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResIndex.setDescription('Uniquely identifies this row.')
mplsTunnelManResRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManResRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResRowStatus.setDescription('This variable is used to create, modify, and/or\n         delete a row in this table.')
mplsTunnelManResMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1, 3), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManResMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResMaxRate.setDescription('The maximum rate in units of 1000 bits/second.\n         \n         Note that setting mplsTunnelManResMaxRate,\n         mplsTunnelManResMeanRate, and\n         mplsTunnelManResMaxBurstSize to 0 indicates best-effort\n         treatment. This object is copied to an instance of\n         mplsTrafficParamMaxRate in mplsTrafficParamTable the OID\n         of which is copied into the corresponding\n         mplsInSegmentTrafficParamPtr.\n         \n         If the ingress node sets a maximum rate of positive\n         infinity, the egress node will return a value of\n         positive infinity on the MIB GET response. This\n         special value may not be used when setting the maximum\n         rate with this MIB.')
mplsTunnelManResMeanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1, 4), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManResMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResMeanRate.setDescription('The mean rate in units of 1000 bits/second.\n         \n         This object is copied into an instance of\n         mplsTrafficParamMeanRate in the\n         mplsTrafficParamTable. The OID of this table entry\n         is then copied into the corresponding\n         mplsInSegmentTrafficParamPtr.\n         \n         When resource allocation is performed as requested\n         by this TSpec object, it is copied into an entry in\n         mplsTrafficParamTable [LSRMIB]:\n         mplsTunnelInMeanRate to mplsTrafficParamMeanRate.\n         The OID of this entry is copied to\n         mplsInSegmentTrafficParamPtr of the corresponding\n         in-segment entry.')
mplsTunnelManResMaxBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1, 5), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManResMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResMaxBurstSize.setDescription('The maximum burst size in bytes. This object is\n         copied to mplsInSegmentMaxBurstSize of the\n         corresponding in-segment.\n         \n         When resource allocation is performed as requested\n         by this TSpec object, it is copied into an entry in\n         mplsTrafficParamTable [LSRMIB]:\n         mplsTunnelInMaxBurstSize to\n         mplsTrafficParamMaxBurstSize. The OID of this entry\n         is copied to mplsInSegmentTrafficParamPtr of the\n         corresponding in-segment entry.')
mplsTunnelManResMeanBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1, 6), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelManResMeanBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResMeanBurstSize.setDescription('The mean burst size in bytes. The implementations\n         which do not implement this variable must return 0\n         for this value and must not allow a user to set\n         this value.')
mplsTunnelManResExBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 12, 1, 7), MplsBurstSize()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelManResExBurstSize.setReference('CR-LDP Specification, Section 4.3.')
if mibBuilder.loadTexts: mplsTunnelManResExBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManResExBurstSize.setDescription('The Excess burst size in bytes. The implementations\n         which do not implement this variable must return\n         noSuchObject(0) exception for this object and must\n         not allow a user to set this value.')
mplsTeObjectReserved13 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 13), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved13.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved13.setDescription('This object is reserved for future use.')
mplsTunnelAutoResTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14), )
if mibBuilder.loadTexts: mplsTunnelAutoResTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResTable.setDescription('Similar to mplsTunnelManResTable but for automatic tunnels.')
mplsTunnelAutoResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelAutoResIndex"))
if mibBuilder.loadTexts: mplsTunnelAutoResEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResEntry.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelAutoResIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1073610752, 1073741823)))
if mibBuilder.loadTexts: mplsTunnelAutoResIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResIndex.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelAutoResMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14, 1, 2), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoResMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResMaxRate.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelAutoResMeanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14, 1, 3), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoResMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResMeanRate.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelAutoResMaxBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoResMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResMaxBurstSize.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelAutoResMeanBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14, 1, 5), MplsBurstSize()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoResMeanBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResMeanBurstSize.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelAutoResExBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 14, 1, 6), MplsBurstSize()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelAutoResExBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAutoResExBurstSize.setDescription('See similar object in mplsTunnelManResTable.')
mplsTeObjectReserved15 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 15), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved15.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved15.setDescription('This object is reserved for future use.')
mplsTunnelDynResTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16), )
if mibBuilder.loadTexts: mplsTunnelDynResTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResTable.setDescription('Similar to mplsTunnelManResTable but for dynamic tunnels.')
mplsTunnelDynResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelDynResIndex"))
if mibBuilder.loadTexts: mplsTunnelDynResEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResEntry.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelDynResIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1073741824, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelDynResIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResIndex.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelDynResMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1, 2), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelDynResMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResMaxRate.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelDynResMeanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1, 3), MplsBitRate()).setUnits('1000s of bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelDynResMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResMeanRate.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelDynResMaxBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelDynResMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResMaxBurstSize.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelDynResMeanBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1, 5), MplsBurstSize()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelDynResMeanBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResMeanBurstSize.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelDynResExBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1, 6), MplsBurstSize()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelDynResExBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResExBurstSize.setDescription('See similar object in mplsTunnelManResTable.')
mplsTunnelDynResStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 16, 1, 7), MplsTunnelStorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelDynResStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDynResStorageType.setDescription('See similar object in mplsTunnelManResTable.')
mplsTeObjectReserved17 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 17), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved17.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved17.setDescription('This object is reserved for future use.')
mplsTunnelARHopTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 18), )
if mibBuilder.loadTexts: mplsTunnelARHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTable.setDescription('The mplsTunnelARHopTable is used to indicate the\n         hops, strict or loose, for an MPLS tunnel defined in\n         any of the three mplsTunnelTables, as reported by the\n         MPLS signaling protocol, for the outgoing direction of\n         the tunnel. Each row in this table is indexed by\n         mplsTunnelARHopListIndex. Each row also has a\n         secondary index mplsTunnelARHopIndex, corresponding\n         to the next hop that this row corresponds to. The\n         first row in the table is the first hop after the\n         origination point of the tunnel. In case we want\n         to specify a particular interface on the\n         originating LSR of an outgoing tunnel by which we\n         want packets to exit the LSR, we specify this as\n         the first hop for this tunnel in\n         mplsTunnelARHopTable.\n         \n         Please note that since the information necessary to\n         build entries within this table are not provided by\n         some MPLS signaling protocols, implementation of\n         this table is optional. Furthermore, since the\n         information in this table is actually provided by\n         the MPLS signaling protocol after the path has been\n         set-up, the entries in this table are provided only\n         for observation, and hence, all variables in this\n         table are accessible exclusively as read-only.')
mplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 18, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelARHopListIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setDescription('An entry in this table represents a tunnel hop. An\n         entry is created by a network administrator for\n         signaled ERLSP set up by an MPLS signaling\n         protocol.')
mplsTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 18, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setDescription('Primary index into this table identifying a\n         particular recorded hop list.')
mplsTunnelARHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 18, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setDescription('Secondary index into this table identifying the\n         particular hop.')
mplsTunnelARHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 18, 1, 3), TeHopAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setDescription('The Hop Address Type of this tunnel hop.\n         \n         If the type value is set to ipv4(1) or ipv6(2). The tunnel path\n         can be determin using mplsTunnelARHopIpAddr object.\n         mplsTunnelARHopAddrUnnum and mplsTunnelARHopLspId\n         should not be used.\n         \n         If the type value is set to unnum(4) or unnumv6(6). The tunnel path\n         can be determin using mplsTunnelARHopAddrUnnum object.\n         mplsTunnelARHopIpAddr and mplsTunnelARHopLspId\n         should not be used.\n         \n         Note that lspid(5) is a valid option only\n         for tunnels signaled via CRLDP. The tunnel path\n         can be determin using mplsTunnelARHopLspId object.\n         mplsTunnelARHopIpAddr and mplsTunnelARHopAddrUnnum\n         should not be used.\n         \n         Currently only ipv4(1) type is supported')
mplsTunnelARHopIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 18, 1, 4), TeHopAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpAddr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpAddr.setDescription('The Tunnel Hop Address for this tunnel hop.\n         \n         The type of this address is determined by the\n         value of the corresponding mplsTunnelARHopAddrType.\n         If mplsTunnelARHopAddrType is set to ipv4(1) or\n         ipv6(2), then this value contains the LSR Router\n         ID of the unnumbered interface. Otherwise the agent\n         SHOULD set this object to the zero-length string\n         and the manager should ignore this object.')
mplsTeObjectReserved19 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 19), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved19.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved19.setDescription('This object is reserved for future use.')
mplsTunnelCHopTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20), )
if mibBuilder.loadTexts: mplsTunnelCHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopTable.setDescription('The mplsTunnelCHopTable is used to indicate the\n         hops, strict or loose, for an MPLS tunnel defined in\n         any of three mplsManTunnelTables, as computed by a\n         constraint-based routing protocol, based on the\n         mplsTunnelManHopTable for the outgoing direction of\n         the tunnel. Each row in this table is indexed by\n         mplsTunnelCHopListIndex. Each row also has a\n         secondary index mplsTunnelCHopIndex, corresponding\n         to the next hop that this row corresponds to. The\n         first row in the table is the first hop after the\n         origination point of the tunnel. In case we want\n         to specify a particular interface on the\n         originating LSR of an outgoing tunnel by which we\n         want packets to exit the LSR, we specify this as\n         the first hop for this tunnel in\n         mplsTunnelCHopTable.\n         \n         Please note that since the information necessary to\n         build entries within this table may not be\n         supported by some LSRs, implementation of this\n         table is optional. Furthermore, since the\n         information in this table is actually provided by\n         routing protocol after the path has been computed,\n         the entries in this table are provided only for\n         observation, and hence, all variables in this table\n         are accessible exclusively as read-only.')
mplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelCHopListIndex"), (0, "PRVT-MPLS-TE-MIB", "mplsTunnelCHopIndex"))
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setDescription('An entry in this table represents a tunnel hop. An\n         entry in this table is created by a constraint-\n         based routing protocol based on the hops specified\n         in the corresponding mplsTunnelManHopTable.')
mplsTunnelCHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setDescription('Primary index into this table identifying a\n         particular computed hop list.')
mplsTunnelCHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setDescription('Secondary index into this table identifying the\n         particular hop.')
mplsTunnelCHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20, 1, 3), TeHopAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setDescription('The Hop Address Type of this tunnel hop.\n         \n         Note that lspid(5) is a valid option only\n         for tunnels signaled via CRLDP.')
mplsTunnelCHopIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20, 1, 4), TeHopAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpAddr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpAddr.setDescription('The Tunnel Hop Address for this tunnel hop.\n         \n         The type of this address is determined by the\n         value of the corresponding mplsTunnelCHopAddrType.\n         \n         If mplsTunnelCHopAddrType is set to unnum(4) or\n         unnumv6(6), then this value will contain the LSR\n         Router ID of the unnumbered interface. Otherwise\n         the agent should set this object to the zero-length\n         string and the manager SHOULD ignore this object.')
mplsTunnelCHopIpPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpPrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpPrefixLen.setDescription('If mplsTunnelCHopAddrType is set to ipv4(1) or\n         ipv6(2), then this value will contain an\n         appropriate prefix length for the IP address in\n         object mplsTunnelCHopIpAddr. Otherwise this value\n         is irrelevant and should be ignored.')
mplsTunnelCHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 20, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopType.setDescription('Denotes whether this is tunnel hop is routed in a\n         strict or loose fashion.')
mplsTeObjectReserved21 = MibScalar((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 21), MplsTeObjectReservedTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTeObjectReserved21.setStatus('current')
if mibBuilder.loadTexts: mplsTeObjectReserved21.setDescription('This object is reserved for future use.')
prvtMplsTunnelTrapEnableTable = MibTable((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 22), )
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableTable.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableTable.setDescription('The prvtMplsTunnelTrapEnable Table allows a manager to\n         enable or disable TRAPs.')
prvtMplsTunnelTrapEnableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 22, 1), ).setIndexNames((0, "PRVT-TEMIB-ENTITY-MIB", "prvtMplsTeMibEntityIndex"))
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableEntry.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableEntry.setDescription('An entry in this table is used to configure trap support for this\n         instance of TE-MIB')
prvtMplsTunnelTrapEnableValue = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 1, 22, 1, 1), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableValue.setStatus('current')
if mibBuilder.loadTexts: prvtMplsTunnelTrapEnableValue.setDescription('If this object is true, then it enables the\n         generation of mplsTunnelUp and mplsTunnelDown\n         traps, otherwise these traps are not emitted.')
mplsManTunnelUp = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0, 1)).setObjects(("PRVT-MPLS-TE-MIB", "mplsManTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsManTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsManTunnelName"))
if mibBuilder.loadTexts: mplsManTunnelUp.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelUp.setDescription('This notification is generated when a\n         mplsManTunnelOperStatus object for one of the\n         configured tunnels is about to leave the down state\n         and transition into some other state (but not into\n         the notPresent state). This other state is\n         indicated by the included value of\n         mplsManTunnelOperStatus.\n         \n         This structure is the same as the generic\n         AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsManTunnelDown = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0, 2)).setObjects(("PRVT-MPLS-TE-MIB", "mplsManTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsManTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsManTunnelName"))
if mibBuilder.loadTexts: mplsManTunnelDown.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelDown.setDescription('This notification is generated when a\n         mplsManTunnelOperStatus object for one of the\n         configured tunnels is about to enter the down state\n         from some other state (but not from the notPresent\n         state). This other state is indicated by the\n         included value of mplsManTunnelOperStatus.\n         \n         This structure is the same as the generic\n         AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsAutoTunnelUp = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0, 3)).setObjects(("PRVT-MPLS-TE-MIB", "mplsAutoTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsAutoTunnelName"))
if mibBuilder.loadTexts: mplsAutoTunnelUp.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelUp.setDescription('This notification is generated when a\n         mplsAutoTunnelOperStatus object for one of the\n         configured tunnels is about to leave the down state\n         and transition into some other state (but not into\n         the notPresent state). This other state is\n         indicated by the included value of\n         mplsAutoTunnelOperStatus.\n         \n         This structure is the same as the generic\n         AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsAutoTunnelDown = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0, 4)).setObjects(("PRVT-MPLS-TE-MIB", "mplsAutoTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsAutoTunnelName"))
if mibBuilder.loadTexts: mplsAutoTunnelDown.setStatus('current')
if mibBuilder.loadTexts: mplsAutoTunnelDown.setDescription('This notification is generated when a\n         mplsAutoTunnelOperStatus object for one of the\n         configured tunnels is about to enter the down state\n         from some other state (but not from the notPresent\n         state). This other state is indicated by the\n         included value of mplsAutoTunnelOperStatus.\n         \n         This structure is the same as the generic\n         AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsDynTunnelUp = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0, 5)).setObjects(("PRVT-MPLS-TE-MIB", "mplsDynTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsDynTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsDynTunnelName"))
if mibBuilder.loadTexts: mplsDynTunnelUp.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelUp.setDescription('This notification is generated when a\n         mplsDynTunnelOperStatus object for one of the\n         configured tunnels is about to leave the down state\n         and transition into some other state (but not into\n         the notPresent state). This other state is\n         indicated by the included value of\n         mplsDynTunnelOperStatus.\n         \n         This structure is the same as the generic\n         AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsDynTunnelDown = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0, 6)).setObjects(("PRVT-MPLS-TE-MIB", "mplsDynTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsDynTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsDynTunnelName"))
if mibBuilder.loadTexts: mplsDynTunnelDown.setStatus('current')
if mibBuilder.loadTexts: mplsDynTunnelDown.setDescription('This notification is generated when a\n         mplsDynTunnelOperStatus object for one of the\n         configured tunnels is about to enter the down state\n         from some other state (but not from the notPresent\n         state). This other state is indicated by the\n         included value of mplsDynTunnelOperStatus.\n         \n         This structure is the same as the generic\n         AMB_MPLS_TUNNEL_TRAP_COMMON.')
mplsManTunnelReoptimized = NotificationType((1, 3, 6, 1, 4, 1, 738, 10, 6, 3, 2, 0, 7)).setObjects(("PRVT-MPLS-TE-MIB", "mplsManTunnelAdminStatus"), ("PRVT-MPLS-TE-MIB", "mplsManTunnelOperStatus"), ("PRVT-MPLS-TE-MIB", "mplsManTunnelARHopTableIndex"), ("PRVT-MPLS-TE-MIB", "mplsManTunnelName"))
if mibBuilder.loadTexts: mplsManTunnelReoptimized.setStatus('current')
if mibBuilder.loadTexts: mplsManTunnelReoptimized.setDescription("This notification is generated when a tunnel is\n         reoptimized. If the mplsTunnelARHopTable is used,\n         then this tunnel instance's entry in the\n         mplsTunnelARHopTable MAY contain the new path for\n         this tunnel some time after this trap is issued by\n         the agent.\n         \n         This structure is the same as the generic\n         AMB_MPLS_TUNNEL_TRAP_COMMON.")
mibBuilder.exportSymbols("PRVT-MPLS-TE-MIB", mplsTunnelDynResMaxBurstSize=mplsTunnelDynResMaxBurstSize, mplsManTunnelCHopTableIndex=mplsManTunnelCHopTableIndex, mplsDynTunnelEntry=mplsDynTunnelEntry, mplsTunnelARHopListIndex=mplsTunnelARHopListIndex, mplsTunnelARHopTable=mplsTunnelARHopTable, MplsGeneralizedLabel=MplsGeneralizedLabel, PYSNMP_MODULE_ID=prvtMplsTeMIB, mplsDynTunnelPathInUse=mplsDynTunnelPathInUse, mplsTunnelCHopAddrType=mplsTunnelCHopAddrType, mplsDynTunnelBackupBandwidth=mplsDynTunnelBackupBandwidth, mplsAutoTunnelARHopTableIndex=mplsAutoTunnelARHopTableIndex, MplsTunnelPrivateDataSyntax=MplsTunnelPrivateDataSyntax, prvtMplsTeMIB=prvtMplsTeMIB, mplsTunnelAutoHopIndex=mplsTunnelAutoHopIndex, mplsAutoTunnelDown=mplsAutoTunnelDown, mplsAutoTunnelBackupHoldingPrio=mplsAutoTunnelBackupHoldingPrio, mplsManTunnelDescr=mplsManTunnelDescr, MplsBitRate=MplsBitRate, TeHopAddress=TeHopAddress, mplsTunnelManHopRowStatus=mplsTunnelManHopRowStatus, mplsManTunnelPathInUse=mplsManTunnelPathInUse, mplsTunnelManHopIndex=mplsTunnelManHopIndex, mplsManTunnelOperStatusFlags=mplsManTunnelOperStatusFlags, mplsManTunnelMBBTimeOut=mplsManTunnelMBBTimeOut, mplsAutoTunnelEntry=mplsAutoTunnelEntry, TeHopAddressType=TeHopAddressType, mplsManTunnelBackupIncAll=mplsManTunnelBackupIncAll, mplsDynTunnelExcludeAnyAffinity=mplsDynTunnelExcludeAnyAffinity, mplsDynTunnelOperStatusFlags=mplsDynTunnelOperStatusFlags, mplsAutoTunnelHoldingPrio=mplsAutoTunnelHoldingPrio, mplsTunnelCHopIndex=mplsTunnelCHopIndex, mplsAutoTunnelCHopTableIndex=mplsAutoTunnelCHopTableIndex, mplsAutoTunnelUp=mplsAutoTunnelUp, mplsManTunnelAttributes=mplsManTunnelAttributes, mplsManTunnelDown=mplsManTunnelDown, mplsTeObjectReserved5=mplsTeObjectReserved5, mplsTunnelCHopEntry=mplsTunnelCHopEntry, mplsTunnelDynResMeanBurstSize=mplsTunnelDynResMeanBurstSize, mplsAutoTunnelName=mplsAutoTunnelName, mplsAutoTunnelIncludeAnyAffinity=mplsAutoTunnelIncludeAnyAffinity, mplsManTunnelMtu=mplsManTunnelMtu, mplsTunnelManHopAddrType=mplsTunnelManHopAddrType, MplsLSPID=MplsLSPID, mplsManTunnelIncludeAnyAffinity=mplsManTunnelIncludeAnyAffinity, mplsManTunnelRebuildTimer=mplsManTunnelRebuildTimer, mplsDynTunnelCHopTableIndex=mplsDynTunnelCHopTableIndex, mplsTunnelAutoHopPathOptionIndex=mplsTunnelAutoHopPathOptionIndex, mplsAutoTunnelExcludeAnyAffinity=mplsAutoTunnelExcludeAnyAffinity, mplsTunnelCHopIpPrefixLen=mplsTunnelCHopIpPrefixLen, mplsTunnelAutoResTable=mplsTunnelAutoResTable, MplsTunnelStorageType=MplsTunnelStorageType, mplsManTunnelIngressLSRId=mplsManTunnelIngressLSRId, mplsManTunnelBackupHoldingPrio=mplsManTunnelBackupHoldingPrio, mplsDynTunnelIndex=mplsDynTunnelIndex, mplsTunnelAutoHopIpPrefixLen=mplsTunnelAutoHopIpPrefixLen, mplsDynTunnelIngressLSRId=mplsDynTunnelIngressLSRId, mplsManTunnelBackupExcAny=mplsManTunnelBackupExcAny, mplsTunnelCHopTable=mplsTunnelCHopTable, mplsTunnelDynResMeanRate=mplsTunnelDynResMeanRate, mplsManTunnelExcludeAnyAffinity=mplsManTunnelExcludeAnyAffinity, mplsTunnelAutoResIndex=mplsTunnelAutoResIndex, prvtMplsTunnelTrapEnableEntry=prvtMplsTunnelTrapEnableEntry, mplsTeObjectReserved1=mplsTeObjectReserved1, mplsDynTunnelBackupIncAll=mplsDynTunnelBackupIncAll, mplsDynTunnelOwner=mplsDynTunnelOwner, mplsAutoTunnelTable=mplsAutoTunnelTable, mplsDynTunnelSetupPrio=mplsDynTunnelSetupPrio, MplsTunnelTNAAddress=MplsTunnelTNAAddress, mplsAutoTunnelOperStatus=mplsAutoTunnelOperStatus, mplsTunnelCHopListIndex=mplsTunnelCHopListIndex, mplsAutoTunnelSetupPrio=mplsAutoTunnelSetupPrio, mplsManTunnelIncludeAllAffinity=mplsManTunnelIncludeAllAffinity, mplsManTunnelAdminStatus=mplsManTunnelAdminStatus, mplsManTunnelGuardedDest=mplsManTunnelGuardedDest, mplsTunnelManResRowStatus=mplsTunnelManResRowStatus, mplsTunnelAutoHopType=mplsTunnelAutoHopType, mplsDynTunnelDescr=mplsDynTunnelDescr, mplsDynTunnelAdminStatus=mplsDynTunnelAdminStatus, mplsManTunnelRowStatus=mplsManTunnelRowStatus, MplsTunnelAffinity=MplsTunnelAffinity, mplsTunnelAutoHopListIndex=mplsTunnelAutoHopListIndex, MplsBurstSize=MplsBurstSize, mplsAutoTunnelLocalProtectInUse=mplsAutoTunnelLocalProtectInUse, mplsTunnelManHopEnable=mplsTunnelManHopEnable, mplsTunnelManResIndex=mplsTunnelManResIndex, mplsDynTunnelInstance=mplsDynTunnelInstance, mplsDynTunnelOperStatus=mplsDynTunnelOperStatus, mplsDynTunnelFastRerouteMode=mplsDynTunnelFastRerouteMode, mplsTunnelDynResTable=mplsTunnelDynResTable, mplsManTunnelBackupIncAny=mplsManTunnelBackupIncAny, mplsAutoTunnelOwner=mplsAutoTunnelOwner, mplsDynTunnelBackupExcAny=mplsDynTunnelBackupExcAny, mplsTeObjectReserved3=mplsTeObjectReserved3, mplsManTunnelPathComp=mplsManTunnelPathComp, mplsDynTunnelDown=mplsDynTunnelDown, mplsTunnelDynResStorageType=mplsTunnelDynResStorageType, prvtMplsTunnelTrapEnableValue=prvtMplsTunnelTrapEnableValue, mplsTeObjectReserved17=mplsTeObjectReserved17, mplsTunnelManHopIpPrefixLen=mplsTunnelManHopIpPrefixLen, mplsAutoTunnelMtu=mplsAutoTunnelMtu, mplsTeObjects=mplsTeObjects, mplsManTunnelBackupBandwidth=mplsManTunnelBackupBandwidth, mplsTunnelManHopListIndex=mplsTunnelManHopListIndex, mplsTunnelAutoResMeanBurstSize=mplsTunnelAutoResMeanBurstSize, mplsManTunnelReoptimized=mplsManTunnelReoptimized, mplsAutoTunnelSessionAttributes=mplsAutoTunnelSessionAttributes, MplsGeneralizedLabelType=MplsGeneralizedLabelType, mplsTunnelARHopIndex=mplsTunnelARHopIndex, mplsManTunnelSetupPrio=mplsManTunnelSetupPrio, mplsAutoTunnelPathInUse=mplsAutoTunnelPathInUse, mplsTunnelManResTable=mplsTunnelManResTable, mplsManTunnelHopTableIndex=mplsManTunnelHopTableIndex, mplsDynTunnelHopTableIndex=mplsDynTunnelHopTableIndex, mplsTunnelARHopEntry=mplsTunnelARHopEntry, mplsManTunnelEgressLSRId=mplsManTunnelEgressLSRId, mplsAutoTunnelMBBTimeOut=mplsAutoTunnelMBBTimeOut, MplsPathIndex=MplsPathIndex, mplsTunnelManHopIpAddr=mplsTunnelManHopIpAddr, mplsTunnelAutoHopTable=mplsTunnelAutoHopTable, mplsAutoTunnelRowStatus=mplsAutoTunnelRowStatus, mplsDynTunnelMBBTimeOut=mplsDynTunnelMBBTimeOut, mplsTunnelAutoResMaxRate=mplsTunnelAutoResMaxRate, mplsTunnelCHopType=mplsTunnelCHopType, mplsDynTunnelUp=mplsDynTunnelUp, MplsTeObjectReservedTC=MplsTeObjectReservedTC, mplsTunnelARHopAddrType=mplsTunnelARHopAddrType, mplsAutoTunnelInstance=mplsAutoTunnelInstance, mplsDynTunnelName=mplsDynTunnelName, mplsAutoTunnelOperStatusFlags=mplsAutoTunnelOperStatusFlags, mplsManTunnelIndex=mplsManTunnelIndex, mplsTunnelAutoResMeanRate=mplsTunnelAutoResMeanRate, mplsTeObjectReserved21=mplsTeObjectReserved21, mplsManTunnelIfIndex=mplsManTunnelIfIndex, mplsTunnelManHopTable=mplsTunnelManHopTable, mplsDynTunnelIncludeAnyAffinity=mplsDynTunnelIncludeAnyAffinity, mplsTunnelAutoHopEntry=mplsTunnelAutoHopEntry, mplsTunnelAutoHopIpAddr=mplsTunnelAutoHopIpAddr, mplsTunnelManHopEntry=mplsTunnelManHopEntry, mplsTunnelDynResEntry=mplsTunnelDynResEntry, mplsAutoTunnelPathComp=mplsAutoTunnelPathComp, mplsAutoTunnelIndex=mplsAutoTunnelIndex, MplsOwner=MplsOwner, MplsExtendedTunnelIdOctetType=MplsExtendedTunnelIdOctetType, MplsTunnelInterfaceIndexOrZero=MplsTunnelInterfaceIndexOrZero, mplsAutoTunnelDescr=mplsAutoTunnelDescr, mplsManTunnelInstance=mplsManTunnelInstance, mplsAutoTunnelFastRerouteMode=mplsAutoTunnelFastRerouteMode, mplsTeObjectReserved7=mplsTeObjectReserved7, mplsTunnelManHopPathOptionIndex=mplsTunnelManHopPathOptionIndex, mplsTunnelManHopInclude=mplsTunnelManHopInclude, mplsDynTunnelHoldingPrio=mplsDynTunnelHoldingPrio, mplsTeObjectReserved19=mplsTeObjectReserved19, mplsTunnelAutoResMaxBurstSize=mplsTunnelAutoResMaxBurstSize, mplsManTunnelARHopTableIndex=mplsManTunnelARHopTableIndex, mplsAutoTunnelBackupIncAll=mplsAutoTunnelBackupIncAll, mplsDynTunnelBackupHoldingPrio=mplsDynTunnelBackupHoldingPrio, mplsManTunnelEntry=mplsManTunnelEntry, mplsManTunnelBackupSetupPrio=mplsManTunnelBackupSetupPrio, mplsTeObjectReserved9=mplsTeObjectReserved9, mplsDynTunnelBackupMaxHops=mplsDynTunnelBackupMaxHops, MplsPathIndexOrZero=MplsPathIndexOrZero, mplsManTunnelFastRerouteMode=mplsManTunnelFastRerouteMode, mplsManTunnelBackupMaxHops=mplsManTunnelBackupMaxHops, mplsDynTunnelEgressLSRId=mplsDynTunnelEgressLSRId, mplsTunnelManResMaxBurstSize=mplsTunnelManResMaxBurstSize, mplsManTunnelOwner=mplsManTunnelOwner, mplsTunnelManResExBurstSize=mplsTunnelManResExBurstSize, mplsTunnelManResEntry=mplsTunnelManResEntry, mplsAutoTunnelGuardedDest=mplsAutoTunnelGuardedDest, mplsManTunnelHoldingPrio=mplsManTunnelHoldingPrio, mplsTeObjectReserved11=mplsTeObjectReserved11, mplsDynTunnelSessionAttributes=mplsDynTunnelSessionAttributes, mplsDynTunnelTable=mplsDynTunnelTable, mplsTunnelAutoResEntry=mplsTunnelAutoResEntry, mplsDynTunnelPathComp=mplsDynTunnelPathComp, mplsDynTunnelLocalProtectInUse=mplsDynTunnelLocalProtectInUse, mplsManTunnelTable=mplsManTunnelTable, mplsAutoTunnelBackupIncAny=mplsAutoTunnelBackupIncAny, mplsDynTunnelRebuildTimer=mplsDynTunnelRebuildTimer, mplsAutoTunnelBackupMaxHops=mplsAutoTunnelBackupMaxHops, mplsTunnelAutoHopInclude=mplsTunnelAutoHopInclude, mplsTunnelManHopType=mplsTunnelManHopType, mplsAutoTunnelHopTableIndex=mplsAutoTunnelHopTableIndex, mplsAutoTunnelAttributes=mplsAutoTunnelAttributes, mplsTunnelAutoResExBurstSize=mplsTunnelAutoResExBurstSize, TeHopAddressAS=TeHopAddressAS, mplsAutoTunnelBackupSetupPrio=mplsAutoTunnelBackupSetupPrio, mplsManTunnelName=mplsManTunnelName, mplsTeNotifications=mplsTeNotifications, prvtMplsTunnelTrapEnableTable=prvtMplsTunnelTrapEnableTable, mplsAutoTunnelBackupExcAny=mplsAutoTunnelBackupExcAny, mplsDynTunnelMtu=mplsDynTunnelMtu, mplsDynTunnelAttributes=mplsDynTunnelAttributes, mplsTunnelCHopIpAddr=mplsTunnelCHopIpAddr, mplsAutoTunnelIngressLSRId=mplsAutoTunnelIngressLSRId, mplsDynTunnelGuardedDest=mplsDynTunnelGuardedDest, mplsManTunnelSessionAttributes=mplsManTunnelSessionAttributes, mplsTunnelDynResExBurstSize=mplsTunnelDynResExBurstSize, mplsDynTunnelARHopTableIndex=mplsDynTunnelARHopTableIndex, MplsTunnelInstanceIndex=MplsTunnelInstanceIndex, mplsTunnelManResMeanRate=mplsTunnelManResMeanRate, mplsAutoTunnelEgressLSRId=mplsAutoTunnelEgressLSRId, TeHopAddressUnnum=TeHopAddressUnnum, mplsManTunnelOperStatus=mplsManTunnelOperStatus, mplsAutoTunnelIncludeAllAffinity=mplsAutoTunnelIncludeAllAffinity, mplsDynTunnelBackupIncAny=mplsDynTunnelBackupIncAny, mplsAutoTunnelIfIndex=mplsAutoTunnelIfIndex, mplsManTunnelLocalProtectInUse=mplsManTunnelLocalProtectInUse, mplsTunnelDynResMaxRate=mplsTunnelDynResMaxRate, mplsDynTunnelIfIndex=mplsDynTunnelIfIndex, mplsAutoTunnelRebuildTimer=mplsAutoTunnelRebuildTimer, mplsDynTunnelIncludeAllAffinity=mplsDynTunnelIncludeAllAffinity, mplsDynTunnelBackupSetupPrio=mplsDynTunnelBackupSetupPrio, mplsAutoTunnelBackupBandwidth=mplsAutoTunnelBackupBandwidth, mplsTunnelManResMeanBurstSize=mplsTunnelManResMeanBurstSize, mplsTeObjectReserved15=mplsTeObjectReserved15, mplsTunnelARHopIpAddr=mplsTunnelARHopIpAddr, mplsManTunnelUp=mplsManTunnelUp, mplsTunnelManResMaxRate=mplsTunnelManResMaxRate, mplsTunnelDynResIndex=mplsTunnelDynResIndex, mplsTeObjectReserved13=mplsTeObjectReserved13, mplsTunnelAutoHopAddrType=mplsTunnelAutoHopAddrType)
