#
# PySNMP MIB module MPOA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/MPOA-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 17:30:34 2022
# On host fv-az126-670 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
lecIndex, = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "lecIndex")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Unsigned32, MibIdentifier, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, enterprises, Gauge32, IpAddress, ModuleIdentity, NotificationType, Integer32, Counter64, Counter32, ObjectIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "MibIdentifier", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "enterprises", "Gauge32", "IpAddress", "ModuleIdentity", "NotificationType", "Integer32", "Counter64", "Counter32", "ObjectIdentity", "TimeTicks")
DisplayString, TimeStamp, RowStatus, MacAddress, TruthValue, TextualConvention, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TimeStamp", "RowStatus", "MacAddress", "TruthValue", "TextualConvention", "TimeInterval")
mpoaMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 8, 1))
mpoaMIB.setRevisions(('1998-11-09 00:00', '1998-05-22 00:00', '1998-02-25 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mpoaMIB.setRevisionsDescriptions(('MPOA v 1.1, Nov 9, 1998\n             Version of the MIB module MPOA-MIB \n             that is contained in the MPOA v1.1 document.\n \n             The difference between af-mpoa-0092.000 and this\n             version is the mpcMpsMacAddressTable has been\n             obsoleted.  The mpcMpsMultipleMacAddressTable\n             has been added.  The mpcMpsMultipleMacAddressTable\n             replaces the mpcMpsMacAddressTable.', 'Final Ballot Version,  May 22, 1998\n             Version of the MIB module MPOA-MIB\n             that is in:  AF-MPOA-0092.000.', 'Straw Ballot Revision 1.0,  February 25, 1998\n \n             Version of the MIB module MPOA-MIB\n             that is in STR-MPOA-MIB-01.01.',))
if mibBuilder.loadTexts: mpoaMIB.setLastUpdated('9811090000Z')
if mibBuilder.loadTexts: mpoaMIB.setOrganization('ATM Forum LANE/MPOA Working Group')
if mibBuilder.loadTexts: mpoaMIB.setContactInfo('The ATM Forum\n             2570 West El Camino Real, Suite 304\n             Mountain View, CA  94040-1313\n             USA\n \n             Tel: +1-650-949-6700\n             Fax: +1-650-949-6705\n \n             Web: http://www.atmforum.com\n             E-mail: info@atmforum.com')
if mibBuilder.loadTexts: mpoaMIB.setDescription('This module defines a portion of the management\n             information base (MIB) for managing Multiprotocol Over\n             ATM clients and servers which was revised based\n             on MPOA Errata contained in MPOA v1.1.\n \n             The difference between af-mpoa-0092.000 and this\n             version is the mpcMpsMacAddressTable has been\n             obsoleted.  The mpcMpsMultipleMacAddressTable\n             has been added.  The mpcMpsMultipleMacAddressTable\n             replaces the mpcMpsMacAddressTable.')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfMpoa = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8))
class AtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity.\n           The address types are: no address (0 octets),\n           E.164 (8 octets), and NSAP (20 octets).\n           Note: The E.164 address is encoded in BCD\n           format.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
class LecIndex(TextualConvention, Integer32):
    description = 'The value of this object identifies the LEC\n                  for which the entry contains management\n                  information.  The value of this object for\n                  a particular LAN Emulation Client (LEC) has\n                  the same value as the lecIndex object, defined\n                  in the LAN-EMULATION-CLIENT MIB, for the same LEC.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class AtmConfigAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity.\n                  The address types are: NSAP SEL Byte (1 octet)\n                  E.164 (8 octets), and NSAP (20 octets).\n                  Note: If the 1 octet NSAP SEL is given, the\n                  other 19 octets of the NSAP are derived\n                  from the system either through ILMI or another method.\n                  Note: The E.164 address is encoded in BCD format.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(1, 1), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
class InternetworkAddrType(TextualConvention, Integer32):
    reference = 'Assigned Numbers, RFC1700, ADDRESS FAMILY NUMBERS'
    description = 'Internetwork Layer Address Types.\n                  Values are defined in Assigned Numbers,\n                  RFC1700. Note: not all of these values make sense in all\n                  contexts where this type is used in this MIB, but they are\n                  included for completeness.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
    namedValues = NamedValues(("other", 0), ("ipV4", 1), ("ipV6", 2), ("nsap", 3), ("hdlc", 4), ("bbn1822", 5), ("ieee802", 6), ("e163", 7), ("e164", 8), ("f69", 9), ("x121", 10), ("ipx", 11), ("appleTalk", 12), ("decnetIV", 13), ("banyanVines", 14), ("e164WithNsap", 15))

class InternetworkAddr(TextualConvention, OctetString):
    description = 'The value of an internetwork layer address.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 60)

class MpcIndex(TextualConvention, Integer32):
    description = 'A unique value, for each MPOA client\n                  which this SNMP agent manages.  It is recommended that\n                  values\n                  are assigned contiguously starting from 1.  The value for\n                  each MPOA Client must remain constant, even if the MPOA\n                  Client or SNMP agent is re-initialized.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MpsIndex(TextualConvention, Integer32):
    description = 'A unique value, for each MPOA Server\n                  which this SNMP agent manages.  It is recommended that\n                  values\n                  are assigned contiguously starting from 1.  The value for\n                  each MPOA Server must remain constant, even if the MPOA\n                  Server or SNMP agent is re-initialized.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

mpoaMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1))
mpoaCommonObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1))
deviceTypeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1), )
if mibBuilder.loadTexts: deviceTypeTable.setReference('Sections:  5.2.3 Device Type TLV, and 4.2 Device Discovery,\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeTable.setStatus('current')
if mibBuilder.loadTexts: deviceTypeTable.setDescription('The device type table\n             represents the mapping of the Lane Data ATM address\n             to the MAC device capability.\n             The unique key is the Lane data ATM address and Lec Index\n             of the LEC associated with the MAC addresses.\n             This table contains information which was\n             gathered from its environment about neighboring\n             machines.\n             This Device type table represents the information of\n             other/remote MPOA devices, discovered/gathered by each MPOA\n             device. This MIB is not the device type of MPS/MPC\n             itself; it is DISCOVERED information.')
deviceTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1, 1), ).setIndexNames((0, "MPOA-MIB", "deviceTypeIndex"))
if mibBuilder.loadTexts: deviceTypeEntry.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeEntry.setStatus('current')
if mibBuilder.loadTexts: deviceTypeEntry.setDescription('An entry in this table and corresponding entries in the\n             deviceTypeMpsMacAddressTable represent a mapping of a MAC device\n             capability (i.e. the set of MAC addresses from a device) to the\n             LEC ATM Address.')
deviceTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: deviceTypeIndex.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeIndex.setStatus('current')
if mibBuilder.loadTexts: deviceTypeIndex.setDescription("Index into this table and also used as one of the indices for\n             the deviceTypeMpsMacAddressTable.  This index has local\n             significance within the mpoaDeviceGroup.\n             Entries in the `deviceTypeMpsMacAddressTable' which correspond\n             to this index, and have the `deviceTypeType' value of `mps' or\n             `mpsAndMps' are considered to be MPS MAC addresses.")
deviceTypeLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1, 1, 2), LecIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTypeLecIndex.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeLecIndex.setStatus('current')
if mibBuilder.loadTexts: deviceTypeLecIndex.setDescription('LecIndex of LEC that supports this\n             data ATM address')
deviceTypeRemoteLecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1, 1, 3), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTypeRemoteLecAtmAddress.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeRemoteLecAtmAddress.setStatus('current')
if mibBuilder.loadTexts: deviceTypeRemoteLecAtmAddress.setDescription('The ATM address learned by LE ARP.')
deviceTypeType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nonMpoa", 1), ("mps", 2), ("mpc", 3), ("mpsAndMpc", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTypeType.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeType.setStatus('current')
if mibBuilder.loadTexts: deviceTypeType.setDescription('same as the TLV')
deviceTypeMpsAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1, 1, 5), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTypeMpsAtmAddress.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeMpsAtmAddress.setStatus('current')
if mibBuilder.loadTexts: deviceTypeMpsAtmAddress.setDescription('Associated MPS address, zeros for non-MPOA and mpc')
deviceTypeMpcAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 1, 1, 6), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTypeMpcAtmAddress.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeMpcAtmAddress.setStatus('current')
if mibBuilder.loadTexts: deviceTypeMpcAtmAddress.setDescription('Associated MPC address, zeros for non-MPOA & mps')
deviceTypeMpsMacAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 2), )
if mibBuilder.loadTexts: deviceTypeMpsMacAddressTable.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeMpsMacAddressTable.setStatus('current')
if mibBuilder.loadTexts: deviceTypeMpsMacAddressTable.setDescription('This table contains MPS MAC Address information gathered from\n             the MPOA DeviceTypeTLV.')
deviceTypeMpsMacAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 2, 1), ).setIndexNames((0, "MPOA-MIB", "deviceTypeIndex"), (0, "MPOA-MIB", "deviceTypeMpsMacAddress"))
if mibBuilder.loadTexts: deviceTypeMpsMacAddressEntry.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeMpsMacAddressEntry.setStatus('current')
if mibBuilder.loadTexts: deviceTypeMpsMacAddressEntry.setDescription("Each entry represents an MPS MAC Address.  Each entry\n             corresponds to a deviceTypeIndex value for which the\n             deviceTypeType attribute is `mps' or `mpsAndMpc'.")
deviceTypeMpsMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1, 2, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTypeMpsMacAddress.setReference('Section 5.2.3 Device Type TLV\n             MPOA Version 1.0 (Letter Ballot) AF-MPOA-0087.000')
if mibBuilder.loadTexts: deviceTypeMpsMacAddress.setStatus('current')
if mibBuilder.loadTexts: deviceTypeMpsMacAddress.setDescription('MPS MAC address contained in the Device Type TLV which\n             is identified by the deviceTypeIndex in the deviceTypeTable.')
mpcObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2))
mpcNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mpcNextIndex.setStatus('current')
if mibBuilder.loadTexts: mpcNextIndex.setDescription("This object contains an appropriate value to\n             be used for mpcIndex when creating entries in\n             the mpcConfigTable.  The value 0 indicates that\n             no new rows can be created.  Otherwise, it is\n             recommended that values are assigned contiguously,\n             starting from 1.\n \n             MPC creation by a Manager:  To obtain the mpcIndex value\n             for a new entry, the manager issues a management protocol\n             retrieval operation to obtain the current value of this\n             object.  If the value retrieved is 0 (zero), the manager\n             cannot create a row.\n \n             After each retrieval of a non-zero value, the manager\n             should issue a management protocol SET operation using\n             the value just retrieved.  If the SET is successful,\n             the agent should update the value to the next unassigned\n             index, or zero if appropriate.\n \n             NOTE:  the manager may also issue a set on this object\n             with a value of its own choosing.  If the set is successful,\n             the manager may use this value for the mpcIndex. In this\n             case, the agent would update the value to the next\n             unassigned index, or zero if appropriate.\n             The definition of `next unassigned index' is any\n             mpcNextIndex value that has not yet been set by a manager,\n             or reserved by the agent (see next paragraph), since this\n             agent was last re-initialized.\n \n             MPC creation by an Agent:  When a row in the\n             mpcConfigTable is created by an agent, the agent should\n             reserve the value of the index by updating the value of\n             this object to the next unassigned index\n             or zero if appropriate.  Thus, a manager will not\n             be able to set an index reserved by an agent.\n \n             In the situation of an agent re-initialization,  all currently\n             used mpcIndexes must be preserved.\n             In other words, the Agent should store in non-volatile memory\n             all of the currently used mpcIndexes (along with all necessary\n             configuration information from the mpcConfigTable).  When the\n             agent is re-initialized, the mpcNextIndex value is\n             any valid Integer32 value which is not being used\n             as an mpcIndex, except 0 which maintains its original\n             definition of indicating that a row cannot be created.")
mpcConfigTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2), )
if mibBuilder.loadTexts: mpcConfigTable.setStatus('current')
if mibBuilder.loadTexts: mpcConfigTable.setDescription('The MPOA Client Configuration Table.\n             This table contains configuration information\n             for all MPOA Clients which this agent manages.')
mpcConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1), ).setIndexNames((0, "MPOA-MIB", "mpcIndex"))
if mibBuilder.loadTexts: mpcConfigEntry.setStatus('current')
if mibBuilder.loadTexts: mpcConfigEntry.setDescription('MPOA Client Configuration Entry.\n             Each entry contains configuration information\n             for one MPOA Client.  The configuration information, including\n             the mpcIndex, must be restored after a re-initialization of an\n             MPC or a re-initialization of the SNMP agent.')
mpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 1), MpcIndex())
if mibBuilder.loadTexts: mpcIndex.setStatus('current')
if mibBuilder.loadTexts: mpcIndex.setDescription("A value which uniquely identifies this conceptual\n             row in the mpcConfigTable.  The `mpcNextIndex' object\n             needs to be used to determine the value of this object.\n             A row cannot be added, unless the mpcCtrlAtmAddress is unique.\n             In the event of either an MPC re-initialization or an agent\n             re-initialization, the value of this mpcIndex must remain the\n             same.  In other words, the row needs to be saved and restored\n             in the event of an MPC or SNMP Agent re-initialization.")
mpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpcRowStatus.setDescription("This object allows creation and deletion of\n             MPOA Clients.\n \n             Within each conceptual mpcConfigTable row, writable objects\n             may be modified, regardless of the value of mpcRowStatus.\n             It is not necessary to set a row's status to `notInService'\n             first.\n \n             A row cannot be created, unless the mpcAtmCtrlAddress\n             in this table is unique.\n             When an MPOA Client is created via this object,\n             it will initially have\n             `mpcActualState' = `initialState'")
mpcConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcConfigMode.setStatus('current')
if mibBuilder.loadTexts: mpcConfigMode.setDescription('Indicates whether this MPC should auto-configure\n             the next time it is (re-)initialized.\n             During the (re-)initialization of this MPC, if\n             the mode is automatic(1), the LECS is contacted and\n             requests are made for all MPC-p* parameters.\n             Otherwise, if the mode is manual(2), the values of the\n             configuration parameters are obtained from the\n             mpcConfigTableand the mpcProtocolTable.  In other words, when\n             the MPC is first initialized, it can use the default or\n             configured values from the mpcConfigTable and\n             mpcProtocolTable.  If the mode is manual (2), no further\n             action is required.  If the mode is automatic (1), then\n             the LECS should be contacted and all available MPC-p1\n             to MPC-p6 parameters would be retrieved.\n             These parameters would then overwrite the existing MPC-p1 to\n             MPC-p6 parameters.  The actual values are reflected in the\n             mpcActualTable.')
mpcCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 4), AtmConfigAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcCtrlAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcCtrlAtmAddr.setDescription("The MPC's Control ATM Address.  There exists one\n             Control ATM Address per MPC, therefore, the value\n             of this entry is unique within the table.  The control ATM\n             Address is the address which is used by the MPC in its requests\n             to the MPS.  The value of this object should not change, once\n             created.")
mpcSCSetupFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcSCSetupFrameCount.setStatus('current')
if mibBuilder.loadTexts: mpcSCSetupFrameCount.setDescription('This represents the MPC-p1 Short-cut setup frame count\n             parameter.\n \n             The MPC-p1 value is frames measured over mpcSCFrameTime seconds.\n             Flow detection is protocol independent. i.e. all network layers\n             mpcProtocolEntries for this MPC share the flow rate\n             specification.\n             A value of 1 causes all flows to initiate resolution/shortcut\n             process.')
mpcSCSetupFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcSCSetupFrameTime.setStatus('current')
if mibBuilder.loadTexts: mpcSCSetupFrameTime.setDescription('MPC-p2 Short-cut setup frame time, in seconds.')
mpcInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcInitialRetryTime.setStatus('current')
if mibBuilder.loadTexts: mpcInitialRetryTime.setDescription("MPC-p4 is the initial value for the retry time out\n             period used for timing out MPOA Resolution Requests\n             in seconds.  Retry time consists of this initial\n             time-out (MPC-p4) and a retry multiplier (MPC-c1).\n             If a response is not received, then another request\n             is sent with a timeout of `retry time' * MPC-c1\n             seconds, or until mpcRetryTimeMaximum.")
mpcRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(40)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcRetryTimeMaximum.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: mpcRetryTimeMaximum.setStatus('current')
if mibBuilder.loadTexts: mpcRetryTimeMaximum.setDescription('MPC-p5 cumulative max value for Retry Time (MPC-p4).\n             Retries are attempted at intervals determined by the\n             algorithm described in the definition of mpcIntialRetryTime.')
mpcHoldDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1200)).clone(160)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcHoldDownTime.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Section 4.1.2.1 MPC Parameters')
if mibBuilder.loadTexts: mpcHoldDownTime.setStatus('current')
if mibBuilder.loadTexts: mpcHoldDownTime.setDescription('MPC-p6 Hold Down Time\n             Minimum time to wait before reinitiating\n             a failed resolution attempt.  Default is\n             mpcRetryTimeMaximum * 4.')
mpcActualTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3), )
if mibBuilder.loadTexts: mpcActualTable.setStatus('current')
if mibBuilder.loadTexts: mpcActualTable.setDescription('MPOA Client Actual Table.\n             A read-only table which contains state\n             information and reflects the actual values which\n             these MPOA Clients are using.  The actual\n             values may differ from the configured values.\n             For example, the mpcConfigMode takes affect\n             only during (re-)initialization of the MPC.\n             The MPC-p1 to MPC-p6 parameters may differ\n             from the configured values because, if the\n             MPC was (re-)initialized and the mpcConfigMode\n             was set to automatic (1) then some, perhaps all,\n             of the MPC-p1 to MPC-p6 parameters were retrieved\n             from the LECS and the values from the LECS may\n             differ from the configured/default values of the\n             mpcConfigTable.  NOTE:  after re-initialization\n             a set to an object in the mpcConfigTable which\n             changes the value of the object will be reflect\n             in this Table, except for a set to the\n             mpcConfigMode which takes effect only during\n             re-initialization.')
mpcActualEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1), )
mpcConfigEntry.registerAugmentions(("MPOA-MIB", "mpcActualEntry"))
mpcActualEntry.setIndexNames(*mpcConfigEntry.getIndexNames())
if mibBuilder.loadTexts: mpcActualEntry.setStatus('current')
if mibBuilder.loadTexts: mpcActualEntry.setDescription("An entry in the MPC Actual Table.\n             An entry represents a specific MPOA Client's\n             state information and the actual values\n             which are being used by the MPOA Client.\n             For example, the corresponding mpcConfigEntry contains\n             default and/or configured parameters, if mpcConfigMode was\n             set to manual, then these are the objects values' which are\n             reflected for the mpcActualEntry.  However, if the\n             mpcConfigMode is automatic, then the mpcActualEntry\n             will be all the corresponding mpcConfigEntry's object,\n             excluding any objects which were retrieved from the LECS.\n             In other words, the objects retrieved from the LECS during\n             the (re-)initialization of the MPC overwrite any of the default\n             and/or configured values.\n             NOTE:  any subsequent `set' to the configured values, e.g. an\n             SNMP\n             set operation, which is successful could result in a change to an\n             mpcConfigTable value, and will be reflected in this table as\n             well.")
mpcActualState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("initialState", 2), ("up", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualState.setStatus('current')
if mibBuilder.loadTexts: mpcActualState.setDescription('This object indicates the actual state\n             of the MPOA Client.')
mpcDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mpcDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\n             which any one or more of this MPC's counters\n             experienced a discontinuity.  The relevant counters\n             are the specific instances associated with this\n             MPC.  If discontinuities have not occurred since the\n             last re-initialization of the local management subsystem,\n             then this object contains a zero value.")
mpcActualConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualConfigMode.setStatus('current')
if mibBuilder.loadTexts: mpcActualConfigMode.setDescription('Indicates whether this MPC auto-configured\n             when it was last (re-)initialized.')
mpcActualSCSetupFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualSCSetupFrameCount.setStatus('current')
if mibBuilder.loadTexts: mpcActualSCSetupFrameCount.setDescription('MPC-p1 Short-cut setup frame count.\n             In frames measured over mpcShortcutFrameTime seconds.\n             Flow detection is protocol independent. i.e. all\n             network layers mpcProtocolEntry share the flow rate\n             specification.\n             A value of 1 implies that resolutions for short-cuts\n             are attempted for all flows.')
mpcActualSCSetupFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualSCSetupFrameTime.setStatus('current')
if mibBuilder.loadTexts: mpcActualSCSetupFrameTime.setDescription('Actual MPC-p2 Short-cut setup frame time, in seconds.')
mpcActualInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualInitialRetryTime.setStatus('current')
if mibBuilder.loadTexts: mpcActualInitialRetryTime.setDescription('Actual MPC-p4 is initial value for the\n             retry time out.')
mpcActualRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualRetryTimeMaximum.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: mpcActualRetryTimeMaximum.setStatus('current')
if mibBuilder.loadTexts: mpcActualRetryTimeMaximum.setDescription('MPC-p5 cumulative maximum value for Retry Time (MPC-p4).\n             Retries are attempted at intervals determined by the\n             algorithm described in the definition of\n             mpcActualInitialRetryTime.')
mpcActualHoldDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualHoldDownTime.setStatus('current')
if mibBuilder.loadTexts: mpcActualHoldDownTime.setDescription('MPC-p6 Hold Down Time\n             Minimum time to wait before reinitiating a failed\n             resolution attempt.  The default value is\n             mpcRetryTimeMaximum * 4.')
mpcDataAtmAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 4), )
if mibBuilder.loadTexts: mpcDataAtmAddressTable.setStatus('current')
if mibBuilder.loadTexts: mpcDataAtmAddressTable.setDescription('A table which shows all the data ATM addresses\n             associated with  all MPOA Clients.')
mpcDataAtmAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 4, 1), ).setIndexNames((0, "MPOA-MIB", "mpcIndex"), (0, "MPOA-MIB", "mpcDataAtmAddress"))
if mibBuilder.loadTexts: mpcDataAtmAddressEntry.setStatus('current')
if mibBuilder.loadTexts: mpcDataAtmAddressEntry.setDescription('Each row defines one data ATM address associated with\n             an MPC.  NOTE:  if an MPC has more than one data ATM\n             address then there will be another entry which contains\n             the same mpcIndex subIdentifier, with a different\n             mpcDataAtmAddress.')
mpcDataAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 4, 1, 1), AtmAddr())
if mibBuilder.loadTexts: mpcDataAtmAddress.setStatus('current')
if mibBuilder.loadTexts: mpcDataAtmAddress.setDescription('A data ATM Address which is associated with\n             an MPOA Client specified by the mpcIndex.')
mpcDataAtmAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcDataAtmAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpcDataAtmAddressRowStatus.setDescription("This object allows creation and deletion of\n             an MPOA Client's Data ATM Addresses.  The\n             row can be created/deleted by either an NMS\n             or by the SNMP agent.")
mpcStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5), )
if mibBuilder.loadTexts: mpcStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: mpcStatisticsTable.setDescription('A read-only table which contains statistical\n             information for all MPOA Clients that\n             this agent manages.')
mpcStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1), )
mpcConfigEntry.registerAugmentions(("MPOA-MIB", "mpcStatisticsEntry"))
mpcStatisticsEntry.setIndexNames(*mpcConfigEntry.getIndexNames())
if mibBuilder.loadTexts: mpcStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: mpcStatisticsEntry.setDescription('Each row in this table contains statistics\n             for one MPOA Client.')
mpcStatTxMpoaResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaResolveRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaResolveRequests.setDescription('The number of MPOA Resolve Requests transmitted\n             by this MPC.\n \n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaResolveReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyAcks.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyAcks.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyAcks.setDescription('The number of positively acknowledged MPC\n             Resolved Replies received by this MPC with an MPOA\n             CIE Code of 0x00 (Success).\n             Discontinuities in the value of this counter can occur at\n             re-initialization of the management system, and/or re-\n             initialization\n             of the MPC, and at other times, as indicated by the value of\n             mpcDiscontinuityTime.')
mpcStatRxMpoaResolveReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufECResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufECResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufECResources.setDescription("The number of MPOA Resolution Replies received with\n             an MPOA CIE Code of 0x81, `Insufficient resources to\n             accept egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufSCResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufSCResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufSCResources.setDescription("The number of MPOA Resolution Replies received with\n             an MPOA CIE Code of 0x82, `Insufficient resources to\n             accept the shortcut'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufEitherResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufEitherResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufEitherResources.setDescription("The number of MPOA Resolution Replies received with\n             an MPOA CIE Code of 0x83, `Insufficient resources to\n             accept either shortcut or egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedInetProt.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedInetProt.setDescription("The number of MPOA Resolution Replies received with\n             an MPOA CIE Code of 0x84, `Unsupported Internework\n             Layer protocol'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedMacEncaps.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedMacEncaps.setDescription("The number of MPOA Resolution Replies received with\n             an MPOA CIE Code of 0x85, `Unsupported MAC layer encapsulation'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnspecifiedOther.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnspecifiedOther.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnspecifiedOther.setDescription("The number of MPOA Resolution Replies received with\n             an MPOA CIE Code of 0x88, `Unspecified/Other'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaImpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaImpRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaImpRequests.setDescription('The number of MPOA Cache Imposition Requests received\n             by this MPC.\n             Discontinuities in the value of this counter can occur at re-\n             initialization\n             of the management system, and/or re-initialization of the MPC,\n             and at\n             other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatTxMpoaImpReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyAcks.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyAcks.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyAcks.setDescription("The number of successful MPOA Cache Imposition replies\n             transmitted by this MPC with an MPOA CIE Code of 0x00\n             `Success'.\n             Discontinuities in the value of this counter can occur at re-\n             initialization\n             of the management system, and/or re-initialization of the MPC,\n             and at\n             other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufECResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufECResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufECResources.setDescription("The number of MPOA Cache Imposition Replies transmitted with\n             an MPOA CIE Code of 0x81, `Insufficient resources to\n             accept egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufSCResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufSCResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufSCResources.setDescription("The number of MPOA Imposition Replies transmitted with\n             an MPOA CIE Code of 0x82, `Insufficient resources to\n             accept shortcut'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufEitherResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufEitherResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufEitherResources.setDescription("The number of MPOA Imposition Replies transmitted with\n             an MPOA CIE Code of 0x83, `Insufficient resources to\n             accept either shortcut or egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedInetProt.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedInetProt.setDescription("The number of MPOA Imposition Replies transmitted with\n             an MPOA CIE Code of 0x84, `Unsupported Internetwork Layer\n             protocol'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedMacEncaps.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedMacEncaps.setDescription("The number of MPOA Imposition Replies transmitted with\n             an MPOA CIE Code of 0x85, `Unsupported MAC Layer\n             encapsulation'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnspecifiedOther.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.  Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnspecifiedOther.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnspecifiedOther.setDescription("The number of MPOA Imposition Replies transmitted with\n             an MPOA CIE Code of 0x88, `Unspecified/Other'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaEgressCachePurgeRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaEgressCachePurgeRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaEgressCachePurgeRequests.setDescription('The number of MPOA Egress Cache Purge Requests transmitted\n             by this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaEgressCachePurgeReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaEgressCachePurgeReplies.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaEgressCachePurgeReplies.setDescription('The number of MPOA Egress Cache Purge Replies received by\n             this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaKeepAlives = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaKeepAlives.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaKeepAlives.setDescription('The number of MPOA Keep Alive messages received by this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaTriggers.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaTriggers.setDescription('The number of MPOA Trigger messages received by this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaDataPlanePurges = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaDataPlanePurges.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaDataPlanePurges.setDescription('The number of MPOA Data Plane Purge messages received\n             by this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatTxMpoaDataPlanePurges = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaDataPlanePurges.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaDataPlanePurges.setDescription('The number of MPOA Data Plane Purge messages transmitted\n             by this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxNhrpPurgeRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxNhrpPurgeRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxNhrpPurgeRequests.setDescription('The number of Purge Requests received by this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatTxNhrpPurgeReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxNhrpPurgeReplies.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxNhrpPurgeReplies.setDescription('The number of Purge Replies transmitted by this MPC.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxErrUnrecognizedExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrUnrecognizedExtensions.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrUnrecognizedExtensions.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `Unrecognized Extension'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrLoopDetecteds = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrLoopDetecteds.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrLoopDetecteds.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `Loop Detected'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrProtoAddrUnreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrProtoAddrUnreachables.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrProtoAddrUnreachables.setDescription("The number of Error Indication packets received by this\n             MPC with the error code `Protocol Address Unreachable'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrProtoErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrProtoErrors.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrProtoErrors.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `Protocol Errors'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrSduSizeExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrSduSizeExceededs.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrSduSizeExceededs.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `SDU Size Exceeded'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrInvalidExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrInvalidExtensions.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrInvalidExtensions.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `Invalid Extensions'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrInvalidReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrInvalidReplies.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrInvalidReplies.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `Invalid Reply'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrAuthenticationFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrAuthenticationFailures.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrAuthenticationFailures.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `Authentication Failure'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrHopCountExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrHopCountExceededs.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrHopCountExceededs.setDescription("The number of Error Indication packets received by\n             this MPC with the error code `Hop Count Exceeded'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPC, and at other times,\n             as indicated by the value of mpcDiscontinuityTime.")
mpcProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 6), )
if mibBuilder.loadTexts: mpcProtocolTable.setReference('Multiprotocol Over ATM Version 1.0 (Letter Ballot),\n             Section 4.1.2.1 MPC Parameters')
if mibBuilder.loadTexts: mpcProtocolTable.setStatus('current')
if mibBuilder.loadTexts: mpcProtocolTable.setDescription('List of protocols, per MPC, for which flow\n             detection is enabled')
mpcProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 6, 1), ).setIndexNames((0, "MPOA-MIB", "mpcIndex"), (0, "MPOA-MIB", "mpcFlowDetectProtocol"))
if mibBuilder.loadTexts: mpcProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: mpcProtocolEntry.setDescription("Each row indicates one protocol for which an MPC will\n             do flow detection.  If the LECS was contacted for\n             configuration information, and the Control Octet of\n             the MPC-p3 has the value of 0x01, `Enable', then protocol\n             values retrieved from the LECS are reflected in this\n             table and the mpcLECSValue object will be (1) true.\n             Also, the user or agent can create rows which\n             appropriately correspond to the MPC denoted by mpcIndex,\n             and the mpcLECSValue object will be set to (2) false.\n             NOTE:  if the LECS does not return information for the\n             MPC-p3 parameter, or if in manual mode, the user or\n             agent should create at least one entry for the\n             corresponding MPC.\n             Both, LECS and user and/or agent created rows may\n             exist in this Table.")
mpcFlowDetectProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 6, 1, 1), InternetworkAddrType())
if mibBuilder.loadTexts: mpcFlowDetectProtocol.setStatus('current')
if mibBuilder.loadTexts: mpcFlowDetectProtocol.setDescription('The protocol on which flow detection is performed.\n             If this value was obtained from the LECS then this\n             value is one of the collection of values returned\n             in the MPC-p3 parameter.')
mpcLECSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 6, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcLECSValue.setStatus('current')
if mibBuilder.loadTexts: mpcLECSValue.setDescription('This object reflects if the current entry is due to\n             a retrieval from the LECS or not.  If this entry is\n             due to the LECS, then true(1) is the value for this\n             object, otherwise, false (2).')
mpcProtocolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcProtocolRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpcProtocolRowStatus.setDescription('This object is used by an agent or manager to\n             create, delete or modify a row in this table.')
mpcMappingTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 7), )
if mibBuilder.loadTexts: mpcMappingTable.setStatus('current')
if mibBuilder.loadTexts: mpcMappingTable.setDescription("A table mapping the `lecIndex' values of\n             LANE Clients to the `mpcIndex' values of\n             corresponding MPOA Clients.")
mpcMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 7, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: mpcMappingEntry.setReference('Multiprotocol Over ATM Version 1.0 (Letter Ballot),\n             Section 4.4.')
if mibBuilder.loadTexts: mpcMappingEntry.setStatus('current')
if mibBuilder.loadTexts: mpcMappingEntry.setDescription('Each row defines one lecIndex --> mpcIndex mapping.\n             The mpcIndex that a lecIndex maps to is not\n             necessarily unique (an MPC can  serve many LECs, however,\n             a LEC cannot be served by more than one MPC).')
mpcMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 7, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpcMappingRowStatus.setDescription('This object is used by an agent or manager to create, delete\n             or modify a row in this table.')
mpcMappingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 7, 1, 2), MpcIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcMappingIndex.setStatus('current')
if mibBuilder.loadTexts: mpcMappingIndex.setDescription('The mpcIndex of the MPOA Client that is performing\n             flow detection for the LANE Client represented by\n             the lecIndex.')
mpcMpsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8), )
if mibBuilder.loadTexts: mpcMpsTable.setStatus('current')
if mibBuilder.loadTexts: mpcMpsTable.setDescription('This is a read-only table which contains\n             information about the MPSs that these MPCs\n             know about.')
mpcMpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8, 1), ).setIndexNames((0, "MPOA-MIB", "mpcMpsIndex"))
if mibBuilder.loadTexts: mpcMpsEntry.setStatus('current')
if mibBuilder.loadTexts: mpcMpsEntry.setDescription('A row created by an MPC.  The MPC learns about\n             an MPS and creates a row.')
mpcMpsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8, 1, 1), MpsIndex())
if mibBuilder.loadTexts: mpcMpsIndex.setStatus('current')
if mibBuilder.loadTexts: mpcMpsIndex.setDescription("The MPS's index which is used to identify\n             a row in this table.")
mpcMpsAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcMpsAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcMpsAtmAddr.setDescription('The Control ATM Address of the MPS')
mpcMpsMacAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 9), )
if mibBuilder.loadTexts: mpcMpsMacAddressTable.setStatus('obsolete')
if mibBuilder.loadTexts: mpcMpsMacAddressTable.setDescription("This is a read-only table which contains\n             information about all the MPSs' MAC Addresses\n             that these MPCs know about.")
mpcMpsMacAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 9, 1), ).setIndexNames((0, "MPOA-MIB", "mpcMpsIndex"), (0, "MPOA-MIB", "mpcLecIndex"))
if mibBuilder.loadTexts: mpcMpsMacAddressEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mpcMpsMacAddressEntry.setDescription("A row is created by an MPC.  The MPC learns about an\n             MPS's MAC Address and creates a row.")
mpcLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 9, 1, 1), LecIndex())
if mibBuilder.loadTexts: mpcLecIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mpcLecIndex.setDescription('The lecIndex which represents the associated LEC.')
mpcMpsMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 9, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcMpsMacAddress.setReference('Multiprotocol Over ATM Version 1.0 (Letter Ballot),\n             Section 3.3.3.1')
if mibBuilder.loadTexts: mpcMpsMacAddress.setStatus('obsolete')
if mibBuilder.loadTexts: mpcMpsMacAddress.setDescription('The MAC Address of the MPS.')
mpcIngressCacheTxTotalPackets = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheTxTotalPackets.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTxTotalPackets.setDescription('The total number of packets transmitted over MPC Short Cuts.')
mpcIngressCacheTxTotalOctets = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheTxTotalOctets.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTxTotalOctets.setDescription('The total number of octets transmitted over MPC Short Cuts.')
mpcIngressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12), )
if mibBuilder.loadTexts: mpcIngressCacheTable.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTable.setDescription('This table contains information for MPC Caches for\n             the ingress MPC.')
mpcIngressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1), ).setIndexNames((0, "MPOA-MIB", "mpcIngressCacheDestInetworkAddrType"), (0, "MPOA-MIB", "mpcIngressCacheDestAddr"), (0, "MPOA-MIB", "mpcIndex"), (0, "MPOA-MIB", "mpcMpsIndex"))
if mibBuilder.loadTexts: mpcIngressCacheEntry.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEntry.setDescription("An entry contains control information\n             for a row in a MPC's Ingress Cache.")
mpcIngressCacheDestInetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 1), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheDestInetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheDestInetworkAddrType.setDescription('The type of the destination internetwork layer address.')
mpcIngressCacheDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 2), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheDestAddr.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheDestAddr.setDescription('The destination internetwork layer address for which\n             this entry is defined.')
mpcIngressCachePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCachePrefixLen.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCachePrefixLen.setDescription('Defines an equivalence class of addresses that match\n             Prefix Length bit positions of the destination\n             internetwork layer address.')
mpcIngressCacheDestAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 4), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheDestAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheDestAtmAddr.setDescription('The Destination ATM Address received in the MPOA\n             Resolution Reply.')
mpcIngressCacheSrcAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 5), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheSrcAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheSrcAtmAddr.setDescription('The Source ATM Address for the MPOA Resolution Request.')
mpcIngressCacheEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doesNotExist", 1), ("inactive", 2), ("active", 3), ("negative", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheEntryState.setReference('Multiprotocol Over ATM, Letter Ballot, Appendix I.2.')
if mibBuilder.loadTexts: mpcIngressCacheEntryState.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEntryState.setDescription("The present state of this MPC ingress cache.\n             The states are:\n             doesNotExist (1) -- the state is not yet available\n             inactive (2)     -- state exists, entry is not yet\n                                 active.  For an example, if\n                                 using the Finite State Machine\n                                 Appendix I.2, then the states\n                                 Cached and query are considered\n                                 `inactive'.\n             active (3)       -- state exists, entry is active.\n                                 For an example, if using the\n                                 Finite State Machine in Appendix I.2,\n                                 then the states resolved and refresh\n                                 are considered `active'.\n             negative (4)     -- state exists, entry is negative,\n                                 which could mean a NAK response was\n                                 received, or entry is doing a\n                                 retry, etc.  For example, if using\n                                 the Finite State Machine in Appendix\n                                 I.2, then the state `hold down' is\n                                 considered `negative'.")
mpcIngressCacheEgressCacheTagValid = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTagValid.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTagValid.setDescription('If the value of this object is true(1), then a valid\n             Egress Cache Tag is present and the value of the Egress\n             Cache Tag is in mpcIngressCacheEgressCacheTag.  Otherwise,\n             if this value is false(2), then there was no Egress Cache\n             Tag, and the value of mpcIngressCacheEgressCacheTag is\n             undefined.')
mpcIngressCacheEgressCacheTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTag.setReference('Multiprotocol Over ATM Version 1.0  (Letter Ballot),\n             Section 4.4.4.1.')
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTag.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTag.setDescription('If a valid Egress Cache Tag is present, then this\n             object contains the value of that tag.  To determine\n             if this object contains a valid value,\n             mpcIngressCacheEgressTagValid should be used.')
mpcIngressCacheLastNhrpCieCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheLastNhrpCieCode.setReference('Normative section 4.4.6.1.1 of Multiprotocol Over\n             ATM Version 1.0  (Letter Ballot)')
if mibBuilder.loadTexts: mpcIngressCacheLastNhrpCieCode.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheLastNhrpCieCode.setDescription('The last NHRP CIE code received for this entry.  This\n             value is valid only during the Hold Down period of the\n             cache entry.  This value is undefined otherwise.')
mpcIngressCacheSigErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheSigErrCode.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheSigErrCode.setDescription('Error code or Success of the last sinalling request\n             for this cache entry.')
mpcIngressCacheRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheRetries.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheRetries.setDescription('The current number of times this MPC has issued a\n             resolution request since it received a valid reply.')
mpcIngressCacheTimeUntilNextResolutionRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 12), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheTimeUntilNextResolutionRequest.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTimeUntilNextResolutionRequest.setDescription('The amount of time the MPC\n             must wait before issuing the next resolution request.')
mpcIngressCacheHoldingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 13), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheHoldingTime.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheHoldingTime.setDescription("The time that this MPC's Ingress Cache Entry will remain\n             valid.  If the mpcIngressCacheEntryState is not active\n             this value will be zero.")
mpcIngressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheServiceCategory.setReference('Lane V2 LUNI TLVs. AF-LANE-0084 page 122')
if mibBuilder.loadTexts: mpcIngressCacheServiceCategory.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheServiceCategory.setDescription('The service categories supported for this shortcut.')
mpcEgressCacheRxTotalPackets = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheRxTotalPackets.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheRxTotalPackets.setDescription('This counts the total number of packets\n             received by MPC Short Cuts.')
mpcEgressCacheRxTotalOctets = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheRxTotalOctets.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheRxTotalOctets.setDescription('This counts the total number of octets\n             received by MPC Short Cuts.')
mpcEgressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15), )
if mibBuilder.loadTexts: mpcEgressCacheTable.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheTable.setDescription('This table contains Egress Cache information for\n             all the MPCs which this agent manages.')
mpcEgressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1), ).setIndexNames((0, "MPOA-MIB", "mpcEgressCacheId"), (0, "MPOA-MIB", "mpcIndex"), (0, "MPOA-MIB", "mpcMpsIndex"))
if mibBuilder.loadTexts: mpcEgressCacheEntry.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEntry.setDescription("An entry in the MPOA Client's Egress Cache table.")
mpcEgressCacheId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheId.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheId.setDescription('Cache ID Provided by the MPS in the Cache\n             Imposition Request.')
mpcEgressCacheInetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 2), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheInetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheInetworkAddrType.setDescription('Type of Internetwork Address in this cache entry.')
mpcEgressCacheIDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 3), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheIDestAddr.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheIDestAddr.setDescription('The destination internetwork layer address\n             for which this entry is defined.')
mpcEgressCachePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCachePrefixLen.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCachePrefixLen.setDescription('Defines an equivalence class of addresses that match\n             Prefix Length bit positions of the destination\n             internetwork layer address.')
mpcEgressCacheEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doesNotExist", 1), ("inactive", 2), ("active", 3), ("negative", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheEntryState.setReference('MPOA Letter Ballot, Appendix I.5.')
if mibBuilder.loadTexts: mpcEgressCacheEntryState.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEntryState.setDescription("The present state of this MPC egress cache entry.\n             The states are:\n                  doesNotExist (1) -- the state is not yet available,\n                  inactive (2) -- state exists, entry is not yet active,\n                  active (3)   -- state exists, entry is active.\n                                  For example,if using the Finite State\n                                  Machine in Appendix 1.5,\n                                  the states active and flooding\n                                  are `active' state.\n                  negative (4) -- state exists, entry is negative.\n \n             For example,if using the Finite\n             State Machine in Appendix 1.5,\n             the state purging is `negative'.")
mpcEgressCacheEgressCacheTagValid = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTagValid.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTagValid.setDescription('If the value of this object is true(1), then a valid\n             Egress Cache Tag is present and the value of the Egress\n             Cache Tag is in mpcEgressCacheEgressCacheTag.  Otherwise,\n             if this value is false(2), then there was no Egress\n             Cache Tag, and the value of mpcEgressCacheEgressCacheTag\n             is undefined.')
mpcEgressCacheEgressCacheTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTag.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTag.setDescription('If a valid Egress Cache Tag is present, then this\n             object contains the value of that tag.  To determine\n             if this object contains a valid value,\n             mpcEgressCacheEgressCacheTagValid should be used.')
mpcEgressCacheHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 8), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheHoldTime.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheHoldTime.setDescription('The remaining time for which this entry is valid.')
mpcEgressCacheDataLinkHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheDataLinkHeader.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheDataLinkHeader.setDescription('The DataLink header that the egress client rebuilds\n             the original DataLink packet with.')
mpcEgressCacheIngressMpcDataAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 10), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheIngressMpcDataAtmAddr.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 81.')
if mibBuilder.loadTexts: mpcEgressCacheIngressMpcDataAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheIngressMpcDataAtmAddr.setDescription('The Data ATM Address of the ingress MPC that issued\n             the MPOA Resolution request')
mpcEgressCacheLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 11), LecIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheLecIndex.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheLecIndex.setDescription('This is the lecIndex of the LANE Client that this flow\n             is associated with.  This can be used to get the ELAN\n             name as well as other LANE parameters.')
mpcEgressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheServiceCategory.setReference('Lane V2 LUNI TLVs.  AF-LANE-0084, page 122.')
if mibBuilder.loadTexts: mpcEgressCacheServiceCategory.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheServiceCategory.setDescription('This is a bitmap describing the service categories\n             supported for this shortcut.  This value represents\n             an inclusive OR of the bits:\n \n             bit 1 - if rt-VBR is supported,\n             bit 2 - if nrt-VBR is supported,\n             bit 4 - if ABR is supported,\n             bit 8 - if CBR is supported\n \n             A value of 0 (zero) indicates that UBR is supported.')
mpcMpsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 16))
mpcMpsMultipleMacAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 16, 1), )
if mibBuilder.loadTexts: mpcMpsMultipleMacAddressTable.setStatus('current')
if mibBuilder.loadTexts: mpcMpsMultipleMacAddressTable.setDescription("This is a read-only table which contains\n             information about all the MPSs' MAC Addresses\n             that these MPCs use during flow detection.\n             Note that due to the multinetted case an MPC may learn\n             about more than one MAC address from an MPS,\n             thus there may be more than one MAC address for the\n             same MPC - MPS - LecIndex represented in this\n             Table.  These MacAddresses are differentiated by\n             the mpcMpsMacAddressIndex.")
mpcMpsMultipleMacAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 16, 1, 1), ).setIndexNames((0, "MPOA-MIB", "mpcMpsIndex"), (0, "MPOA-MIB", "mpcFlowDetectLecIndex"), (0, "MPOA-MIB", "mpcMpsMacAddressIndex"))
if mibBuilder.loadTexts: mpcMpsMultipleMacAddressEntry.setStatus('current')
if mibBuilder.loadTexts: mpcMpsMultipleMacAddressEntry.setDescription('A row is created by an MPC.  The MPC learns about a\n             MPS and the one or more MAC Address of the MPS which\n             the MPC uses during flow detection.  Each row represents\n             an MPS MAC Address used by an MPC during flow detection.')
mpcFlowDetectLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 16, 1, 1, 1), LecIndex())
if mibBuilder.loadTexts: mpcFlowDetectLecIndex.setStatus('current')
if mibBuilder.loadTexts: mpcFlowDetectLecIndex.setDescription('The lecIndex which represents the associated LEC.')
mpcMpsMacAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 16, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mpcMpsMacAddressIndex.setStatus('current')
if mibBuilder.loadTexts: mpcMpsMacAddressIndex.setDescription('This value is used to differentiate MAC Addresses from \n             the same MPS used by the same MPC during flow detection.\n             This value should be unique within the scope of this table.')
mpcMpsFlowDetectMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 16, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcMpsFlowDetectMacAddress.setStatus('current')
if mibBuilder.loadTexts: mpcMpsFlowDetectMacAddress.setDescription('An MPS MAC Address used by an MPC during flow detection.')
mpsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3))
mpsNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsNextIndex.setStatus('current')
if mibBuilder.loadTexts: mpsNextIndex.setDescription("This object contains an appropriate value to\n             be used for mpsIndex when creating entries in\n             the mpsConfigTable.  The value 0 indicates that\n             no new rows can be created.  Otherwise, it is\n             recommended that values are assigned contiguously,\n             starting from 1.\n \n             MPS creation by a Manager:  To obtain the mpsIndex\n             value for a new entry, the manager issues a management\n             protocol retrieval operation to obtain the current value\n             of this object.  If the value retrieved is 0 (zero), the\n             manager cannot create a row.\n \n\n             After each retrieval of a non-zero value, the manager\n             should issue a management protocol SET operation using\n             the value just retrieved.  If the SET is successful,\n             the agent should update the value to the next\n             unassigned index, or zero if appropriate.\n \n             NOTE:  the manager may also issue a set on this object\n             with a value of its own choosing.  If the set is successful,\n             the manager may use this value for the mpsIndex. In this\n             case, the agent would update the value to the next\n             unassigned index, or zero if appropriate.\n             The definition of `next unassigned index' is any\n             mpsNextIndex value that has not yet been set by a\n             manager, or reserved by the agent (see next paragraph),\n             since this agent was last re-initialized.\n \n             MPS creation by an Agent:  When a row in the mpsConfigTable is\n             created by an agent, the agent should reserve the value of\n             the index by updating the value of this object to\n             the next unassigned index or zero if appropriate.  Thus, a\n             manager will not be able to set an index reserved by an agent.\n             In the situation of an agent re-initialization all currently\n             used mpsIndexes must be preserved.  In other words, the Agent\n             should store in non-volatile memory  all the currently used\n             mpsIndexes (along with all necessary configuration information\n             from the mpsConfigTable).  When the agent is re-initialized,\n             the mpsNextIndex value is any valid Integer32 which is not\n             being used as an mpsIndex, except 0 which maintains its\n             original definition of indicating that a row cannot be created.")
mpsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2), )
if mibBuilder.loadTexts: mpsConfigTable.setStatus('current')
if mibBuilder.loadTexts: mpsConfigTable.setDescription('The MPOA Server Configuration Table.\n             This table represents the configuration information for\n             all MPOA Servers which this agent manages.')
mpsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1), ).setIndexNames((0, "MPOA-MIB", "mpsIndex"))
if mibBuilder.loadTexts: mpsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: mpsConfigEntry.setDescription('MPOA Server Configuration Entry.\n             Each entry contains configuration information\n             for one MPOA Server.')
mpsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 1), MpsIndex())
if mibBuilder.loadTexts: mpsIndex.setStatus('current')
if mibBuilder.loadTexts: mpsIndex.setDescription("A value which uniquely identifies this conceptual\n             row in the mpsConfigTable.  The `mpsNextIndex' object\n             needs to be used to determine the value of this object.\n             A row cannot be added, unless the mpsCtrlAtmAddress\n             is unique.\n             In the event of an MPS re-initialization, the value\n             of this mpsIndex must remain the same.  However, in\n             the event of an agent re-initialization, this value\n             does not need to be preserved.")
mpsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpsRowStatus.setDescription("This object allows creation and deletion of MPOA Servers.\n             Within each conceptual mpsConfigTable row, objects which are\n             writable may be modified regardless of the value of\n             mpsRowStatus.  It is not necessary to set a row's status\n             to `notInService' first.\n \n             A row cannot be created, unless the mpsAtmCtrlAddress\n             in this table is unique. When an MPOA Server is created\n             via this object, it will initially have\n                  `mpsActualState' = `initialState'.")
mpsConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsConfigMode.setStatus('current')
if mibBuilder.loadTexts: mpsConfigMode.setDescription('Indicates whether this MPS should auto-configure\n             the next time it is (re-)initialized.\n             In automatic(1) mode the LECS is contacted and\n             requests are made for the MPS-p* parameters.\n             In manual(2) mode, the values of the configuration\n             parameters are obtained from the mpsConfigTable\n             and the mpsProtocolTable.')
mpsCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 4), AtmConfigAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsCtrlAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpsCtrlAtmAddr.setDescription("The MPS's Control ATM Address.  There exists one\n             Control ATM Address per MPS, therefore, the value\n             of this entry is unique within the table.")
mpsKeepAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsKeepAliveTime.setStatus('current')
if mibBuilder.loadTexts: mpsKeepAliveTime.setDescription('MPS-p1 Keep-alive time is max interval between\n             the MPS sending MPOA Keep-Alives in seconds.')
mpsKeepAliveLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1000)).clone(35)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsKeepAliveLifeTime.setStatus('current')
if mibBuilder.loadTexts: mpsKeepAliveLifeTime.setDescription('MPS-p2 Keep-Alive Lifetime\n             The length of time an MPC may consider a Keep-Alive\n             valid in seconds.  This value must be at least\n             three times the mpsKeepAliveTime (MPS-p1).')
mpsInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsInitialRetryTime.setStatus('current')
if mibBuilder.loadTexts: mpsInitialRetryTime.setDescription('MPS-p4 is initial value in seconds for the\n             MPOA retry mechanism.')
mpsRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(40)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsRetryTimeMaximum.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: mpsRetryTimeMaximum.setStatus('current')
if mibBuilder.loadTexts: mpsRetryTimeMaximum.setDescription('MPS-p5 cumulative max value in seconds\n             for Retry Time (MPS-p4).')
mpsGiveupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300)).clone(40)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsGiveupTime.setStatus('current')
if mibBuilder.loadTexts: mpsGiveupTime.setDescription('MPS-p6 Give Up Time.\n             Minimum time in seconds to wait before giving up on a\n             pending resolution request.')
mpsDefaultHoldingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsDefaultHoldingTime.setStatus('current')
if mibBuilder.loadTexts: mpsDefaultHoldingTime.setDescription('MPS-p7 Default Holding Time in minutes.\n             The default Holding Time used in NHRP\n             Resolution Replies.  An egress MPS may use\n             local information to determine a more\n             appropriate Holding Time.')
mpsActualTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3), )
if mibBuilder.loadTexts: mpsActualTable.setStatus('current')
if mibBuilder.loadTexts: mpsActualTable.setDescription('A read-only table containing identification, status,\n             and operational information about the MPOA\n             Servers this agent manages.')
mpsActualEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1), )
mpsConfigEntry.registerAugmentions(("MPOA-MIB", "mpsActualEntry"))
mpsActualEntry.setIndexNames(*mpsConfigEntry.getIndexNames())
if mibBuilder.loadTexts: mpsActualEntry.setStatus('current')
if mibBuilder.loadTexts: mpsActualEntry.setDescription("An entry in the MPS Actual Table.\n             An entry represents a specific MPOA Server's\n             status and operation information.")
mpsActualState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("initialState", 2), ("up", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualState.setStatus('current')
if mibBuilder.loadTexts: mpsActualState.setDescription('This object indicates the current operational\n             status of the MPOA Server.')
mpsDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mpsDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\n             which any one or more of this MPS's counters\n             experienced a discontinuity.  The relevant counters\n             are the specific instances associated with this\n             MPS.  If discontinuities have not occurred since the\n             last re-initialization of the local management subsystem,\n             then this object contains a zero value.")
mpsActualConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualConfigMode.setStatus('current')
if mibBuilder.loadTexts: mpsActualConfigMode.setDescription('Indicates whether this MPS auto-configured\n             when it was last (re-)initialized.')
mpsActualKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualKeepAlive.setStatus('current')
if mibBuilder.loadTexts: mpsActualKeepAlive.setDescription('The maximum amount of time in seconds this MPS waits\n             between sending MPOA Keep-Alives.')
mpsActualKeepAliveLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualKeepAliveLifeTime.setStatus('current')
if mibBuilder.loadTexts: mpsActualKeepAliveLifeTime.setDescription('The length of time in seconds this MPS\n             considers a Keep-Alive valid.')
mpsActualInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualInitialRetryTime.setStatus('current')
if mibBuilder.loadTexts: mpsActualInitialRetryTime.setDescription('The actual initial value in seconds for the MPOA\n             retry mechanism.')
mpsActualRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 300)).clone(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualRetryTimeMaximum.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: mpsActualRetryTimeMaximum.setStatus('current')
if mibBuilder.loadTexts: mpsActualRetryTimeMaximum.setDescription('The actual cumulative max value in seconds\n             for Retry Time.')
mpsActualGiveupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300)).clone(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualGiveupTime.setStatus('current')
if mibBuilder.loadTexts: mpsActualGiveupTime.setDescription('Minimum time in seconds that this MPS waits\n             before giving up on a pending resolution request.')
mpsActualDefaultHoldingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsActualDefaultHoldingTime.setStatus('current')
if mibBuilder.loadTexts: mpsActualDefaultHoldingTime.setDescription('The actual Holding Time in minutes used in\n             NHRP Resolution Replies.')
mpsStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4), )
if mibBuilder.loadTexts: mpsStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: mpsStatisticsTable.setDescription('This table represents the statistical information\n             for the MPSs, which this agent manages.')
mpsStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1), )
mpsConfigEntry.registerAugmentions(("MPOA-MIB", "mpsStatisticsEntry"))
mpsStatisticsEntry.setIndexNames(*mpsConfigEntry.getIndexNames())
if mibBuilder.loadTexts: mpsStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: mpsStatisticsEntry.setDescription('Each row in this table contains statistics\n             for one MPOA server.')
mpsStatRxMpoaResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaResolveRequests.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaResolveRequests.setDescription('The number of MPOA Resolve Requests received\n             by this MPS which are translated to NHRP\n             resolve requests.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatTxMpoaResolveReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyAcks.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyAcks.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyAcks.setDescription("The number of MPOA Resolve Replies transmitted by this\n             MPS which contain the MPOA CIE Code of 0x00, `Success'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatTxMpoaResolveReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufECResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufECResources.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufECResources.setDescription("The number of MPOA Resolve Replies transmitted by this MPS\n             which contain the MPOA CIE Code of 0x81, `Insufficient\n             resources to accept egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatTxMpoaResolveReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufSCResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufSCResources.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufSCResources.setDescription("The number of MPOA Resolve Replies transmitted by this MPS\n             which contain the MPOA CIE Code of 0x82,\n             `Insufficient resources to accept shortcut'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatTxMpoaResolveReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufEitherResources.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufEitherResources.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyInsufEitherResources.setDescription("The number of MPOA Resolve Replies transmitted by this MPS\n             which contain the MPOA CIE CODE of 0x83, `Insufficient\n             resources to accept either shortcut or egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatTxMpoaResolveReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnsupportedInetProt.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnsupportedInetProt.setDescription("The number of MPOA Resolve Replies transmitted by this MPS\n             which contain the MPOA CIE CODE of 0x84, `Unsupported\n             Internetwork\n             Layer protocol'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatTxMpoaResolveReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnsupportedMacEncaps.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnsupportedMacEncaps.setDescription("The number of MPOA Resolve Replies transmitted by this MPS\n             which contain the MPOA CIE CODE of 0x85, `Unsupported MAC\n             layer encapsulation'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatTxMpoaResolveReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnspecifiedOther.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnspecifiedOther.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyUnspecifiedOther.setDescription("The number of MPOA Resolve Replies transmitted by this MPS\n             which contain the MPOA CIE CODE of 0x88, `Unspecified/Other'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatTxMpoaResolveReplyOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyOther.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyOther.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaResolveReplyOther.setDescription('The number of MPOA Resolve Replies transmitted by this\n             MPS which are not counted above.  NOTE:  this would\n             include NHRP errors.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatGiveupTimeExpireds = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatGiveupTimeExpireds.setStatus('current')
if mibBuilder.loadTexts: mpsStatGiveupTimeExpireds.setDescription('The number of times the MPS Give up Time (MPS-p6)\n             has expired while waiting for a reply from a\n             re-originated MPOA resolution request, i.e. a\n             reply for a translated NHRP resolution request.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatTxMpoaImpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaImpRequests.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaImpRequests.setDescription('The number of MPOA Cache Imposition Requests\n             transmitted by this MPS.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatRxMpoaImpReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyAcks.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyAcks.setDescription("The number of successful MPOA Cache Imposition Replies\n             received by this MPS which contain an MPOA CIE Code of 0x00,\n             `Success'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatRxMpoaImpReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufECResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufECResources.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufECResources.setDescription("The number of MPOA Cache Imposition Replies received by\n             this MPS which contain the MPOA CIE Code of 0x81,\n             `Insufficient resources to accept egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatRxMpoaImpReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufSCResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufSCResources.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufSCResources.setDescription("The number of MPOA Cache Imposition Replies received by\n             this MPS which contain the MPOA CIE Code of 0x82,\n             `Insufficient resources to accept shortcut'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatRxMpoaImpReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufEitherResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufEitherResources.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyInsufEitherResources.setDescription("The number of MPOA Cache Imposition Replies received by\n             this MPS which contain the MPOA CIE Code of 0x83,\n             `Insufficient resources to accept either shortcut or\n             egress cache entry'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatRxMpoaImpReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnsupportedInetProt.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnsupportedInetProt.setDescription("The number of MPOA Cache Imposition Replies received by\n             this MPS which contain the MPOA CIE Code of 0x84,\n             `Unsupported Internetwork Layer protocol'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatRxMpoaImpReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnsupportedMacEncaps.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnsupportedMacEncaps.setDescription("The number of MPOA Cache Imposition Replies received by\n             this MPS which contain the MPOA CIE Code of 0x85,\n             `Unsupported MAC layer encapsulation'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatRxMpoaImpReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnspecifiedOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnspecifiedOther.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyUnspecifiedOther.setDescription("The number of MPOA Cache Imposition Replies received by\n             this MPS which contain the MPOA CIE Code of 0x88,\n             `Unspecified/Other'.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.")
mpsStatRxMpoaImpReplyOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyOther.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaImpReplyOther.setDescription('The number of MPOA Cache Imposition Replies received by\n             this MPS which are not counted previously.  NOTE:\n             this would include NHRP errors.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatRxMpoaEgressCachePurgeRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxMpoaEgressCachePurgeRequests.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxMpoaEgressCachePurgeRequests.setDescription('The number of MPOA Egress Cache Purges Requests\n             received by this MPS.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatTxMpoaEgressCachePurgeReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaEgressCachePurgeReplies.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaEgressCachePurgeReplies.setDescription('The number of MPOA Egress Cache Purge Replies\n             transmitted by this MPS.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatTxMpoaTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxMpoaTriggers.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Section 4.7.2.1 MPOA Trigger')
if mibBuilder.loadTexts: mpsStatTxMpoaTriggers.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxMpoaTriggers.setDescription('The number of MPOA Trigger messages transmitted by this MPS.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatTxNhrpResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxNhrpResolveRequests.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxNhrpResolveRequests.setDescription('Total count of MPOA Resolution Requests received\n             by the Ingress MPS which were translated to NHRP\n             Resolution Requests and transmitted to the NHS.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatRxNhrpResolveReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxNhrpResolveReplies.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxNhrpResolveReplies.setDescription('Total count of NHRP Resolution Replies received\n             by the Ingress.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatRxNhrpResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatRxNhrpResolveRequests.setStatus('current')
if mibBuilder.loadTexts: mpsStatRxNhrpResolveRequests.setDescription('Total count of NHRP Resolution Requests received by\n             the Egress MPS from the NHS.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsStatTxNhrpResolveReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsStatTxNhrpResolveReplies.setStatus('current')
if mibBuilder.loadTexts: mpsStatTxNhrpResolveReplies.setDescription('Total count of NHRP Resolution Replies transmitted\n             by the Egress MPS to the NHS.\n             Discontinuities in the value of this counter can occur\n             at re-initialization of the management system, and/or\n             re-initialization of the MPS, and at other times,\n             as indicated by the value of mpsDiscontinuityTime.')
mpsProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 5), )
if mibBuilder.loadTexts: mpsProtocolTable.setReference('Multiprotocol Over ATM Version 1.0 (Letter Ballot),\n             Section 4.1.1.1 MPS Parameters')
if mibBuilder.loadTexts: mpsProtocolTable.setStatus('current')
if mibBuilder.loadTexts: mpsProtocolTable.setDescription('List of protocols, per MPS, for which\n             MPOA resolution is enabled.')
mpsProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 5, 1), ).setIndexNames((0, "MPOA-MIB", "mpsIndex"), (0, "MPOA-MIB", "mpsInternetworkLayerProtocol"))
if mibBuilder.loadTexts: mpsProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: mpsProtocolEntry.setDescription("Each row indicates one protocol for which an MPS\n             will perform MPOA resolution.\n             If the LECS was contacted for configuration\n             information, and the MPS-p3's control octet is set to Enable,\n             0x01, then protocol values retrieved from the LECS are reflected\n             in this table and the mpsLECSValue object will be (1) true.\n             Also, the user or agent can create rows which\n             appropriately correspond to the MPS denoted by mpsIndex,\n             and the mpsLECSValue object will be set to (2) false.\n             NOTE:  if the LECS does not return information for\n             the MPS-p3 parameter, or if in manual mode, the user or agent\n             should create at least one entry for the corresponding MPS.\n             Both, LECS and user and/or agent created rows may exist in\n             this Table.")
mpsInternetworkLayerProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 5, 1, 1), InternetworkAddrType())
if mibBuilder.loadTexts: mpsInternetworkLayerProtocol.setStatus('current')
if mibBuilder.loadTexts: mpsInternetworkLayerProtocol.setDescription('MPS-p3 A protocol on which to perform MPOA resolution.')
mpsLECSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 5, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsLECSValue.setStatus('current')
if mibBuilder.loadTexts: mpsLECSValue.setDescription('This object reflects if the current entry is due to\n             a retrieval from the LECS or not.  If this entry is\n             due to the LECS, then true(1) is the value for this object,\n             otherwise, false (2).')
mpsProtocolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsProtocolRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpsProtocolRowStatus.setDescription("This object allows network managers to enable\n             resolution for the `mpsInternetworkLayerProtocol'.")
mpsMappingTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 6), )
if mibBuilder.loadTexts: mpsMappingTable.setStatus('current')
if mibBuilder.loadTexts: mpsMappingTable.setDescription("A table mapping the `lecIndex' values of\n             LANE Clients to the `mpsIndex' values of\n             corresponding MPOA Servers.")
mpsMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 6, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: mpsMappingEntry.setReference('LAN Emulation Client Management Specification.\n             af-lane-0044-000.')
if mibBuilder.loadTexts: mpsMappingEntry.setStatus('current')
if mibBuilder.loadTexts: mpsMappingEntry.setDescription('Each row defines one lecIndex --> mpsIndex mapping.\n             The mpsIndex that a lecIndex maps to is not\n             necessarily unique. In other words, there can be\n             multiple LECs associated with one MPS.')
mpsMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 6, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpsMappingRowStatus.setDescription('Allows creation, enabling/disabling of this row.')
mpsMappingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 6, 1, 2), MpsIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpsMappingIndex.setStatus('current')
if mibBuilder.loadTexts: mpsMappingIndex.setDescription('The mpsMappingIndex of the MPOA Server that is associated with\n             this LEC.  The mpsMappingIndex corresponds to the mpsIndex.')
mpsMpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 9), )
if mibBuilder.loadTexts: mpsMpcTable.setStatus('current')
if mibBuilder.loadTexts: mpsMpcTable.setDescription('This read-only table contains information about the\n             MPCs that these MPSs know about.')
mpsMpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 9, 1), ).setIndexNames((0, "MPOA-MIB", "mpsIndex"), (0, "MPOA-MIB", "mpsMpcIndex"))
if mibBuilder.loadTexts: mpsMpcEntry.setStatus('current')
if mibBuilder.loadTexts: mpsMpcEntry.setDescription('A row created by an MPS.  The MPS learns about the MPC and\n             creates a row.')
mpsMpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 9, 1, 1), MpcIndex())
if mibBuilder.loadTexts: mpsMpcIndex.setStatus('current')
if mibBuilder.loadTexts: mpsMpcIndex.setDescription('The local index for the mpc represented by this entry')
mpsMpcCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 9, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsMpcCtrlAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpsMpcCtrlAtmAddr.setDescription('MPC control ATM address ')
mpsIngressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7), )
if mibBuilder.loadTexts: mpsIngressCacheTable.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheTable.setDescription('This table tracks all the Ingress Cache information\n             of the MPSs which this agents manages.')
mpsIngressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1), ).setIndexNames((0, "MPOA-MIB", "mpsIngressCacheDestInternetworkAddrType"), (0, "MPOA-MIB", "mpsIngressCacheDestAddr"), (0, "MPOA-MIB", "mpsIndex"), (0, "MPOA-MIB", "mpsMpcIndex"))
if mibBuilder.loadTexts: mpsIngressCacheEntry.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheEntry.setDescription("A entry contains parameters and state variables\n             for a row in a MPS's Ingress Cache.")
mpsIngressCacheDestInternetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 1), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheDestInternetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheDestInternetworkAddrType.setDescription('The type of internetwork layer address of the\n             Destination Address.')
mpsIngressCacheDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 2), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheDestAddr.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheDestAddr.setDescription('The Ingress MPS Destination Internetwork Layer Address.')
mpsIngressCachePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCachePrefixLen.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCachePrefixLen.setDescription('The Prefix Length of the mpsIngressCacheDestAddr.')
mpsIngressCacheEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doesNotExist", 1), ("inactive", 2), ("active", 3), ("negative", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheEntryState.setReference('Multiprotocol Over ATM, Letter Ballot, Appendix I.3.')
if mibBuilder.loadTexts: mpsIngressCacheEntryState.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheEntryState.setDescription("The state of this MPS Ingress cache.\n             The states are:\n                  doesNotExist (1) -- the state is not yet available\n                  inactive (2) -- state exists, entry is not yet active\n                                  For example,if using the Finite\n                                  State Machine in Appendix I.3,\n                                  the state resolving is `inactive'.\n                  active (3) -- state exists, entry is active.\n                                For example,if using the Finite\n                                State Machine in Appendix I.3,\n                                the state resolved\n                                is `active' state.\n                  negative (4) -- state exists, entry is negative.\n                                  For example,if using the Finite\n                                  State Machine in Appendix I.3,\n                                  the state purging is `negative'.")
mpsIngressCacheSrcInternetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 5), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheSrcInternetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheSrcInternetworkAddrType.setDescription('The type of internetwork layer address of the\n             Source Address.')
mpsIngressCacheSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 6), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheSrcAddr.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheSrcAddr.setDescription('The Ingress MPS Source Internetwork Layer Address.')
mpsIngressCacheSourceMpcCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 7), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheSourceMpcCtrlAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheSourceMpcCtrlAtmAddr.setDescription("The ATM Address from the source of this MPOA request.\n             In other words, the Ingress MPC's Control Atm Address.")
mpsIngressCacheResolvedAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 8), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheResolvedAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheResolvedAtmAddr.setDescription('The ATM Address which has been resolved by an Egress MPC.')
mpsIngressCacheHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 9), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheHoldTime.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheHoldTime.setDescription('Time interval that this value is valid.')
mpsIngressCacheMpoaRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheMpoaRequestId.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheMpoaRequestId.setDescription('The request ID contained in the MPOA resolution request\n             from the local Ingress MPC.')
mpsIngressCacheNhrpRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheNhrpRequestId.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheNhrpRequestId.setDescription('The request ID which this MPS generates to identify the\n             NHRP resolution request.')
mpsIngressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsIngressCacheServiceCategory.setReference('Lane V2 LUNI TLVs')
if mibBuilder.loadTexts: mpsIngressCacheServiceCategory.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheServiceCategory.setDescription('The service categories supported for this shortcut.')
mpsEgressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8), )
if mibBuilder.loadTexts: mpsEgressCacheTable.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheTable.setDescription('This table contains information regarding the\n             Egress MPOA Server Cache Table.')
mpsEgressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1), ).setIndexNames((0, "MPOA-MIB", "mpsEgressCacheId"), (0, "MPOA-MIB", "mpsIndex"), (0, "MPOA-MIB", "mpsMpcIndex"))
if mibBuilder.loadTexts: mpsEgressCacheEntry.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheEntry.setDescription("An entry represents an entry in the MPS's Egress\n             cache Table which keeps track of the state of the\n             impositions.")
mpsEgressCacheId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheId.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheId.setDescription('The id which identifies this cache entry.')
mpsEgressCacheDestInternetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 2), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheDestInternetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheDestInternetworkAddrType.setDescription('The destination protocol address type.')
mpsEgressCacheDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 3), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheDestAddr.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheDestAddr.setDescription('The destination protocol address.')
mpsEgressCachePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCachePrefixLen.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCachePrefixLen.setDescription('The destination prefix length.')
mpsEgressCacheHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 5), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheHoldTime.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheHoldTime.setDescription('Time interval that this value is valid.')
mpsEgressCacheEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doesNotExist", 1), ("inactive", 2), ("active", 3), ("negative", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheEntryState.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Appendix I.4 Egress MPS Control State Machine.')
if mibBuilder.loadTexts: mpsEgressCacheEntryState.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheEntryState.setDescription("The present states of this MPS egress cache entry.\n             The states are:\n                  doesNotExist (1) -- the state is not yet available\n                  inactive (2) -- state exists, entry is not yet active\n                       For example,if using the Finite\n                       State Machine in Appendix 1.4,\n                       the state imposing is `inactive'.\n                  active (3) -- state exists, entry is active.\n                       For example,if using the Finite\n                       State Machine in Appendix 1.4,\n                       the state imposed\n                       is `active' state.\n                  negative (4) -- state exists, entry is negative.\n                       For example,if using the Finite\n                       State Machine in Appendix 1.4,\n                       the states purging and clearing\n                       are `negative'.")
mpsEgressCacheDataLinkHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheDataLinkHeader.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheDataLinkHeader.setDescription('Data-Link Layer Header.')
mpsEgressCacheElanId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheElanId.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheElanId.setDescription('The elan id that this Cache Imposition is sent on.')
mpsEgressCacheSourceClientAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 9), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheSourceClientAtmAddr.setReference('Multiprotocol Over ATM.  AF-MPOA-0087.000.\n             Page 45.')
if mibBuilder.loadTexts: mpsEgressCacheSourceClientAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheSourceClientAtmAddr.setDescription("The Ingress NHC's Atm Address used in the\n             original cache imposition.")
mpsEgressCacheNhrpRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheNhrpRequestId.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheNhrpRequestId.setDescription('The request id from the original NHRP Resolution Request,\n             may be only useful in the Resolving State.')
mpsEgressCacheMpoaRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheMpoaRequestId.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheMpoaRequestId.setDescription("The new request id which is generated for this imposition's\n             request, may be only useful in the Resolving State.")
mpsEgressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheServiceCategory.setReference('Lane V2 LUNI TLVs')
if mibBuilder.loadTexts: mpsEgressCacheServiceCategory.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheServiceCategory.setDescription('The service categories supported for this shortcut.')
mpsEgressCacheNextHopInternetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 13), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheNextHopInternetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheNextHopInternetworkAddrType.setDescription('The NextHop protocol address type.')
mpsEgressCacheNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 3, 8, 1, 14), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpsEgressCacheNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheNextHopAddr.setDescription('The NextHop protocol address.')
mpoaMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2))
mpoaMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1))
mpoaMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 2))
mpoaMpcMibBasicCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 2, 1)).setObjects(("MPOA-MIB", "mpcConfigGroup"), ("MPOA-MIB", "mpcActualGroup"), ("MPOA-MIB", "mpcDataAtmAddressGroup"), ("MPOA-MIB", "mpcStatisticsGroup"), ("MPOA-MIB", "mpcProtocolGroup"), ("MPOA-MIB", "mpcMpsGroup"), ("MPOA-MIB", "mpcIngressCacheGroup"), ("MPOA-MIB", "mpcEgressCacheGroup"), ("MPOA-MIB", "mpcMpsMultipleMacAddressGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpoaMpcMibBasicCompliance = mpoaMpcMibBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: mpoaMpcMibBasicCompliance.setDescription('The basic implementation requirements for SNMP entities\n             which support MPOA Clients.')
mpoaMpcMibAdvancedCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 2, 2)).setObjects(("MPOA-MIB", "mpoaDeviceTypeGroup"), ("MPOA-MIB", "mpoaDeviceTypeMpsMacGroup"), ("MPOA-MIB", "mpcConfigGroup"), ("MPOA-MIB", "mpcActualGroup"), ("MPOA-MIB", "mpcDataAtmAddressGroup"), ("MPOA-MIB", "mpcStatisticsGroup"), ("MPOA-MIB", "mpcProtocolGroup"), ("MPOA-MIB", "mpcMpsGroup"), ("MPOA-MIB", "mpcIngressCacheTotalPacketGroup"), ("MPOA-MIB", "mpcIngressCacheGroup"), ("MPOA-MIB", "mpcEgressCacheTotalPacketGroup"), ("MPOA-MIB", "mpcEgressCacheGroup"), ("MPOA-MIB", "mpcMpsMultipleMacAddressGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpoaMpcMibAdvancedCompliance = mpoaMpcMibAdvancedCompliance.setStatus('current')
if mibBuilder.loadTexts: mpoaMpcMibAdvancedCompliance.setDescription('The advanced implementation requirements for SNMP entities\n             which support MPOA Clients.')
mpoaMpcMibAdvancedPlusOctetsCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 2, 3)).setObjects(("MPOA-MIB", "mpoaDeviceTypeGroup"), ("MPOA-MIB", "mpoaDeviceTypeMpsMacGroup"), ("MPOA-MIB", "mpcConfigGroup"), ("MPOA-MIB", "mpcActualGroup"), ("MPOA-MIB", "mpcDataAtmAddressGroup"), ("MPOA-MIB", "mpcStatisticsGroup"), ("MPOA-MIB", "mpcProtocolGroup"), ("MPOA-MIB", "mpcMpsGroup"), ("MPOA-MIB", "mpcIngressCacheTotalPacketGroup"), ("MPOA-MIB", "mpcIngressCacheTotalOctetGroup"), ("MPOA-MIB", "mpcIngressCacheGroup"), ("MPOA-MIB", "mpcEgressCacheTotalPacketGroup"), ("MPOA-MIB", "mpcEgressCacheTotalOctetGroup"), ("MPOA-MIB", "mpcEgressCacheGroup"), ("MPOA-MIB", "mpcMpsMultipleMacAddressGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpoaMpcMibAdvancedPlusOctetsCompliance = mpoaMpcMibAdvancedPlusOctetsCompliance.setStatus('current')
if mibBuilder.loadTexts: mpoaMpcMibAdvancedPlusOctetsCompliance.setDescription('The AdvancedPlusOctets implementation requirements for SNMP\n             entities\n             which support MPOA Clients.  This includes supporting\n             the 64 bit octet counters.')
mpoaMpsMibBasicCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 2, 4)).setObjects(("MPOA-MIB", "mpsConfigGroup"), ("MPOA-MIB", "mpsActualGroup"), ("MPOA-MIB", "mpsStatisticsGroup"), ("MPOA-MIB", "mpsProtocolGroup"), ("MPOA-MIB", "mpsIngressCacheGroup"), ("MPOA-MIB", "mpsEgressCacheGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpoaMpsMibBasicCompliance = mpoaMpsMibBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: mpoaMpsMibBasicCompliance.setDescription('The implementation requirements for SNMP entities\n             which support MPOA Servers.')
mpoaMpsMibAdvancedCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 2, 5)).setObjects(("MPOA-MIB", "mpoaDeviceTypeGroup"), ("MPOA-MIB", "mpoaDeviceTypeMpsMacGroup"), ("MPOA-MIB", "mpsConfigGroup"), ("MPOA-MIB", "mpsActualGroup"), ("MPOA-MIB", "mpsStatisticsGroup"), ("MPOA-MIB", "mpsProtocolGroup"), ("MPOA-MIB", "mpsIngressCacheGroup"), ("MPOA-MIB", "mpsEgressCacheGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpoaMpsMibAdvancedCompliance = mpoaMpsMibAdvancedCompliance.setStatus('current')
if mibBuilder.loadTexts: mpoaMpsMibAdvancedCompliance.setDescription('The advanced implementation requirements for SNMP entities\n             which support MPOA Servers.')
mpoaDeviceTypeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 1)).setObjects(("MPOA-MIB", "deviceTypeLecIndex"), ("MPOA-MIB", "deviceTypeRemoteLecAtmAddress"), ("MPOA-MIB", "deviceTypeType"), ("MPOA-MIB", "deviceTypeMpsAtmAddress"), ("MPOA-MIB", "deviceTypeMpcAtmAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpoaDeviceTypeGroup = mpoaDeviceTypeGroup.setStatus('current')
if mibBuilder.loadTexts: mpoaDeviceTypeGroup.setDescription('A collection of objects which exists when\n             the MPOA device learns the MPOA device type and\n             MPOA control addresses of neighboring MPOA devices\n             using the LANEv2 Device Type TLV.')
mpoaDeviceTypeMpsMacGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 2)).setObjects(("MPOA-MIB", "deviceTypeMpsMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpoaDeviceTypeMpsMacGroup = mpoaDeviceTypeMpsMacGroup.setStatus('current')
if mibBuilder.loadTexts: mpoaDeviceTypeMpsMacGroup.setDescription('A collection of objects which is present when the\n             MPOA device learns the MPOA device type and MPOA\n             control addresses of neighboring MPOA devices using\n             the LANEv2 Device Type TLV.')
mpcConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 3)).setObjects(("MPOA-MIB", "mpcNextIndex"), ("MPOA-MIB", "mpcRowStatus"), ("MPOA-MIB", "mpcConfigMode"), ("MPOA-MIB", "mpcCtrlAtmAddr"), ("MPOA-MIB", "mpcSCSetupFrameCount"), ("MPOA-MIB", "mpcSCSetupFrameTime"), ("MPOA-MIB", "mpcInitialRetryTime"), ("MPOA-MIB", "mpcRetryTimeMaximum"), ("MPOA-MIB", "mpcHoldDownTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcConfigGroup = mpcConfigGroup.setStatus('current')
if mibBuilder.loadTexts: mpcConfigGroup.setDescription('A collection of objects used for creating and\n             configuring MPOA Clients.')
mpcActualGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 4)).setObjects(("MPOA-MIB", "mpcActualState"), ("MPOA-MIB", "mpcDiscontinuityTime"), ("MPOA-MIB", "mpcActualConfigMode"), ("MPOA-MIB", "mpcActualSCSetupFrameCount"), ("MPOA-MIB", "mpcActualSCSetupFrameTime"), ("MPOA-MIB", "mpcActualInitialRetryTime"), ("MPOA-MIB", "mpcActualRetryTimeMaximum"), ("MPOA-MIB", "mpcActualHoldDownTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcActualGroup = mpcActualGroup.setStatus('current')
if mibBuilder.loadTexts: mpcActualGroup.setDescription('A collection of objects describing the status\n             and operational parameters of the managed MPC.')
mpcDataAtmAddressGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 5)).setObjects(("MPOA-MIB", "mpcDataAtmAddressRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcDataAtmAddressGroup = mpcDataAtmAddressGroup.setStatus('current')
if mibBuilder.loadTexts: mpcDataAtmAddressGroup.setDescription('A collection of objects which describe the\n             set of data ATM addresses for the MPCs.')
mpcStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 6)).setObjects(("MPOA-MIB", "mpcStatTxMpoaResolveRequests"), ("MPOA-MIB", "mpcStatRxMpoaResolveReplyAcks"), ("MPOA-MIB", "mpcStatRxMpoaResolveReplyInsufECResources"), ("MPOA-MIB", "mpcStatRxMpoaResolveReplyInsufSCResources"), ("MPOA-MIB", "mpcStatRxMpoaResolveReplyInsufEitherResources"), ("MPOA-MIB", "mpcStatRxMpoaResolveReplyUnsupportedInetProt"), ("MPOA-MIB", "mpcStatRxMpoaResolveReplyUnsupportedMacEncaps"), ("MPOA-MIB", "mpcStatRxMpoaResolveReplyUnspecifiedOther"), ("MPOA-MIB", "mpcStatRxMpoaImpRequests"), ("MPOA-MIB", "mpcStatTxMpoaImpReplyAcks"), ("MPOA-MIB", "mpcStatTxMpoaImpReplyInsufECResources"), ("MPOA-MIB", "mpcStatTxMpoaImpReplyInsufSCResources"), ("MPOA-MIB", "mpcStatTxMpoaImpReplyInsufEitherResources"), ("MPOA-MIB", "mpcStatTxMpoaImpReplyUnsupportedInetProt"), ("MPOA-MIB", "mpcStatTxMpoaImpReplyUnsupportedMacEncaps"), ("MPOA-MIB", "mpcStatTxMpoaImpReplyUnspecifiedOther"), ("MPOA-MIB", "mpcStatTxMpoaEgressCachePurgeRequests"), ("MPOA-MIB", "mpcStatRxMpoaEgressCachePurgeReplies"), ("MPOA-MIB", "mpcStatRxMpoaKeepAlives"), ("MPOA-MIB", "mpcStatRxMpoaTriggers"), ("MPOA-MIB", "mpcStatRxMpoaDataPlanePurges"), ("MPOA-MIB", "mpcStatTxMpoaDataPlanePurges"), ("MPOA-MIB", "mpcStatRxNhrpPurgeRequests"), ("MPOA-MIB", "mpcStatTxNhrpPurgeReplies"), ("MPOA-MIB", "mpcStatRxErrUnrecognizedExtensions"), ("MPOA-MIB", "mpcStatRxErrLoopDetecteds"), ("MPOA-MIB", "mpcStatRxErrProtoAddrUnreachables"), ("MPOA-MIB", "mpcStatRxErrProtoErrors"), ("MPOA-MIB", "mpcStatRxErrSduSizeExceededs"), ("MPOA-MIB", "mpcStatRxErrInvalidExtensions"), ("MPOA-MIB", "mpcStatRxErrInvalidReplies"), ("MPOA-MIB", "mpcStatRxErrAuthenticationFailures"), ("MPOA-MIB", "mpcStatRxErrHopCountExceededs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcStatisticsGroup = mpcStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: mpcStatisticsGroup.setDescription('A collection of objects that provide statistics\n             on the MPOA protocol parameters.')
mpcProtocolGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 7)).setObjects(("MPOA-MIB", "mpcLECSValue"), ("MPOA-MIB", "mpcProtocolRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcProtocolGroup = mpcProtocolGroup.setStatus('current')
if mibBuilder.loadTexts: mpcProtocolGroup.setDescription('A collection of objects to specify which\n             parameters this MPC is enabled for.')
mpcMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 8)).setObjects(("MPOA-MIB", "mpcMappingRowStatus"), ("MPOA-MIB", "mpcMappingIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcMappingGroup = mpcMappingGroup.setStatus('current')
if mibBuilder.loadTexts: mpcMappingGroup.setDescription('A collection of objects to map from LEC to MPC')
mpcMpsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 9)).setObjects(("MPOA-MIB", "mpcMpsAtmAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcMpsGroup = mpcMpsGroup.setStatus('current')
if mibBuilder.loadTexts: mpcMpsGroup.setDescription('A collection of objects which aid the MPCs to track\n             information for all the MPSs which are known by the MPCs.')
mpcMpsMacAddressGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 10)).setObjects(("MPOA-MIB", "mpcMpsMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcMpsMacAddressGroup = mpcMpsMacAddressGroup.setStatus('obsolete')
if mibBuilder.loadTexts: mpcMpsMacAddressGroup.setDescription('A collection of objects which aid the MPCs to track\n             MAC Address information for all the MPSs which are known\n             by the MPCs.')
mpcIngressCacheTotalPacketGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 11)).setObjects(("MPOA-MIB", "mpcIngressCacheTxTotalPackets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcIngressCacheTotalPacketGroup = mpcIngressCacheTotalPacketGroup.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTotalPacketGroup.setDescription('A collection of objects which count the total\n             number of packets transmitted over MPC\n             short cuts.')
mpcIngressCacheTotalOctetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 12)).setObjects(("MPOA-MIB", "mpcIngressCacheTxTotalOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcIngressCacheTotalOctetGroup = mpcIngressCacheTotalOctetGroup.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTotalOctetGroup.setDescription('A collection of objects which count the total\n             number of octets transmitted over MPC\n             short cuts.')
mpcIngressCacheGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 13)).setObjects(("MPOA-MIB", "mpcIngressCacheDestInetworkAddrType"), ("MPOA-MIB", "mpcIngressCacheDestAddr"), ("MPOA-MIB", "mpcIngressCachePrefixLen"), ("MPOA-MIB", "mpcIngressCacheDestAtmAddr"), ("MPOA-MIB", "mpcIngressCacheSrcAtmAddr"), ("MPOA-MIB", "mpcIngressCacheEntryState"), ("MPOA-MIB", "mpcIngressCacheEgressCacheTagValid"), ("MPOA-MIB", "mpcIngressCacheEgressCacheTag"), ("MPOA-MIB", "mpcIngressCacheLastNhrpCieCode"), ("MPOA-MIB", "mpcIngressCacheSigErrCode"), ("MPOA-MIB", "mpcIngressCacheRetries"), ("MPOA-MIB", "mpcIngressCacheTimeUntilNextResolutionRequest"), ("MPOA-MIB", "mpcIngressCacheHoldingTime"), ("MPOA-MIB", "mpcIngressCacheServiceCategory"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcIngressCacheGroup = mpcIngressCacheGroup.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheGroup.setDescription('A collection of objects used to monitor the\n             MPOA ingress cache.')
mpcEgressCacheTotalPacketGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 14)).setObjects(("MPOA-MIB", "mpcEgressCacheRxTotalPackets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcEgressCacheTotalPacketGroup = mpcEgressCacheTotalPacketGroup.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheTotalPacketGroup.setDescription('A collection of objects which count the total\n             number of packets received by MPC short cuts.')
mpcEgressCacheTotalOctetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 15)).setObjects(("MPOA-MIB", "mpcEgressCacheRxTotalOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcEgressCacheTotalOctetGroup = mpcEgressCacheTotalOctetGroup.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheTotalOctetGroup.setDescription('A collection of objects which count the total\n             number of octets received by MPC short cuts.')
mpcEgressCacheGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 16)).setObjects(("MPOA-MIB", "mpcEgressCacheId"), ("MPOA-MIB", "mpcEgressCacheInetworkAddrType"), ("MPOA-MIB", "mpcEgressCacheIDestAddr"), ("MPOA-MIB", "mpcEgressCachePrefixLen"), ("MPOA-MIB", "mpcEgressCacheEntryState"), ("MPOA-MIB", "mpcEgressCacheEgressCacheTagValid"), ("MPOA-MIB", "mpcEgressCacheEgressCacheTag"), ("MPOA-MIB", "mpcEgressCacheHoldTime"), ("MPOA-MIB", "mpcEgressCacheDataLinkHeader"), ("MPOA-MIB", "mpcEgressCacheIngressMpcDataAtmAddr"), ("MPOA-MIB", "mpcEgressCacheLecIndex"), ("MPOA-MIB", "mpcEgressCacheServiceCategory"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcEgressCacheGroup = mpcEgressCacheGroup.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheGroup.setDescription('A collection of objects used to monitor the\n             MPOA egress cache.')
mpsConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 17)).setObjects(("MPOA-MIB", "mpsNextIndex"), ("MPOA-MIB", "mpsRowStatus"), ("MPOA-MIB", "mpsConfigMode"), ("MPOA-MIB", "mpsCtrlAtmAddr"), ("MPOA-MIB", "mpsKeepAliveTime"), ("MPOA-MIB", "mpsKeepAliveLifeTime"), ("MPOA-MIB", "mpsInitialRetryTime"), ("MPOA-MIB", "mpsRetryTimeMaximum"), ("MPOA-MIB", "mpsGiveupTime"), ("MPOA-MIB", "mpsDefaultHoldingTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsConfigGroup = mpsConfigGroup.setStatus('current')
if mibBuilder.loadTexts: mpsConfigGroup.setDescription('A collection of objects used for creating and\n             configuring MPOA Servers.')
mpsActualGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 18)).setObjects(("MPOA-MIB", "mpsActualState"), ("MPOA-MIB", "mpsDiscontinuityTime"), ("MPOA-MIB", "mpsActualConfigMode"), ("MPOA-MIB", "mpsActualKeepAlive"), ("MPOA-MIB", "mpsActualKeepAliveLifeTime"), ("MPOA-MIB", "mpsActualInitialRetryTime"), ("MPOA-MIB", "mpsActualRetryTimeMaximum"), ("MPOA-MIB", "mpsActualGiveupTime"), ("MPOA-MIB", "mpsActualDefaultHoldingTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsActualGroup = mpsActualGroup.setStatus('current')
if mibBuilder.loadTexts: mpsActualGroup.setDescription('A collection of objects describing the status\n             and operational parameters of the managed MPS.')
mpsStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 19)).setObjects(("MPOA-MIB", "mpsStatRxMpoaResolveRequests"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyAcks"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyInsufECResources"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyInsufSCResources"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyInsufEitherResources"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyUnsupportedInetProt"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyUnsupportedMacEncaps"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyUnspecifiedOther"), ("MPOA-MIB", "mpsStatTxMpoaResolveReplyOther"), ("MPOA-MIB", "mpsStatGiveupTimeExpireds"), ("MPOA-MIB", "mpsStatTxMpoaImpRequests"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyAcks"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyInsufECResources"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyInsufSCResources"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyInsufEitherResources"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyUnsupportedInetProt"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyUnsupportedMacEncaps"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyUnspecifiedOther"), ("MPOA-MIB", "mpsStatRxMpoaImpReplyOther"), ("MPOA-MIB", "mpsStatRxMpoaEgressCachePurgeRequests"), ("MPOA-MIB", "mpsStatTxMpoaEgressCachePurgeReplies"), ("MPOA-MIB", "mpsStatTxMpoaTriggers"), ("MPOA-MIB", "mpsStatTxNhrpResolveRequests"), ("MPOA-MIB", "mpsStatRxNhrpResolveReplies"), ("MPOA-MIB", "mpsStatRxNhrpResolveRequests"), ("MPOA-MIB", "mpsStatTxNhrpResolveReplies"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsStatisticsGroup = mpsStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: mpsStatisticsGroup.setDescription('A collection of objects that provide statistics\n             on the MPOA Server protocol parameters.')
mpsProtocolGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 20)).setObjects(("MPOA-MIB", "mpsLECSValue"), ("MPOA-MIB", "mpsProtocolRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsProtocolGroup = mpsProtocolGroup.setStatus('current')
if mibBuilder.loadTexts: mpsProtocolGroup.setDescription('A collection of objects to specify which\n             parameters this MPS is enabled for.')
mpsMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 21)).setObjects(("MPOA-MIB", "mpsMappingRowStatus"), ("MPOA-MIB", "mpsMappingIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsMappingGroup = mpsMappingGroup.setStatus('current')
if mibBuilder.loadTexts: mpsMappingGroup.setDescription('A collection of objects to map from MPSs to LECs.')
mpsMpcGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 22)).setObjects(("MPOA-MIB", "mpsMpcCtrlAtmAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsMpcGroup = mpsMpcGroup.setStatus('current')
if mibBuilder.loadTexts: mpsMpcGroup.setDescription('A collection of objects which aid the MPSs to track\n             information for all the MPCs which are known by the\n             MPSs.')
mpsIngressCacheGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 23)).setObjects(("MPOA-MIB", "mpsIngressCacheDestInternetworkAddrType"), ("MPOA-MIB", "mpsIngressCacheDestAddr"), ("MPOA-MIB", "mpsIngressCachePrefixLen"), ("MPOA-MIB", "mpsIngressCacheEntryState"), ("MPOA-MIB", "mpsIngressCacheSrcInternetworkAddrType"), ("MPOA-MIB", "mpsIngressCacheSrcAddr"), ("MPOA-MIB", "mpsIngressCacheSourceMpcCtrlAtmAddr"), ("MPOA-MIB", "mpsIngressCacheResolvedAtmAddr"), ("MPOA-MIB", "mpsIngressCacheHoldTime"), ("MPOA-MIB", "mpsIngressCacheMpoaRequestId"), ("MPOA-MIB", "mpsIngressCacheNhrpRequestId"), ("MPOA-MIB", "mpsIngressCacheServiceCategory"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsIngressCacheGroup = mpsIngressCacheGroup.setStatus('current')
if mibBuilder.loadTexts: mpsIngressCacheGroup.setDescription('A collection of objects to monitor the MPS\n             ingress cache.')
mpsEgressCacheGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 24)).setObjects(("MPOA-MIB", "mpsEgressCacheId"), ("MPOA-MIB", "mpsEgressCacheDestInternetworkAddrType"), ("MPOA-MIB", "mpsEgressCacheDestAddr"), ("MPOA-MIB", "mpsEgressCachePrefixLen"), ("MPOA-MIB", "mpsEgressCacheHoldTime"), ("MPOA-MIB", "mpsEgressCacheEntryState"), ("MPOA-MIB", "mpsEgressCacheDataLinkHeader"), ("MPOA-MIB", "mpsEgressCacheElanId"), ("MPOA-MIB", "mpsEgressCacheSourceClientAtmAddr"), ("MPOA-MIB", "mpsEgressCacheNhrpRequestId"), ("MPOA-MIB", "mpsEgressCacheMpoaRequestId"), ("MPOA-MIB", "mpsEgressCacheServiceCategory"), ("MPOA-MIB", "mpsEgressCacheNextHopInternetworkAddrType"), ("MPOA-MIB", "mpsEgressCacheNextHopAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsEgressCacheGroup = mpsEgressCacheGroup.setStatus('current')
if mibBuilder.loadTexts: mpsEgressCacheGroup.setDescription("A collection of objects to monitor MPS's egress\n             cache parameters.")
mpcMpsMultipleMacAddressGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1, 25)).setObjects(("MPOA-MIB", "mpcMpsFlowDetectMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpcMpsMultipleMacAddressGroup = mpcMpsMultipleMacAddressGroup.setStatus('current')
if mibBuilder.loadTexts: mpcMpsMultipleMacAddressGroup.setDescription('A collection of objects which aid the MPCs to track\n             MAC Address information for all the MPSs which are\n             used during flow detection by the MPCs.')
mibBuilder.exportSymbols("MPOA-MIB", mpsStatRxMpoaResolveRequests=mpsStatRxMpoaResolveRequests, InternetworkAddrType=InternetworkAddrType, mpsStatTxMpoaResolveReplyOther=mpsStatTxMpoaResolveReplyOther, mpcIngressCacheEgressCacheTag=mpcIngressCacheEgressCacheTag, mpcStatTxMpoaImpReplyAcks=mpcStatTxMpoaImpReplyAcks, mpcConfigEntry=mpcConfigEntry, mpsIngressCacheEntryState=mpsIngressCacheEntryState, mpcRowStatus=mpcRowStatus, mpcStatRxMpoaEgressCachePurgeReplies=mpcStatRxMpoaEgressCachePurgeReplies, mpcStatRxErrAuthenticationFailures=mpcStatRxErrAuthenticationFailures, mpcStatisticsGroup=mpcStatisticsGroup, mpsKeepAliveLifeTime=mpsKeepAliveLifeTime, deviceTypeIndex=deviceTypeIndex, LecIndex=LecIndex, mpsMpcIndex=mpsMpcIndex, mpcMpsEntry=mpcMpsEntry, mpcIngressCacheTotalOctetGroup=mpcIngressCacheTotalOctetGroup, mpcStatRxMpoaResolveReplyInsufECResources=mpcStatRxMpoaResolveReplyInsufECResources, mpcStatRxErrInvalidReplies=mpcStatRxErrInvalidReplies, mpoaCommonObjects=mpoaCommonObjects, mpcEgressCachePrefixLen=mpcEgressCachePrefixLen, mpcActualGroup=mpcActualGroup, mpsIngressCacheGroup=mpsIngressCacheGroup, mpcStatRxMpoaResolveReplyInsufEitherResources=mpcStatRxMpoaResolveReplyInsufEitherResources, mpsRowStatus=mpsRowStatus, mpsProtocolRowStatus=mpsProtocolRowStatus, mpcIngressCacheTable=mpcIngressCacheTable, mpcEgressCacheTotalOctetGroup=mpcEgressCacheTotalOctetGroup, mpsProtocolGroup=mpsProtocolGroup, mpsMappingTable=mpsMappingTable, mpcIngressCacheDestInetworkAddrType=mpcIngressCacheDestInetworkAddrType, mpcEgressCacheEntry=mpcEgressCacheEntry, mpsEgressCacheTable=mpsEgressCacheTable, mpoaMpsMibAdvancedCompliance=mpoaMpsMibAdvancedCompliance, InternetworkAddr=InternetworkAddr, mpsStatTxMpoaResolveReplyInsufEitherResources=mpsStatTxMpoaResolveReplyInsufEitherResources, mpsIngressCachePrefixLen=mpsIngressCachePrefixLen, mpcStatRxErrProtoErrors=mpcStatRxErrProtoErrors, mpsConfigGroup=mpsConfigGroup, mpcEgressCacheEgressCacheTag=mpcEgressCacheEgressCacheTag, mpsDiscontinuityTime=mpsDiscontinuityTime, mpsActualGroup=mpsActualGroup, mpsActualGiveupTime=mpsActualGiveupTime, mpsActualEntry=mpsActualEntry, mpcIngressCacheTotalPacketGroup=mpcIngressCacheTotalPacketGroup, deviceTypeMpsMacAddressEntry=deviceTypeMpsMacAddressEntry, mpcStatRxErrInvalidExtensions=mpcStatRxErrInvalidExtensions, mpcIngressCacheTxTotalPackets=mpcIngressCacheTxTotalPackets, mpcStatTxMpoaDataPlanePurges=mpcStatTxMpoaDataPlanePurges, mpcMpsObjects=mpcMpsObjects, mpsIngressCacheDestAddr=mpsIngressCacheDestAddr, mpsActualTable=mpsActualTable, mpsIngressCacheMpoaRequestId=mpsIngressCacheMpoaRequestId, mpsMappingIndex=mpsMappingIndex, mpcDataAtmAddressEntry=mpcDataAtmAddressEntry, mpsStatTxMpoaResolveReplyAcks=mpsStatTxMpoaResolveReplyAcks, mpsEgressCacheSourceClientAtmAddr=mpsEgressCacheSourceClientAtmAddr, mpsStatRxMpoaImpReplyAcks=mpsStatRxMpoaImpReplyAcks, mpsMappingEntry=mpsMappingEntry, mpoaDeviceTypeMpsMacGroup=mpoaDeviceTypeMpsMacGroup, atmForum=atmForum, mpcConfigGroup=mpcConfigGroup, mpsConfigMode=mpsConfigMode, mpcLECSValue=mpcLECSValue, mpcIngressCachePrefixLen=mpcIngressCachePrefixLen, mpcLecIndex=mpcLecIndex, mpsMpcEntry=mpsMpcEntry, mpcStatRxMpoaResolveReplyAcks=mpcStatRxMpoaResolveReplyAcks, mpsEgressCacheNextHopInternetworkAddrType=mpsEgressCacheNextHopInternetworkAddrType, mpcDataAtmAddressRowStatus=mpcDataAtmAddressRowStatus, mpcStatRxErrHopCountExceededs=mpcStatRxErrHopCountExceededs, mpcEgressCacheRxTotalOctets=mpcEgressCacheRxTotalOctets, mpcStatRxErrLoopDetecteds=mpcStatRxErrLoopDetecteds, mpcEgressCacheId=mpcEgressCacheId, mpsMappingRowStatus=mpsMappingRowStatus, mpsIngressCacheNhrpRequestId=mpsIngressCacheNhrpRequestId, mpsEgressCacheElanId=mpsEgressCacheElanId, mpcMappingGroup=mpcMappingGroup, AtmConfigAddr=AtmConfigAddr, mpsGiveupTime=mpsGiveupTime, mpsStatisticsTable=mpsStatisticsTable, mpcStatRxMpoaResolveReplyUnsupportedMacEncaps=mpcStatRxMpoaResolveReplyUnsupportedMacEncaps, deviceTypeRemoteLecAtmAddress=deviceTypeRemoteLecAtmAddress, mpcIngressCacheSigErrCode=mpcIngressCacheSigErrCode, mpsProtocolEntry=mpsProtocolEntry, mpcFlowDetectProtocol=mpcFlowDetectProtocol, mpcMpsIndex=mpcMpsIndex, AtmAddr=AtmAddr, mpsEgressCacheHoldTime=mpsEgressCacheHoldTime, mpsIngressCacheSourceMpcCtrlAtmAddr=mpsIngressCacheSourceMpcCtrlAtmAddr, mpcActualHoldDownTime=mpcActualHoldDownTime, mpcDataAtmAddressGroup=mpcDataAtmAddressGroup, mpcEgressCacheHoldTime=mpcEgressCacheHoldTime, mpcEgressCacheLecIndex=mpcEgressCacheLecIndex, mpcEgressCacheTable=mpcEgressCacheTable, mpsStatRxNhrpResolveRequests=mpsStatRxNhrpResolveRequests, mpsEgressCacheServiceCategory=mpsEgressCacheServiceCategory, deviceTypeMpsMacAddressTable=deviceTypeMpsMacAddressTable, mpsEgressCacheMpoaRequestId=mpsEgressCacheMpoaRequestId, mpcMappingTable=mpcMappingTable, mpcStatTxMpoaImpReplyInsufECResources=mpcStatTxMpoaImpReplyInsufECResources, mpcStatTxNhrpPurgeReplies=mpcStatTxNhrpPurgeReplies, mpsIngressCacheSrcInternetworkAddrType=mpsIngressCacheSrcInternetworkAddrType, deviceTypeMpsMacAddress=deviceTypeMpsMacAddress, mpcStatRxMpoaResolveReplyUnsupportedInetProt=mpcStatRxMpoaResolveReplyUnsupportedInetProt, mpcIngressCacheDestAtmAddr=mpcIngressCacheDestAtmAddr, mpcIngressCacheHoldingTime=mpcIngressCacheHoldingTime, mpsActualRetryTimeMaximum=mpsActualRetryTimeMaximum, mpcEgressCacheEgressCacheTagValid=mpcEgressCacheEgressCacheTagValid, atmForumNetworkManagement=atmForumNetworkManagement, mpsStatRxMpoaImpReplyInsufSCResources=mpsStatRxMpoaImpReplyInsufSCResources, mpsEgressCacheEntryState=mpsEgressCacheEntryState, mpoaMpcMibAdvancedPlusOctetsCompliance=mpoaMpcMibAdvancedPlusOctetsCompliance, mpsEgressCacheDataLinkHeader=mpsEgressCacheDataLinkHeader, mpcEgressCacheTotalPacketGroup=mpcEgressCacheTotalPacketGroup, mpsStatTxNhrpResolveRequests=mpsStatTxNhrpResolveRequests, mpsKeepAliveTime=mpsKeepAliveTime, mpsNextIndex=mpsNextIndex, mpsStatTxMpoaResolveReplyUnsupportedInetProt=mpsStatTxMpoaResolveReplyUnsupportedInetProt, mpcProtocolEntry=mpcProtocolEntry, mpsStatRxMpoaImpReplyOther=mpsStatRxMpoaImpReplyOther, mpcFlowDetectLecIndex=mpcFlowDetectLecIndex, mpcActualState=mpcActualState, mpsCtrlAtmAddr=mpsCtrlAtmAddr, deviceTypeMpcAtmAddress=deviceTypeMpcAtmAddress, mpsStatRxMpoaImpReplyUnspecifiedOther=mpsStatRxMpoaImpReplyUnspecifiedOther, mpsIngressCacheSrcAddr=mpsIngressCacheSrcAddr, mpcDataAtmAddressTable=mpcDataAtmAddressTable, mpcStatTxMpoaImpReplyUnsupportedInetProt=mpcStatTxMpoaImpReplyUnsupportedInetProt, mpsIngressCacheHoldTime=mpsIngressCacheHoldTime, mpsStatisticsGroup=mpsStatisticsGroup, deviceTypeType=deviceTypeType, atmfMpoa=atmfMpoa, mpcRetryTimeMaximum=mpcRetryTimeMaximum, mpcStatRxMpoaResolveReplyInsufSCResources=mpcStatRxMpoaResolveReplyInsufSCResources, mpcStatisticsTable=mpcStatisticsTable, mpsIngressCacheEntry=mpsIngressCacheEntry, mpcStatRxNhrpPurgeRequests=mpcStatRxNhrpPurgeRequests, mpcProtocolTable=mpcProtocolTable, mpsIndex=mpsIndex, mpcStatRxMpoaTriggers=mpcStatRxMpoaTriggers, mpcProtocolGroup=mpcProtocolGroup, mpcObjects=mpcObjects, mpcHoldDownTime=mpcHoldDownTime, mpsStatisticsEntry=mpsStatisticsEntry, mpcMpsMultipleMacAddressGroup=mpcMpsMultipleMacAddressGroup, mpsStatRxMpoaImpReplyUnsupportedMacEncaps=mpsStatRxMpoaImpReplyUnsupportedMacEncaps, mpcStatRxMpoaResolveReplyUnspecifiedOther=mpcStatRxMpoaResolveReplyUnspecifiedOther, mpcCtrlAtmAddr=mpcCtrlAtmAddr, mpcEgressCacheEntryState=mpcEgressCacheEntryState, mpsStatTxMpoaResolveReplyInsufECResources=mpsStatTxMpoaResolveReplyInsufECResources, mpcSCSetupFrameCount=mpcSCSetupFrameCount, mpcMpsMultipleMacAddressTable=mpcMpsMultipleMacAddressTable, mpcStatRxMpoaDataPlanePurges=mpcStatRxMpoaDataPlanePurges, mpcIngressCacheEntry=mpcIngressCacheEntry, mpsEgressCachePrefixLen=mpsEgressCachePrefixLen, mpsStatTxMpoaResolveReplyInsufSCResources=mpsStatTxMpoaResolveReplyInsufSCResources, mpsStatTxMpoaResolveReplyUnspecifiedOther=mpsStatTxMpoaResolveReplyUnspecifiedOther, mpsEgressCacheId=mpsEgressCacheId, mpcEgressCacheGroup=mpcEgressCacheGroup, mpsStatRxMpoaImpReplyInsufECResources=mpsStatRxMpoaImpReplyInsufECResources, mpcIngressCacheDestAddr=mpcIngressCacheDestAddr, mpcEgressCacheInetworkAddrType=mpcEgressCacheInetworkAddrType, mpsInternetworkLayerProtocol=mpsInternetworkLayerProtocol, mpcInitialRetryTime=mpcInitialRetryTime, deviceTypeTable=deviceTypeTable, mpcStatRxErrUnrecognizedExtensions=mpcStatRxErrUnrecognizedExtensions, mpcEgressCacheServiceCategory=mpcEgressCacheServiceCategory, mpsEgressCacheGroup=mpsEgressCacheGroup, mpcSCSetupFrameTime=mpcSCSetupFrameTime, mpsLECSValue=mpsLECSValue, mpcActualSCSetupFrameCount=mpcActualSCSetupFrameCount, mpoaMIBGroups=mpoaMIBGroups, mpsMappingGroup=mpsMappingGroup, mpoaMpcMibBasicCompliance=mpoaMpcMibBasicCompliance, deviceTypeEntry=deviceTypeEntry, mpsActualKeepAliveLifeTime=mpsActualKeepAliveLifeTime, mpsDefaultHoldingTime=mpsDefaultHoldingTime, mpcActualEntry=mpcActualEntry, MpcIndex=MpcIndex, mpsConfigTable=mpsConfigTable, mpcActualTable=mpcActualTable, mpsStatTxMpoaImpRequests=mpsStatTxMpoaImpRequests, mpsActualState=mpsActualState, mpsEgressCacheNhrpRequestId=mpsEgressCacheNhrpRequestId, mpcMpsMacAddressIndex=mpcMpsMacAddressIndex, mpcIngressCacheTimeUntilNextResolutionRequest=mpcIngressCacheTimeUntilNextResolutionRequest, mpsStatTxMpoaTriggers=mpsStatTxMpoaTriggers, mpsActualConfigMode=mpsActualConfigMode, mpcStatTxMpoaImpReplyUnspecifiedOther=mpcStatTxMpoaImpReplyUnspecifiedOther, mpcIngressCacheGroup=mpcIngressCacheGroup, mpcActualSCSetupFrameTime=mpcActualSCSetupFrameTime, mpoaMIBObjects=mpoaMIBObjects, mpcMpsFlowDetectMacAddress=mpcMpsFlowDetectMacAddress, mpcStatTxMpoaResolveRequests=mpcStatTxMpoaResolveRequests, mpsActualDefaultHoldingTime=mpsActualDefaultHoldingTime, mpsActualKeepAlive=mpsActualKeepAlive, mpcIndex=mpcIndex, deviceTypeLecIndex=deviceTypeLecIndex, mpcProtocolRowStatus=mpcProtocolRowStatus, mpcMpsTable=mpcMpsTable, mpcIngressCacheRetries=mpcIngressCacheRetries, mpcStatTxMpoaImpReplyUnsupportedMacEncaps=mpcStatTxMpoaImpReplyUnsupportedMacEncaps, mpsProtocolTable=mpsProtocolTable, mpcMpsMacAddressEntry=mpcMpsMacAddressEntry, mpsStatGiveupTimeExpireds=mpsStatGiveupTimeExpireds, mpsStatTxMpoaResolveReplyUnsupportedMacEncaps=mpsStatTxMpoaResolveReplyUnsupportedMacEncaps, mpsStatRxMpoaImpReplyInsufEitherResources=mpsStatRxMpoaImpReplyInsufEitherResources, mpcActualConfigMode=mpcActualConfigMode, mpcMpsMacAddress=mpcMpsMacAddress, mpsMpcCtrlAtmAddr=mpsMpcCtrlAtmAddr, mpoaMIBConformance=mpoaMIBConformance, deviceTypeMpsAtmAddress=deviceTypeMpsAtmAddress, mpsEgressCacheDestInternetworkAddrType=mpsEgressCacheDestInternetworkAddrType, mpsStatRxMpoaImpReplyUnsupportedInetProt=mpsStatRxMpoaImpReplyUnsupportedInetProt, mpcIngressCacheEntryState=mpcIngressCacheEntryState, mpcStatTxMpoaImpReplyInsufEitherResources=mpcStatTxMpoaImpReplyInsufEitherResources, mpcActualInitialRetryTime=mpcActualInitialRetryTime, mpcConfigTable=mpcConfigTable, mpcActualRetryTimeMaximum=mpcActualRetryTimeMaximum, mpcDataAtmAddress=mpcDataAtmAddress, mpcStatisticsEntry=mpcStatisticsEntry, mpsIngressCacheDestInternetworkAddrType=mpsIngressCacheDestInternetworkAddrType, mpsEgressCacheNextHopAddr=mpsEgressCacheNextHopAddr, mpcMpsMacAddressGroup=mpcMpsMacAddressGroup, mpsStatTxMpoaEgressCachePurgeReplies=mpsStatTxMpoaEgressCachePurgeReplies, mpcIngressCacheServiceCategory=mpcIngressCacheServiceCategory, mpcMpsAtmAddr=mpcMpsAtmAddr, mpcIngressCacheLastNhrpCieCode=mpcIngressCacheLastNhrpCieCode, mpcEgressCacheIngressMpcDataAtmAddr=mpcEgressCacheIngressMpcDataAtmAddr, mpcMappingIndex=mpcMappingIndex, mpcEgressCacheDataLinkHeader=mpcEgressCacheDataLinkHeader, mpsIngressCacheTable=mpsIngressCacheTable, mpcStatRxErrSduSizeExceededs=mpcStatRxErrSduSizeExceededs, mpcIngressCacheTxTotalOctets=mpcIngressCacheTxTotalOctets, mpcConfigMode=mpcConfigMode, mpcMappingRowStatus=mpcMappingRowStatus, mpcMpsMacAddressTable=mpcMpsMacAddressTable, mpsObjects=mpsObjects, mpsMpcTable=mpsMpcTable, MpsIndex=MpsIndex, mpcMpsGroup=mpcMpsGroup, mpsStatRxNhrpResolveReplies=mpsStatRxNhrpResolveReplies, mpcIngressCacheSrcAtmAddr=mpcIngressCacheSrcAtmAddr, mpcStatRxMpoaKeepAlives=mpcStatRxMpoaKeepAlives, mpoaMIBCompliances=mpoaMIBCompliances, mpoaMpsMibBasicCompliance=mpoaMpsMibBasicCompliance, mpsMpcGroup=mpsMpcGroup, mpcStatRxMpoaImpRequests=mpcStatRxMpoaImpRequests, mpcStatTxMpoaEgressCachePurgeRequests=mpcStatTxMpoaEgressCachePurgeRequests, mpsIngressCacheServiceCategory=mpsIngressCacheServiceCategory, mpcNextIndex=mpcNextIndex, mpsEgressCacheDestAddr=mpsEgressCacheDestAddr, mpsIngressCacheResolvedAtmAddr=mpsIngressCacheResolvedAtmAddr)
mibBuilder.exportSymbols("MPOA-MIB", mpcIngressCacheEgressCacheTagValid=mpcIngressCacheEgressCacheTagValid, mpcMpsMultipleMacAddressEntry=mpcMpsMultipleMacAddressEntry, mpsEgressCacheEntry=mpsEgressCacheEntry, mpoaMIB=mpoaMIB, mpcEgressCacheIDestAddr=mpcEgressCacheIDestAddr, mpsStatRxMpoaEgressCachePurgeRequests=mpsStatRxMpoaEgressCachePurgeRequests, PYSNMP_MODULE_ID=mpoaMIB, mpsStatTxNhrpResolveReplies=mpsStatTxNhrpResolveReplies, mpoaMpcMibAdvancedCompliance=mpoaMpcMibAdvancedCompliance, mpoaDeviceTypeGroup=mpoaDeviceTypeGroup, mpcMappingEntry=mpcMappingEntry, mpcEgressCacheRxTotalPackets=mpcEgressCacheRxTotalPackets, mpsRetryTimeMaximum=mpsRetryTimeMaximum, mpsActualInitialRetryTime=mpsActualInitialRetryTime, mpcDiscontinuityTime=mpcDiscontinuityTime, mpcStatTxMpoaImpReplyInsufSCResources=mpcStatTxMpoaImpReplyInsufSCResources, mpsInitialRetryTime=mpsInitialRetryTime, mpsConfigEntry=mpsConfigEntry, mpcStatRxErrProtoAddrUnreachables=mpcStatRxErrProtoAddrUnreachables)
