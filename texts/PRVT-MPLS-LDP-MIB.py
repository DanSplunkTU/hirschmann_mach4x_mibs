#
# PySNMP MIB module PRVT-MPLS-LDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-MPLS-LDP-MIB
# Produced by pysmi-1.1.3 at Sun Nov 21 00:45:48 2021
# On host fv-az39-63 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddress, InetAddressType, InetPortNumber, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetPortNumber", "InetAddressPrefixLength")
MplsIndexType, = mibBuilder.importSymbols("MPLS-LSR-MIB", "MplsIndexType")
MplsAtmVcIdentifier, MplsLabelDistributionMethod, MplsLspType, MplsLsrIdentifier, MplsLdpLabelType, MplsLdpIdentifier, mplsStdMIB, MplsRetentionMode = mibBuilder.importSymbols("MPLS-TC-PRIV-STDEXT-MIB", "MplsAtmVcIdentifier", "MplsLabelDistributionMethod", "MplsLspType", "MplsLsrIdentifier", "MplsLdpLabelType", "MplsLdpIdentifier", "mplsStdMIB", "MplsRetentionMode")
prvtcrldpSigIndex, mpls, prvtcrldpPmIndex = mibBuilder.importSymbols("PRVT-CR-LDP-MIB", "prvtcrldpSigIndex", "mpls", "prvtcrldpPmIndex")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ObjectIdentity, iso, Counter32, Integer32, IpAddress, Bits, MibIdentifier, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Gauge32, TimeTicks, NotificationType, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "iso", "Counter32", "Integer32", "IpAddress", "Bits", "MibIdentifier", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Gauge32", "TimeTicks", "NotificationType", "Unsigned32")
RowStatus, TextualConvention, TimeStamp, DisplayString, TruthValue, TimeInterval, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TimeStamp", "DisplayString", "TruthValue", "TimeInterval", "StorageType")
mplsLdpStdMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1))
mplsLdpStdMIB.setRevisions(('2009-02-17 00:00', '2006-06-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsLdpStdMIB.setRevisionsDescriptions(('Removed references to undefined OBJECT-GROUPs.', 'Initial version published as part of RFC 3815.',))
if mibBuilder.loadTexts: mplsLdpStdMIB.setLastUpdated('200902170000Z')
if mibBuilder.loadTexts: mplsLdpStdMIB.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: mplsLdpStdMIB.setContactInfo(' BATM/Telco Systems Support team\n\t\t\t\t\tEmail: \n\t\t\t\tFor North America: techsupport@telco.com\n\t\t\t\tFor North Europe: support@batm.de, info@batm.de\n\t\t\t\tFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: mplsLdpStdMIB.setDescription("This MIB contains managed object definitions for the\n        'Multiprotocol Label Switching, Label Distribution\n        Protocol, LDP'.")
class MplsLabel(TextualConvention, Integer32):
    description = 'This value represents an MPLS label.\n        The label contents are specific to\n        the label being represented.\n\n        The label carried in an MPLS shim header\n        (for LDP, the Generic Label) is a 20-bit number\n        represented by 4 octets. Bits 0-19 contain a\n        label or a reserved label value.  Bits 20-31 MUST\n        be zero.\n\n        The frame relay label can be either 10-bits or\n        23-bits depending on the DLCI field size and the\n        upper 22-bits or upper 9-bits must be zero, respectively.\n\n        For an ATM label the lower 16-bits represents the VCI,\n        the next 12-bits represents the VPI and the remaining\n        bits MUST be zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class MplsLdpLabelTypes(TextualConvention, Integer32):
    description = 'The Layer 2 label types which are defined for\n        MPLS LDP are generic(1), atm(2), or frameRelay(3).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("generic", 1), ("atm", 2), ("frameRelay", 3))

mplsLdpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1))
mplsLdpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 2, 0))
mplsLdpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3))
mplsLdpLsrObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 1))
mplsLdpEntityObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2))
mplsLdpLsrTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 1, 1), )
if mibBuilder.loadTexts: mplsLdpLsrTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrTable.setDescription('This table contains information about the Label Switching\n        Router (LSR) or Label Edge Router (LER) that is running the\n        MPLS Label Distribution Protocol.')
mplsLdpLsrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 1, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"))
if mibBuilder.loadTexts: mplsLdpLsrEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrEntry.setDescription('An entry in this table contains the LSR objects specific to\n         an instance of PRVT-CR-LDP.')
mplsLdpLsrId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 1, 1, 1, 1), MplsLsrIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpLsrId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrId.setDescription("The Label Switching Router's Identifier.")
mplsLdpLsrLoopDetectionCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("hopCount", 3), ("pathVector", 4), ("hopCountAndPathVector", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpLsrLoopDetectionCapable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrLoopDetectionCapable.setDescription('A indication of whether this\n        Label Switching Router supports\n        loop detection.\n\n        none(1) -- Loop Detection is not supported\n                   on this LSR.\n\n        other(2) -- Loop Detection is supported but\n                    by a method other than those\n                    listed below.\n\n        hopCount(3) -- Loop Detection is supported by\n                       Hop Count only.\n\n        pathVector(4) -- Loop Detection is supported by\n                         Path Vector only.\n\n        hopCountAndPathVector(5) -- Loop Detection is\n                             supported by both Hop Count\n                             And Path Vector.\n\n        Since Loop Detection is determined during\n        Session Initialization, an individual session\n        may not be running with loop detection.  This\n        object simply gives an indication of whether or not the\n        LSR has the ability to support Loop Detection and\n        which types.')
mplsLdpEntityTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1), )
if mibBuilder.loadTexts: mplsLdpEntityTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTable.setDescription('This table contains information about the\n        MPLS Label Distribution Protocol Entities which\n        exist on this Label Switching Router (LSR)\n        or Label Edge Router (LER).')
mplsLdpEntityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityEntry.setDescription('An entry in this table represents an LDP entity.\n        An entry can be created by a network administrator\n        or by an SNMP agent as instructed by LDP.')
mplsLdpEntityLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 1), MplsLdpIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setReference('RFC3036, LDP Specification, Section on LDP Identifiers.')
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setDescription('The LDP identifier.  The first four octets encode an IP\n         address assigned to the LSR, and the last two octets\n         identify a specific label space within the LSR.')
mplsLdpEntityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: mplsLdpEntityIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndex.setDescription("This index is used as a secondary index to uniquely\n        identify this row.  Before creating a row in this table,\n        the 'mplsLdpEntityIndexNext' object should be retrieved.\n        That value should be used for the value of this index\n        when creating a row in this table.  NOTE:  if a value\n        of zero (0) is retrieved, that indicates that no rows\n        can be created in this table at this time.\n\n        A secondary index (this object) is meaningful to some\n        but not all, LDP implementations.  For example\n        an LDP implementation which uses PPP would\n        use this index to differentiate PPP sub-links.\n\n        Another way to use this index is to give this the\n        value of ifIndex.  However, this is dependant\n        on the implementation.\n\n        This field is deprecated in the following tables provided\n        by PRVT-CR-LDP Session Controller.\n\n        - mplsLdpEntityTable.\n        - mplsLdpPeerTable.\n\n        In these tables the value of the Entity Index will always\n        be filled in to be 1.")
mplsLdpEntityProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityProtocolVersion.setReference('RFC3036, LDP Specification, Section 3.5.3 Initialization\n       Message.')
if mibBuilder.loadTexts: mplsLdpEntityProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityProtocolVersion.setDescription('The version number of the protocol.  The value of 0 on a\n       read indicates that the version of the protocol is unknown.\n       Otherwise, the value of this object represents the version\n       of the LDP protocol.\n\n       Section 3.5.3 in the LDP Specification specifies\n       that the version of the LDP protocol is negotiated during\n       session establishment. The value of this object\n       represents the value that is sent in the initialization\n       message.')
mplsLdpEntityAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAdminStatus.setDescription("The administrative status of this LDP Entity.\n        If this object is changed from 'enable' to 'disable'\n        and this entity has already attempted to establish\n        contact with a Peer (which implies that the\n        'mplsLdpEntityRowStatus' object has been set to\n        'active'), then all contact with that\n        Peer is lost and all information from that Peer\n        needs to be removed from the MIB. (This implies\n        that the network management subsystem should clean\n        up any related entry in the mplsLdpPeerTable.  This\n        further implies that a 'tear-down' for that session\n        is issued and the session and all information related\n        to that session cease to exist).\n\n        At this point the user is able to change values\n        which are related to this entity.\n\n        When the admin status is set back to 'enable', then\n        this Entity will attempt to establish a new session\n        with the Peer.")
mplsLdpEntityOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityOperStatus.setDescription('The operational status of this LDP Entity.\n\n        The value of unknown(1) indicates that the\n        operational status cannot be determined at\n        this time.  The value of unknown should be\n        a transient condition before changing\n        to enabled(2) or disabled(3).')
mplsLdpEntityWellKnownTcpDiscoveryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 6), InetPortNumber().clone(646)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityWellKnownTcpDiscoveryPort.setReference('RFC3036, LDP Specification, Section 3.10, Well-known\n         Numbers, and Section 3.10.1.  UDP and TCP Ports.')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownTcpDiscoveryPort.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownTcpDiscoveryPort.setDescription('The TCP Port for\n        LDP.  The default value is the well-known\n        value of this port.')
mplsLdpEntityWellKnownUdpDiscoveryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 7), InetPortNumber().clone(646)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityWellKnownUdpDiscoveryPort.setReference('RFC3036, LDP Specification, Section 2.4.1,\n        Basic Discovery Mechanism, Section 2.4.2,\n        Extended Discovery Mechanism, Section\n        3.10, Well-known Numbers, and Section 3.10.1.\n        UDP and TCP Ports.')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownUdpDiscoveryPort.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownUdpDiscoveryPort.setDescription('The UDP Discovery Port for\n        LDP.  The default value is the\n        well-known value for this port.')
mplsLdpEntityMaxPduLength = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 65535)).clone(4096)).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setReference('RFC3036, LDP Specification, Section 3.5.3.\n       Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setDescription("The maximum PDU Length that is sent in\n       the Common Session Parameters of an Initialization\n       Message.  According to the LDP Specification [RFC3036]\n       a value of 255 or less specifies the\n       default maximum length of 4096 octets, this is why\n       the value of this object starts at 256.\n\n       The receiving LSR MUST calculate the maximum PDU\n       length for the session by using the smaller of its and\n       its peer's proposals for Max PDU Length.")
mplsLdpEntityKeepAliveHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(40)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityKeepAliveHoldTimer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityKeepAliveHoldTimer.setDescription('The 16-bit integer value which is the proposed keep\n        alive hold timer for this LDP Entity.')
mplsLdpEntityHelloHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityHelloHoldTimer.setReference('RFC3036, LDP Specification, Section 3.5.2.,\n        Hello Message.')
if mibBuilder.loadTexts: mplsLdpEntityHelloHoldTimer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityHelloHoldTimer.setDescription("The 16-bit integer value which is the proposed Hello\n        hold timer for this LDP Entity. The Hello Hold time\n        in seconds.\n\n        An LSR maintains a record of Hellos received\n        from potential peers.  This object represents\n        the Hold Time in the Common Hello Parameters TLV of\n        the Hello Message.\n\n        A value of 0 is a default value and should be\n        interpretted in conjunction with the\n        mplsLdpEntityTargetPeer object.\n\n        If the value of this object is 0: if the value of the\n        mplsLdpEntityTargetPeer object is false(2), then this\n        specifies that the Hold Time's actual default value is\n        15 seconds (i.e., the default Hold time for Link Hellos\n        is 15 seconds).  Otherwise if the value of the\n        mplsLdpEntityTargetPeer object is true(1), then this\n        specifies that the Hold Time's actual default value is\n        45 seconds (i.e., the default Hold time for Targeted\n        Hellos is 45 seconds).\n\n        A value of 65535 means infinite (i.e., wait forever).\n\n        All other values represent the amount of time in\n        seconds to wait for a Hello Message.  Setting the\n        hold time to a value smaller than 15 is not\n        recommended, although not forbidden according\n        to RFC3036.\n\n        For auto-created entities that use the global label space\n        (and therefore might correspond to more than one\n        adjacency over more than one interface), this value will\n        only be meaningful if all interfaces that correspond to\n        this entity are configured to use the same hello hold\n        time, since this property can be configured on a per\n        interface basis.\n\n        If the interfaces have differing configurations, the\n        value returned on a MIB Get will be 0.")
mplsLdpEntityInitSessionThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityInitSessionThreshold.setReference('RFC3036, LDP Specification,\n        Section 2.5.3 Session Initialization.')
if mibBuilder.loadTexts: mplsLdpEntityInitSessionThreshold.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityInitSessionThreshold.setDescription("When attempting to establish a session with\n        a given Peer, the given LDP Entity should\n        send out the SNMP notification,\n        'mplsLdpInitSessionThresholdExceeded', when\n        the number of Session Initialization messages\n        sent exceeds this threshold.\n\n        The notification is used to notify an\n        operator when this Entity and its Peer are\n        possibly engaged in an endless sequence\n        of messages as each NAKs the other's\n\n        Initialization messages with Error Notification\n        messages.  Setting this threshold which triggers\n        the notification is one way to notify the\n        operator.  The notification should be generated\n        each time this threshold is exceeded and\n        for every subsequent Initialization message\n        which is NAK'd with an Error Notification\n        message after this threshold is exceeded.\n\n        A value of 0 (zero) for this object\n        indicates that the threshold is infinity, thus\n        the SNMP notification will never be generated.")
mplsLdpEntityLabelDistMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 12), MplsLabelDistributionMethod()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityLabelDistMethod.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLabelDistMethod.setDescription('For any given LDP session, the method of\n        label distribution must be specified.')
mplsLdpEntityLabelRetentionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 13), MplsRetentionMode()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityLabelRetentionMode.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLabelRetentionMode.setDescription('The LDP Entity can be configured to use either\n        conservative or liberal label retention mode.\n\n        If the value of this object is conservative(1)\n        then advertized label mappings are retained\n        only if they will be used to forward packets,\n        i.e., if label came from a valid next hop.\n\n        If the value of this object is liberal(2)\n        then all advertized label mappings are retained\n        whether they are from a valid next hop or not.')
mplsLdpEntityPathVectorLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityPathVectorLimit.setReference('RFC3036, LDP Specification, Section 2.8 Loop Dection,\n       Section 3.4.5 Path Vector TLV.')
if mibBuilder.loadTexts: mplsLdpEntityPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityPathVectorLimit.setDescription("If the value of this object is 0 (zero) then\n        Loop Detection for Path Vectors is disabled.\n\n        Otherwise, if this object has a value greater than\n        zero, then Loop Dection for Path Vectors is enabled,\n        and the Path Vector Limit is this value.\n        Also, the value of the object,\n        'mplsLdpLsrLoopDetectionCapable', must be set to\n        either 'pathVector(4)' or 'hopCountAndPathVector(5)',\n        if this object has a value greater than 0 (zero),\n        otherwise it is ignored.")
mplsLdpEntityHopCountLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityHopCountLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityHopCountLimit.setDescription("If the value of this object is 0 (zero),\n        then Loop Detection using Hop Counters is\n        disabled.\n\n        If the value of this object is greater than\n        0 (zero) then Loop Detection using Hop\n        Counters is enabled, and this object\n        specifies this Entity's maximum allowable\n        value for the Hop Count.\n        Also, the value of the object\n        mplsLdpLsrLoopDetectionCapable must be set\n        to either 'hopCount(3)' or\n        'hopCountAndPathVector(5)' if this object\n        has a value greater than 0 (zero), otherwise\n        it is ignored.")
mplsLdpEntityTransportAddrKind = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("interface", 1), ("loopback", 2))).clone('loopback')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTransportAddrKind.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTransportAddrKind.setDescription('This specifies whether the loopback or interface\n        address is to be used as the transport address\n        in the transport address TLV of the\n        hello message.\n\n        If the value is interface(1), then the IP\n        address of the interface from which hello\n        messages are sent is used as the transport\n        address in the hello message.\n\n        Otherwise, if the value is loopback(2), then the IP\n        address of the loopback interface is used as the\n        transport address in the hello message.')
mplsLdpEntityTargetPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetPeer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetPeer.setDescription('If this LDP entity uses targeted peer then set\n        this to true.')
mplsLdpEntityTargetPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 18), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetPeerAddrType.setDescription('The type of the internetwork layer address used for\n        the Extended Discovery.  This object indicates how\n        the value of mplsLdpEntityTargetPeerAddr is to\n        be interpreted.')
mplsLdpEntityTargetPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 19), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetPeerAddr.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetPeerAddr.setDescription('The value of the internetwork layer address\n        used for the Extended Discovery.  The value of\n        mplsLdpEntityTargetPeerAddrType specifies how\n        this address is to be interpreted.')
mplsLdpEntityLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 20), MplsLdpLabelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityLabelType.setReference('RFC3036, LDP Specification, Section 3.5.3.,\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLabelType.setDescription('Specifies the optional parameters for the LDP\n        Initialization Message.\n\n        If the value is generic(1) then no\n        optional parameters will be sent in\n        the LDP Initialization message associated\n        with this Entity.\n\n        If the value is atmParameters(2) then\n        a row must be created in the\n        mplsLdpEntityAtmTable, which\n        corresponds to this entry.\n\n        If the value is frameRelayParameters(3) then\n        a row must be created in the\n        mplsLdpEntityFrameRelayTable, which\n        corresponds to this entry.')
mplsLdpEntityDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 21), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion\n        at which any one or more of this entity's counters\n        suffered a discontinuity.  The relevant counters\n        are the specific instances associated with this\n        entity of any Counter32 object contained\n        in the 'mplsLdpEntityStatsTable'.  If no such\n        discontinuities have occurred since the last\n        re-initialization of the local management\n        subsystem, then this object contains a zero\n        value.")
mplsLdpEntityStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 22), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpEntityRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 25), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityRowStatus.setDescription("An object that allows entries in this table to\n         be created and deleted using the\n         RowStatus convention.\n\n         Once the 'mplsLdpEntityAdminStatus' object has\n         the value of 'up' and this object has the value\n         of 'active' then the Entity will atttempt to\n         contact an LDP Peer.  If the value of this object\n         is changed to 'notInService', then the Entity looses\n         contact with the LDP Peer and all information related\n         to that Peer must be removed from the MIB.  This has\n         the same effect as changing 'mplsLdpEntityAdminStatus'\n         from 'enable' to 'disable'.\n\n         When this object is set to 'active' and the value of\n         the 'mplsLdpEntityAdminStatus' is 'enable' then\n         this Entity will attempt to contact the Peer and\n         establish new sessions.")
mplsLdpEntityWildcardEntity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 1, 1, 24), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityWildcardEntity.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityWildcardEntity.setDescription("Specifies whether the LDP Entity is to be used for\n         accepting 'unsolicited' Hello messages that include the R\n         bit.\n\n         The value of this object is ignored unless\n         mplsLdpEntityTargetedPeer is set to true\n         mplsLdpEntityTargetedPeerAddr is set to 0.")
mplsLdpEntityStatsTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4), )
if mibBuilder.loadTexts: mplsLdpEntityStatsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsTable.setDescription('This table is a read-only table which augments\n        the mplsLdpEntityTable.  The purpose of this\n        table is to keep statistical information about\n        the LDP Entities on the LSR.')
mplsLdpEntityStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1), )
mplsLdpEntityEntry.registerAugmentions(("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsEntry"))
mplsLdpEntityStatsEntry.setIndexNames(*mplsLdpEntityEntry.getIndexNames())
if mibBuilder.loadTexts: mplsLdpEntityStatsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsEntry.setDescription('A row in this table contains statistical information\n        about an LDP Entity.  Some counters contained in a\n        row are for fatal errors received during a former\n        LDP Session associated with this entry.  For example,\n        an LDP PDU received on a TCP connection during an\n        LDP Session contains a fatal error.  That\n        error is counted here, because the\n        session is terminated.\n\n        If the error is NOT fatal (i.e., the Session\n        remains), then the error is counted in the\n        mplsLdpSessionStatsEntry.')
mplsLdpEntityStatsSessionAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionAttempts.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionAttempts.setDescription("A count of the Session Initialization messages\n        which were sent or received by this LDP Entity and\n        were NAK'd.   In other words, this counter counts\n        the number of session initializations that failed.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.")
mplsLdpEntityStatsSessionRejectedNoHelloErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedNoHelloErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedNoHelloErrors.setDescription('A count of the Session Rejected/No Hello Error\n        Notification Messages sent or received by\n        this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsSessionRejectedAdErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedAdErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedAdErrors.setDescription('A count of the Session Rejected/Parameters\n        Advertisement Mode Error Notification Messages sent\n        or received by this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsSessionRejectedMaxPduErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedMaxPduErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedMaxPduErrors.setDescription('A count of the Session Rejected/Parameters\n\n        Max Pdu Length Error Notification Messages sent\n        or received by this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsSessionRejectedLRErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedLRErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsSessionRejectedLRErrors.setDescription('A count of the Session Rejected/Parameters\n        Label Range Notification Messages sent\n        or received by this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsBadLdpIdentifierErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsBadLdpIdentifierErrors.setReference('RFC3036, LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadLdpIdentifierErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadLdpIdentifierErrors.setDescription('This object counts the number of Bad LDP Identifier\n        Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsBadPduLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsBadPduLengthErrors.setReference('RFC3036, LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadPduLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadPduLengthErrors.setDescription('This object counts the number of Bad PDU Length\n        Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsBadMessageLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsBadMessageLengthErrors.setReference('RFC3036, LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadMessageLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadMessageLengthErrors.setDescription('This object counts the number of Bad Message\n        Length Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsBadTlvLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsBadTlvLengthErrors.setReference('RFC3036, LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadTlvLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsBadTlvLengthErrors.setDescription('This object counts the number of Bad TLV\n        Length Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsMalformedTlvValueErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsMalformedTlvValueErrors.setReference('RFC3036, LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpEntityStatsMalformedTlvValueErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsMalformedTlvValueErrors.setDescription('This object counts the number of Malformed TLV\n        Value Fatal Errors detected by the session(s)\n        (past and present) associated with this\n        LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsKeepAliveTimerExpErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsKeepAliveTimerExpErrors.setReference('RFC3036, LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpEntityStatsKeepAliveTimerExpErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsKeepAliveTimerExpErrors.setDescription('This object counts the number of Session Keep Alive\n        Timer Expired Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsShutdownReceivedNotifications = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsShutdownReceivedNotifications.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsShutdownReceivedNotifications.setDescription('This object counts the number of Shutdown Notifications\n        received related to session(s) (past and present)\n        associated with this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpEntityStatsShutdownSentNotifications = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityStatsShutdownSentNotifications.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsShutdownSentNotifications.setDescription('This object counts the number of Shutdown Notfications\n        sent related to session(s) (past and present) associated\n        with this LDP Entity.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpEntityDiscontinuityTime.')
mplsLdpSessionObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3))
mplsLdpPeerLastChange = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerLastChange.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLastChange.setDescription('The value of sysUpTime at the time of the most\n        recent addition or deletion to/from the\n        mplsLdpPeerTable/mplsLdpSessionTable.')
mplsLdpPeerTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 2), )
if mibBuilder.loadTexts: mplsLdpPeerTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerTable.setDescription('Information about LDP peers known by Entities in\n        the mplsLdpEntityTable.  The information in this table\n        is based on information from the Entity-Peer interaction\n        during session initialization but is not appropriate\n        for the mplsLdpSessionTable, because objects in this\n        table may or may not be used in session establishment.')
mplsLdpPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 2, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"))
if mibBuilder.loadTexts: mplsLdpPeerEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerEntry.setDescription('Information about a single Peer which is related\n        to a Session.  NOTE:  this table is used to\n        augment the mplsLdpSessionTable.')
mplsLdpPeerLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 2, 1, 1), MplsLdpIdentifier())
if mibBuilder.loadTexts: mplsLdpPeerLdpId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLdpId.setDescription('The LDP identifier of this LDP Peer.')
mplsLdpPeerLabelDistMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 2, 1, 2), MplsLabelDistributionMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerLabelDistMethod.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLabelDistMethod.setDescription('For any given LDP session, the method of\n        label distribution must be specified.')
mplsLdpPeerPathVectorLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerPathVectorLimit.setReference('RFC3036, LDP Specification, Section 2.8 Loop Dection,\n       Section 3.4.5 Path Vector TLV.')
if mibBuilder.loadTexts: mplsLdpPeerPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerPathVectorLimit.setDescription('If the value of this object is 0 (zero) then\n        Loop Dection for Path Vectors for this Peer\n        is disabled.\n\n        Otherwise, if this object has a value greater than\n        zero, then Loop Dection for Path  Vectors for this\n        Peer is enabled and the Path Vector Limit is this value.')
mplsLdpPeerTransportAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerTransportAddrType.setReference('RFC3036, LDP Specification, Section 2.5.2\n       Transport Connection Establishment and\n       Section 3.5.2.1 Hello Message Procedures.')
if mibBuilder.loadTexts: mplsLdpPeerTransportAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerTransportAddrType.setDescription("The type of the Internet address for the\n        mplsLdpPeerTransportAddr object.  The LDP\n        specification describes this as being either\n        an IPv4 Transport Address or IPv6 Transport\n        Address which is used in opening the LDP session's\n        TCP connection, or if the optional TLV is not\n        present, then this is the IPv4/IPv6 source\n        address for the UPD packet carrying the Hellos.\n\n        This object specifies how the value of the\n        mplsLdpPeerTransportAddr object should be\n        interpreted.")
mplsLdpPeerTransportAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerTransportAddr.setReference('RFC3036, LDP Specification, Section 2.5.2\n       Transport Connection Establishment and\n       Section 3.5.2.1 Hello Message Procedures.')
if mibBuilder.loadTexts: mplsLdpPeerTransportAddr.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerTransportAddr.setDescription('The Internet address advertised by the peer\n        in the Hello Message or the Hello source address.\n\n        The type of this address is specified by the\n        value of the mplsLdpPeerTransportAddrType\n        object.')
mplsLdpSessionTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3), )
if mibBuilder.loadTexts: mplsLdpSessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionTable.setDescription('A table of Sessions between the LDP Entities\n        and LDP Peers.  Each row in this table\n        represents a single session.')
mplsLdpSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"))
if mibBuilder.loadTexts: mplsLdpSessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionEntry.setDescription("An entry in this table represents information on a\n        single session between an LDP Entity and LDP Peer.\n        The information contained in a row is read-only.\n\n        Please note:  the Path Vector Limit for the\n        Session is the value which is configured in\n        the corresponding mplsLdpEntityEntry. The\n        Peer's Path Vector Limit is in the\n        mplsLdpPeerPathVectorLimit object in the\n        mplsLdpPeerTable.\n\n        Values which may differ from those configured are\n        noted in the objects of this table, the\n        mplsLdpAtmSessionTable and the\n        mplsLdpFrameRelaySessionTable. A value will\n        differ if it was negotiated between the\n        Entity and the Peer. Values may or may not\n        be negotiated. For example, if the values\n        are the same then no negotiation takes place.\n        If they are negotiated, then they may differ.")
mplsLdpSessionStateLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionStateLastChange.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStateLastChange.setDescription('The value of sysUpTime at the time this\n        Session entered its current state as\n        denoted by the mplsLdpSessionState\n        object.')
mplsLdpSessionState = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonexistent", 1), ("initialized", 2), ("openrec", 3), ("opensent", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionState.setReference('RFC3036, LDP Specification, Section 2.5.4,\n        Initialization State Machine.')
if mibBuilder.loadTexts: mplsLdpSessionState.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionState.setDescription('The current state of the session, all of the\n        states 1 - 5 are based on the state machine\n        for session negotiation behavior.')
mplsLdpSessionRole = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("passive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRole.setReference('RFC3036, LDP Specification, Section 2.5.3.,\n        Session Initialization')
if mibBuilder.loadTexts: mplsLdpSessionRole.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRole.setDescription("During session establishment the LSR/LER takes either\n        the active role or the passive role based on address\n        comparisons.  This object indicates whether this LSR/LER\n        was behaving in an active role or passive role during\n        this session's establishment.\n\n        The value of unknown(1), indicates that the role is not\n        able to be determined at the present time.")
mplsLdpSessionProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionProtocolVersion.setReference('RFC3036, LDP Specification, Section 3.5.3,\n       Initialization Message.')
if mibBuilder.loadTexts: mplsLdpSessionProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionProtocolVersion.setDescription('The version of the LDP Protocol which\n        this session is using.  This is the version of\n        the LDP protocol which has been negotiated\n        during session initialization.')
mplsLdpSessionKeepAliveHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 5), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveHoldTimeRemaining.setDescription("The keep alive hold time remaining for this session in\n        units of hundredths of a second.  This interval will\n        change when the 'next' Keep Alive message which\n        corresponds to this session is received.  A value of zero\n        indicates that the keep alive hold timer is not running.")
mplsLdpSessionKeepAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveTime.setReference('RFC3036, LDP Specification, Section 3.5.3,\n          Initialization Message.')
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveTime.setDescription("The negotiated KeepAlive Time which\n           represents the amount of seconds between\n           keep alive messages.  The\n           mplsLdpEntityKeepAliveHoldTimer\n           related to this Session is the\n           value that was proposed as the\n           KeepAlive Time for this session.\n\n           This value is negotiated during\n           session initialization between\n           the entity's proposed value\n           (i.e., the value configured in\n           mplsLdpEntityKeepAliveHoldTimer)\n           and the peer's proposed\n           KeepAlive Hold Timer value.\n           This value is the smaller\n           of the two proposed values.")
mplsLdpSessionMaxPduLength = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionMaxPduLength.setReference('RFC3036, LDP Specification, Section 3.5.3,\n          Initialization Message.')
if mibBuilder.loadTexts: mplsLdpSessionMaxPduLength.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionMaxPduLength.setDescription('The value of maximum allowable length for LDP PDUs for\n           this session.  This value may have been negotiated\n           during the Session Initialization.  This object is\n           related to the mplsLdpEntityMaxPduLength object.  The\n           mplsLdpEntityMaxPduLength object specifies the requested\n           LDP PDU length, and this object reflects the negotiated\n           LDP PDU length between the Entity and\n           the Peer.')
mplsLdpSessionDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\n        which any one or more of this session's counters\n        suffered a discontinuity.  The relevant counters are\n        the specific instances associated with this session\n        of any Counter32 or Counter64 object contained in the\n        mplsLdpSessionStatsTable.  If no such discontinuities have\n        occurred since the last re-initialization of the local\n        management subsystem, then this object contains a zero\n        value.\n\n        The initial value of this object is the value of\n        sysUpTime when the entry was created in this table.\n\n        Also, a NMS(command generator) can distinguish when a session\n        between a given Entity and Peer goes away and then a new\n        session is established.  This value would change and\n        thus indicate to the NMS(command generator) that this is a\n        different session.")
mplsLdpSessionConfiguredHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionConfiguredHoldTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionConfiguredHoldTime.setDescription('The locally configured keepalive hold time for this\n        session, in seconds.  Note that the value of this field\n        reflects configuration at the time of session\n        initialization; this may differ from the configuration\n        that would apply to a new session, if configuration has\n        changed since this session was initialized.')
mplsLdpSessionPeerHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionPeerHoldTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerHoldTime.setDescription("The peer's advertised keepalive hold time for this session\n        in seconds.  Note that the value of this field reflects\n        the peer's configuration at the time of session\n        initialization; this may differ from the configuration\n        that would apply to a new session, if the peer's\n        configuration has changed since this session was\n        initialized.")
mplsLdpSessionHoldTimeInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 3, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionHoldTimeInUse.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionHoldTimeInUse.setDescription('The keepalive hold time that is currently in use for this\n        session, in seconds.')
mplsLdpSessionStatsTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 4), )
if mibBuilder.loadTexts: mplsLdpSessionStatsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsTable.setDescription('A table of statistics for Sessions between\n        LDP Entities and LDP Peers.  The table is read\n        only.  Counters are only incremented when the U\n        bit is not set.')
mplsLdpSessionStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 4, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"))
if mibBuilder.loadTexts: mplsLdpSessionStatsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsEntry.setDescription('An entry in this table represents statistical\n        information on a single session between an LDP\n        Entity and LDP Peer.  Errors are only counted\n        if the U bit is not set in the message or TLV.')
mplsLdpSessionStatsUnknownMesTypeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownMesTypeErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownMesTypeErrors.setDescription('This object counts the number of Unknown Message Type\n        Errors detected by this LSR/LER during this session.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpSessionDiscontinuityTime.')
mplsLdpSessionStatsUnknownTlvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownTlvErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownTlvErrors.setDescription('This object counts the number of Unknown TLV Errors\n        detected by this LSR/LER during this session.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpSessionDiscontinuityTime.')
mplsLdpHelloAdjacencyObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5))
mplsLdpHelloAdjacencyTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1), )
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyTable.setDescription('A table of Hello Adjacencies for Sessions.')
mplsLdpHelloAdjacencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpHelloAdjacencyIndex"))
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyEntry.setDescription('Each row represents a single LDP Hello Adjacency.\n        An LDP Session can have one or more Hello adjacencies.')
mplsLdpHelloAdjacencyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyIndex.setDescription('An identifier for this specific adjacency.')
mplsLdpHelloAdjacencyHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1, 1, 2), TimeInterval()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTimeRemaining.setDescription("If the value of this object is 65535,\n        this means that the hold time is infinite\n        (i.e., wait forever).\n\n        Otherwise, the time remaining for\n        this Hello Adjacency to receive its\n        next Hello Message.\n\n        This interval will change when the 'next'\n        Hello Message which corresponds to this\n        Hello Adjacency is received unless it\n        is infinite.")
mplsLdpHelloAdjacencyHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTime.setReference('RFC3036, LDP Specification, Section 3.5.2 Hello Message')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTime.setDescription('The Hello hold time which is negotiated between\n        the Entity and the Peer.  The entity associated\n        with this Hello Adjacency issues a proposed\n        Hello Hold Time value in the\n        mplsLdpEntityHelloHoldTimer object.  The peer\n        also proposes a value and this object represents\n        the negotiated value.\n\n        A value of 0 means the default,\n        which is 15 seconds for Link Hellos\n        and 45 seconds for Targeted Hellos.\n        A value of 65535 indicates an\n        infinite hold time.')
mplsLdpHelloAdjacencyType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("link", 1), ("targeted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyType.setDescription("This adjacency is the result of a 'link'\n        hello if the value of this object is link(1).\n        Otherwise, it is a result of a 'targeted'\n        hello, targeted(2).")
mplsLdpHelloAdjacencyConfiguredHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyConfiguredHoldTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyConfiguredHoldTime.setDescription('The locally configured hello hold time for this adjacency,\n        in seconds.')
mplsLdpHelloAdjacencyPeerHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 5, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyPeerHoldTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyPeerHoldTime.setDescription("The peer's advertised hello hold time for this adjacency,\n        in seconds.")
mplsInSegmentLdpLspTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 6), )
if mibBuilder.loadTexts: mplsInSegmentLdpLspTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLdpLspTable.setDescription('A table of LDP LSPs which\n        map to the mplsInSegmentTable in the\n        MPLS-LSR-MIB module.')
mplsInSegmentLdpLspEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 6, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsInSegmentLdpLspIndex"))
if mibBuilder.loadTexts: mplsInSegmentLdpLspEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLdpLspEntry.setDescription("An entry in this table represents information\n        on a single LDP LSP which is represented by\n        a session's index triple (mplsLdpEntityLdpId,\n        mplsLdpEntityIndex, mplsLdpPeerLdpId) AND the\n        index for the mplsInSegmentTable\n        (mplsInSegmentLdpLspLabelIndex) from the\n        MPLS-LSR-MIB.\n\n        The information contained in a row is read-only.")
mplsInSegmentLdpLspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 6, 1, 1), MplsIndexType())
if mibBuilder.loadTexts: mplsInSegmentLdpLspIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLdpLspIndex.setDescription("This contains the same value as the\n        mplsInSegmentIndex in the\n        MPLS-LSR-MIB's mplsInSegmentTable.")
mplsInSegmentLdpLspLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 6, 1, 2), MplsLdpLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentLdpLspLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLdpLspLabelType.setDescription('The Layer 2 Label Type.')
mplsInSegmentLdpLspType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 6, 1, 3), MplsLspType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentLdpLspType.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLdpLspType.setDescription('The type of LSP connection.')
mplsOutSegmentLdpLspTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 7), )
if mibBuilder.loadTexts: mplsOutSegmentLdpLspTable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentLdpLspTable.setDescription('A table of LDP LSPs which\n        map to the mplsOutSegmentTable in the\n       MPLS-LSR-MIB.')
mplsOutSegmentLdpLspEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 7, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsOutSegmentLdpLspIndex"))
if mibBuilder.loadTexts: mplsOutSegmentLdpLspEntry.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentLdpLspEntry.setDescription("An entry in this table represents information\n        on a single LDP LSP which is represented by\n        a session's index triple (mplsLdpEntityLdpId,\n        mplsLdpEntityIndex, mplsLdpPeerLdpId) AND the\n        index (mplsOutSegmentLdpLspIndex)\n        for the mplsOutSegmentTable.\n\n        The information contained in a row is read-only.")
mplsOutSegmentLdpLspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 7, 1, 1), MplsIndexType())
if mibBuilder.loadTexts: mplsOutSegmentLdpLspIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentLdpLspIndex.setDescription("This contains the same value as the\n        mplsOutSegmentIndex in the\n        MPLS-LSR-MIB's mplsOutSegmentTable.")
mplsOutSegmentLdpLspLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 7, 1, 2), MplsLdpLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentLdpLspLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentLdpLspLabelType.setDescription('The Layer 2 Label Type.')
mplsOutSegmentLdpLspType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 7, 1, 3), MplsLspType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentLdpLspType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentLdpLspType.setDescription('The type of LSP connection.')
mplsFecObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10))
mplsFecLastChange = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecLastChange.setStatus('current')
if mibBuilder.loadTexts: mplsFecLastChange.setDescription('The value of sysUpTime at the time of the most\n        recent addition/deletion of an entry\n        to/from the mplsLdpFectTable or\n        the most recent change in values to any objects\n        in the mplsLdpFecTable.\n\n        If no such changes have occurred since the last\n        re-initialization of the local management subsystem,\n        then this object contains a zero value.')
mplsFecTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2), )
if mibBuilder.loadTexts: mplsFecTable.setStatus('current')
if mibBuilder.loadTexts: mplsFecTable.setDescription('This table represents the FEC\n        (Forwarding Equivalence Class)\n        Information associated with an LSP.')
mplsFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsFecIndex"))
if mibBuilder.loadTexts: mplsFecEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFecEntry.setDescription('Each row represents a single FEC Element.')
mplsFecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsFecIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFecIndex.setDescription('The index which uniquely identifies this entry.')
mplsFecType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("prefix", 1), ("hostAddress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecType.setReference('RFC3036, Section 3.4.1. FEC TLV.')
if mibBuilder.loadTexts: mplsFecType.setStatus('current')
if mibBuilder.loadTexts: mplsFecType.setDescription("The type of the FEC.  If the value of this object\n        is 'prefix(1)' then the FEC type described by this\n        row is an address prefix.\n\n        If the value of this object is 'hostAddress(2)' then\n        the FEC type described by this row is a host address.")
mplsFecAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecAddrType.setReference('RFC3036, Section 3.4.1. FEC TLV.')
if mibBuilder.loadTexts: mplsFecAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddrType.setDescription('The value of this object is the type of the\n        Internet address.  The value of this object,\n        decides how the value of the mplsFecAddr object\n        is interpreted.')
mplsFecAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecAddr.setReference('RFC3036, Section 3.4.1 FEC TLV.')
if mibBuilder.loadTexts: mplsFecAddr.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddr.setDescription("The value of this object is interpreted based\n        on the value of the 'mplsFecAddrType' object.\n\n        This address is then further interpretted as\n        an being used with the address prefix,\n        or as the host address.  This further interpretation\n        is indicated by the 'mplsFecType' object.\n        In other words, the FEC element is populated\n        according to the Prefix FEC Element value encoding, or\n        the Host Address FEC Element encoding.")
mplsFecAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2, 1, 3), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecAddrPrefixLength.setReference('RFC3036, Section 3.4.1. FEC TLV.')
if mibBuilder.loadTexts: mplsFecAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddrPrefixLength.setDescription("If the value of the 'mplsFecType' is 'hostAddress(2)' then\n        this object is undefined.\n\n        If the value of 'mplsFecType' is 'prefix(1)' then the\n        value of this object is the length in bits of the address\n        prefix represented by 'mplsFecAddr', or zero.  If the\n        value of this object is zero, this indicates that the\n        prefix matches all addresses.  In this case the address\n        prefix MUST also be zero (i.e., 'mplsFecAddr' should have\n        the value of zero).")
mplsFecStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 10, 2, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsFecStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpLspFecLastChange = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpLspFecLastChange.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecLastChange.setDescription('The value of sysUpTime at the time of the most\n        recent addition/deletion of an entry\n        to/from the mplsLdpLspFecTable or\n        the most recent change in values to any objects in the\n        mplsLdpLspFecTable.\n\n        If no such changes have occurred since the last\n        re-initialization of the local management subsystem,\n        then this object contains a zero value.')
mplsLdpLspFecTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 12), )
if mibBuilder.loadTexts: mplsLdpLspFecTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecTable.setDescription('A table which shows the relationship between\n      LDP LSPs and FECs.  Each row represents\n      a single LDP LSP to FEC association.')
mplsLdpLspFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 12, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpLspFecSegment"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpLspFecSegmentIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpLspFecIndex"))
if mibBuilder.loadTexts: mplsLdpLspFecEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecEntry.setDescription('An entry represents a LDP LSP\n      to FEC association.')
mplsLdpLspFecSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inSegment", 1), ("outSegment", 2))))
if mibBuilder.loadTexts: mplsLdpLspFecSegment.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecSegment.setDescription('If the value is inSegment(1), then this\n       indicates that the following index,\n       mplsLdpLspFecSegmentIndex, contains the same\n       value as the mplsInSegmentLdpLspIndex.\n\n       Otherwise, if the value of this object is\n       outSegment(2),  then this\n       indicates that following index,\n       mplsLdpLspFecSegmentIndex, contains the same\n       value as the mplsOutSegmentLdpLspIndex.')
mplsLdpLspFecSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 12, 1, 2), MplsIndexType())
if mibBuilder.loadTexts: mplsLdpLspFecSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecSegmentIndex.setDescription('This index is interpretted by using the value\n       of the mplsLdpLspFecSegment.\n\n       If the mplsLdpLspFecSegment is inSegment(1),\n       then this index has the same value as\n       mplsInSegmentLdpLspIndex.\n\n       If the mplsLdpLspFecSegment is outSegment(2),\n       then this index has the same value as\n       mplsOutSegmentLdpLspIndex.')
mplsLdpLspFecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLdpLspFecIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecIndex.setDescription('This index identifies the FEC entry in the\n        mplsFecTable associated with this session.\n        In other words, the value of this index\n        is the same as the value of the mplsFecIndex\n        that denotes the FEC associated with this\n        Session.')
mplsLdpLspFecStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 12, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpLspFecStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecStorageType.setDescription("The storage type for this conceptual row.\n       Conceptual rows having the value 'permanent(4)'\n       need not allow write-access to any columnar\n       objects in the row.")
mplsLdpLspFecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 12, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpLspFecRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspFecRowStatus.setDescription("The status of this conceptual row.  If the\n        value of this object is 'active(1)', then\n        none of the writable objects of this entry\n        can be modified.\n\n        The Agent should delete this row when\n        the session ceases to exist.  If an\n        operator wants to associate the session with\n        a different FEC, the recommended\n        procedure is (as described in detail in the section\n        entitled, 'Changing Values After Session\n        Establishment', and again described in the\n        DESCRIPTION clause of the\n        mplsLdpEntityAdminStatus object)\n        is to set the mplsLdpEntityAdminStatus to\n        down, thereby explicitly causing a session\n        to be torn down. This will also\n        cause this entry to be deleted.\n\n        Then, set the mplsLdpEntityAdminStatus\n        to enable which enables a new session to be initiated.\n        Once the session is initiated, an entry may be\n        added to this table to associate the new session\n        with a FEC.")
mplsLdpSessionPeerAddrTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 13), )
if mibBuilder.loadTexts: mplsLdpSessionPeerAddrTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddrTable.setDescription("This table 'extends' the mplsLdpSessionTable.\n        This table is used to store Label Address Information\n        from Label Address Messages received by this LSR from\n        Peers.  This table is read-only and should be updated\n        when Label Withdraw Address Messages are received, i.e.,\n        Rows should be deleted as appropriate.\n\n        NOTE:  since more than one address may be contained\n        in a Label Address Message, this table 'sparse augments',\n        the mplsLdpSessionTable's information.")
mplsLdpSessionPeerAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 13, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpSessionPeerAddrIndex"))
if mibBuilder.loadTexts: mplsLdpSessionPeerAddrEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddrEntry.setDescription("An entry in this table represents information on\n        a session's single next hop address which was\n        advertised in an Address Message from the LDP peer.\n        The information contained in a row is read-only.")
mplsLdpSessionPeerAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpSessionPeerAddrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddrIndex.setDescription('An index which uniquely identifies this entry within\n        a given session.')
mplsLdpSessionPeerNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 13, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddrType.setDescription('The internetwork layer address type of this Next Hop\n        Address as specified in the Label Address Message\n        associated with this Session. The value of this\n        object indicates how to interpret the value of\n        mplsLdpSessionPeerNextHopAddr.')
mplsLdpSessionPeerNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 3, 13, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddr.setReference('RFC3036, Section 2.7. LDP Identifiers\n        and Next Hop Addresses')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddr.setDescription('The next hop address.  The type of this address\n        is specified by the value of the\n        mplsLdpSessionPeerNextHopAddrType.')
mplsLdpEntityIndexNextTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 2), )
if mibBuilder.loadTexts: mplsLdpEntityIndexNextTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndexNextTable.setDescription('This table contains the next available values of\n        mplsLdpEntityIndex for all entities.')
mplsLdpEntityIndexNextEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 2, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"))
if mibBuilder.loadTexts: mplsLdpEntityIndexNextEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndexNextEntry.setDescription('An entry in this table represents the next available\n        mplsLdpEntityIndex for a specific LDP entity.\n        This MIB table is indexed by the PRVT-LDP entity Index.')
mplsLdpEntityIndexNext = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndexNext.setDescription('This object contains an appropriate value to\n        be used for mplsLdpEntityIndex when creating\n        entries in the mplsLdpEntityTable. The value\n        0 indicates that no unassigned entries are\n        available. To obtain the mplsLdpEntityIndex\n        value for a new entry, the manager issues a\n        management protocol retrieval operation to obtain\n        the current value of this object.  After each\n        retrieval, the agent should modify the value to\n        the next unassigned index.')
mplsLdpInitSessionThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 2, 0, 1)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpEntityInitSessionThreshold"))
if mibBuilder.loadTexts: mplsLdpInitSessionThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsLdpInitSessionThresholdExceeded.setDescription("This notification is generated when the value of\n        the 'mplsLdpEntityInitSessionThreshold' object\n        is not zero, and the number of Session\n        Initialization messages exceeds the value\n        of the 'mplsLdpEntityInitSessionThreshold' object.")
mplsLdpPathVectorLimitMismatch = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 2, 0, 2)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpEntityPathVectorLimit"), ("PRVT-MPLS-LDP-MIB", "mplsLdpPeerPathVectorLimit"))
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setDescription("This notification is sent when the\n        'mplsLdpEntityPathVectorLimit' does NOT match\n        the value of the 'mplsLdpPeerPathVectorLimit' for\n        a specific Entity.")
mplsLdpSessionUp = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 2, 0, 3)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpSessionState"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionDiscontinuityTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownMesTypeErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownTlvErrors"))
if mibBuilder.loadTexts: mplsLdpSessionUp.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionUp.setDescription("If this notification is sent when the\n        value of 'mplsLdpSessionState' enters \n        the 'operational(5)' state.")
mplsLdpSessionDown = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 2, 0, 4)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpSessionState"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionDiscontinuityTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownMesTypeErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownTlvErrors"))
if mibBuilder.loadTexts: mplsLdpSessionDown.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionDown.setDescription("This notification is sent when the  \n        value of 'mplsLdpSessionState' leaves\n        the 'operational(5)' state.")
mplsLdpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3, 1))
mplsLdpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3, 2))
mplsLdpModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3, 2, 1)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpGeneralGroup"), ("PRVT-MPLS-LDP-MIB", "mplsLdpNotificationsGroup"), ("PRVT-MPLS-LDP-MIB", "mplsLdpLspGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpModuleFullCompliance = mplsLdpModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpModuleFullCompliance.setDescription('The Module is implemented with support\n        for read-create and read-write.  In other\n        words, both monitoring and configuration\n        are available when using this MODULE-COMPLIANCE.')
mplsLdpModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3, 2, 2)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpGeneralGroup"), ("PRVT-MPLS-LDP-MIB", "mplsLdpNotificationsGroup"), ("PRVT-MPLS-LDP-MIB", "mplsLdpLspGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpModuleReadOnlyCompliance = mplsLdpModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpModuleReadOnlyCompliance.setDescription('The Module is implemented with support\n        for read-only.  In other words, only monitoring\n        is available by implementing this MODULE-COMPLIANCE.')
mplsLdpGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3, 1, 1)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpLsrId"), ("PRVT-MPLS-LDP-MIB", "mplsLdpLsrLoopDetectionCapable"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndexNext"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityProtocolVersion"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAdminStatus"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityOperStatus"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityWellKnownTcpDiscoveryPort"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityWellKnownUdpDiscoveryPort"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityMaxPduLength"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityKeepAliveHoldTimer"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityHelloHoldTimer"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityInitSessionThreshold"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityLabelDistMethod"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityLabelRetentionMode"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityPathVectorLimit"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityHopCountLimit"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityTransportAddrKind"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityTargetPeer"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityTargetPeerAddrType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityTargetPeerAddr"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityLabelType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityDiscontinuityTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStorageType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityRowStatus"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityWildcardEntity"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsSessionAttempts"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsSessionRejectedNoHelloErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsSessionRejectedAdErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsSessionRejectedMaxPduErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsSessionRejectedLRErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsBadLdpIdentifierErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsBadPduLengthErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsBadMessageLengthErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsBadTlvLengthErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsMalformedTlvValueErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsKeepAliveTimerExpErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsShutdownReceivedNotifications"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityStatsShutdownSentNotifications"), ("PRVT-MPLS-LDP-MIB", "mplsLdpPeerLastChange"), ("PRVT-MPLS-LDP-MIB", "mplsLdpPeerLabelDistMethod"), ("PRVT-MPLS-LDP-MIB", "mplsLdpPeerPathVectorLimit"), ("PRVT-MPLS-LDP-MIB", "mplsLdpPeerTransportAddrType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpPeerTransportAddr"), ("PRVT-MPLS-LDP-MIB", "mplsLdpHelloAdjacencyHoldTimeRemaining"), ("PRVT-MPLS-LDP-MIB", "mplsLdpHelloAdjacencyHoldTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpHelloAdjacencyType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpHelloAdjacencyConfiguredHoldTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpHelloAdjacencyPeerHoldTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionStateLastChange"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionState"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionRole"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionProtocolVersion"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionKeepAliveHoldTimeRemaining"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionKeepAliveTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionMaxPduLength"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionDiscontinuityTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionConfiguredHoldTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionPeerHoldTime"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionHoldTimeInUse"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownMesTypeErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownTlvErrors"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionPeerNextHopAddrType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionPeerNextHopAddr"), ("PRVT-MPLS-LDP-MIB", "mplsFecLastChange"), ("PRVT-MPLS-LDP-MIB", "mplsFecType"), ("PRVT-MPLS-LDP-MIB", "mplsFecAddrType"), ("PRVT-MPLS-LDP-MIB", "mplsFecAddr"), ("PRVT-MPLS-LDP-MIB", "mplsFecAddrPrefixLength"), ("PRVT-MPLS-LDP-MIB", "mplsFecStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpGeneralGroup = mplsLdpGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpGeneralGroup.setDescription('Objects that apply to all MPLS LDP implementations.')
mplsLdpLspGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3, 1, 2)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsInSegmentLdpLspLabelType"), ("PRVT-MPLS-LDP-MIB", "mplsInSegmentLdpLspType"), ("PRVT-MPLS-LDP-MIB", "mplsOutSegmentLdpLspLabelType"), ("PRVT-MPLS-LDP-MIB", "mplsOutSegmentLdpLspType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpLspFecLastChange"), ("PRVT-MPLS-LDP-MIB", "mplsLdpLspFecStorageType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpLspFecRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpLspGroup = mplsLdpLspGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLspGroup.setDescription('These objects are for LDP implementations\n        which interface to the Label Information Base (LIB)\n        in the MPLS-LSR-STD-MIB.  The LIB is\n        represented in the mplsInSegmentTable,\n        mplsOutSegmentTable and mplsXCTable.')
mplsLdpNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 3, 1, 3)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpInitSessionThresholdExceeded"), ("PRVT-MPLS-LDP-MIB", "mplsLdpPathVectorLimitMismatch"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionUp"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpNotificationsGroup = mplsLdpNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpNotificationsGroup.setDescription('The notification for an MPLS LDP implementation.')
mplsLdpAtmObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4))
mplsLdpAtmConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 5))
mplsLdpEntityAtmObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1))
mplsLdpEntityAtmTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1), )
if mibBuilder.loadTexts: mplsLdpEntityAtmTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmTable.setDescription("This table contains ATM specific information\n        which could be used in the\n        'Optional Parameters' and other ATM specific\n        information.")
mplsLdpEntityAtmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityAtmEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmEntry.setDescription('An entry in this table represents the ATM parameters\n        and ATM information for this LDP entity.')
mplsLdpEntityAtmIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setDescription('This value represents either the InterfaceIndex\n       or 0 (zero).  The value of zero means that the\n       InterfaceIndex is not known.\n\n       However, if the InterfaceIndex is known, then it must\n       be represented by this value.\n\n       If an InterfaceIndex becomes known, then the\n       network management entity (e.g., SNMP agent) responsible\n       for this object MUST change the value from 0 (zero) to the\n       value of the InterfaceIndex.  If an ATM Label is\n       being used in forwarding data, then the value of this\n       object MUST be the InterfaceIndex.')
mplsLdpEntityAtmMergeCap = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 0), ("vpMerge", 1), ("vcMerge", 2), ("vpAndVcMerge", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setReference('RFC3036, LDP Specification, Section 3.5.3\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setDescription("Denotes the Merge Capability of this Entity.\n        This is the EXACT value for the ATM Session\n        Parameter, field M (for ATM Merge Capabilities).\n        The ATM Session Parameter is an optional\n        parameter in the Initialization Message.\n\n        The description from rfc3036.txt is:\n\n        'M, ATM Merge Capabilities\n           Specifies the merge capabilities of an ATM switch.  The\n           following values are supported in this version of the\n           specification:\n\n                  Value          Meaning\n\n                    0            Merge not supported\n                    1            VP Merge supported\n                    2            VC Merge supported\n                    3            VP & VC Merge supported\n\n           If the merge capabilities of the LSRs differ, then:\n           -  Non-merge and VC-merge LSRs may freely interoperate.\n\n           -  The interoperability of VP-merge-capable switches\n              with non-VP-merge-capable switches is a subject\n              for future study.  When the LSRs differ on the\n              use of VP-merge, the session is established,\n              but VP merge is not used.'\n\n           Please refer to the following reference for a\n           complete description of this feature.")
mplsLdpEntityAtmLRComponents = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setReference('RFC3036, LDP Specification, Section 3.5.3\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setDescription("Number of Label Range Components in the Initialization\n        message.  This also represents the number of entries\n        in the mplsLdpEntityAtmLRTable which correspond\n        to this entry.\n\n        This is the EXACT value for the ATM Session Parameter,\n        field N (for Number of label range components).\n        The ATM Session Parameter is an optional parameter\n        in the Initialization Message.\n\n        The description from rfc3036.txt is:\n\n        'N, Number of label range components\n           Specifies the number of ATM Label Range\n           Components included in the TLV.'\n\n         Please refer to the following reference for\n         a complete description of this feature.")
mplsLdpEntityAtmVcDirectionality = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirectional", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setReference('RFC3036, LDP Specification, Section 3.5.3\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)',\n        a given VCI, within a given VPI, is used as a\n        label for both directions independently.\n\n        If the value of this object is 'unidirectional(1)',\n        a given VCI within a VPI designates one direction.\n\n        This is the EXACT value for the ATM Session Parameter,\n        field D (for VC Directionality).  The ATM Session\n        Parameter is an optional parameter in the\n        Initialization Message.\n\n        The description from rfc3036.txt is:\n\n        'D, VC Directionality\n           A value of 0 specifies bidirectional VC capability,\n           meaning the LSR can (within a given VPI) support\n           the use of a given VCI as a label for both link\n           directions independently.  A value of 1\n           specifies unidirectional VC capability, meaning\n           (within a given VPI) a given VCI may appear in\n           a label mapping for one direction on the link\n           only.  When either or both of the peers\n           specifies unidirectional VC capability, both\n           LSRs use unidirectional VC label assignment for\n           the link as follows.  The LSRs compare their\n           LDP Identifiers as unsigned integers.  The LSR\n           with the larger LDP Identifier may assign\n           only odd-numbered VCIs in the VPI/VCI\n           range as labels.  The system with the smaller\n           LDP Identifier may assign only even-numbered\n           VCIs in the VPI/VCI range as labels.'\n\n           Please refer to the following reference\n           for a complete description of this feature.")
mplsLdpEntityAtmLsrConnectivity = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("indirect", 2))).clone('direct')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setDescription('The peer LSR may be connected indirectly by means\n        of an ATM VP so that the VPI values may be different\n        on either endpoint so the label MUST be encoded\n        entirely within the VCI field.')
mplsLdpEntityAtmDefaultControlVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVpi.setDescription('The default VPI value for the non-MPLS connection.  The\n        default value of this is 0 (zero) but other values may\n        be configured.  This object allows a different value\n        to be configured.')
mplsLdpEntityAtmDefaultControlVci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 7), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVci.setDescription('The Default VCI value for a non-MPLS connection.  The\n        default value of this is 32 but other values may be\n        configured.  This object allows a different value to\n        be configured.')
mplsLdpEntityAtmUnlabTrafVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVpi.setDescription("VPI value of the VCC supporting unlabeled traffic.  This\n        non-MPLS connection is used to carry unlabeled (IP)\n        packets.  The default value is the same as the default\n        value of the 'mplsLdpEntityAtmDefaultControlVpi', however\n        another value may be configured.")
mplsLdpEntityAtmUnlabTrafVci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 9), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVci.setDescription("VCI value of the VCC supporting unlabeled traffic.\n        This non-MPLS connection is used to carry unlabeled (IP)\n        packets. The default value is the same as the default\n        value of the 'mplsLdpEntityAtmDefaultControlVci', however\n        another value may be configured.")
mplsLdpEntityAtmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 1, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpEntityAtmLRTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 2), )
if mibBuilder.loadTexts: mplsLdpEntityAtmLRTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRTable.setDescription("The MPLS LDP Entity ATM Label Range (LR) Table.\n        The purpose of this table is to provide a mechanism\n        for configuring a contiguous range of vpi's\n        with a contiguous range of vci's, or a 'label range'\n        for LDP Entities.\n\n        LDP Entities which use ATM must have at least one\n        entry in this table.\n\n        There must exist at least one entry in this\n        table for every LDP Entity that has\n        'mplsLdpEntityLabelType' object with\n        a value of 'atmSessionParameters'.")
mplsLdpEntityAtmLREntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 2, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmLRMinVpi"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmLRMinVci"))
if mibBuilder.loadTexts: mplsLdpEntityAtmLREntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLREntry.setDescription('A row in the LDP Entity ATM Label\n        Range Table.  One entry in this table contains\n        information on a single range of labels\n        represented by the configured Upper and Lower\n        Bounds VPI/VCI pairs.  These are the same\n        data used in the Initialization Message.\n\n        NOTE:  The ranges for a specific LDP Entity\n        are UNIQUE and non-overlapping.  For example,\n        for a specific LDP Entity index, there could\n        be one entry having LowerBound vpi/vci == 0/32, and\n        UpperBound vpi/vci == 0/100, and a second entry\n        for this same interface with LowerBound\n        vpi/vci == 0/101 and UpperBound vpi/vci == 0/200.\n        However, there could not be a third entry with\n        LowerBound vpi/vci == 0/200 and\n        UpperBound vpi/vci == 0/300 because this label\n        range overlaps with the second entry (i.e., both\n        entries now have 0/200).\n\n        A row will not become active unless a unique and\n        non-overlapping range is specified.\n\n        At least one label range entry for a\n        specific LDP Entity MUST\n        include the default VPI/VCI  values denoted\n        in the LDP Entity Table.\n\n        A request to create a row with an overlapping\n        range should result in an inconsistentValue\n        error.')
mplsLdpEntityAtmLRMinVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVpi.setDescription('The minimum VPI number configured for this range.\n        The value of zero is a valid value for the VPI portion\n        of the label.')
mplsLdpEntityAtmLRMinVci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 2, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVci.setDescription('The minimum VCI number configured for this range.')
mplsLdpEntityAtmLRMaxVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVpi.setDescription('The maximum VPI number configured for this range.')
mplsLdpEntityAtmLRMaxVci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 2, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVci.setDescription('The maximum VCI number configured for this range.')
mplsLdpEntityAtmLRStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 1, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpAtmSessionObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 2))
mplsLdpAtmSessionTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 2, 1), )
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setDescription("A table which relates sessions in the\n        'mplsLdpSessionTable' and their label\n        range intersections.  There could be one\n        or more label range intersections between an\n        LDP Entity and LDP Peer using ATM as the\n        underlying  media.  Each row represents\n        a single label range intersection.\n\n        This table cannot use the 'AUGMENTS'\n        clause because there is not necessarily\n        a one-to-one mapping between this table\n        and the mplsLdpSessionTable.")
mplsLdpAtmSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 2, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpSessionAtmLRLowerBoundVpi"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpSessionAtmLRLowerBoundVci"))
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setDescription('An entry in this table represents information on a\n        single label range intersection between an LDP Entity\n        and LDP Peer.\n\n        The information contained in a row is read-only.')
mplsLdpSessionAtmLRLowerBoundVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVpi.setDescription('The minimum VPI number for this range.')
mplsLdpSessionAtmLRLowerBoundVci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 2, 1, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVci.setDescription('The minimum VCI number for this range.')
mplsLdpSessionAtmLRUpperBoundVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVpi.setDescription('The maximum VPI number for this range.')
mplsLdpSessionAtmLRUpperBoundVci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 4, 2, 1, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVci.setDescription('The maximum VCI number for this range.')
mplsLdpAtmGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 5, 1))
mplsLdpAtmCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 5, 2))
mplsLdpAtmModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 5, 2, 1)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpAtmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmModuleFullCompliance = mplsLdpAtmModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmModuleFullCompliance.setDescription('The Module is implemented with support for\n        read-create and read-write.  In other words,\n        both monitoring and configuration\n        are available when using this MODULE-COMPLIANCE.')
mplsLdpAtmModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 5, 2, 2)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpAtmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmModuleReadOnlyCompliance = mplsLdpAtmModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmModuleReadOnlyCompliance.setDescription('The Module is implemented with support for\n        read-only.  In other words, only monitoring\n        is available by implementing this MODULE-COMPLIANCE.')
mplsLdpAtmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 5, 1, 1)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmIfIndexOrZero"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmMergeCap"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmLRComponents"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmVcDirectionality"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmLsrConnectivity"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmDefaultControlVpi"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmDefaultControlVci"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmUnlabTrafVpi"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmUnlabTrafVci"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmStorageType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmLRMaxVpi"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmLRMaxVci"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityAtmLRStorageType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionAtmLRUpperBoundVpi"), ("PRVT-MPLS-LDP-MIB", "mplsLdpSessionAtmLRUpperBoundVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmGroup = mplsLdpAtmGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmGroup.setDescription('Objects that apply to all MPLS LDP implementations\n        using ATM as the Layer 2.')
mplsLdpFrameRelayObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6))
mplsLdpFrameRelayConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 7))
mplsLdpEntityFrameRelayObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1))
mplsLdpEntityFrameRelayTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 1), )
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayTable.setDescription("This table contains Frame Relay specific\n        information which could be used in the\n        'Optional Parameters' and other Frame Relay\n        specific information.")
mplsLdpEntityFrameRelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayEntry.setDescription('An entry in this table represents the Frame Relay\n        optional parameters associated with the LDP entity.')
mplsLdpEntityFrameRelayIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of\n       the 'ifLayer' where the Frame Relay Labels 'owned' by this\n       entry were created, or 0 (zero).  The value of zero\n       means that the InterfaceIndex is not known.  For example,\n       if the InterfaceIndex is created subsequent to the\n       Frame Relay Label's creation, then it would not be known.\n       However, if the InterfaceIndex is known, then it must\n       be represented by this value.\n\n       If an InterfaceIndex becomes known, then the\n       network management entity (e.g., SNMP agent) responsible\n       for this object MUST change the value from 0 (zero) to the\n       value of the InterfaceIndex.  If an Frame Relay Label is\n       being used in forwarding data, then the value of this\n       object MUST be the InterfaceIndex.")
mplsLdpEntityFrameRelayMergeCap = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notSupported", 0), ("supported", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayMergeCap.setReference('RFC3036, LDP Specification, Section 3.5.3\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayMergeCap.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayMergeCap.setDescription("This represents whether or not the Frame Relay merge\n        capability is supported.  This is the EXACT value for the\n        Frame Relay Session Parameter, field M (for Frame Relay\n        Merge Capabilities).  The Frame Relay Session Parameter\n        is an optional parameter in the Initialization Message.\n\n        The description from rfc3036.txt is:\n        'M, Frame Relay Merge Capabilities\n           Specifies the merge capabilities of a Frame\n           Relay switch.  The following values are\n           supported in this version of the\n           specification:\n\n                  Value          Meaning\n\n                    0            Merge not supported\n                    1            Merge supported\n\n           Non-merge and merge Frame Relay LSRs may\n           freely interoperate.'\n\n           Please refer to the following reference for a\n           complete description of this feature.")
mplsLdpEntityFrameRelayLRComponents = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRComponents.setReference('RFC3036, LDP Specification, Section 3.5.3\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRComponents.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRComponents.setDescription("Number of Label Range Components in the Initialization\n        message.  This also represents the number of entries\n        in the mplsLdpEntityFrameRelayLRTable which correspond\n        to this entry.\n\n        This is the EXACT value for the Frame Relay Session\n        Parameter, field N (for Number of label range\n        components).  The Frame Relay Session Parameter\n        is an optional parameter in the Initialization\n        Message.\n\n        The description from rfc3036.txt is:\n\n        'N, Number of label range components\n            Specifies the number of Frame Relay Label\n            Range Components included in the TLV.'\n\n         Please refer to the following reference for a\n         complete description of this feature.")
mplsLdpEntityFrameRelayVcDirectionality = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirection", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayVcDirectionality.setReference('RFC3036, LDP Specification, Section 3.5.3\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayVcDirectionality.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)', then\n        the LSR supports the use of a given DLCI as a label for\n        both directions independently.  If the value of\n        this object is 'unidirectional(1)', then the LSR\n        uses the given DLCI as a label in only one direction.\n\n        This is the EXACT value for the Frame Relay Session\n        Parameter, field D (for VC Directionality).  The\n        Frame Relay Session Parameter is an optional\n        parameter in the Initialization Message.\n\n        The description from rfc3036.txt is:\n\n        'D, VC Directionality\n           A value of 0 specifies bidirectional VC capability,\n           meaning the LSR can support the use of a given\n           DLCI as a label for both link directions\n           independently.  A value of 1 specifies\n           unidirectional VC capability, meaning a given\n           DLCI may appear in a label mapping for one\n           direction on the link only.  When either or both\n           of the peers specifies unidirectional VC\n           capability, both LSRs use unidirectional VC\n           label assignment for the link as follows.  The\n           LSRs compare their LDP Identifiers as unsigned\n           integers.  The LSR with the larger LDP\n           Identifier may assign only odd-numbered DLCIs\n           in the range as labels.  The system with the\n           smaller LDP Identifier may assign only\n           even-numbered DLCIs in the range as labels.'\n\n           Please refer to the following reference for a\n           complete description of this feature.")
mplsLdpEntityFrameRelayStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 1, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpEntityFrameRelayLRTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 2), )
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRTable.setDescription("This table contains information about the\n        Optional Parameters for the Frame Relay Session\n        in the LDP Initialization Message, specifically\n        it contains information about the Frame Relay\n        Label Range Components.\n\n        If the value of the object\n        'mplsLdpEntityLabelType' contains the\n        value of 'frameRelaySessionParameters(3)' then\n        there must be at least one corresponding entry\n        in this table.")
mplsLdpEntityFrameRelayLREntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 2, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayLRMinDlci"))
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLREntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLREntry.setDescription('An entry in this table represents the Frame Relay\n        Label Range Component associated with the LDP entity.')
mplsLdpEntityFrameRelayLRMinDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRMinDlci.setReference('RFC3034, Use of Label Switching on Frame Relay\n        Networks Specification.')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRMinDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRMinDlci.setDescription("The lower bound which is supported.  This value\n        should be the same as that in the Frame Relay Label\n        Range Component's Minimum DLCI field.  The value\n        of zero is valid for the minimum DLCI field of\n        the label.")
mplsLdpEntityFrameRelayLRMaxDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRMaxDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRMaxDlci.setDescription("The upper bound which is supported.  This value\n        should be the same as that in the Frame Relay Label\n        Range Component's Maximum DLCI field.")
mplsLdpEntityFrameRelayLRLen = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("tenDlciBits", 0), ("twentyThreeDlciBits", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRLen.setReference('RFC3036, LDP Specification, Section 3.5.3\n        Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRLen.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRLen.setDescription("This object specifies the length of the DLCI bits.\n\n        This is the EXACT value for the Len field of the\n        Frame Relay Label Range Component.\n\n        The description from rfc3036.txt is:\n\n        'Len\n            This field specifies the number of bits of the DLCI.\n            The following values are supported:\n\n                 Len    DLCI bits\n\n                 0       10\n                 2       23\n\n            Len values 1 and 3 are reserved.'\n\n         Please refer to the following reference for a complete\n         description of this feature.")
mplsLdpEntityFrameRelayLRStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 1, 2, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayLRStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpFrameRelaySessionObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 2))
mplsLdpFrameRelaySessionTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 2, 1), )
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionTable.setDescription("A table of Frame Relay label range intersections\n        between the LDP Entities and LDP Peers.\n        Each row represents a single label range intersection.\n\n        NOTE:  this table cannot use the 'AUGMENTS'\n        clause because there is not necessarily a one-to-one\n        mapping between this table and the\n        mplsLdpSessionTable.")
mplsLdpFrameRelaySessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 2, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpFrameRelaySessionMinDlci"))
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionEntry.setDescription('An entry in this table represents information on a\n        single label range intersection between an\n        LDP Entity and LDP Peer.\n\n        The information contained in a row is read-only.')
mplsLdpFrameRelaySessionMinDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionMinDlci.setReference('RFC3034, Use of Label Switching on Frame Relay\n        Networks Specification.')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionMinDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionMinDlci.setDescription('The lower bound of DLCIs which are supported.\n        The value of zero is a valid value for the\n        minimum DLCI field of the label.')
mplsLdpFrameRelaySessionMaxDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionMaxDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionMaxDlci.setDescription('The upper bound of DLCIs which are supported.')
mplsLdpFrameRelaySessionLen = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 6, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("tenDlciBits", 0), ("twentyThreeDlciBits", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionLen.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionLen.setDescription('This object specifies the DLCI bits.')
mplsLdpFrameRelayGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 7, 1))
mplsLdpFrameRelayCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 7, 2))
mplsLdpFrameRelayModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 7, 2, 2)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpFrameRelayGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpFrameRelayModuleReadOnlyCompliance = mplsLdpFrameRelayModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelayModuleReadOnlyCompliance.setDescription('The Module is implemented with support for\n        read-only.  In other words, only monitoring\n        is available by implementing this MODULE-COMPLIANCE.')
mplsLdpFrameRelayGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 7, 1, 1)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayIfIndexOrZero"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayMergeCap"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayLRComponents"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayVcDirectionality"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayStorageType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayLRMaxDlci"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayLRLen"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityFrameRelayLRStorageType"), ("PRVT-MPLS-LDP-MIB", "mplsLdpFrameRelaySessionMaxDlci"), ("PRVT-MPLS-LDP-MIB", "mplsLdpFrameRelaySessionLen"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpFrameRelayGroup = mplsLdpFrameRelayGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelayGroup.setDescription('Objects that apply to all MPLS LDP implementations\n        using Frame Relay as the Layer 2.')
mplsLdpGenericObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8))
mplsLdpGenericConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 9))
mplsLdpEntityGenericObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1))
mplsLdpEntityGenericLRTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1, 1), )
if mibBuilder.loadTexts: mplsLdpEntityGenericLRTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityGenericLRTable.setDescription("The MPLS LDP Entity Generic Label Range (LR)\n        Table.\n\n        The purpose of this table is to provide a mechanism\n        for configurating a contiguous range of generic labels,\n        or a 'label range' for LDP Entities.\n\n        LDP Entities which use Generic Labels must have at least\n        one entry in this table.  In other words, this table\n        'extends' the mpldLdpEntityTable for Generic Labels.")
mplsLdpEntityGenericLREntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityGenericLRMin"), (0, "PRVT-MPLS-LDP-MIB", "mplsLdpEntityGenericLRMax"))
if mibBuilder.loadTexts: mplsLdpEntityGenericLREntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityGenericLREntry.setDescription("A row in the LDP Entity Generic Label\n        Range (LR) Table.  One entry in this table contains\n        information on a single range of labels\n        represented by the configured Upper and Lower\n        Bounds pairs.  NOTE: there is NO corresponding\n        LDP message which relates to the information\n        in this table, however, this table does provide\n        a way for a user to 'reserve' a generic label\n        range.\n\n        NOTE:  The ranges for a specific LDP Entity\n        are UNIQUE and non-overlapping.\n\n        A row will not be created unless a unique and\n        non-overlapping range is specified.")
mplsLdpEntityGenericLRMin = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)))
if mibBuilder.loadTexts: mplsLdpEntityGenericLRMin.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityGenericLRMin.setDescription('The minimum label configured for this range.')
mplsLdpEntityGenericLRMax = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)))
if mibBuilder.loadTexts: mplsLdpEntityGenericLRMax.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityGenericLRMax.setDescription('The maximum label configured for this range.')
mplsLdpEntityGenericLabelSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("perPlatform", 1), ("perInterface", 2))).clone('perPlatform')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityGenericLabelSpace.setReference('RFC3036, LDP Specification, Section 2.2.1,\n        Label Spaces.')
if mibBuilder.loadTexts: mplsLdpEntityGenericLabelSpace.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityGenericLabelSpace.setDescription('This value of this object is perPlatform(1), then\n       this means that the label space type is\n       per platform.\n\n       If this object is perInterface(2), then this\n       means that the label space type is per Interface.')
mplsLdpEntityGenericIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1, 1, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityGenericIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityGenericIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of\n       the 'ifLayer' where these Generic Label would be created,\n       or 0 (zero).  The value of zero means that the\n       InterfaceIndex is not known.\n\n       However, if the InterfaceIndex is known,\n       then it must be represented by this value.\n\n       If an InterfaceIndex becomes known, then the\n       network management entity (e.g., SNMP agent) responsible\n       for this object MUST change the value from 0 (zero) to the\n       value of the InterfaceIndex.")
mplsLdpEntityGenericLRStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 8, 1, 1, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityGenericLRStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityGenericLRStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpGenericGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 9, 1))
mplsLdpGenericCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 9, 2))
mplsLdpGenericModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 9, 2, 2)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpGenericGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpGenericModuleReadOnlyCompliance = mplsLdpGenericModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpGenericModuleReadOnlyCompliance.setDescription('The Module is implemented with support for\n        read-only.  In other words, only monitoring\n        is available by implementing this MODULE-COMPLIANCE.')
mplsLdpGenericGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 1, 9, 1, 1)).setObjects(("PRVT-MPLS-LDP-MIB", "mplsLdpEntityGenericLabelSpace"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityGenericIfIndexOrZero"), ("PRVT-MPLS-LDP-MIB", "mplsLdpEntityGenericLRStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpGenericGroup = mplsLdpGenericGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpGenericGroup.setDescription('Objects that apply to all MPLS LDP implementations\n        using Generic Labels as the Layer 2.')
mibBuilder.exportSymbols("PRVT-MPLS-LDP-MIB", mplsLdpFrameRelayObjects=mplsLdpFrameRelayObjects, mplsLdpAtmSessionObjects=mplsLdpAtmSessionObjects, mplsInSegmentLdpLspTable=mplsInSegmentLdpLspTable, mplsLdpSessionPeerNextHopAddr=mplsLdpSessionPeerNextHopAddr, mplsLdpEntityAtmUnlabTrafVpi=mplsLdpEntityAtmUnlabTrafVpi, mplsLdpAtmCompliances=mplsLdpAtmCompliances, mplsLdpEntityFrameRelayLRMaxDlci=mplsLdpEntityFrameRelayLRMaxDlci, mplsLdpEntityAtmDefaultControlVpi=mplsLdpEntityAtmDefaultControlVpi, mplsLdpEntityAtmLRMinVci=mplsLdpEntityAtmLRMinVci, mplsLdpEntityAdminStatus=mplsLdpEntityAdminStatus, mplsLdpEntityStatsBadLdpIdentifierErrors=mplsLdpEntityStatsBadLdpIdentifierErrors, mplsLdpEntityFrameRelayTable=mplsLdpEntityFrameRelayTable, mplsLdpSessionKeepAliveTime=mplsLdpSessionKeepAliveTime, mplsOutSegmentLdpLspTable=mplsOutSegmentLdpLspTable, mplsLdpEntityAtmIfIndexOrZero=mplsLdpEntityAtmIfIndexOrZero, mplsLdpEntityFrameRelayLRMinDlci=mplsLdpEntityFrameRelayLRMinDlci, mplsLdpEntityIndex=mplsLdpEntityIndex, mplsLdpEntityStatsSessionRejectedNoHelloErrors=mplsLdpEntityStatsSessionRejectedNoHelloErrors, mplsLdpLspFecEntry=mplsLdpLspFecEntry, mplsLdpEntityAtmLRTable=mplsLdpEntityAtmLRTable, mplsFecAddrType=mplsFecAddrType, mplsLdpHelloAdjacencyType=mplsLdpHelloAdjacencyType, mplsLdpPeerTransportAddrType=mplsLdpPeerTransportAddrType, mplsLdpSessionAtmLRUpperBoundVpi=mplsLdpSessionAtmLRUpperBoundVpi, mplsLdpAtmModuleReadOnlyCompliance=mplsLdpAtmModuleReadOnlyCompliance, mplsLdpModuleFullCompliance=mplsLdpModuleFullCompliance, mplsLdpEntityStatsSessionRejectedLRErrors=mplsLdpEntityStatsSessionRejectedLRErrors, mplsLdpFrameRelaySessionMinDlci=mplsLdpFrameRelaySessionMinDlci, mplsLdpSessionAtmLRUpperBoundVci=mplsLdpSessionAtmLRUpperBoundVci, mplsLdpFrameRelayCompliances=mplsLdpFrameRelayCompliances, mplsFecType=mplsFecType, mplsLdpEntityFrameRelayStorageType=mplsLdpEntityFrameRelayStorageType, mplsLdpInitSessionThresholdExceeded=mplsLdpInitSessionThresholdExceeded, mplsInSegmentLdpLspType=mplsInSegmentLdpLspType, mplsOutSegmentLdpLspEntry=mplsOutSegmentLdpLspEntry, mplsLdpPeerTable=mplsLdpPeerTable, mplsLdpEntityEntry=mplsLdpEntityEntry, mplsLdpEntityStatsShutdownSentNotifications=mplsLdpEntityStatsShutdownSentNotifications, mplsLdpEntityGenericIfIndexOrZero=mplsLdpEntityGenericIfIndexOrZero, mplsLdpAtmSessionTable=mplsLdpAtmSessionTable, mplsLdpEntityLdpId=mplsLdpEntityLdpId, mplsLdpEntityProtocolVersion=mplsLdpEntityProtocolVersion, mplsLdpEntityOperStatus=mplsLdpEntityOperStatus, mplsLdpHelloAdjacencyHoldTime=mplsLdpHelloAdjacencyHoldTime, mplsFecObjects=mplsFecObjects, mplsFecIndex=mplsFecIndex, mplsLdpHelloAdjacencyTable=mplsLdpHelloAdjacencyTable, mplsLdpEntityFrameRelayLRStorageType=mplsLdpEntityFrameRelayLRStorageType, mplsLdpEntityAtmMergeCap=mplsLdpEntityAtmMergeCap, mplsFecStorageType=mplsFecStorageType, mplsLdpEntityFrameRelayIfIndexOrZero=mplsLdpEntityFrameRelayIfIndexOrZero, mplsLdpSessionPeerAddrEntry=mplsLdpSessionPeerAddrEntry, mplsLdpLspGroup=mplsLdpLspGroup, MplsLdpLabelTypes=MplsLdpLabelTypes, mplsLdpPeerPathVectorLimit=mplsLdpPeerPathVectorLimit, mplsLdpFrameRelayGroup=mplsLdpFrameRelayGroup, mplsLdpHelloAdjacencyIndex=mplsLdpHelloAdjacencyIndex, mplsLdpHelloAdjacencyHoldTimeRemaining=mplsLdpHelloAdjacencyHoldTimeRemaining, PYSNMP_MODULE_ID=mplsLdpStdMIB, mplsLdpEntityAtmLsrConnectivity=mplsLdpEntityAtmLsrConnectivity, mplsLdpFrameRelaySessionLen=mplsLdpFrameRelaySessionLen, mplsLdpEntityTargetPeer=mplsLdpEntityTargetPeer, mplsInSegmentLdpLspEntry=mplsInSegmentLdpLspEntry, mplsLdpConformance=mplsLdpConformance, mplsLdpEntityGenericLRStorageType=mplsLdpEntityGenericLRStorageType, mplsLdpEntityAtmObjects=mplsLdpEntityAtmObjects, mplsLdpEntityGenericObjects=mplsLdpEntityGenericObjects, mplsLdpEntityStatsBadMessageLengthErrors=mplsLdpEntityStatsBadMessageLengthErrors, mplsLdpPeerTransportAddr=mplsLdpPeerTransportAddr, mplsLdpGenericGroup=mplsLdpGenericGroup, mplsLdpLspFecIndex=mplsLdpLspFecIndex, mplsLdpEntityObjects=mplsLdpEntityObjects, mplsLdpEntityAtmLRMaxVpi=mplsLdpEntityAtmLRMaxVpi, mplsLdpEntityLabelDistMethod=mplsLdpEntityLabelDistMethod, mplsLdpLspFecLastChange=mplsLdpLspFecLastChange, mplsLdpEntityStatsShutdownReceivedNotifications=mplsLdpEntityStatsShutdownReceivedNotifications, mplsLdpEntityLabelType=mplsLdpEntityLabelType, mplsLdpFrameRelaySessionEntry=mplsLdpFrameRelaySessionEntry, mplsFecEntry=mplsFecEntry, mplsLdpAtmGroups=mplsLdpAtmGroups, mplsLdpSessionStatsEntry=mplsLdpSessionStatsEntry, mplsLdpHelloAdjacencyPeerHoldTime=mplsLdpHelloAdjacencyPeerHoldTime, mplsLdpEntityAtmLRMaxVci=mplsLdpEntityAtmLRMaxVci, mplsLdpEntityMaxPduLength=mplsLdpEntityMaxPduLength, mplsLdpEntityGenericLRMin=mplsLdpEntityGenericLRMin, mplsLdpEntityGenericLRTable=mplsLdpEntityGenericLRTable, mplsLdpEntityIndexNextTable=mplsLdpEntityIndexNextTable, mplsLdpAtmGroup=mplsLdpAtmGroup, mplsLdpSessionEntry=mplsLdpSessionEntry, mplsLdpEntityInitSessionThreshold=mplsLdpEntityInitSessionThreshold, mplsOutSegmentLdpLspIndex=mplsOutSegmentLdpLspIndex, mplsLdpSessionUp=mplsLdpSessionUp, mplsLdpSessionDown=mplsLdpSessionDown, mplsLdpPeerEntry=mplsLdpPeerEntry, mplsLdpCompliances=mplsLdpCompliances, mplsLdpGenericObjects=mplsLdpGenericObjects, mplsLdpGenericConformance=mplsLdpGenericConformance, mplsLdpSessionStateLastChange=mplsLdpSessionStateLastChange, mplsLdpSessionAtmLRLowerBoundVpi=mplsLdpSessionAtmLRLowerBoundVpi, mplsOutSegmentLdpLspLabelType=mplsOutSegmentLdpLspLabelType, mplsLdpEntityFrameRelayLRLen=mplsLdpEntityFrameRelayLRLen, mplsLdpEntityKeepAliveHoldTimer=mplsLdpEntityKeepAliveHoldTimer, mplsLdpSessionDiscontinuityTime=mplsLdpSessionDiscontinuityTime, mplsInSegmentLdpLspIndex=mplsInSegmentLdpLspIndex, mplsLdpLspFecStorageType=mplsLdpLspFecStorageType, mplsLdpSessionAtmLRLowerBoundVci=mplsLdpSessionAtmLRLowerBoundVci, mplsLdpAtmModuleFullCompliance=mplsLdpAtmModuleFullCompliance, mplsLdpLsrLoopDetectionCapable=mplsLdpLsrLoopDetectionCapable, mplsLdpSessionPeerAddrTable=mplsLdpSessionPeerAddrTable, mplsLdpSessionObjects=mplsLdpSessionObjects, mplsLdpPeerLastChange=mplsLdpPeerLastChange, mplsFecAddr=mplsFecAddr, mplsLdpLspFecTable=mplsLdpLspFecTable, mplsLdpEntityAtmVcDirectionality=mplsLdpEntityAtmVcDirectionality, mplsLdpFrameRelaySessionMaxDlci=mplsLdpFrameRelaySessionMaxDlci, mplsLdpEntityGenericLREntry=mplsLdpEntityGenericLREntry, mplsLdpLsrTable=mplsLdpLsrTable, mplsLdpEntityTargetPeerAddr=mplsLdpEntityTargetPeerAddr, mplsLdpEntityAtmUnlabTrafVci=mplsLdpEntityAtmUnlabTrafVci, mplsLdpNotificationsGroup=mplsLdpNotificationsGroup, mplsLdpSessionTable=mplsLdpSessionTable, mplsFecAddrPrefixLength=mplsFecAddrPrefixLength, mplsLdpEntityAtmLRMinVpi=mplsLdpEntityAtmLRMinVpi, mplsLdpEntityIndexNextEntry=mplsLdpEntityIndexNextEntry, mplsLdpEntityAtmTable=mplsLdpEntityAtmTable, mplsLdpEntityFrameRelayLREntry=mplsLdpEntityFrameRelayLREntry, mplsLdpEntityTransportAddrKind=mplsLdpEntityTransportAddrKind, mplsLdpLsrObjects=mplsLdpLsrObjects, mplsLdpEntityLabelRetentionMode=mplsLdpEntityLabelRetentionMode, mplsInSegmentLdpLspLabelType=mplsInSegmentLdpLspLabelType, mplsLdpEntityStatsKeepAliveTimerExpErrors=mplsLdpEntityStatsKeepAliveTimerExpErrors, mplsLdpPeerLdpId=mplsLdpPeerLdpId, mplsLdpLspFecRowStatus=mplsLdpLspFecRowStatus, mplsLdpEntityAtmLRComponents=mplsLdpEntityAtmLRComponents, mplsLdpStdMIB=mplsLdpStdMIB, mplsLdpEntityAtmEntry=mplsLdpEntityAtmEntry, mplsLdpEntityFrameRelayVcDirectionality=mplsLdpEntityFrameRelayVcDirectionality, mplsLdpSessionProtocolVersion=mplsLdpSessionProtocolVersion, mplsLdpEntityTargetPeerAddrType=mplsLdpEntityTargetPeerAddrType, mplsLdpEntityFrameRelayLRTable=mplsLdpEntityFrameRelayLRTable, mplsLdpLsrEntry=mplsLdpLsrEntry, mplsLdpEntityStatsSessionRejectedAdErrors=mplsLdpEntityStatsSessionRejectedAdErrors, mplsOutSegmentLdpLspType=mplsOutSegmentLdpLspType, mplsLdpEntityGenericLRMax=mplsLdpEntityGenericLRMax, mplsLdpEntityWellKnownUdpDiscoveryPort=mplsLdpEntityWellKnownUdpDiscoveryPort, mplsLdpEntityRowStatus=mplsLdpEntityRowStatus, mplsLdpObjects=mplsLdpObjects, mplsLdpEntityFrameRelayObjects=mplsLdpEntityFrameRelayObjects, mplsLdpFrameRelaySessionTable=mplsLdpFrameRelaySessionTable, mplsLdpLspFecSegment=mplsLdpLspFecSegment, mplsLdpSessionState=mplsLdpSessionState, mplsLdpSessionKeepAliveHoldTimeRemaining=mplsLdpSessionKeepAliveHoldTimeRemaining, mplsLdpSessionPeerAddrIndex=mplsLdpSessionPeerAddrIndex, mplsLdpLspFecSegmentIndex=mplsLdpLspFecSegmentIndex, mplsLdpEntityStatsBadTlvLengthErrors=mplsLdpEntityStatsBadTlvLengthErrors, mplsLdpEntityPathVectorLimit=mplsLdpEntityPathVectorLimit, mplsLdpEntityHelloHoldTimer=mplsLdpEntityHelloHoldTimer, mplsLdpEntityHopCountLimit=mplsLdpEntityHopCountLimit, mplsLdpLsrId=mplsLdpLsrId, mplsLdpAtmConformance=mplsLdpAtmConformance, mplsLdpGenericModuleReadOnlyCompliance=mplsLdpGenericModuleReadOnlyCompliance, mplsLdpSessionMaxPduLength=mplsLdpSessionMaxPduLength, mplsFecTable=mplsFecTable, mplsLdpEntityStatsTable=mplsLdpEntityStatsTable, mplsLdpPathVectorLimitMismatch=mplsLdpPathVectorLimitMismatch, mplsLdpEntityStatsEntry=mplsLdpEntityStatsEntry, mplsLdpEntityAtmLREntry=mplsLdpEntityAtmLREntry, mplsLdpSessionStatsTable=mplsLdpSessionStatsTable, mplsLdpSessionStatsUnknownMesTypeErrors=mplsLdpSessionStatsUnknownMesTypeErrors, mplsLdpSessionPeerNextHopAddrType=mplsLdpSessionPeerNextHopAddrType, mplsLdpEntityFrameRelayEntry=mplsLdpEntityFrameRelayEntry, mplsLdpHelloAdjacencyEntry=mplsLdpHelloAdjacencyEntry, mplsLdpEntityIndexNext=mplsLdpEntityIndexNext, mplsLdpEntityAtmDefaultControlVci=mplsLdpEntityAtmDefaultControlVci, mplsLdpGenericCompliances=mplsLdpGenericCompliances, mplsLdpGroups=mplsLdpGroups, mplsLdpSessionStatsUnknownTlvErrors=mplsLdpSessionStatsUnknownTlvErrors, mplsLdpEntityStatsSessionRejectedMaxPduErrors=mplsLdpEntityStatsSessionRejectedMaxPduErrors, mplsLdpModuleReadOnlyCompliance=mplsLdpModuleReadOnlyCompliance, mplsLdpEntityAtmLRStorageType=mplsLdpEntityAtmLRStorageType, mplsLdpFrameRelaySessionObjects=mplsLdpFrameRelaySessionObjects, mplsLdpFrameRelayGroups=mplsLdpFrameRelayGroups, mplsLdpEntityStatsSessionAttempts=mplsLdpEntityStatsSessionAttempts, mplsLdpEntityStorageType=mplsLdpEntityStorageType, mplsLdpEntityAtmStorageType=mplsLdpEntityAtmStorageType, mplsLdpEntityStatsBadPduLengthErrors=mplsLdpEntityStatsBadPduLengthErrors, mplsLdpEntityDiscontinuityTime=mplsLdpEntityDiscontinuityTime, mplsLdpSessionPeerHoldTime=mplsLdpSessionPeerHoldTime, mplsLdpGeneralGroup=mplsLdpGeneralGroup, mplsLdpNotifications=mplsLdpNotifications, mplsLdpFrameRelayConformance=mplsLdpFrameRelayConformance, mplsLdpFrameRelayModuleReadOnlyCompliance=mplsLdpFrameRelayModuleReadOnlyCompliance, mplsLdpSessionRole=mplsLdpSessionRole, MplsLabel=MplsLabel, mplsLdpHelloAdjacencyObjects=mplsLdpHelloAdjacencyObjects, mplsLdpGenericGroups=mplsLdpGenericGroups, mplsLdpEntityStatsMalformedTlvValueErrors=mplsLdpEntityStatsMalformedTlvValueErrors, mplsLdpEntityGenericLabelSpace=mplsLdpEntityGenericLabelSpace, mplsLdpPeerLabelDistMethod=mplsLdpPeerLabelDistMethod, mplsFecLastChange=mplsFecLastChange, mplsLdpHelloAdjacencyConfiguredHoldTime=mplsLdpHelloAdjacencyConfiguredHoldTime, mplsLdpEntityWellKnownTcpDiscoveryPort=mplsLdpEntityWellKnownTcpDiscoveryPort, mplsLdpSessionHoldTimeInUse=mplsLdpSessionHoldTimeInUse, mplsLdpAtmSessionEntry=mplsLdpAtmSessionEntry, mplsLdpEntityWildcardEntity=mplsLdpEntityWildcardEntity, mplsLdpEntityTable=mplsLdpEntityTable, mplsLdpAtmObjects=mplsLdpAtmObjects, mplsLdpEntityFrameRelayLRComponents=mplsLdpEntityFrameRelayLRComponents, mplsLdpEntityFrameRelayMergeCap=mplsLdpEntityFrameRelayMergeCap, mplsLdpSessionConfiguredHoldTime=mplsLdpSessionConfiguredHoldTime)
