#
# PySNMP MIB module PRVT-SWITCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-SWITCH-MIB
# Produced by pysmi-1.1.3 at Wed Dec  1 17:13:26 2021
# On host fv-az33-471 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
ifIndex, ifAdminStatus, ifOperStatus = mibBuilder.importSymbols("IF-MIB", "ifIndex", "ifAdminStatus", "ifOperStatus")
privateVendorOID, = mibBuilder.importSymbols("PRIV-VENDORDEF-MIB", "privateVendorOID")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, Counter64, TimeTicks, Bits, ObjectIdentity, Gauge32, NotificationType, MibIdentifier, Unsigned32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter64", "TimeTicks", "Bits", "ObjectIdentity", "Gauge32", "NotificationType", "MibIdentifier", "Unsigned32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter32", "Integer32")
TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention")
prvtSwitchMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 5, 100))
prvtSwitchMib.setRevisions(('2009-06-22 00:00', '2009-04-14 00:00', '2009-03-08 00:00', '2009-02-20 00:00', '2009-01-12 00:00', '2008-09-25 00:00', '2008-03-28 00:00', '2008-02-28 00:00', '2007-12-28 00:00', '2007-12-12 00:00', '2007-09-26 00:00', '2007-04-24 00:00', '2007-02-06 00:00', '2006-10-25 00:00', '2006-07-02 00:00', '2006-06-14 00:00', '2006-04-20 00:00', '2006-02-10 00:00', '2006-02-02 00:00', '2005-12-22 00:00', '2005-12-08 00:00', '2005-10-03 00:00', '2005-09-26 00:00', '2005-09-07 00:00', '2005-07-20 00:00', '2005-07-08 00:00', '2005-03-07 00:00', '2005-02-16 00:00', '2005-02-01 00:00', '2004-06-29 00:00', '2004-05-03 00:00', '2004-03-03 00:00', '2004-02-03 00:00', '2003-11-18 00:00', '2003-10-16 00:00', '2003-09-09 00:00', '2003-07-02 00:00', '2003-05-06 00:00', '2002-12-12 00:00', '2002-12-01 00:00', '2002-11-21 00:00', '2002-11-17 00:00', '2002-09-09 00:00', '2002-04-10 00:00', '2001-08-14 00:00', '2001-07-22 00:00', '2001-07-15 00:00', '2001-05-17 00:00', '2001-05-15 00:00', '2001-04-19 00:00', '2001-04-15 00:00', '2000-06-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtSwitchMib.setRevisionsDescriptions(('Add value unsupported(255) for object configL2IfaceAdminCrossOver.', 'Add description for reportsHardwareFanStatus 0.', 'Updated devices system OIDs.', 'Add support for temperature high limit (reportsHardwareTemperatureScale,reportsHardwareTemperatureHighLimit).', 'Mark configL2IfaceDuplexSpeedSet. Add additional 10G value for\nconfigL2IfaceDuplexSpeedSet and reportsL2IfaceDuplexSpeedGet', 'Add support for crossover and remote-fault-detect.', 'Updated devices system OIDs.', 'Added OIDs of various devices.', 'Added sysAssemblyNumber, sysPartNumber, sysCLEI, sysHwRevision, sysManufacturingDate objects', 'Added configL2IfaceMtu.', 'Added new objects in configL2IfaceTable', 'Updated OID definitions', 'Updated description of reportsHardwarePSStatus object', 'New OID group added', 'Added T-Metro-ES and Alcatel system OID.', 'Changed mMiRIC-E1(89) to mMiRIC-E3(89)', 'Added new duplex and speed values', 'Added all missing port/module types', 'Defined the DUAL SFP module type', "Added new object identifier for devices.\nAdded new notification sysIntfModuleChange.\nChanged ModuleHwType modules that had '_' in them, should be with '-' instaead\nm100BaseGBIC_not_installed to m100BaseGBIC-not-installed.\nmCES_4TDM to mCES-4TDM,\nm1250BaseSingleFiber_SFP to m1250BaseSingleFiber-SFP.", 'Added the new sysIntfModuleChange notification for T-Metro devices.', 'Returned the old duplex-speed mixed object for backward compatability', 'Separated the duplex mode and speed setting in the configL2Table', 'Added the m1250BaseSingleFiber_SFP(87) port type', 'Added the mCES_4TDM(86) port type', 'Removed the range values for reportsL2IfaceUnit, reportsL2IfaceSlot and\nreportsL2IfacePort.', 'Added the mCES and 31000BaseX-SFP module types for T-Metro devices.', 'Fixed spelling errors and changed the contact info.', 'Added TMetro to sysProductsOids, added new module types: tMetroCES,\ntMetro2XSFPuplink, tMetro2F, tMetro1G', 'Added T6Pro to sysProductsOids, added a new module type CPM', 'Added support for exposing the switch series', 'L2 Interface name (configL2IfaceName) max size changed from 16 to 256.', 'Addded m100BaseGBIC_not_installed to ModuleHwType.', 'Added sysManufacturing group,sysSerialNumber.', '1. Added portRedundantLinkChange notification.\n2. Added reportsIfJack. This table enables support of interfaces attached to\nmore then one physical interface.\n3. Added reportsL2IfaceActiveJackIndex.', 'Added SFP port types.', 'Added support for reporting hardware port type', 'Move to SMI-V2.', 'Added support for controlling STP topology change detection', 'Added support for Sniffer', 'Added support for RSTP', 'Added support for POS interface speed 155 & 622 M.', 'Added new module for T5Pro including ATM/MLP and 5 ports SM/MM.', 'Add traps.', 'Distinction between set & get flow type to support flow auto-negotiation.', 'Added Default VLAN to configL2IfaceTable', 'Added new sysIntfModule types m1000BaseGBIC_installed/not_installed', 'Added t5ProRouter.', 'Added reportsHardware group.', 'Added config & reports group.', 'Added new modules to sysIntfModule.', 'Initial version.',))
if mibBuilder.loadTexts: prvtSwitchMib.setLastUpdated('200906220000Z')
if mibBuilder.loadTexts: prvtSwitchMib.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtSwitchMib.setContactInfo(' BATM/Telco Systems Support team\nEmail:\nFor North America: techsupport@telco.com\nFor North Europe: support@batm.de, info@batm.de\nFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtSwitchMib.setDescription('The switch MIB module for managing switch\nparameters')
prvt_products = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1)).setLabel("prvt-products")
prvt_mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 2)).setLabel("prvt-mgmt")
rptr = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 1))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 2))
trclam = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 3))
router = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 4))
switch = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5))
ipSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6))
bsw = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 1))
tps = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 2))
tpf = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 3))
titan = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 5))
titant5 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 7))
edgeLinkT4 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 15))
edgeLinkT5 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 17))
titanPro = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 20))
acs25L4282 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 500))
acs25L4282t5 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 502))
vol0215 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 999))
vol4000 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 998))
vol5000 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 996))
class UnitIndex(TextualConvention, Integer32):
    description = 'This value represents the physical position of the unit inside the\nstack.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("master", 1), ("slave1", 2), ("slave2", 3), ("slave3", 4), ("slave4", 5))

class ModuleHwType(TextualConvention, Integer32):
    description = 'This value represents the physical type of the port or module.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))
    namedValues = NamedValues(("uninstalled", 1), ("stacking", 2), ("m100BaseTx", 3), ("m100BaseFxVF45", 4), ("m1000BaseSxSCMM850", 6), ("m1000BaseLxSC1300", 7), ("m1000BaseSCSMLDA", 8), ("m1000BaseSCSMLDB", 9), ("m1000BaseSxVF45MM850", 10), ("m1000BaseLxVF451300", 11), ("m1000BaseSxMTRJMM", 12), ("m1000BaseLxMTRJ1300", 13), ("m10BaseFlVF45", 14), ("m10BaseFlVF45X4Ports", 15), ("m100BaseFxSCMM", 16), ("m100BaseFxSCSM", 17), ("m100BaseFxSCSM2Port", 18), ("m100BaseFxSCSMLD", 19), ("m100BaseFxSCSMLD2Port", 20), ("m100BaseFxMTRJMM", 21), ("m100BaseFxMTRJSM", 22), ("mDUAL-SFP", 23), ("mDUAL-SFP-installed", 24), ("m1000BaseTx", 25), ("m1000BaseCx", 26), ("mVDSLNT", 30), ("mVDSLLT", 31), ("mVDSLNTand100BaseTX", 32), ("mVDSLLTand100BaseTX", 33), ("mVDSLLT24Port", 34), ("mLayer31000BaseSXSCMM", 35), ("mLayer31000BaseLXSCSM", 36), ("mLayer31000BaseSXSFFMM", 37), ("mLayer31000BaseLXSFFSM", 38), ("mLayer3100BaseFXSCMM2Port", 39), ("mLayer3100BaseFXSCSM2Port", 40), ("mLayer3100BaseFXSCMM4Port", 41), ("mLayer3100BaseFXSCSM4Port", 42), ("mLayer3100BaseFXSFFMM", 43), ("mLayer3100BaseFXSFFSM", 44), ("mLayer3100BaseTX", 45), ("m1000BaseGBIC-installed", 46), ("m1000BaseGBIC-not-installed", 47), ("mLayer31000BaseSX-GIBIC", 48), ("mLayer31000BaseLX-GIBIC", 49), ("mLayer31000BaseCX-GIBIC", 50), ("mLayer31000BaseT-GIBIC", 51), ("mLayer3100BaseSMLCL-GIBIC", 52), ("mLayer3100BaseM5o6SNI-GIBIC", 53), ("mLayer31000BasePOSMM", 54), ("mLayer31000BasePOSSM", 55), ("mLayer3100BaseFXSFFMM20Port", 56), ("mLayer3100BaseFXSFFSM20Port", 57), ("mLayer3100BaseFXSFFMM5Port", 58), ("mLayer3100BaseFXSFFSM5Port", 59), ("mDS3ATM", 60), ("mDS1MLP", 61), ("mMLPmother", 62), ("m1000BaseSFP-installed", 63), ("mLayer31000BaseSX-SFP", 65), ("mLayer31000BaseLX-SFP", 66), ("mLayer31000BaseCX-SFP", 67), ("mLayer31000BaseT-SFP", 68), ("mLayer3100BaseSMLCL-SFP", 69), ("mLayer3100BaseM5o6SNI-SFP", 70), ("m100BaseGBIC-not-installed", 71), ("mLayer310GBaseSR-XFP", 72), ("mLayer310GBaseLR-XFP", 73), ("mLayer310GBaseER-XFP", 74), ("mLayer310GBaseSW-XFP", 75), ("mLayer310GBaseLW-XFP", 76), ("mLayer310GBaseEW-XFP", 77), ("mLayer310GBase-XFP", 78), ("m10000BaseMEDIA-not-installed", 79), ("mCpmCard", 80), ("mLayer310GBaseLRW-XFP", 81), ("mLayer310GBaseERW-XFP", 82), ("mLayer31000BaseX-SFP", 83), ("mCES", 84), ("mLayer3100BaseFX-SFP", 85), ("mCES-4TDM", 86), ("mLayer31000BaseLX-BD-SFP", 87), ("mMiRIC-E1", 88), ("mMiRIC-E3", 89), ("mMiRIC-T1", 90), ("mMiRIC-T3", 91), ("mLayer31000BaseSFP-Unknown", 92), ("m10000BaseXFP-Unknown", 93), ("xAUI-1G-10G", 94), ("mLayer3-10-1000BaseT", 95), ("mLayer310GBaseSMSR-XFP", 96), ("mLayer310GBaseSMLR-XFP", 97), ("mLayer310GBaseSMER-XFP", 98), ("mLayer310GBaseSMSW-XFP", 99), ("mLayer310GBaseSMLW-XFP", 101), ("mLayer310GBaseSMEW-XFP", 102), ("mLayer310GBaseSMSRW-XFP", 103), ("mLayer310GBaseSMLRW-XFP", 104), ("mLayer310GBaseSMERW-XFP", 105), ("mLayer310GBaseCpPgt-XFP", 106), ("mLayer310GBaseSMZR-XFP", 107), ("mLayer31000BaseZX-SFP", 108), ("mLayer310GBaseSMZX-XFP", 109), ("mLayer310GBaseSMEX-XFP", 110), ("mLayer31000BaseT-WithoutAN-SFP", 111), ("mLayer3100BaseLX-BD-SFP", 112))

class Series(TextualConvention, Integer32):
    description = 'This value represents the series of the switch.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("notExist", 1), ("e-series", 2), ("g-series", 3), ("t-series", 4))

prvtSwitchNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0))
sys = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1))
config = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2))
reports = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3))
test = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 4))
commands = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 5))
prvtSwitchConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 6))
sysProductsOids = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1))
sysIntf = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 2))
sysManufacturing = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3))
sysSwitchingHW = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 4))
t4Router = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1))
t5Router = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 2))
t5ProRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 3))
t6Router = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 4))
t5c_48TRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 5)).setLabel("t5c-48TRouter")
t5RNRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 6))
t5c_24TRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 7)).setLabel("t5c-24TRouter")
t5c_24MRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 8)).setLabel("t5c-24MRouter")
t5c_24FRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 9)).setLabel("t5c-24FRouter")
t5c_24GRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 10)).setLabel("t5c-24GRouter")
t5c_24GTRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 11)).setLabel("t5c-24GTRouter")
t6pro_lc_20G = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 13)).setLabel("t6pro-lc-20G")
t6pro_cpm = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 14)).setLabel("t6pro-cpm")
tMetro = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 16))
tMarc = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17))
aHUB1_A = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 18)).setLabel("aHUB1-A")
tMetro_ES = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 19)).setLabel("tMetro-ES")
tMarc_E = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 20)).setLabel("tMarc-E")
tMarc_EW = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 21)).setLabel("tMarc-EW")
tMarc_WDB = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 22)).setLabel("tMarc-WDB")
tMarc_WD = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 23)).setLabel("tMarc-WD")
tMarc_F = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 24)).setLabel("tMarc-F")
t5c_XG = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 27)).setLabel("t5c-XG")
compact = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 14, 1))
classic = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 14, 2))
as9205 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 7, 1))
as9205_F = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 9, 1)).setLabel("as9205-F")
tMarc_250 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 1)).setLabel("tMarc-250")
tMarc_254 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 2)).setLabel("tMarc-254")
tMarc_254h = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 3)).setLabel("tMarc-254h")
tMarc_340 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 10)).setLabel("tMarc-340")
tMarc_380 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 11)).setLabel("tMarc-380")
tMarc_340_E = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 20, 1)).setLabel("tMarc-340-E")
tMarc_380_E = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 20, 2)).setLabel("tMarc-380-E")
tMarc_340_EW = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 21, 1)).setLabel("tMarc-340-EW")
tMarc_380_EW = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 21, 2)).setLabel("tMarc-380-EW")
tMarc_340WD_B = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 22, 1)).setLabel("tMarc-340WD-B")
tMarc_340WD = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 23, 1)).setLabel("tMarc-340WD")
tMarc_340_F = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 24, 1)).setLabel("tMarc-340-F")
tMarc_280 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 20)).setLabel("tMarc-280")
dm9225 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 1, 1))
dm9225_E = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 2, 1)).setLabel("dm9225-E")
dm9234 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 17, 10, 1))
alcatel_7250 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 16, 1)).setLabel("alcatel-7250")
alcatel_7250_ES = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 19, 1)).setLabel("alcatel-7250-ES")
alcatel_7250_ESA = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 19, 2)).setLabel("alcatel-7250-ESA")
tMetro_ESA = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 19, 3)).setLabel("tMetro-ESA")
as9220 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 19, 10))
tMetro_200S = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 19, 11)).setLabel("tMetro-200S")
as9215 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 27, 1))
bI_Ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 18, 1)).setLabel("bI-Ethernet")
fI_Ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 18, 2)).setLabel("fI-Ethernet")
t5c = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 100))
t5cgt = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 222))
t5g = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 333))
v24s = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 444))
edgeGate281 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1000))
edgeGate281SYS = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1001))
edgeGate231 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1010))
edgeGate282 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1020))
edgeGate282S = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1021))
edgeGate482S = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1022))
edgeGate483S = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1023))
edgeGate483D = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1024))
edgeGate201 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1031))
edgeGate232 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1041))
ac500 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1050))
ac505 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1050, 1))
ac512 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1050, 2))
ac524 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 1, 1050, 3))
sysIntfTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 2, 1), )
if mibBuilder.loadTexts: sysIntfTable.setStatus('current')
if mibBuilder.loadTexts: sysIntfTable.setDescription('This table contains the interfaces module type.')
sysIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 2, 1, 1), ).setIndexNames((0, "PRVT-SWITCH-MIB", "sysStackNo"), (0, "PRVT-SWITCH-MIB", "sysSlotNo"))
if mibBuilder.loadTexts: sysIntfEntry.setStatus('current')
if mibBuilder.loadTexts: sysIntfEntry.setDescription('sysIntfEntry')
sysStackNo = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 2, 1, 1, 1), UnitIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysStackNo.setStatus('current')
if mibBuilder.loadTexts: sysStackNo.setDescription('This object identifies the switch')
sysSlotNo = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSlotNo.setStatus('current')
if mibBuilder.loadTexts: sysSlotNo.setDescription('This indicates a single instance of a slot')
sysIntfUnitExist = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uninstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysIntfUnitExist.setStatus('current')
if mibBuilder.loadTexts: sysIntfUnitExist.setDescription('This indicates interface module type')
sysIntfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 2, 1, 1, 4), ModuleHwType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysIntfModule.setStatus('current')
if mibBuilder.loadTexts: sysIntfModule.setDescription('This indicates interface module type')
sysSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSerialNumber.setStatus('current')
if mibBuilder.loadTexts: sysSerialNumber.setDescription("This is the device's serial number, which is entered during the manufacturing process.\n")
sysSwitchModel = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSwitchModel.setStatus('current')
if mibBuilder.loadTexts: sysSwitchModel.setDescription('Specifies the equipment model')
sysAssemblyNumber = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAssemblyNumber.setStatus('current')
if mibBuilder.loadTexts: sysAssemblyNumber.setDescription('Specifies the equipment assembly number')
sysPartNumber = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPartNumber.setStatus('current')
if mibBuilder.loadTexts: sysPartNumber.setDescription('Specifies the equipment part number')
sysCLEI = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCLEI.setStatus('current')
if mibBuilder.loadTexts: sysCLEI.setDescription('Specifies the common language equipment identification')
sysHwRevision = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHwRevision.setStatus('current')
if mibBuilder.loadTexts: sysHwRevision.setDescription('Specifies the HW revision')
sysManufacturingDate = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 3, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysManufacturingDate.setStatus('current')
if mibBuilder.loadTexts: sysManufacturingDate.setDescription('Specifies the manufacturing date')
sysSwitchSeries = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 1, 4, 1), Series()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSwitchSeries.setStatus('current')
if mibBuilder.loadTexts: sysSwitchSeries.setDescription('This object displays the switch series.')
configL2 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2))
configL2SpanOnOff = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enableSTP", 1), ("disable", 2), ("enableRSTP", 3), ("enablePVST", 4), ("enableMST", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2SpanOnOff.setStatus('current')
if mibBuilder.loadTexts: configL2SpanOnOff.setDescription("Enables/disables Spanning Tree. When Spanning Tree is disabled, the switch's ports are placed in\nforwarding mode, regardless of the current Spanning Tree state. When re-enabled, the normal state\ntransitions take place.")
configL2IfaceTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2), )
if mibBuilder.loadTexts: configL2IfaceTable.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceTable.setDescription('A list of Interfaces and their properties')
configL2IfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1), ).setIndexNames((0, "PRVT-SWITCH-MIB", "configL2IfaceUnit"), (0, "PRVT-SWITCH-MIB", "configL2IfaceSlot"), (0, "PRVT-SWITCH-MIB", "configL2IfacePort"))
if mibBuilder.loadTexts: configL2IfaceEntry.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceEntry.setDescription('An index of interfaces.')
configL2IfaceUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configL2IfaceUnit.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceUnit.setDescription('An index that uniquely identifies a unit in the\nInterface Table.')
configL2IfaceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configL2IfaceSlot.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceSlot.setDescription('An index that uniquely identifies a slot within the unit\nin the Interface Table.')
configL2IfacePort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configL2IfacePort.setStatus('current')
if mibBuilder.loadTexts: configL2IfacePort.setDescription('An index that uniquely identifies a port within the slot\nin the Interface Table.')
configL2IfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceName.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceName.setDescription("The textual name of this interface, e.g., 'John'.")
configL2IfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceEnable.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceEnable.setDescription("Enables (1)or disables (2) control for the interface.\nFor this product, this is the ONLY way to enable or\ndisable the interface. 'ifAdminStatus' in RFC1213 and\n'dot1dStpPortEnable' in RFC1493 are both implemented\nas 'read-only'.")
configL2IfaceSTPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceSTPEnable.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceSTPEnable.setDescription('Enables (1) and disables (2) Spanning Tree operation for this\ninterface.')
configL2IfaceDuplexSpeedSet = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 99))).clone(namedValues=NamedValues(("autonegotiate", 1), ("half-10", 2), ("full-10", 3), ("half-100", 4), ("full-100", 5), ("half-1000", 6), ("full-1000", 7), ("pos-155", 8), ("pos-622", 9), ("full-10000", 10), ("half-auto", 11), ("full-auto", 12), ("auto-10", 13), ("auto-100", 14), ("auto-1000", 16), ("illegal", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceDuplexSpeedSet.setStatus('obsolete')
if mibBuilder.loadTexts: configL2IfaceDuplexSpeedSet.setDescription('The desired speed and duplex mode for the interface. If the selected\ncontrol is not available for the interface, a value of illegal (99)\nis returned. If the port type does NOT support the\ndefault of autonegotiate (1), then the application will\ninitialize the port to a valid value (e.g., 1000full (6)).\nNote that not all controls are available for all interfaces.\nFor example, only full-1000 (6) is available for Gigabit\nEthernet interfaces.\n\nAs this object was marked as obsolete the following two\nconfigurable parameters of an interface should be used:\nconfigL2IfaceDuplexModeSet, configL2IfaceSpeedSet ')
configL2IfaceFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autonegotiate", 1), ("flowon", 2), ("flowoff", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceFlow.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceFlow.setDescription('The desired flow mode for the interface. If the selected control is not available\non the interface, a value of illegal (99) is returned. If the port type does NOT support\nthe default value of autonegotiate (1), then the application will initialize the port to a\nvalid value (e.g., 1000full (6)).Note that not all controls are available for all interfaces.\nFor example, only full-1000 (6) is available for Gigabit Ethernet interfaces.')
configL2IfaceBackpressure = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("backpressureon", 1), ("backpressureoff", 2), ("illegal", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceBackpressure.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceBackpressure.setDescription('The desired back-pressure mode for the interface.\nIf the selected control is not available on the interface,\na value of illegal (99) is returned.')
configL2IfaceResetCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noop", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceResetCounters.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceResetCounters.setDescription('This object enables resetting the statistics counters selected for this\nport.')
configL2IfaceDefaultVID = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceDefaultVID.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceDefaultVID.setDescription('This object sets the default VLAN ID according to 802.1Q.')
configL2IfaceSnifferIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceSnifferIfIndex.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceSnifferIfIndex.setDescription('This object connects this port to a sniffer port indexed by the specified ifIndex.\nSetting this value to 0 disconnects this port from the sniffer.')
configL2TopologyChangeDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2TopologyChangeDetection.setStatus('current')
if mibBuilder.loadTexts: configL2TopologyChangeDetection.setDescription('This object controls the STP topology change detection for this interface.')
configL2IfaceDuplexModeSet = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("full", 2), ("half", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceDuplexModeSet.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceDuplexModeSet.setDescription('The duplex mode for the interface. If the port type does NOT support\nthe default of autonegotiate (1), then the application will\ninitialize the port to a valid value (e.g., full (2)).')
configL2IfaceSpeedSet = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 99))).clone(namedValues=NamedValues(("auto", 1), ("speed-10", 2), ("speed-100", 3), ("speed-1000", 4), ("speed-10000", 5), ("pos-155", 6), ("pos-622", 7), ("illegal", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceSpeedSet.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceSpeedSet.setDescription('The desired speed and duplex mode for the interface. If the selected\ncontrol is not available for the interface, a value of illegal (99)\nis returned. If the port type does NOT support the\ndefault of autonegotiate (1), then the application will\ninitialize the port to a valid value (e.g., 1000 (3)).\nNote that not all controls are available for all interfaces.\nFor example, only 1000 (4) is available for Gigabit\nEthernet interfaces.')
configL2IfaceBroadcastRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceBroadcastRateLimit.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceBroadcastRateLimit.setDescription('Rate limit broadcast traffic. Must be a number between 64Kbps and 1Gbps,\nspecified in Kbps.')
configL2IfaceMulticastRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceMulticastRateLimit.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceMulticastRateLimit.setDescription('Rate limit multicast traffic. Must be a number between 64Kbps and 1Gbps,\nspecified in Kbps.')
configL2IfaceUnknownRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceUnknownRateLimit.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceUnknownRateLimit.setDescription('Rate limit unknown traffic. Must be a number between 64Kbps and 1Gbps,\nspecified in Kbps. For detail information see documentation.')
configL2IfaceBroadcastBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceBroadcastBurstSize.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceBroadcastBurstSize.setDescription('Burst size broadcast traffic. Must be a number between 12Kbps and 1Mbps,\nspecified in Kbps.')
configL2IfaceMulticastBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceMulticastBurstSize.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceMulticastBurstSize.setDescription('Burst size multicast traffic. Must be a number between 12Kbps and 1Mbps,\nspecified in Kbps.')
configL2IfaceUnknownBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceUnknownBurstSize.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceUnknownBurstSize.setDescription('Burst size unknown traffic. Must be a number between 12Kbps and 1Mbps,\nspecified in Kbps. For detail information see documentation.')
configL2IfaceMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 9216)).clone(1528)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceMtu.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceMtu.setDescription('The Maximum Transmission Unit (in octets) of the interface.')
configL2IfaceAdminCrossOver = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("auto", 1), ("mdi", 2), ("mdi-x", 3), ("unsupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceAdminCrossOver.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceAdminCrossOver.setDescription('The administrative MDI/MDI-X cable connection status of ports, as specified in IEEE 803.2.\nThe mdi-x mode (crossover) is configured (3), the interface works in MDI-X mode.\nThe mdi mode (2) defines port to work in standard MDI mode.\nThe auto (1) defines automatic crossover detection, and any type of MDI/MDI-X cabling can be used on the port.\nNote: This attribute can be configured only on interfaces that support that option.')
configL2IfaceRemoteFaultDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 2, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enableRemoteFaultDetect", 1), ("disableRemoteFaultDetect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configL2IfaceRemoteFaultDetect.setStatus('current')
if mibBuilder.loadTexts: configL2IfaceRemoteFaultDetect.setDescription('Controls the remote fault detection on interfaces, connected to 100Base Fiber pair.\nOnce enabled (1), the switch will indicate link-down event on the interface, once remote\npeer detects link down.\nNote: Relevant only on 100Base Fiber interfaces.')
reportsL2 = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1))
reportsL2IfaceTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1), )
if mibBuilder.loadTexts: reportsL2IfaceTable.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceTable.setDescription('A list of Interfaces and their properties')
reportsL2IfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1), ).setIndexNames((0, "PRVT-SWITCH-MIB", "reportsL2IfaceUnit"), (0, "PRVT-SWITCH-MIB", "reportsL2IfaceSlot"), (0, "PRVT-SWITCH-MIB", "reportsL2IfacePort"))
if mibBuilder.loadTexts: reportsL2IfaceEntry.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceEntry.setDescription('An index of interfaces.')
reportsL2IfaceUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceUnit.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceUnit.setDescription('An index that uniquely identifies a unit in the\nInterface Table.')
reportsL2IfaceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceSlot.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceSlot.setDescription('An index that uniquely identifies a slot within the unit\nin the Interface Table.')
reportsL2IfacePort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfacePort.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfacePort.setDescription('An index that uniquely identifies a port within the slot\nin the Interface Table.')
reportsL2IfaceBridgeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceBridgeIndex.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceBridgeIndex.setDescription('This is the bridge index of this port.')
reportsL2IfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10Mbit", 12), ("proteon-80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("e1", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frame-relay", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceType.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceType.setDescription('The type of interface, repeated here from the definitions\nin RFC1213 as a matter of convenience.')
reportsL2IfaceLink = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceLink.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceLink.setDescription('The state of Link Detect on the interface.')
reportsL2IfaceDuplexSpeedGet = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 99))).clone(namedValues=NamedValues(("unknown", 1), ("half-10", 2), ("full-10", 3), ("half-100", 4), ("full-100", 5), ("half-1000", 6), ("full-1000", 7), ("pos-155", 8), ("pos-622", 9), ("full-10000", 10), ("illegal", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceDuplexSpeedGet.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceDuplexSpeedGet.setDescription('The actual speed and duplex for the interface. If the\ninterface is not configured to one of the acceptable\nvalues, a value of illegal (99) is returned.')
reportsL2IfaceTXOctetsNoErr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceTXOctetsNoErr.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceTXOctetsNoErr.setDescription('The number of octets transmitted from the interface. This\nnumber does not include octets with errors.')
reportsL2IfaceTXPacketsNoErr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceTXPacketsNoErr.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceTXPacketsNoErr.setDescription('The number of packets transmitted from the interface. This\nnumber does not include packets with errors.')
reportsL2IfaceRXOctetsNoErr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceRXOctetsNoErr.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceRXOctetsNoErr.setDescription('The number of octets received on the interface. This\nnumber does not include octets with errors.')
reportsL2IfaceRXPacketsNoErr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceRXPacketsNoErr.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceRXPacketsNoErr.setDescription('The number of packets received on the interface. This\nnumber does not include packets with errors.')
reportsL2IfaceIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfInOctets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfInOctets.setDescription('The total number of octets received on the\ninterface, including framing characters.')
reportsL2IfaceIfInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfInUcastPkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfInUcastPkts.setDescription('The number of subnetwork-unicast packets\ndelivered to a higher-layer protocol.')
reportsL2IfaceIfInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfInNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork-\nbroadcast or subnetwork-multicast) packets\ndelivered to a higher-layer protocol.')
reportsL2IfaceIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfInDiscards.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfInDiscards.setDescription('The number of inbound packets that were chosen\nto be discarded even if no errors that prevent their deliverability\nto a higher-layer protocol had been detected. One possible reason for\ndiscarding such a packet could be to free buffer space.')
reportsL2IfaceIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfInErrors.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfInErrors.setDescription('The number of inbound packets that contained\nerrors preventing them from being deliverable to a\nhigher-layer protocol.')
reportsL2IfaceIfInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfInUnknownProtos.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfInUnknownProtos.setDescription('The number of packets received via the interface\nthat were discarded because of an unknown or\nunsupported protocol.')
reportsL2IfaceIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfOutOctets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfOutOctets.setDescription('The total number of octets transmitted out of the\ninterface, including framing characters.')
reportsL2IfaceIfOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfOutUcastPkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfOutUcastPkts.setDescription('The total number of packets that higher-level\nprotocols requested to be transmitted to a\nsubnetwork-unicast address, including those that\nwere discarded or not sent.')
reportsL2IfaceIfOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfOutNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfOutNUcastPkts.setDescription('The total number of packets that higher-level\nprotocols requested to be transmitted to a non-\nunicast (i.e., a subnetwork-broadcast or\nsubnetwork-multicast) address, including those\nthat were discarded or not sent.')
reportsL2IfaceIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfOutDiscards.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfOutDiscards.setDescription('The number of outbound packets that were chosen\nto be discarded even if no errors that prevented their\ntransmission had been detected. One\npossible reason for discarding such a packet could\nbe to free up buffer space.')
reportsL2IfaceIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceIfOutErrors.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceIfOutErrors.setDescription('The number of outbound packets that could not be\ntransmitted because of errors.')
reportsL2IfaceStatsDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsDropEvents.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsDropEvents.setDescription('The total number of events in which packets\nwere dropped by the probe due to lack of resources.\nNote that this number is not necessarily the number of\npackets dropped; it is just the number of times this\ncondition has been detected.')
reportsL2IfaceStatsOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsOctets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsOctets.setDescription('The total number of octets of data (including\nthose in bad packets) received on the\nnetwork (excluding framing bits but including\nFCS octets).\n\nThis object can be used as a reasonable estimate of\nEthernet utilization. If greater precision is\ndesired, the etherStatsPkts and etherStatsOctets\nobjects should be sampled before and after a common\ninterval. The differences in the sampled values are\nPkts and Octets, respectively, and the number of\nseconds in the interval is Interval. These values\nare used to calculate the Utilization as follows:\n\nPkts * (9.6 + 6.4) + (Octets * .8)\nUtilization = -------------------------------------\nInterval * 10,000\n\nThe result of this equation is the Ethernet segment utilization\nwhich is the percent utilization of the ethernet\nsegment on a 0 to 100 percent scale.')
reportsL2IfaceStatsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts.setDescription('The total number of packets (including bad packets,\nbroadcast packets, and multicast packets) received.')
reportsL2IfaceStatsBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsBroadcastPkts.setDescription('The total number of good packets received that were\ndirected to the broadcast address. Note that this\ndoes not include multicast packets.')
reportsL2IfaceStatsMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsMulticastPkts.setDescription('The total number of good packets received that were\ndirected to a multicast address. Note that this\nnumber does not include packets directed to the\nbroadcast address.')
reportsL2IfaceStatsCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsCRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsCRCAlignErrors.setDescription('The total number of packets received that\nhad a length (excluding framing bits, but\nincluding FCS octets) of between 64 and 1518\noctets, inclusive, but had either a bad\nFrame Check Sequence (FCS) with an integral\nnumber of octets (FCS Error) or a bad FCS with\na non-integral number of octets (Alignment Error).')
reportsL2IfaceStatsUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsUndersizePkts.setDescription('The total number of packets received that were\nless than 64 octets long (excluding framing bits,\nbut including FCS octets) and were otherwise well\nformed.')
reportsL2IfaceStatsOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsOversizePkts.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsOversizePkts.setDescription('The total number of packets received that were\nlonger than 1518 octets (excluding framing bits,\nbut including FCS octets) and were otherwise\nwell formed.')
reportsL2IfaceStatsFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsFragments.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsFragments.setDescription('The total number of packets received that were less\nthan 64 octets in length (excluding framing bits but\nincluding FCS octets) and had either a bad Frame\nCheck Sequence (FCS) with an integral number of\noctets (FCS Error) or a bad FCS with a non-integral\nnumber of octets (Alignment Error).\n\nNote that it is entirely normal for\netherStatsFragments to increment. This is because\nit counts both runts (which are normal occurrences\ndue to collisions) and noise hits.')
reportsL2IfaceStatsJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsJabbers.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsJabbers.setDescription('The total number of packets received that were\nlonger than 1518 octets (excluding framing bits,\nbut including FCS octets), and had either a bad\nFrame Check Sequence (FCS) with an integral number\nof octets (FCS Error) or a bad FCS with a\nnon-integral number of octets (Alignment Error).\n\nNote that this definition of jabber is different\nfrom the definition in IEEE-802.3 section 8.2.1.5\n(10BASE5) and section 10.3.1.4 (10BASE2). These\ndocuments define jabber as the condition in which any\npacket exceeds 20 ms. The allowed range to detect\njabber is between 20 ms and 150 ms.')
reportsL2IfaceStatsCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsCollisions.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsCollisions.setDescription("The best estimate of the total number of collisions\non this Ethernet segment.\n\nThe value returned will depend on the RMON probe's location.\nSections 8.2.1.3 (10BASE-5) and 10.3.1.3 (10BASE-2) of\nIEEE standard 802.3 states that a station must detect a collision in\nthe receive mode if three or more stations are\ntransmitting simultaneously. A repeater port must\ndetect a collision when two or more stations are\ntransmitting simultaneously. Thus a probe placed on\na repeater port could record more collisions than a\nprobe connected to a station on the same segment\nwould.\n\nProbe location plays a much smaller role when\nconsidering 10BASE-T. Section 14.2.1.4 (10BASE-T) of IEEE\nstandard 802.3 defines a collision as the\nsimultaneous presence of signals on the DO and RD\ncircuits (transmitting and receiving at the same\ntime). A 10BASE-T station can only detect\ncollisions when it is transmitting. Thus probes\nplaced on a station and a repeater, should report\nthe same number of collisions.\n\nNote also that an RMON probe inside a repeater\nshould ideally report collisions between the\nrepeater and one or more other hosts (transmit\ncollisions as defined by IEEE 802.3k) plus receiver\ncollisions observed on any coaxial segments to which\nthe repeater is connected.")
reportsL2IfaceStatsPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts64Octets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts64Octets.setDescription('The total number of packets (including bad\npackets) received that were 64 octets in length\n(excluding framing bits but including FCS octets).')
reportsL2IfaceStatsPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts65to127Octets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts65to127Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n65 and 127 octets in length inclusive\n(excluding framing bits but including FCS octets).')
reportsL2IfaceStatsPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts128to255Octets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts128to255Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n128 and 255 octets in length inclusive\n(excluding framing bits but including FCS octets).')
reportsL2IfaceStatsPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts256to511Octets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts256to511Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n256 and 511 octets in length inclusive\n(excluding framing bits but including FCS octets).')
reportsL2IfaceStatsPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts512to1023Octets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts512to1023Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n512 and 1023 octets in length inclusive\n(excluding framing bits but including FCS octets).')
reportsL2IfaceStatsPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts1024to1518Octets.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceStatsPkts1024to1518Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n1024 and 1518 octets in length inclusive\n(excluding framing bits but including FCS octets).')
reportsL2IfaceFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("flowon", 2), ("flowoff", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceFlow.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceFlow.setDescription('The flow control for the interface.')
reportsL2IfaceHWType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 41), ModuleHwType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceHWType.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceHWType.setDescription('The HW type of the interface.')
reportsL2IfaceActiveJackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 1, 1, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsL2IfaceActiveJackIndex.setStatus('current')
if mibBuilder.loadTexts: reportsL2IfaceActiveJackIndex.setDescription('The current active jack index.')
reportsHardware = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2))
reportsHardwarePSStatus = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsHardwarePSStatus.setStatus('current')
if mibBuilder.loadTexts: reportsHardwarePSStatus.setDescription('Each OCTET holds the status of 1 power supply or if supported,\na status of its corresponding power supply fan. Every octet can\nshow one of the following states:\n0 - power supply not installed;\n1 - power supply is installed but does not function correctly;\n2 - power supply is installed and working OK;\nThere are devices, which can also show status of the Fan,\nattached to the power supply. All devices which support the Power\nSupply fan, will display their status in series of octet pairs.\nThe fan status octet will be displayed right after the supply\nstatus octet. ')
reportsHardwareFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsHardwareFanStatus.setStatus('current')
if mibBuilder.loadTexts: reportsHardwareFanStatus.setDescription('Each OCTET holds the status of 1 fan\n0 - Fan stopped\n1 - Fan failed\n2 - Fan OK')
reportsHardwareTemperature = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsHardwareTemperature.setStatus('current')
if mibBuilder.loadTexts: reportsHardwareTemperature.setDescription('The internal temperature of the unit in degrees Celsius.')
reportsHardwarePSVoltage = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsHardwarePSVoltage.setStatus('current')
if mibBuilder.loadTexts: reportsHardwarePSVoltage.setDescription('Each OCTET holds the voltage of a corresponding power supply. Every octet can\nshow one of the following states:\n0 - power supply not installed or voltage information is not supported;\n1-C - power supply in V, hexadecimal;')
reportsHardwareTemperatureScale = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("celsius", 1), ("fahrenheit", 2))).clone('celsius')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reportsHardwareTemperatureScale.setStatus('current')
if mibBuilder.loadTexts: reportsHardwareTemperatureScale.setDescription('Displays the scale used - Celsius (Centigrade) or Fahrenheit when measuring CPU temperature. The value of this object determines the type of scale used for the values of reportsHardwareTemperature and reportsHardwareTemperatureHighLimit objects.')
reportsHardwareTemperatureHighLimit = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 70)).clone(55)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reportsHardwareTemperatureHighLimit.setStatus('current')
if mibBuilder.loadTexts: reportsHardwareTemperatureHighLimit.setDescription('Displays the highest allowed Celsius (Centigrade) or Fahrenheit temperature at the unit CPU area. When this limit is reached an SNMP notification is sent.')
reportsHardwareDoorStatus = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsHardwareDoorStatus.setStatus('current')
if mibBuilder.loadTexts: reportsHardwareDoorStatus.setDescription('Status of door\n0 - Door not installed\n1 - Door open\n2 - Door closed')
reportsIfJack = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 3))
reportsIfJackTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 3, 2), )
if mibBuilder.loadTexts: reportsIfJackTable.setStatus('current')
if mibBuilder.loadTexts: reportsIfJackTable.setDescription('Information about the external jacks attached to\nMAUs attached to an interface.')
reportsIfJackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 3, 2, 1), ).setIndexNames((0, "PRVT-SWITCH-MIB", "reportsL2IfaceUnit"), (0, "PRVT-SWITCH-MIB", "reportsL2IfaceSlot"), (0, "PRVT-SWITCH-MIB", "reportsL2IfacePort"), (0, "PRVT-SWITCH-MIB", "reportsIfJackIndex"))
if mibBuilder.loadTexts: reportsIfJackEntry.setStatus('current')
if mibBuilder.loadTexts: reportsIfJackEntry.setDescription('An entry in the table, containing information\nabout a particular jack.')
reportsIfJackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: reportsIfJackIndex.setStatus('current')
if mibBuilder.loadTexts: reportsIfJackIndex.setDescription('This variable uniquely identifies the jack\ndescribed by this entry from among other jacks\nattached to the same MAU.')
reportsIfJackType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 3, 3, 2, 1, 2), ModuleHwType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reportsIfJackType.setStatus('current')
if mibBuilder.loadTexts: reportsIfJackType.setDescription('The jack connector type, as it appears on the\nouter side of the system.')
cpuTemperatureExceeded = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 1)).setObjects(("PRVT-SWITCH-MIB", "reportsHardwareTemperature"))
if mibBuilder.loadTexts: cpuTemperatureExceeded.setStatus('current')
if mibBuilder.loadTexts: cpuTemperatureExceeded.setDescription('The cpuTemperatuteExceeded trap indicates that the sending\nagent senses that the internal temperature has passed the\nprogram threshold.')
powerSupplyStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 2)).setObjects(("PRVT-SWITCH-MIB", "reportsHardwarePSStatus"))
if mibBuilder.loadTexts: powerSupplyStatusChange.setStatus('current')
if mibBuilder.loadTexts: powerSupplyStatusChange.setDescription('The powerSupplyStatusChange trap indicates that the sending\nagent senses a change in the status of one of the power supplies.')
fanStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 3)).setObjects(("PRVT-SWITCH-MIB", "reportsHardwareFanStatus"))
if mibBuilder.loadTexts: fanStatusChange.setStatus('current')
if mibBuilder.loadTexts: fanStatusChange.setDescription('The fanStatusChange trap indicates that the sending\nagent senses a change in the status of one of the fans.')
portSecurityViolation = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 4)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: portSecurityViolation.setStatus('current')
if mibBuilder.loadTexts: portSecurityViolation.setDescription('The port security violation notification indicates that a port security violation has been detected, e.g more MAC adresses have been learned on that port than the number allowed.')
portRedundantLinkChange = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 5)).setObjects(("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"), ("PRVT-SWITCH-MIB", "reportsL2IfaceLink"))
if mibBuilder.loadTexts: portRedundantLinkChange.setStatus('current')
if mibBuilder.loadTexts: portRedundantLinkChange.setDescription('The port redundant link change notification indicates that the physical state of a redundant (i.e.\nblocked or discarding) link has changed from link-up\nto link down or vice versa.')
sysIntfModuleChange = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 6)).setObjects(("PRVT-SWITCH-MIB", "sysIntfModule"))
if mibBuilder.loadTexts: sysIntfModuleChange.setStatus('current')
if mibBuilder.loadTexts: sysIntfModuleChange.setDescription('The System Interface Module change notification indicates\nthat the physical status of a module in the\nunit has changed.')
prvtLogNotifyFull = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 7))
if mibBuilder.loadTexts: prvtLogNotifyFull.setStatus('current')
if mibBuilder.loadTexts: prvtLogNotifyFull.setDescription('Log buffer is almost full.')
doorStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 0, 8)).setObjects(("PRVT-SWITCH-MIB", "reportsHardwareDoorStatus"))
if mibBuilder.loadTexts: doorStatusChange.setStatus('current')
if mibBuilder.loadTexts: doorStatusChange.setDescription('The doorStatusChange trap indicates that the sending\nagent senses a change in the status of the door.')
prvtSwitchMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 6, 2))
prvtSwitchNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 738, 1, 5, 100, 6, 2, 3)).setObjects(("PRVT-SWITCH-MIB", "cpuTemperatureExceeded"), ("PRVT-SWITCH-MIB", "powerSupplyStatusChange"), ("PRVT-SWITCH-MIB", "fanStatusChange"), ("PRVT-SWITCH-MIB", "portSecurityViolation"), ("PRVT-SWITCH-MIB", "portRedundantLinkChange"), ("PRVT-SWITCH-MIB", "sysIntfModuleChange"), ("PRVT-SWITCH-MIB", "doorStatusChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtSwitchNotificationGroup = prvtSwitchNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: prvtSwitchNotificationGroup.setDescription('Private Notification Group.')
mibBuilder.exportSymbols("PRVT-SWITCH-MIB", ac500=ac500, sysSerialNumber=sysSerialNumber, portRedundantLinkChange=portRedundantLinkChange, tMarc_340_F=tMarc_340_F, configL2IfaceRemoteFaultDetect=configL2IfaceRemoteFaultDetect, as9205_F=as9205_F, reportsHardwarePSStatus=reportsHardwarePSStatus, edgeGate483D=edgeGate483D, sysSwitchingHW=sysSwitchingHW, reportsL2IfacePort=reportsL2IfacePort, tMarc_340WD=tMarc_340WD, sysManufacturingDate=sysManufacturingDate, tps=tps, vol0215=vol0215, tMarc_F=tMarc_F, reportsL2IfaceIfInUcastPkts=reportsL2IfaceIfInUcastPkts, reportsL2IfaceFlow=reportsL2IfaceFlow, sysSwitchSeries=sysSwitchSeries, reportsL2IfaceStatsCRCAlignErrors=reportsL2IfaceStatsCRCAlignErrors, prvt_mgmt=prvt_mgmt, t5g=t5g, edgeGate281SYS=edgeGate281SYS, t5c_XG=t5c_XG, vol4000=vol4000, sysHwRevision=sysHwRevision, t5RNRouter=t5RNRouter, reportsL2IfaceStatsBroadcastPkts=reportsL2IfaceStatsBroadcastPkts, configL2IfaceResetCounters=configL2IfaceResetCounters, tMetro=tMetro, edgeGate482S=edgeGate482S, t6pro_cpm=t6pro_cpm, edgeGate232=edgeGate232, config=config, reportsL2IfaceStatsCollisions=reportsL2IfaceStatsCollisions, sysProductsOids=sysProductsOids, configL2IfaceUnit=configL2IfaceUnit, configL2IfaceBroadcastBurstSize=configL2IfaceBroadcastBurstSize, edgeGate282S=edgeGate282S, reportsL2IfaceStatsPkts128to255Octets=reportsL2IfaceStatsPkts128to255Octets, reportsL2IfaceIfInOctets=reportsL2IfaceIfInOctets, reportsL2IfaceStatsOversizePkts=reportsL2IfaceStatsOversizePkts, reportsL2=reportsL2, reportsIfJackTable=reportsIfJackTable, configL2IfaceEntry=configL2IfaceEntry, test=test, reportsL2IfaceIfInErrors=reportsL2IfaceIfInErrors, prvtSwitchConformance=prvtSwitchConformance, alcatel_7250=alcatel_7250, reportsHardwareTemperature=reportsHardwareTemperature, tMarc_340_E=tMarc_340_E, reportsL2IfaceIfInUnknownProtos=reportsL2IfaceIfInUnknownProtos, reportsL2IfaceStatsUndersizePkts=reportsL2IfaceStatsUndersizePkts, reportsL2IfaceIfInDiscards=reportsL2IfaceIfInDiscards, trclam=trclam, aHUB1_A=aHUB1_A, bI_Ethernet=bI_Ethernet, titanPro=titanPro, sysManufacturing=sysManufacturing, configL2IfaceBroadcastRateLimit=configL2IfaceBroadcastRateLimit, configL2IfaceBackpressure=configL2IfaceBackpressure, tMetro_200S=tMetro_200S, prvtSwitchMIBGroups=prvtSwitchMIBGroups, reportsL2IfaceStatsPkts512to1023Octets=reportsL2IfaceStatsPkts512to1023Octets, reportsIfJackEntry=reportsIfJackEntry, configL2IfaceDuplexModeSet=configL2IfaceDuplexModeSet, t5ProRouter=t5ProRouter, reportsL2IfaceStatsPkts=reportsL2IfaceStatsPkts, edgeGate201=edgeGate201, reportsL2IfaceTXPacketsNoErr=reportsL2IfaceTXPacketsNoErr, reportsL2IfaceRXOctetsNoErr=reportsL2IfaceRXOctetsNoErr, alcatel_7250_ESA=alcatel_7250_ESA, tMarc=tMarc, sys=sys, reportsL2IfaceStatsPkts256to511Octets=reportsL2IfaceStatsPkts256to511Octets, reportsL2IfaceDuplexSpeedGet=reportsL2IfaceDuplexSpeedGet, reportsL2IfaceSlot=reportsL2IfaceSlot, reportsL2IfaceIfOutOctets=reportsL2IfaceIfOutOctets, configL2IfaceMtu=configL2IfaceMtu, acs25L4282t5=acs25L4282t5, reportsL2IfaceActiveJackIndex=reportsL2IfaceActiveJackIndex, t5Router=t5Router, bridge=bridge, reportsL2IfaceIfInNUcastPkts=reportsL2IfaceIfInNUcastPkts, Series=Series, configL2IfaceSlot=configL2IfaceSlot, reportsL2IfaceEntry=reportsL2IfaceEntry, reportsL2IfaceIfOutNUcastPkts=reportsL2IfaceIfOutNUcastPkts, reportsIfJackType=reportsIfJackType, reportsIfJack=reportsIfJack, reportsL2IfaceType=reportsL2IfaceType, bsw=bsw, configL2IfaceDuplexSpeedSet=configL2IfaceDuplexSpeedSet, rptr=rptr, doorStatusChange=doorStatusChange, configL2IfaceFlow=configL2IfaceFlow, switch=switch, reportsL2IfaceIfOutDiscards=reportsL2IfaceIfOutDiscards, reportsHardware=reportsHardware, ac505=ac505, t5c_24GRouter=t5c_24GRouter, configL2TopologyChangeDetection=configL2TopologyChangeDetection, reports=reports, t5cgt=t5cgt, t5c_24FRouter=t5c_24FRouter, configL2IfaceTable=configL2IfaceTable, classic=classic, reportsL2IfaceTable=reportsL2IfaceTable, prvtSwitchMib=prvtSwitchMib, sysIntf=sysIntf, tMarc_380=tMarc_380, tMarc_E=tMarc_E, t5c_24GTRouter=t5c_24GTRouter, tMetro_ESA=tMetro_ESA, tMarc_280=tMarc_280, tMarc_WD=tMarc_WD, fI_Ethernet=fI_Ethernet, ac512=ac512, tMarc_340=tMarc_340, prvt_products=prvt_products, reportsL2IfaceRXPacketsNoErr=reportsL2IfaceRXPacketsNoErr, cpuTemperatureExceeded=cpuTemperatureExceeded, dm9234=dm9234, edgeGate281=edgeGate281, tMarc_EW=tMarc_EW, t5c=t5c, reportsL2IfaceStatsPkts65to127Octets=reportsL2IfaceStatsPkts65to127Octets, t5c_24MRouter=t5c_24MRouter, tMarc_WDB=tMarc_WDB, tMarc_340_EW=tMarc_340_EW, configL2IfaceSpeedSet=configL2IfaceSpeedSet, configL2IfaceMulticastRateLimit=configL2IfaceMulticastRateLimit, reportsL2IfaceStatsDropEvents=reportsL2IfaceStatsDropEvents, edgeGate483S=edgeGate483S, titan=titan, fanStatusChange=fanStatusChange, tMarc_254=tMarc_254, edgeGate282=edgeGate282, reportsL2IfaceTXOctetsNoErr=reportsL2IfaceTXOctetsNoErr, reportsHardwareDoorStatus=reportsHardwareDoorStatus, alcatel_7250_ES=alcatel_7250_ES, reportsIfJackIndex=reportsIfJackIndex, t6pro_lc_20G=t6pro_lc_20G, configL2IfaceName=configL2IfaceName, t5c_24TRouter=t5c_24TRouter, sysSlotNo=sysSlotNo, vol5000=vol5000, as9205=as9205, as9215=as9215, dm9225=dm9225, sysIntfEntry=sysIntfEntry, edgeLinkT4=edgeLinkT4, ModuleHwType=ModuleHwType, as9220=as9220, configL2IfaceEnable=configL2IfaceEnable, reportsL2IfaceStatsOctets=reportsL2IfaceStatsOctets, prvtSwitchNotificationGroup=prvtSwitchNotificationGroup, sysAssemblyNumber=sysAssemblyNumber, configL2IfacePort=configL2IfacePort, configL2IfaceUnknownBurstSize=configL2IfaceUnknownBurstSize, sysPartNumber=sysPartNumber, tMarc_340WD_B=tMarc_340WD_B, UnitIndex=UnitIndex, tMarc_380_EW=tMarc_380_EW, t6Router=t6Router, reportsL2IfaceBridgeIndex=reportsL2IfaceBridgeIndex, configL2IfaceAdminCrossOver=configL2IfaceAdminCrossOver, reportsL2IfaceLink=reportsL2IfaceLink, compact=compact, configL2IfaceUnknownRateLimit=configL2IfaceUnknownRateLimit, commands=commands, configL2IfaceMulticastBurstSize=configL2IfaceMulticastBurstSize, reportsL2IfaceStatsMulticastPkts=reportsL2IfaceStatsMulticastPkts, t4Router=t4Router, tMetro_ES=tMetro_ES, reportsL2IfaceUnit=reportsL2IfaceUnit, powerSupplyStatusChange=powerSupplyStatusChange, sysIntfUnitExist=sysIntfUnitExist, edgeLinkT5=edgeLinkT5, sysSwitchModel=sysSwitchModel, sysStackNo=sysStackNo, reportsHardwareFanStatus=reportsHardwareFanStatus, sysIntfModule=sysIntfModule, reportsL2IfaceStatsJabbers=reportsL2IfaceStatsJabbers, v24s=v24s, tMarc_254h=tMarc_254h, sysIntfTable=sysIntfTable, tpf=tpf, tMarc_380_E=tMarc_380_E, titant5=titant5, edgeGate231=edgeGate231, configL2SpanOnOff=configL2SpanOnOff, sysCLEI=sysCLEI, PYSNMP_MODULE_ID=prvtSwitchMib, reportsL2IfaceIfOutUcastPkts=reportsL2IfaceIfOutUcastPkts, tMarc_250=tMarc_250, ipSwitch=ipSwitch, ac524=ac524, prvtSwitchNotifications=prvtSwitchNotifications, reportsL2IfaceStatsPkts64Octets=reportsL2IfaceStatsPkts64Octets, reportsHardwareTemperatureHighLimit=reportsHardwareTemperatureHighLimit, acs25L4282=acs25L4282, reportsL2IfaceIfOutErrors=reportsL2IfaceIfOutErrors, prvtLogNotifyFull=prvtLogNotifyFull, configL2IfaceDefaultVID=configL2IfaceDefaultVID, sysIntfModuleChange=sysIntfModuleChange, t5c_48TRouter=t5c_48TRouter, router=router, configL2=configL2, reportsL2IfaceStatsFragments=reportsL2IfaceStatsFragments, configL2IfaceSTPEnable=configL2IfaceSTPEnable, reportsL2IfaceHWType=reportsL2IfaceHWType, portSecurityViolation=portSecurityViolation, reportsHardwarePSVoltage=reportsHardwarePSVoltage, configL2IfaceSnifferIfIndex=configL2IfaceSnifferIfIndex, reportsL2IfaceStatsPkts1024to1518Octets=reportsL2IfaceStatsPkts1024to1518Octets, dm9225_E=dm9225_E, reportsHardwareTemperatureScale=reportsHardwareTemperatureScale)
