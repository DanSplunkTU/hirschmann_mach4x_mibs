#
# PySNMP MIB module ALCATEL-IND1-POLICY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nokia/aos7/ALCATEL-IND1-POLICY-MIB
# Produced by pysmi-1.1.8 at Tue Jan 11 21:37:30 2022
# On host fv-az74-997 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
softentIND1Policy, = mibBuilder.importSymbols("ALCATEL-IND1-BASE", "softentIND1Policy")
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Gauge32, TimeTicks, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Bits, ObjectIdentity, Unsigned32, NotificationType, Counter64, Counter32, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "TimeTicks", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Bits", "ObjectIdentity", "Unsigned32", "NotificationType", "Counter64", "Counter32", "Integer32", "iso")
RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "DisplayString")
alcatelIND1PolicyMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1))
alcatelIND1PolicyMIB.setRevisions(('2010-05-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: alcatelIND1PolicyMIB.setRevisionsDescriptions(('Fixed the Notifications to use MIB Module OID.0 as Notifications root.',))
if mibBuilder.loadTexts: alcatelIND1PolicyMIB.setLastUpdated('201005130000Z')
if mibBuilder.loadTexts: alcatelIND1PolicyMIB.setOrganization('Alcatel-Lucent')
if mibBuilder.loadTexts: alcatelIND1PolicyMIB.setContactInfo('Please consult with Customer Service to ensure the most appropriate\n             version of this document is used with the products in question:\n\n                        Alcatel-Lucent, Enterprise Solutions Division\n                       (Formerly Alcatel Internetworking, Incorporated)\n                               26801 West Agoura Road\n                            Agoura Hills, CA  91301-5122\n                              United States Of America\n\n            Telephone:               North America  +1 800 995 2696\n                                     Latin America  +1 877 919 9526\n                                     Europe         +31 23 556 0100\n                                     Asia           +65 394 7933\n                                     All Other      +1 818 878 4507\n\n            Electronic Mail:         support@ind.alcatel.com\n            World Wide Web:          http://alcatel-lucent.com/wps/portal/enterprise\n            File Transfer Protocol:  ftp://ftp.ind.alcatel.com/pub/products/mibs')
if mibBuilder.loadTexts: alcatelIND1PolicyMIB.setDescription('This module describes an authoritative enterprise-specific Simple\n             Network Management Protocol (SNMP) Management Information Base (MIB):\n\n                 For the Birds Of Prey Product Line\n                 Configuration and monitoring of policy manager parameters\n\n             The right to make changes in specification and other information\n             contained in this document without prior notice is reserved.\n\n             No liability shall be assumed for any incidental, indirect, special, or\n             consequential damages whatsoever arising from or related to this\n             document or the information contained herein.\n\n             Vendors, end-users, and other interested parties are granted\n             non-exclusive license to use this specification in connection with\n             management of the products for which it is intended to be used.\n\n                         Copyright (C) 1995-2007 Alcatel-Lucent\n                             ALL RIGHTS RESERVED WORLDWIDE')
alcatelIND1PolicyMIBNotifications = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 0))
if mibBuilder.loadTexts: alcatelIND1PolicyMIBNotifications.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1PolicyMIBNotifications.setDescription('Branch For POLICY MIB Subsystem Notifications.')
alcatelIND1PolicyMIBObjects = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1))
if mibBuilder.loadTexts: alcatelIND1PolicyMIBObjects.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1PolicyMIBObjects.setDescription('Branch for policy manager application objects')
alcatelIND1PolicyMIBConformance = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2))
if mibBuilder.loadTexts: alcatelIND1PolicyMIBConformance.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1PolicyMIBConformance.setDescription('Branch for policy manager application conformance information')
alcatelIND1PolicyMIBGroups = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1))
if mibBuilder.loadTexts: alcatelIND1PolicyMIBGroups.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1PolicyMIBGroups.setDescription('Branch for policy manager application units of conformance')
alcatelIND1PolicyMIBCompliances = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 2))
if mibBuilder.loadTexts: alcatelIND1PolicyMIBCompliances.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1PolicyMIBCompliances.setDescription('Branch for policy manager application compliance statements')
class PolicyEventCodes(TextualConvention, Integer32):
    description = 'The policyEventCodes TC describes all possible policy events\n             and should be used for NMS correlation.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58))
    namedValues = NamedValues(("pyEventInitLog", 1), ("pyEventLdapInit", 2), ("pyEventLdapSearch", 3), ("pyEventTooManyRequests", 4), ("pyEventServerStateChange", 5), ("pyEventLdapSyntaxSourceAddr", 6), ("pyEventLdapSyntaxDestAddr", 7), ("pyEventLdapSyntaxInDSByte", 8), ("pyEventLdapSyntaxRecDSByte", 9), ("pyEventLdapSyntaxPVPMonth", 10), ("pyEventLdapSyntaxPVPDoW", 11), ("pyEventLdapSyntaxPVPToD", 12), ("pyEventLdapSyntaxPVPTime", 13), ("pyEventLdapSyntaxSPort", 14), ("pyEventLdapSyntaxDPort", 15), ("pyEventLdapReferenceTP", 16), ("pyEventLdapReferencePVP", 17), ("pyEventInternalCodeError", 18), ("pyEventLdapSelectError", 19), ("pyEventLdapReferenceXYLAN", 20), ("pyEventDebugMemoryAlloc", 21), ("pyEventDebugMemoryFree", 22), ("pyEventPolicyCacheFlushed", 23), ("pyEventLdapServerDefined", 24), ("pyEventLdapSyntaxSourceMACAddr", 25), ("pyEventLdapSyntaxDestMACAddr", 26), ("pyEventLdapServerDeleted", 27), ("pyEventOptimizedPvpMonth", 28), ("pyEventOptimizedPvpDoW", 29), ("pyEventZeroPvpMonth", 30), ("pyEventZeroPvpDoW", 31), ("pyEventRuleScope", 32), ("pyEventRuleActivated", 33), ("pyEventRuleDeactivated", 34), ("pyEventLdapReferenceIPFilter", 35), ("pyEventLdapSyntaxTOSByte", 36), ("pyEventTimeChangeDetected", 37), ("pyEventPolicyWillNeverBeValid", 38), ("pyEventLdapSetOption", 39), ("pyEventLdapTLSChannelInit", 40), ("pyEventLdapTLSParametersOK", 41), ("pyEventMaxPolicyCountReached", 42), ("pyEventMemoryError", 43), ("pyEventMonitorSocketError", 44), ("pyEventDispositionError", 45), ("pyEventNameLengthError", 46), ("pyEventTableResize", 47), ("pyEvent48", 48), ("pyEvent49", 49), ("pyEvent50", 50), ("pyEvent51", 51), ("pyEvent52", 52), ("pyEvent53", 53), ("pyEvent54", 54), ("pyEvent55", 55), ("pyEvent56", 56), ("pyEvent57", 57), ("pyEventPolicyCacheLoaded", 58))

serverPolicyDecision = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("flushPolicies", 0), ("recachePolicies", 1), ("recacheQMMACGroup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serverPolicyDecision.setStatus('current')
if mibBuilder.loadTexts: serverPolicyDecision.setDescription("This object allows an NMS application to influence the policy\n      manager's treatment of existing policy decisions that were\n      established by the policy manager.  By setting recachePolicies,\n      an NMS can cause the policy manager to reload all its policies from the\n      current primary LDAP server. By setting flushPolicies, all the policies\n      are deleted by the policy manager.")
rsvpDefaultPolicy = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accept", 1), ("deny", 2))))
if mibBuilder.loadTexts: rsvpDefaultPolicy.setStatus('deprecated')
if mibBuilder.loadTexts: rsvpDefaultPolicy.setDescription('This object allows an NMS application to define the agent action\n      when there are no policy servers available to a switch.  When\n      this object is set to accept(1), the policy manager in the switch\n      will allow all RSVP control message requests.  When set to deny(2),\n      the policy manager will deny all RSVP control message requests.')
policyManagerEventTableSize = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyManagerEventTableSize.setStatus('current')
if mibBuilder.loadTexts: policyManagerEventTableSize.setDescription('This object defines the size of the policy manager event table.\n      When this object is set, the subagent adjusts the event table to\n      meet the size defined.')
directoryServerTable = MibTable((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4), )
if mibBuilder.loadTexts: directoryServerTable.setStatus('current')
if mibBuilder.loadTexts: directoryServerTable.setDescription('This table contains information related to the LDAP-based\n      directory server from the perspective of the policy manager.')
directoryServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-POLICY-MIB", "directoryServerAddress"), (0, "ALCATEL-IND1-POLICY-MIB", "directoryServerPort"))
if mibBuilder.loadTexts: directoryServerEntry.setStatus('current')
if mibBuilder.loadTexts: directoryServerEntry.setDescription('An entry in the directory server table.  Each entry\n      represents a directory server instance to the policy manager.')
directoryServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: directoryServerAddress.setStatus('current')
if mibBuilder.loadTexts: directoryServerAddress.setDescription('The IP Address of an LDAP server. The policy manager uses this\n          object combined with the directory server port number to uniquely\n          identify an LDAP server to use for directory queries and updates.')
directoryServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(389)).setMaxAccess("readonly")
if mibBuilder.loadTexts: directoryServerPort.setStatus('current')
if mibBuilder.loadTexts: directoryServerPort.setDescription('This object contains the TCP port number, which, along with the\n      directory server IP address, identifies the LDAP server.')
directoryServerPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerPreference.setStatus('current')
if mibBuilder.loadTexts: directoryServerPreference.setDescription('This object represents the relative preference of the server\n      entry. The higher the value of this object, the greater the\n      preference the policy manager places on using this server for\n      LDAP queries. This object is used when the policy manager uses\n      server selection based on the configured preference.')
directoryServerAuthenticationType = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("simplePassword", 1))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerAuthenticationType.setStatus('current')
if mibBuilder.loadTexts: directoryServerAuthenticationType.setDescription("The value of this object specifies what authentication\n      mechanism the LDAP server expects. For simplePassword(1),\n      the policy manager uses the directoryServerPassword object\n          for each LDAP query. kerberos and publicKey mechanisms are\n          currently unsupported. The none(0) value directs the policy\n          manager to use the 'anonymous' method for LDAP queries.")
directoryServerUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerUserId.setStatus('current')
if mibBuilder.loadTexts: directoryServerUserId.setDescription('This object only has significance when the\n      directoryServerAuthenticationType has a value of\n      simplePassword(1). This simple display string is used by the\n      policy manager in LDAP queries and updates.')
directoryServerPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerPassword.setStatus('current')
if mibBuilder.loadTexts: directoryServerPassword.setDescription('This object only has significance when the\n      directoryServerAuthenticationType has a value of\n      simplePassword(1). This simple display string is used by the\n      policy manager in LDAP queries and updates.')
directoryServerSearchbase = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 31)).clone('o=Alcatel IND, c=US')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerSearchbase.setStatus('current')
if mibBuilder.loadTexts: directoryServerSearchbase.setDescription('This object specifies the base object required for\n      LDAP search operations. This object represents, in\n      distinguished name format, the point where server\n      searches start. Generally, this object represents\n      the base object of the organization.')
directoryServerCacheChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("recachePolicy", 1))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerCacheChange.setStatus('current')
if mibBuilder.loadTexts: directoryServerCacheChange.setDescription("This object allows an NMS application to influence the policy\n      manager's cache of policy-related data when this server becomes\n      the primary LDAP server selected for the switch.  Setting this object\n      to recachePolicy(1) conveys to the policy manager that the\n      policy class object should be obtained from the LDAP server\n      represented by this table entry when this server becomes the\n      primary LDAP server.  By setting this object to 'none', the\n      policy manager will use the existing policy and policy rule\n      cache rather than reloading the policy data from this server.\n      In the case where there is no policy cache (for instance, when\n      the switch powers up) the policy manager will attempt to reload\n      the policy class cache even if this object is set to 'none'. ")
directoryServerLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: directoryServerLastChange.setStatus('current')
if mibBuilder.loadTexts: directoryServerLastChange.setDescription('This object contains the value of sysUpTime at the time of\n      the last creation, deletion or modification of an object in\n      this table entry.')
directoryServerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: directoryServerAdminStatus.setDescription("This object specifies the desired administrative state of\n      the directory server.  The up and down states control the\n      policy manager's decision to user the server for LDAP queries\n      and updates.")
directoryServerOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: directoryServerOperStatus.setStatus('current')
if mibBuilder.loadTexts: directoryServerOperStatus.setDescription('This object identifies the current operational state of the\n      LDAP server. Semantics of this object closely resemble the\n      ifOperStatus definition, however, the LDAP application layer\n      is NOT modeled as an interface as defined by RFC2233.')
directoryServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 12), RowStatus().clone('createAndGo')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: directoryServerRowStatus.setDescription('This object is used to create a new table entry or modify\n      or delete an existing table entry in this table.')
directoryServerEnableSSL = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableSSL", 0), ("enableSSL", 1))).clone('disableSSL')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: directoryServerEnableSSL.setStatus('current')
if mibBuilder.loadTexts: directoryServerEnableSSL.setDescription('This object enables or disables SSL for the LDAP server.')
policyEventTable = MibTable((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 5), )
if mibBuilder.loadTexts: policyEventTable.setStatus('current')
if mibBuilder.loadTexts: policyEventTable.setDescription('This table contains significant events related to the\n        operation of the policy manager. ')
policyEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 5, 1), ).setIndexNames((0, "ALCATEL-IND1-POLICY-MIB", "policyEventIndex"))
if mibBuilder.loadTexts: policyEventEntry.setStatus('current')
if mibBuilder.loadTexts: policyEventEntry.setDescription('An entry in the policy manager event table.')
policyEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyEventIndex.setStatus('current')
if mibBuilder.loadTexts: policyEventIndex.setDescription('This object uniquely identifies the event record.')
policyEventCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 5, 1, 2), PolicyEventCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyEventCode.setStatus('current')
if mibBuilder.loadTexts: policyEventCode.setDescription('This object identifies the event that occurred. The internal\n      protocol error and LDAP error events are rollup events that\n      represent a collection of events with similar characteristics.\n      The internal error event occurs due to software resource or\n      logic  problems; the LDAP error occurs because of LDAP init,\n      search, format, protocol or other similar errors.')
policyEventDetailString = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 5, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyEventDetailString.setStatus('current')
if mibBuilder.loadTexts: policyEventDetailString.setDescription('This object gives details about the event that took place.\n      Included in the string are (potentially) fields that provide\n      more specific fault location and isolation, context resolution,\n      and event (error) instance information.')
policyEventTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 5, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyEventTime.setStatus('current')
if mibBuilder.loadTexts: policyEventTime.setDescription('This object contains the value of sysUpTime at the time\n      the event occurred.')
policyRuleNamesTable = MibTable((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 6), )
if mibBuilder.loadTexts: policyRuleNamesTable.setStatus('current')
if mibBuilder.loadTexts: policyRuleNamesTable.setDescription('This table contains information that identifies the LDAP-based\n      policy rules defined on a directory server that are pushed by\n          the policy manager to the QoS&F manager for making policy decisions.')
policyRuleNamesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 6, 1), ).setIndexNames((0, "ALCATEL-IND1-POLICY-MIB", "policyRuleNamesIndex"))
if mibBuilder.loadTexts: policyRuleNamesEntry.setStatus('current')
if mibBuilder.loadTexts: policyRuleNamesEntry.setDescription('An entry in the policy rules table.  Each entry represents the\n      name of a policy rule on the directory server.  The policy manager\n      uses these names to build the correct policy rules.')
policyRuleNamesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyRuleNamesIndex.setStatus('current')
if mibBuilder.loadTexts: policyRuleNamesIndex.setDescription('This object is a unique index identifying the policyRuleNames entry.')
policyRuleNamesName = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 6, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyRuleNamesName.setStatus('current')
if mibBuilder.loadTexts: policyRuleNamesName.setDescription('This object defines the name of the policyRule that the policy manager\n      will use to build a switch policy. The name coincides with the directory\n      server class name equivalent.')
policyRuleNamesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 6, 1, 3), RowStatus().clone('active')).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyRuleNamesRowStatus.setStatus('current')
if mibBuilder.loadTexts: policyRuleNamesRowStatus.setDescription('Deprecated (to avoid proliferation of control planes) - rules\n        to be changed should be updated in LDAP and flushed/pushed to\n        switches accordingly.')
policyRuleOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("notReady", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyRuleOperStatus.setStatus('current')
if mibBuilder.loadTexts: policyRuleOperStatus.setDescription("This object is used to convey to an NMS the state of the policy.\n        A value of 'up' implies that the policy rule has been pushed to\n        the QoS / filtering manager (i.e. the PEP).  A value of 'down'\n        means the policy is invalid, so it was not pushed to the\n        QoS / filtering manager.  A value of 'notReady' means this\n        rule is valid, but not currently active (PVP not active, etc).")
policyStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7), )
if mibBuilder.loadTexts: policyStatsTable.setStatus('current')
if mibBuilder.loadTexts: policyStatsTable.setDescription('This table defines the objects maintained by the policy manager\n          representing statistics available on a per policy server instance.\n                The objects in this table correspond directly to the similarly named\n          objects in <draft-white-slapm-mib-00.txt>, except that the objects in\n          the draft are scalars. Note that the I-D is now RFC 2758, and experimental\n          category RFC.\n                There are semantic differences from RFC 2758 for some objects - the\n          differences are detailed in the DESCRIPTION clauses. Some objects\n          behave differently from the RFC because of our combined PDP/PEP\n          implementation. Note that RFC 2758 applies to hosts more than switches.')
policyStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7, 1), ).setIndexNames((0, "ALCATEL-IND1-POLICY-MIB", "policyStatsAddress"), (0, "ALCATEL-IND1-POLICY-MIB", "policyStatsServerPort"))
if mibBuilder.loadTexts: policyStatsEntry.setStatus('current')
if mibBuilder.loadTexts: policyStatsEntry.setDescription('An entry in the policy manager stats table.')
policyStatsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStatsAddress.setStatus('current')
if mibBuilder.loadTexts: policyStatsAddress.setDescription('IP address of the policy server related to these statistics')
policyStatsServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStatsServerPort.setStatus('current')
if mibBuilder.loadTexts: policyStatsServerPort.setDescription('TCP port number of the policy server related to these statistics')
policyStatsQueryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStatsQueryCount.setStatus('current')
if mibBuilder.loadTexts: policyStatsQueryCount.setDescription('The query count gives the total number of times a policy repository\n                was queried by the policy decision point. The policy repository is the LDAP\n                server where policies are stored.')
policyStatsAccessCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStatsAccessCount.setStatus('current')
if mibBuilder.loadTexts: policyStatsAccessCount.setDescription('Total number of times that a policy repository was\n        accessed with respect to a policy agent.  The policy decision\n        point (PDP)  in this implementation accesses the repository via\n        LDAP. The access count includes all operations required to\n        access the policy rules (including role evaluations and discrete\n        policy entry accesses.)\n\n        The value of this object will increment on repository access.')
policyStatsSuccessAccessCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStatsSuccessAccessCount.setStatus('current')
if mibBuilder.loadTexts: policyStatsSuccessAccessCount.setDescription("Total number of successful policy repository accesses.  This\n        value increments if a 'known' attribute has been discovered in\n        a repository search, regardless of its PDP processing status.\n        This object will increment less than policyStatsAccessCount\n        on most repository accesses, based on repository structure\n        and what roles match the policy decision point.")
policyStatsNotFoundCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStatsNotFoundCount.setStatus('current')
if mibBuilder.loadTexts: policyStatsNotFoundCount.setDescription('Total number of policy repository accesses that resulted\n        in an entry not being located. Not found counts increment on\n        protocol search failures and other attribute lookup problems.\n        Generally, policyStatsNotFoundCount increments only in\n        error cases.')
policyNotificationTable = MibTable((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 8), )
if mibBuilder.loadTexts: policyNotificationTable.setStatus('current')
if mibBuilder.loadTexts: policyNotificationTable.setDescription('This table contains an association between an event ID and the\n        notification method that the policy manager uses to convey to an\n        NMS that the event occurred. ')
policyNotificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 8, 1), ).setIndexNames((0, "ALCATEL-IND1-POLICY-MIB", "policyNotificationIndex"))
if mibBuilder.loadTexts: policyNotificationEntry.setStatus('current')
if mibBuilder.loadTexts: policyNotificationEntry.setDescription('An entry in the policy manager notification table.')
policyNotificationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 8, 1, 1), PolicyEventCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyNotificationIndex.setStatus('current')
if mibBuilder.loadTexts: policyNotificationIndex.setDescription('This object is a unique index identifying the policyNotification entry.\n      This index corresponds to the same value as the policyEvent.')
policyNotificationCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noNotification", 0), ("writeToLog", 1), ("sendTrap", 2), ("logAndTrap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyNotificationCode.setStatus('current')
if mibBuilder.loadTexts: policyNotificationCode.setDescription('This object defines the notification method used to convey information\n      about switch events to the NMS.  The notification code allows for\n      multiple notification methods, updated by an NMS by setting the\n      appropriate method corresponding to the event index.')
policyEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyEventCount.setStatus('current')
if mibBuilder.loadTexts: policyEventCount.setDescription('Total number of times that this event was recognized. This value\n       increments for each event occurance. No advertised management\n       facility exists to clear these history counters. This object is\n       intended to be a hint to management applications as to the past\n       operating history of a switch even if entries are no longer\n       present in the policyEventTable.')
policyManagerSwitchIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyManagerSwitchIdentifier.setStatus('current')
if mibBuilder.loadTexts: policyManagerSwitchIdentifier.setDescription('The value of this object type identifies the switch\n                 with a identifier that is unique through out the network\n                 This identifier is stored on the switch and the Directory\n                 Server for policies that are specific to this switch.\n                 If this variable is changed on the switch then the Directory\n                 Server also must be changed correspondingly.\n                 Changing the variable on the switch and not making the\n                 corresponding change on the Directory Server will render the\n                 policies defined for this switch unusable.The syntax of this\n                 variable is macAddress:Date:Time.\n                 Example: xx:xx:xx:xx:xx:xx:yyyymmdd:hhmmss ')
policyManagerTrapObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 10))
policyEventNotification = NotificationType((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 0, 1)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyTrapEventDetailString"), ("ALCATEL-IND1-POLICY-MIB", "policyTrapEventCode"))
if mibBuilder.loadTexts: policyEventNotification.setStatus('current')
if mibBuilder.loadTexts: policyEventNotification.setDescription('The policyEventNotification allows the switch to notify an NMS when\n        significant events happen. The NMS can then investigate and perform\n        appropriate control functions.  Other tables allow the NMS app to\n        zone in on the problem as part of a proactive monitoring system by the\n        NMS application. ')
policyTrapEventDetailString = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 10, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyTrapEventDetailString.setStatus('current')
if mibBuilder.loadTexts: policyTrapEventDetailString.setDescription('Details about the event that took place')
policyTrapEventCode = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 1, 10, 2), PolicyEventCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyTrapEventCode.setStatus('current')
if mibBuilder.loadTexts: policyTrapEventCode.setDescription('The code of the event')
alcatelIND1PolicyMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 2, 1)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyMIBGlobalGroup"), ("ALCATEL-IND1-POLICY-MIB", "policyMIBDirectoryServerGroup"), ("ALCATEL-IND1-POLICY-MIB", "policyMIBEventTableGroup"), ("ALCATEL-IND1-POLICY-MIB", "policyMIBRuleNamesGroup"), ("ALCATEL-IND1-POLICY-MIB", "policyMIBStatsGroup"), ("ALCATEL-IND1-POLICY-MIB", "policyMIBNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alcatelIND1PolicyMIBCompliance = alcatelIND1PolicyMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1PolicyMIBCompliance.setDescription('The policy manager compliance statement')
policyMIBGlobalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 1)).setObjects(("ALCATEL-IND1-POLICY-MIB", "serverPolicyDecision"), ("ALCATEL-IND1-POLICY-MIB", "policyManagerEventTableSize"), ("ALCATEL-IND1-POLICY-MIB", "policyManagerSwitchIdentifier"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBGlobalGroup = policyMIBGlobalGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBGlobalGroup.setDescription('A collection of objects providing information on global\n                policy manager state')
policyMIBDirectoryServerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 2)).setObjects(("ALCATEL-IND1-POLICY-MIB", "directoryServerAddress"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerPort"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerPreference"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerAuthenticationType"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerUserId"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerPassword"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerSearchbase"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerCacheChange"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerLastChange"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerAdminStatus"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerOperStatus"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerRowStatus"), ("ALCATEL-IND1-POLICY-MIB", "directoryServerEnableSSL"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBDirectoryServerGroup = policyMIBDirectoryServerGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBDirectoryServerGroup.setDescription('A collection of objects for managing LDAP directory\n                servers')
policyMIBEventTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 3)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyEventIndex"), ("ALCATEL-IND1-POLICY-MIB", "policyEventCode"), ("ALCATEL-IND1-POLICY-MIB", "policyEventDetailString"), ("ALCATEL-IND1-POLICY-MIB", "policyEventTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBEventTableGroup = policyMIBEventTableGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBEventTableGroup.setDescription('A collection of objects detailling the events that\n                occurred during policy manager operation')
policyMIBRuleNamesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 4)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyRuleNamesIndex"), ("ALCATEL-IND1-POLICY-MIB", "policyRuleNamesName"), ("ALCATEL-IND1-POLICY-MIB", "policyRuleNamesRowStatus"), ("ALCATEL-IND1-POLICY-MIB", "policyRuleOperStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBRuleNamesGroup = policyMIBRuleNamesGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBRuleNamesGroup.setDescription('A collection of object to know which policy rules have\n                been retrieved from a directory server')
policyMIBStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 5)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyStatsAddress"), ("ALCATEL-IND1-POLICY-MIB", "policyStatsServerPort"), ("ALCATEL-IND1-POLICY-MIB", "policyStatsAccessCount"), ("ALCATEL-IND1-POLICY-MIB", "policyStatsSuccessAccessCount"), ("ALCATEL-IND1-POLICY-MIB", "policyStatsNotFoundCount"), ("ALCATEL-IND1-POLICY-MIB", "policyStatsQueryCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBStatsGroup = policyMIBStatsGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBStatsGroup.setDescription('A collection of object to keep a trace of how directory\n                servers are accessed by the policy manager')
policyMIBNotificationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 6)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyNotificationIndex"), ("ALCATEL-IND1-POLICY-MIB", "policyNotificationCode"), ("ALCATEL-IND1-POLICY-MIB", "policyEventCount"), ("ALCATEL-IND1-POLICY-MIB", "policyTrapEventDetailString"), ("ALCATEL-IND1-POLICY-MIB", "policyTrapEventCode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBNotificationGroup = policyMIBNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBNotificationGroup.setDescription('A collection of object to configure what the policy manager\n                must do when specific events happen')
policyMIBTrapEventGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 7)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyTrapEventDetailString"), ("ALCATEL-IND1-POLICY-MIB", "policyTrapEventCode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBTrapEventGroup = policyMIBTrapEventGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBTrapEventGroup.setDescription('A collection of objects that appear in policy manager\n\t\tevent notifications.')
policyMIBTrapsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 2, 1, 14, 1, 2, 1, 8)).setObjects(("ALCATEL-IND1-POLICY-MIB", "policyEventNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyMIBTrapsGroup = policyMIBTrapsGroup.setStatus('current')
if mibBuilder.loadTexts: policyMIBTrapsGroup.setDescription('Collection of traps for management of Policy Manager')
mibBuilder.exportSymbols("ALCATEL-IND1-POLICY-MIB", policyRuleNamesTable=policyRuleNamesTable, policyNotificationTable=policyNotificationTable, policyTrapEventDetailString=policyTrapEventDetailString, policyMIBRuleNamesGroup=policyMIBRuleNamesGroup, alcatelIND1PolicyMIB=alcatelIND1PolicyMIB, policyEventCode=policyEventCode, policyStatsAddress=policyStatsAddress, policyRuleOperStatus=policyRuleOperStatus, alcatelIND1PolicyMIBGroups=alcatelIND1PolicyMIBGroups, policyEventNotification=policyEventNotification, alcatelIND1PolicyMIBNotifications=alcatelIND1PolicyMIBNotifications, policyManagerTrapObjs=policyManagerTrapObjs, policyEventIndex=policyEventIndex, policyRuleNamesName=policyRuleNamesName, policyMIBTrapsGroup=policyMIBTrapsGroup, directoryServerLastChange=directoryServerLastChange, policyEventTime=policyEventTime, policyEventTable=policyEventTable, policyManagerEventTableSize=policyManagerEventTableSize, serverPolicyDecision=serverPolicyDecision, rsvpDefaultPolicy=rsvpDefaultPolicy, policyRuleNamesIndex=policyRuleNamesIndex, policyStatsTable=policyStatsTable, policyNotificationEntry=policyNotificationEntry, directoryServerCacheChange=directoryServerCacheChange, directoryServerEntry=directoryServerEntry, directoryServerPassword=directoryServerPassword, policyMIBTrapEventGroup=policyMIBTrapEventGroup, policyStatsAccessCount=policyStatsAccessCount, alcatelIND1PolicyMIBCompliance=alcatelIND1PolicyMIBCompliance, directoryServerPort=directoryServerPort, alcatelIND1PolicyMIBCompliances=alcatelIND1PolicyMIBCompliances, PYSNMP_MODULE_ID=alcatelIND1PolicyMIB, directoryServerPreference=directoryServerPreference, directoryServerAddress=directoryServerAddress, alcatelIND1PolicyMIBObjects=alcatelIND1PolicyMIBObjects, policyStatsServerPort=policyStatsServerPort, policyStatsNotFoundCount=policyStatsNotFoundCount, policyStatsSuccessAccessCount=policyStatsSuccessAccessCount, policyEventEntry=policyEventEntry, directoryServerSearchbase=directoryServerSearchbase, policyMIBGlobalGroup=policyMIBGlobalGroup, policyTrapEventCode=policyTrapEventCode, directoryServerOperStatus=directoryServerOperStatus, directoryServerUserId=directoryServerUserId, directoryServerTable=directoryServerTable, directoryServerAuthenticationType=directoryServerAuthenticationType, alcatelIND1PolicyMIBConformance=alcatelIND1PolicyMIBConformance, directoryServerRowStatus=directoryServerRowStatus, policyMIBNotificationGroup=policyMIBNotificationGroup, policyMIBEventTableGroup=policyMIBEventTableGroup, policyNotificationIndex=policyNotificationIndex, policyMIBStatsGroup=policyMIBStatsGroup, policyRuleNamesRowStatus=policyRuleNamesRowStatus, PolicyEventCodes=PolicyEventCodes, policyStatsQueryCount=policyStatsQueryCount, policyEventCount=policyEventCount, policyMIBDirectoryServerGroup=policyMIBDirectoryServerGroup, policyNotificationCode=policyNotificationCode, policyManagerSwitchIdentifier=policyManagerSwitchIdentifier, policyStatsEntry=policyStatsEntry, directoryServerEnableSSL=directoryServerEnableSSL, policyRuleNamesEntry=policyRuleNamesEntry, directoryServerAdminStatus=directoryServerAdminStatus, policyEventDetailString=policyEventDetailString)
