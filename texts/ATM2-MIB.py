#
# PySNMP MIB module ATM2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/ATM2-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 16:24:53 2022
# On host fv-az126-328 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
atmVplVpi, atmVclEntry, atmVclVci, atmMIBObjects, atmInterfaceConfEntry, atmVplEntry, atmVcCrossConnectEntry, atmVclVpi, atmVpCrossConnectEntry = mibBuilder.importSymbols("ATM-MIB", "atmVplVpi", "atmVclEntry", "atmVclVci", "atmMIBObjects", "atmInterfaceConfEntry", "atmVplEntry", "atmVcCrossConnectEntry", "atmVclVpi", "atmVpCrossConnectEntry")
AtmVcIdentifier, AtmSigDescrParamIndex, AtmAddr, AtmVpIdentifier, AtmTrafficDescrParamIndex, AtmInterfaceType, AtmIlmiNetworkPrefix = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVcIdentifier", "AtmSigDescrParamIndex", "AtmAddr", "AtmVpIdentifier", "AtmTrafficDescrParamIndex", "AtmInterfaceType", "AtmIlmiNetworkPrefix")
ifIndex, InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero", "InterfaceIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
ObjectIdentity, iso, Gauge32, TimeTicks, Counter64, IpAddress, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Integer32, Bits, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "iso", "Gauge32", "TimeTicks", "Counter64", "IpAddress", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Integer32", "Bits", "Counter32")
DisplayString, TimeStamp, TextualConvention, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TimeStamp", "TextualConvention", "TruthValue", "RowStatus")
atm2MIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 37, 1, 14))
atm2MIB.setRevisions(('2003-09-23 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atm2MIB.setRevisionsDescriptions(('Initial version of this MIB, published as RFC 3606.',))
if mibBuilder.loadTexts: atm2MIB.setLastUpdated('200309230000Z')
if mibBuilder.loadTexts: atm2MIB.setOrganization('IETF AToMMIB Working Group')
if mibBuilder.loadTexts: atm2MIB.setContactInfo('AToMMIB WG\n             http://www.ietf.org/html.charters/atommib-charter.html\n           Editors:\n                    Faye Ly\n           Postal:  Pedestal Networks\n                    6503 Dumbarton Circle\n                    Fremont, CA 94555\n                    USA\n           Tel:     +1 510 896 2908\n           E-Mail:  faye@pedestalnetworks.com\n\n                    Michael Noto\n           Postal:  Cisco Systems\n                    170 W. Tasman Drive\n                    San Jose, CA 95134-1706\n                    USA\n\n           E-mail:  mnoto@cisco.com\n\n                    Andrew Smith\n           Postal:  Consultant\n\n           E-Mail:  ah_smith@acm.org\n\n                    Ethan Mickey Spiegel\n           Postal:  Cisco Systems\n                    170 W. Tasman Drive\n                    San Jose, CA 95134-1706\n                    USA\n           Tel:     +1 408 526 6408\n           Fax:     +1 408 526 6488\n           E-Mail:  mspiegel@cisco.com\n\n                    Kaj Tesink\n           Postal:  Telcordia Technologies\n                    331 Newman Springs Road\n\n                    Red Bank, NJ 07701\n                    USA\n           Tel:     +1 732 758 5254\n           E-mail:  kaj@research.telcordia.com')
if mibBuilder.loadTexts: atm2MIB.setDescription('Copyright (C) The Internet Society (2003). This version of\n         this MIB module is part of RFC 3606; see the RFC itself for\n         full legal notices.\n\n         This MIB Module is a supplement to the ATM-MIB\n         defined in RFC 2515.')
atm2MIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 1))
atm2MIBTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2))
atmSvcVpCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1), )
if mibBuilder.loadTexts: atmSvcVpCrossConnectTable.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectTable.setDescription('The ATM SVPC Cross-Connect table.  A\n         bi-directional VP cross-connect between two\n         switched VPLs is modeled as one entry in this\n         table.  A Soft PVPC cross-connect, between a\n         soft permanent VPL and a switched VPL, is\n         also modeled as one entry in this table.')
atmSvcVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1), ).setIndexNames((0, "ATM2-MIB", "atmSvcVpCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmSvcVpCrossConnectEntry.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectEntry.setDescription('An entry in the ATM SVPC Cross-Connect table.\n         This entry is used to model a bi-directional\n         ATM VP cross-connect between two VPLs.')
atmSvcVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmSvcVpCrossConnectIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectIndex.setDescription('A unique value to identify this SVPC\n         cross-connect.  For each VP associated\n         with this cross-connect, the agent reports\n         this cross-connect index value in the\n         atmVplCrossConnectIdentifer attribute of the\n\n         corresponding atmVplTable entries.')
atmSvcVpCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowIfIndex.setDescription('The value of this object is equal to the\n         ifIndex value of the ATM interface port for this\n         SVPC cross-connect.  The term low implies\n         that this ATM interface has the numerically lower\n         ifIndex value than the other ATM interface\n         identified in the same atmSvcVpCrossConnectEntry.')
atmSvcVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 3), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI\n         value associated with the SVPC cross-connect\n         at the ATM interface that is identified by\n         atmSvcVpCrossConnectLowIfIndex.  The VPI value\n         cannot exceed the number supported by the\n         atmInterfaceCurrentMaxSvpcVpi at the low ATM interface\n         port.')
atmSvcVpCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighIfIndex.setDescription('The value of this object is equal to the\n         ifIndex value of the ATM interface port for\n         this SVC VP cross-connect.  The term high\n         implies that this ATM interface has the\n         numerically higher ifIndex value than the\n         other ATM interface identified in the same\n         atmSvcVpCrossConnectEntry.')
atmSvcVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 5), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI\n         value associated with the SVPC cross-connect\n         at the ATM interface that is identified by\n         atmSvcVpCrossConnectHighIfIndex.  The VPI value\n         cannot exceed the number supported by the\n         atmInterfaceCurrentMaxSvpcVpi at the high ATM interface\n         port.')
atmSvcVpCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVpCrossConnectCreationTime.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectCreationTime.setDescription('The value of the sysUpTime object\n         at the time this bi-directional SVPC\n         cross-connect was created.  If the current\n         state was entered prior to the last\n         re-initialization of the agent, then this\n         object contains a zero value.')
atmSvcVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVpCrossConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectRowStatus.setDescription('This object is used to delete rows in the\n            atmSvcVpCrossConnectTable.')
atmSvcVcCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2), )
if mibBuilder.loadTexts: atmSvcVcCrossConnectTable.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectTable.setDescription('The ATM SVCC Cross-Connect table.  A\n         bi-directional VC cross-connect between two\n         switched VCLs is modeled as one entry in\n         this table.  A Soft PVCC cross-connect,\n         between a soft permanent VCL and a switched\n         VCL, is also modeled as one entry in this\n         table.')
atmSvcVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1), ).setIndexNames((0, "ATM2-MIB", "atmSvcVcCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVci"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmSvcVcCrossConnectEntry.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectEntry.setDescription('An entry in the ATM SVCC Cross-Connect table.\n         This entry is used to model a bi-directional ATM\n         VC cross-connect between two VCLs.')
atmSvcVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmSvcVcCrossConnectIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectIndex.setDescription('A unique value to identify this SVCC cross-connect.\n         For each VP associated with this cross-connect, the\n         agent reports this cross-connect index value in the\n         atmVclCrossConnectIdentifier attribute of the\n         corresponding atmVplTable entries.')
atmSvcVcCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowIfIndex.setDescription('The value of this object is equal to the\n         ifIndex value of the ATM interface port for this\n\n         SVCC cross-connect.  The term low implies that\n         this ATM interface has the numerically lower\n         ifIndex value than the other ATM interface\n         identified in the same atmSvcVcCrossConnectEntry.')
atmSvcVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 3), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI\n         value associated with the SVCC cross-connect\n         at the ATM interface that is identified by\n         atmSvcVcCrossConnectLowIfIndex.  The VPI value\n         cannot exceed the number supported by the\n         atmInterfaceCurrentMaxSvccVpi at the low ATM interface\n         port.')
atmSvcVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 4), AtmVcIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVci.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI\n         value associated with the SVCC cross-connect\n         at the ATM interface that is identified by\n         atmSvcVcCrossConnectLowIfIndex.  The VCI value\n         cannot exceed the number supported by the\n         atmInterfaceCurrentMaxSvccVci at the low ATM interface\n         port.')
atmSvcVcCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 5), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighIfIndex.setDescription('The value of this object is equal to the\n         ifIndex value for the ATM interface port for\n         this SVCC cross-connect.  The term high implies\n         that this ATM interface has the numerically\n         higher ifIndex value than the other ATM interface\n         identified in the same atmSvcVcCrossConnectEntry.')
atmSvcVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 6), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI\n         value associated with the SVCC cross-connect\n         at the ATM interface that is identified by\n         atmSvcVcCrossConnectHighIfIndex.  The VPI value\n         cannot exceed the number supported by the\n         atmInterfaceCurrentMaxSvccVpi at the high ATM interface\n         port.')
atmSvcVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 7), AtmVcIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVci.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI\n         value associated with the SVCC cross-connect\n         at the ATM interface that is identified by\n         atmSvcVcCrossConnectHighIfIndex.  The VCI value\n         cannot exceed the number supported by the\n         atmInterfaceMaxVciBits at the high ATM interface\n         port.')
atmSvcVcCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVcCrossConnectCreationTime.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectCreationTime.setDescription('The value of the sysUpTime object\n         at the time this bi-directional SVCC\n         cross-connect was created.  If the current\n         state was entered prior to the last\n         re-initialization of the agent, then this\n         object contains a zero value.')
atmSvcVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVcCrossConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectRowStatus.setDescription('This object is used to delete rows in the\n            atmSvcVcCrossConnectTable.')
atmSigStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3), )
if mibBuilder.loadTexts: atmSigStatTable.setStatus('current')
if mibBuilder.loadTexts: atmSigStatTable.setDescription('This table contains ATM interface signalling\n        statistics, one entry per ATM signalling\n        interface.')
atmSigStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmSigStatEntry.setDescription('This list contains signalling statistics variables.')
atmSigSSCOPConEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setReference('ITU-T Recommendation Q.2110, Broadband\n            Integrated Services Digital Network\n            (B-ISDN) - ATM Adaptation Layer - Service\n            Specific Connection Oriented Protocol (SSCOP)\n            Specification, July 1994.')
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setDescription('SSCOP Connection Events Counter.  This counter counts\n            the sum of the following errors:\n\n            1) SSCOP Connection Disconnect Counter\n\n                The abnormal occurrence of this event is\n                characterized by the expiry of Timer_NO_RESPONSE.\n                (This event is communicated to the layer management\n                with MAA-ERROR code P.  See ITU-T Q.2110.)\n\n             2) SSCOP Connection Initiation Failure\n\n                This condition indicates the inability to establish\n                an SSCOP connection.  This event occurs whenever the\n                number of expiries of the connection control timer\n                (Timer_CC) equals or exceeds the MaxCC, or upon\n                receipt of a connection reject message BGREJ PDU.\n                (This event is communicated to layer management with\n                MAA-ERROR code O.  See ITU-T Q.2110.)\n\n             3) SSCOP Connection Re-Establ/Resynch\n\n                This event occurs upon receipt of a BGN PDU or\n                RS PDU.')
atmSigSSCOPErrdPdus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setReference('ITU-T Recommendation Q.2110, Broadband\n            Integrated Services Digital Network\n            (B-ISDN) - ATM Adaptation Layer - Service\n            Specific Connection Oriented Protocol (SSCOP)\n            Specification, July 1994.')
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setStatus('current')
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setDescription('SSCOP Errored PDUs Counter.  This counter counts the\n           sum of the following errors:\n\n           1) Invalid PDUs.\n              These are defined in SSCOP and consist of PDUs\n              with an incorrect length (MAA-ERROR code U), an\n              undefined PDU type code, or that are not 32-bit\n              aligned.\n\n           2) PDUs that result in MAA-ERROR codes and are\n\n              discarded.\n\n           See MAA-ERROR codes A-D, F-M, and Q-T defined in\n           ITU-T Q.2110.')
atmSigDetectSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectSetupAttempts.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectSetupAttempts.setDescription('Call Setup Attempts Counter.  This counter counts\n           the number of call setup attempts (both successful\n           and unsuccessful) detected on this interface.')
atmSigEmitSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitSetupAttempts.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitSetupAttempts.setDescription('Call Setup Attempts Counter.  This counter counts\n           the number of call setup attempts (both successful\n           and unsuccessful) transmitted on this interface.')
atmSigDetectUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailRoutes.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectUnavailRoutes.setDescription('Number of Route Unavailability detected on this interface.\n           This counter is incremented when a RELEASE, RELEASE COMPLETE\n           (only when not preceded by a RELEASE message for the same\n           call), ADD PARTY REJECT, or STATUS message that\n           contains one of the following cause code values is\n           received (Note: These cause values\n           apply to both UNI3.0 and UNI3.1):\n\n           Cause Value            Meaning\n\n              1            unallocated (unassigned) number\n              2            no route to specified transit network\n              3            no route to destination\n\n           NOTE:  For this counter, RELEASE COMPLETE\n           messages that are a reply to a previous RELEASE\n           message and contain the same cause value, are\n           redundant (for counting purposes) and should not\n           be counted.')
atmSigEmitUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailRoutes.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitUnavailRoutes.setDescription('Number of Route Unavailability transmitted from this\n           interface.  This counter is incremented when a RELEASE,\n           RELEASE COMPLETE (only when not preceded by a RELEASE\n           message for the same call), ADD PARTY REJECT, or\n           STATUS message that contains one of the following cause\n           code values is transmitted (Note: These cause values apply\n           to both UNI3.0 and UNI3.1):\n\n           Cause Value            Meaning\n\n              1            unallocated (unassigned) number\n              2            no route to specified transit network\n              3            no route to destination\n\n           NOTE:  For this counter, RELEASE COMPLETE\n           messages that are a reply to a previous RELEASE\n           message and contain the same cause value, are\n           redundant (for counting purposes) and should not\n           be counted.')
atmSigDetectUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailResrcs.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectUnavailResrcs.setDescription('Number of Resource Unavailability detected on this\n           interface.  This counter is incremented when a RELEASE,\n           RELEASE COMPLETE (only when not preceded by a RELEASE\n           message for the same call), ADD PARTY REJECT, or\n           STATUS message that contains one of the following\n\n           cause code values is received (Note: These cause\n           values apply to both UNI3.0 and UNI3.1 unless\n           otherwise stated):\n\n           Cause Value          Meaning\n\n              35          requested VPCI/VCI not available\n              37          user cell rate not available (UNI3.1\n                          only)\n              38          network out of order\n              41          temporary failure\n              45          no VPCI/VCI available\n              47          resource unavailable, unspecified\n              49          Quality of Service unavailable\n              51          user cell rate not available (UNI3.0\n                          only)\n              58          bearer capability not presently\n                          available\n              63          Service or option not available,\n                          unspecified\n              92          too many pending add party requests\n\n           NOTE:  For this counter, RELEASE COMPLETE\n           messages that are a reply to a previous RELEASE\n           message and contain the same cause value, are\n           redundant (for counting purposes) and should not\n           be counted.')
atmSigEmitUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailResrcs.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitUnavailResrcs.setDescription('Number of Resource Unavailability transmitted from this\n          interface.  This counter is incremented when a RELEASE,\n          RELEASE COMPLETE (only when not preceded by a RELEASE message\n          for the same call), ADD PARTY REJECT, or STATUS message that\n          contains one of the following cause code values is transmitted\n          (Note: These cause values apply to both UNI3.0 and UNI3.1\n          unless otherwise stated):\n\n          Cause Value          Meaning\n\n             35          requested VPCI/VCI not available\n             37          user cell rate not available (UNI3.1\n                         only)\n             38          network out of order\n\n             41          temporary failure\n             45          no VPCI/VCI available\n             47          resource unavailable, unspecified\n             49          Quality of Service unavailable\n             51          user cell rate not available (UNI3.0\n                         only)\n             58          bearer capability not presently\n                         available\n             63          Service or option not available,\n                         unspecified\n             92          too many pending add party requests\n\n          NOTE:  For this counter, RELEASE COMPLETE messages that are a\n          reply to a previous RELEASE message and contain the same cause\n          value, are redundant (for counting purposes) and should not be\n          counted.')
atmSigDetectCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectCldPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call\n         detected on this interface.  This counter is incremented when a\n         RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE\n         message for the same call), ADD PARTY REJECT, or STATUS message\n         that contains one of the following cause code values is\n         received (Note: These cause values apply to both UNI3.0 and\n         UNI3.1):\n\n         Cause Value         Meaning\n\n            17           user busy\n            18           no user responding\n            21           call rejected\n            22           number changed\n            23           user rejects all calls with calling\n                         line identification restriction (CLIR)\n            27           destination out of order\n            31           normal, unspecified\n            88           incompatible destination\n\n         NOTE:  For this counter, RELEASE COMPLETE messages that are a\n         reply to a previous RELEASE message and contain the same cause\n         value, are redundant (for counting purposes) and should not be\n\n         counted.\n\n         Note: Cause Value #30 'response to STATUS ENQUIRY' was not\n         included in this memo since it did not apply to a hard\n         failure.")
atmSigEmitCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitCldPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call\n        transmitted from this interface.  This counter is incremented\n        when a RELEASE, RELEASE COMPLETE (only when not preceded by a\n        RELEASE message for the same call), ADD PARTY REJECT, or STATUS\n        message that contains one of the following cause code values is\n        transmitted (Note: These cause values apply to both UNI3.0 and\n        UNI3.1):\n\n        Cause Value         Meaning\n\n           17           user busy\n           18           no user responding\n           21           call rejected\n           22           number changed\n           23           user rejects all calls with calling\n                        line identification restriction (CLIR)\n           27           destination out of order\n           31           normal, unspecified\n           88           incompatible destination\n\n        NOTE:  For this counter, RELEASE COMPLETE messages that are a\n        reply to a previous RELEASE message and contain the same cause\n        value, are redundant (for counting purposes) and should not be\n        counted.\n\n        Note: Cause Value #30 'response to STATUS ENQUIRY' was not\n        included in this memo since it did not apply to a hard failure.")
atmSigDetectMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectMsgErrors.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectMsgErrors.setDescription("Number of Incorrect Messages detected on this interface.  The\n       Incorrect Messages Counter reflects any sort of incorrect\n       information in a message.  This includes:\n\n       - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT,\n         and STATUS messages transmitted, that contain any of\n         the Cause values listed below.\n\n       - Ignored messages.  These messages are dropped\n         because the message was so damaged that it could\n         not be further processed.  A list of dropped\n         messages is compiled below:\n\n          1.  Message with invalid protocol discriminator\n\n          2.  Message with errors in the call reference I.E.\n               - Bits 5-8 of the first octet not equal to\n                 '0000'\n               - Bits 1-4 of the first octet indicating a\n                 length other than 3 octets\n               - RELEASE COMPLETE message received with a\n                 call reference that does not relate to a\n                 call active or in progress\n               - SETUP message received with call reference\n                 flag incorrectly set to 1\n               - SETUP message received with a call\n                 reference for a call that is already\n                 active or in progress.\n\n          3.  Message too short\n\n       The following cause values are monitored by this counter (Note:\n       These cause values apply to both UNI3.0 and UNI3.1 unless\n       otherwise stated):\n\n       Cause Value     Meaning\n\n          10     VPCI/VCI unacceptable (UNI3.0 only)\n          36     VPCI/VCI assignment failure (UNI3.1 only)\n          81     invalid call reference value\n          82     identified channel does not exist\n          89     invalid endpoint reference\n          96     mandatory information element is missing\n          97     message type non-existent or not\n                 implemented\n          99     information element non-existent or not\n                 implemented\n\n          100    invalid information element contents\n          101    message not compatible with call state\n          104    incorrect message length\n          111    protocol error, unspecified\n\n          NOTE:  For this counter, RELEASE COMPLETE messages that are\n          a reply to a previous RELEASE message and contain the same\n          cause value, are redundant (for counting purposes) and\n          should not be counted.")
atmSigEmitMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitMsgErrors.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitMsgErrors.setDescription("Number of Incorrect Messages transmitted on this interface.\n       The Incorrect Messages Counter reflects any sort of incorrect\n       information in a message.  This includes:\n\n       - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT,\n         and STATUS messages transmitted or\n         received, that contain any of the Cause values\n         listed below.\n\n       - Ignored messages.  These messages are dropped\n         because the message was so damaged that it could\n         not be further processed.  A list of dropped\n         messages is compiled below:\n\n          1.  Message with invalid protocol discriminator\n\n          2.  Message with errors in the call reference I.E.\n               - Bits 5-8 of the first octet not equal to\n                 '0000'\n               - Bits 1-4 of the first octet indicating a\n                 length other than 3 octets\n               - RELEASE COMPLETE message received with a\n                 call reference that does not relate to a\n                 call active or in progress\n               - SETUP message received with call reference\n                 flag incorrectly set to 1\n               - SETUP message received with a call\n                 reference for a call that is already\n                 active or in progress.\n\n          3.  Message too short\n\n       The following cause values are monitored by this counter\n       (Note: These cause values apply to both UNI3.0 and UNI3.1\n       unless otherwise stated):\n\n       Cause Value     Meaning\n\n          10     VPCI/VCI unacceptable (UNI3.0 only)\n          36     VPCI/VCI assignment failure (UNI3.1 only)\n          81     invalid call reference value\n          82     identified channel does not exist\n          89     invalid endpoint reference\n          96     mandatory information element is missing\n          97     message type non-existent or not\n                 implemented\n          99     information element non-existent or not\n                 implemented\n          100    invalid information element contents\n          101    message not compatible with call state\n          104    incorrect message length\n          111    protocol error, unspecified\n\n          NOTE:  For this counter, RELEASE COMPLETE messages that are\n          a reply to a previous RELEASE message and contain the same\n          cause value, are redundant (for counting purposes) and\n          should not be counted.")
atmSigDetectClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectClgPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectClgPtyEvents.setDescription('Number of Calling Party Events detected on this interface.\n       This counter monitors error events that occur due to the\n       originating user doing something wrong.  This counter is\n       incremented when a RELEASE, RELEASE COMPLETE (only when not\n       preceded by a RELEASE message for the same call), ADD PARTY\n       REJECT, or STATUS message that contains one of the following\n       cause code values is received (Note: These cause values\n       apply to both UNI3.0 and UNI3.1):\n\n       Cause Value     Meaning\n\n          28     invalid number format (address incomplete)\n          43     access information discarded\n          57     bearer capability not authorized\n          65     bearer capability not implemented\n\n          73     unsupported combination of traffic\n                 parameters\n          78     AAL parameters cannot be supported (UNI3.1\n                 only)\n          91     invalid transit network selection\n          93     AAL parameters cannot be supported (UNI3.0\n                 only)\n\n          NOTE:  For this counter, RELEASE COMPLETE messages that\n          are a reply to a previous RELEASE message and contain\n          the same cause value, are redundant (for counting purposes)\n          and should not be counted.')
atmSigEmitClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitClgPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitClgPtyEvents.setDescription('Number of Calling Party Events transmitted from this interface.\n       This counter monitors error events that occur due to the\n       originating user doing something wrong.  This counter is\n       incremented when a RELEASE, RELEASE COMPLETE (only when not\n       preceded by a RELEASE message for the same call), ADD PARTY\n       REJECT, or STATUS message that contains one of the following\n       cause code values is transmitted (Note: These cause values\n       apply to both UNI3.0 and UNI3.1):\n\n       Cause Value     Meaning\n\n          28     invalid number format (address incomplete)\n          43     access information discarded\n          57     bearer capability not authorized\n          65     bearer capability not implemented\n          73     unsupported combination of traffic\n                 parameters\n          78     AAL parameters cannot be supported (UNI3.1\n                 only)\n          91     invalid transit network selection\n          93     AAL parameters cannot be supported (UNI3.0\n                 only)\n\n          NOTE:  For this counter, RELEASE COMPLETE messages that are\n          a reply to a previous RELEASE message and contain the same\n          cause value, are redundant (for counting purposes) and\n          should not be counted.')
atmSigDetectTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectTimerExpireds.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectTimerExpireds.setDescription("Number of Timer Expiries detected on this interface.  The Timer\n       Expiries Counter provides a count of network timer expiries, and\n       to some extent, host or switch timer expiries.  The conditions\n       for incrementing this counter are:\n\n          - Expiry of any network timer\n\n          - Receipt of a RELEASE or RELEASE COMPLETE\n            message with Cause #102, 'recovery on\n            timer expiry'.\n\n          NOTE:  For this counter, RELEASE COMPLETE messages that are\n          a reply to a previous RELEASE message and contain the same\n          cause value, are redundant (for counting purposes) and\n          should not be counted.")
atmSigEmitTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitTimerExpireds.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitTimerExpireds.setDescription("Number of Timer Expiries transmitted from this interface.\n       The Timer Expiries Counter provides a count of network timer\n       expiries, and to some extent, host or switch timer expiries.\n       The conditions for incrementing this counter are:\n\n          - Expiry of any network timer\n\n          - Receipt of a RELEASE or RELEASE COMPLETE\n            message with Cause #102, 'recovery on\n            timer expiry'.\n\n       NOTE:  For this counter, RELEASE COMPLETE messages that are a\n       reply to a previous RELEASE message and contain the same cause\n       value, are redundant (for counting purposes) and should not be\n       counted.")
atmSigDetectRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectRestarts.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectRestarts.setDescription('Number of Restart Activity errors detected on this interface.\n       The Restart Activity Counter provides a count of host, switch,\n       or network restart activity.  This counter is incremented when\n       receiving a RESTART message.')
atmSigEmitRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitRestarts.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitRestarts.setDescription('Number of Restart Activity errors transmitted from this\n       interface.  The Restart Activity Counter provides a count of\n       host, switch, or network restart activity.  This counter is\n       incremented when transmitting a RESTART message.')
atmSigInEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigInEstabls.setStatus('current')
if mibBuilder.loadTexts: atmSigInEstabls.setDescription('Number of SVCs established at this signalling entity for\n       incoming connections.')
atmSigOutEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigOutEstabls.setStatus('current')
if mibBuilder.loadTexts: atmSigOutEstabls.setDescription('Number of SVCs established at this signalling entity for\n       outgoing connections.')
atmSigSupportTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4), )
if mibBuilder.loadTexts: atmSigSupportTable.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportTable.setDescription('This table contains ATM local interface configuration\n       parameters, one entry per ATM signalling interface.')
atmSigSupportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigSupportEntry.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportEntry.setDescription('This list contains signalling configuration parameters\n       and state variables.')
atmSigSupportClgPtyNumDel = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtyNumDel.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportClgPtyNumDel.setDescription('This object indicates whether the Calling Party Number\n       Information Element is transferred to the called party\n       address.  The value of this object can be:\n\n         - enabled(1)  This Information Element is transferred\n                       to the called party\n\n         - disabled(2) This Information Element is NOT\n                       transferred to the called party.')
atmSigSupportClgPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtySubAddr.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportClgPtySubAddr.setDescription("This object indicates whether to accept and transfer the Calling\n       Party Subaddress Information Element from the calling party to\n       the called party.  Calling party subaddress information shall\n       only be transferred to the called party if calling party number\n       delivery is enabled (i.e., atmSigSupportClgPtyNumDel =\n       'enabled(1)'.  The value of this object can be:\n\n         - enabled(1)  This Information Element is transferred\n                       to the called party\n\n         - disabled(2) This Information Element is NOT\n                       transferred to the called party.")
atmSigSupportCldPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportCldPtySubAddr.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportCldPtySubAddr.setDescription('This object indicates whether to accept, transfer, and deliver\n       the Called Party Subaddress Information Element from the calling\n       party to the called party.  The value of this object can be:\n\n         - enabled(1)  This Information Element is transferred\n                       to the called party\n\n         - disabled(2) This Information Element is NOT\n                       transferred to the called party.')
atmSigSupportHiLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportHiLyrInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportHiLyrInfo.setDescription('This object indicates whether to accept, transfer, and deliver\n       the Broadband High Layer Information Element from the calling\n       party to the called party.  The value of this object can be:\n\n         - enabled(1)  This Information Element is transferred\n                       to the called party\n\n         - disabled(2) This Information Element is NOT\n                       transferred to the called party.')
atmSigSupportLoLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportLoLyrInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportLoLyrInfo.setDescription('This object indicates whether to accept, transfer, and deliver\n       the Broadband Low Layer Information Element from the calling\n       party to the called party.  The value of this object can be:\n\n         - enabled(1)  This Information Element is transferred\n                       to the called party\n\n         - disabled(2) This Information Element is NOT\n                       transferred to the called party.')
atmSigSupportBlliRepeatInd = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportBlliRepeatInd.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportBlliRepeatInd.setDescription("This object indicates whether to accept, transfer, and deliver\n        the Broadband Repeat Indicator with two or three instances of\n        the Broadband Low Layer Information Element for low layer\n        information selection from the calling party to the called\n        party.  This object's value should always be disabled(2) if\n        the value of atmSigSupportLolyrInfo is disabled(2).\n\n        The value of this object can be:\n\n        - enabled(1)  This Information Element is transferred\n              to the called party\n\n        - disabled(2) This Information Element is NOT\n              transferred to the called party.")
atmSigSupportAALInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportAALInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportAALInfo.setDescription('This object indicates whether to accept, transfer, and deliver\n       the ATM Adaptation Layer Parameters Information Element from the\n       calling party to the called party.  The value of this object can\n       be:\n\n         - enabled(1)  This Information Element is transferred\n                       to the called party\n\n         - disabled(2) This Information Element is NOT\n                       transferred to the called party.')
atmSigSupportPrefCarrier = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 8), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportPrefCarrier.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportPrefCarrier.setDescription("This parameter identifies the carrier to which intercarrier\n       calls originated from this interface are routed when transit\n       network selection information is not provided by the calling\n       party.  If a Carrier Identification Code (CIC) is used the\n       parameter shall contain the CIC.  For three-digit CICs, the first\n       octet shall be '0' and the CIC is contained in the three\n       following octets.  If the preferred carrier feature is not\n       supported the value is a zero-length string.")
atmSigDescrParamTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5), )
if mibBuilder.loadTexts: atmSigDescrParamTable.setReference('ATM User-Network Interface Specification, Version 3.1 (UNI\n            3.1), September 1994, Section 5.4.5 Variable Length\n            Information Elements.')
if mibBuilder.loadTexts: atmSigDescrParamTable.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamTable.setDescription('A table contains signalling capabilities of VCLs except the\n            Traffic Descriptor.  Traffic descriptors are described in\n            the atmTrafficDescrParamTable.')
atmSigDescrParamEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1), ).setIndexNames((0, "ATM2-MIB", "atmSigDescrParamIndex"))
if mibBuilder.loadTexts: atmSigDescrParamEntry.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamEntry.setDescription('Each entry in this table represents a\n            set of signalling capabilities that can\n            be applied to a VCL.  There is no requirement\n            for unique entries, except that the index must\n            be unique.')
atmSigDescrParamIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 1), AtmSigDescrParamIndex())
if mibBuilder.loadTexts: atmSigDescrParamIndex.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamIndex.setDescription('The value of this object is used by the\n            atmVclGenSigDescrIndex object in the atmVclGenTable to\n            identify a row in this table.')
atmSigDescrParamAalType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("aal1", 2), ("aal34", 3), ("aal5", 4), ("userDefined", 5), ("aal2", 6))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalType.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamAalType.setDescription('The AAL type.  The value of this object is set to other(1)\n            when not defined.')
atmSigDescrParamAalSscsType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("assured", 2), ("nonassured", 3), ("frameRelay", 4), ("null", 5))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalSscsType.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamAalSscsType.setDescription('The SSCS type used by this entry.')
atmSigDescrParamBhliType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("iso", 2), ("user", 3), ("hiProfile", 4), ("vendorSpecific", 5))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliType.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBhliType.setDescription('The Broadband high layer type.')
atmSigDescrParamBhliInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBhliInfo.setDescription('The Broadband high layer information.  When\n            atmSigDescrParamBhliType is set to iso(2), the value of this\n            object is a zero length string.  When\n            atmSigDescrParamBhliType is set to user(3), the value of\n            this object is an octet string with length ranging from 0 to\n            8.  When atmSigDescrParamBhliType is set to hiProfile(4),\n            the value of this object is a length of 4 octet string\n            containing user to user profile identifier.  When\n            atmSigDescrParamBhliType is set to vendorSpecific(5), the\n            value of this object is a length of 7 octet string, where\n            the most significant 3 octets consist of a globally-\n            administered OUI, and the least significant 4 octets are the\n            vender administered application OUI.')
atmSigDescrParamBbcConnConf = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ptp", 1), ("ptmp", 2))).clone('ptp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBbcConnConf.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBbcConnConf.setDescription('The Broadband bearer capability user plane connection\n              configuration parameter.')
atmSigDescrParamBlliLayer2 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("iso1745", 2), ("q921", 3), ("x25linklayer", 4), ("x25multilink", 5), ("lapb", 6), ("hdlcArm", 7), ("hdlcNrm", 8), ("hdlcAbm", 9), ("iso88022", 10), ("x75slp", 11), ("q922", 12), ("userDef", 13), ("iso7776", 14))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer2.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer2.setDescription('The Broadband low layer information, protocol type of layer\n            2.  The value of this object is other(1) if layer 2 protocol\n            is not used.')
atmSigDescrParamBlliLayer3 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("x25pkt", 2), ("isoiec8208", 3), ("x223iso8878", 4), ("isoiec8473", 5), ("t70", 6), ("tr9577", 7), ("userDef", 8))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer3.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer3.setDescription('The Broadband low layer information, protocol type of layer\n\n            3.  The value of this object is other(1) if layer 3 protocol\n            is not used.')
atmSigDescrParamBlliPktSize = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("s16", 2), ("s32", 3), ("s64", 4), ("s128", 5), ("s256", 6), ("s512", 7), ("s1024", 8), ("s2048", 9), ("s4096", 10))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliPktSize.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliPktSize.setDescription('The default packet size defined in B-LLI.')
atmSigDescrParamBlliSnapId = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliSnapId.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliSnapId.setDescription('The SNAP ID used for Broadband low layer protocol layer 3.\n            The value of this object is other(1) if\n            atmSigDescrParamBlliLayer3 is set to other(1).')
atmSigDescrParamBlliOuiPid = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 11), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(5, 5), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliOuiPid.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliOuiPid.setDescription('The OUI/PID encoding for Broadband low layer protocol layer\n            3.  The value of this object is a zero length string if\n            atmSigDescrParamBlliLayer3 is set to other(1).  When used,\n            it is always 5 octets with the most significant octet as the\n            OUI Octet 1 and the least significant octet as the PID Octet\n            2.')
atmSigDescrParamRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamRowStatus.setDescription('This object is used to create and delete rows in the\n            atmSigDescrParamTable.')
atmIfRegisteredAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6), )
if mibBuilder.loadTexts: atmIfRegisteredAddrTable.setStatus('current')
if mibBuilder.loadTexts: atmIfRegisteredAddrTable.setDescription('This table contains a list of ATM addresses that can be used for\n       calls to and from a given interface by a switch or service.  The\n       ATM addresses are either registered by the endsystem via ILMI or\n       statically configured.  This table does not expose PNNI\n       reachability information.  ILMI registered addresses cannot be\n       deleted using this table.  This table only applies to switches\n       and network services.')
atmIfRegisteredAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIfRegAddrAddress"))
if mibBuilder.loadTexts: atmIfRegisteredAddrEntry.setStatus('current')
if mibBuilder.loadTexts: atmIfRegisteredAddrEntry.setDescription('An entry in the ATM Interface Registered Address table.')
atmIfRegAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmIfRegAddrAddress.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrAddress.setDescription('An address registered for a given switch or service interface.')
atmIfRegAddrAddressSource = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("dynamic", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRegAddrAddressSource.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrAddressSource.setDescription('The type of address source for a given ATM Address. The value\n       dynamic(3) is indicated when ILMI is used.')
atmIfRegAddrOrgScope = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("localNetwork", 1), ("localNetworkPlusOne", 2), ("localNetworkPlusTwo", 3), ("siteMinusOne", 4), ("intraSite", 5), ("sitePlusOne", 6), ("organizationMinusOne", 7), ("intraOrganization", 8), ("organizationPlusOne", 9), ("communityMinusOne", 10), ("intraCommunity", 11), ("communityPlusOne", 12), ("regional", 13), ("interRegional", 14), ("global", 15)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrOrgScope.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrOrgScope.setDescription('This object indicates the organizational scope for\n        the referenced address.  The information of the\n        referenced address shall not be distributed outside\n        the indicated scope.   Refer to Annex 5.3 of ATM\n        Forum UNI Signalling 4.0 for guidelines regarding\n        the use of organizational scopes.\n\n        This value cannot be configured for ILMI-registered\n        addresses.\n\n        The default values for organizational scope are\n        localNetwork(1) for ATM group addresses, and\n        global(15) for individual addresses.')
atmIfRegAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrRowStatus.setDescription('This object is used to create and delete rows in the\n       atmIfRegisteredAddrTable.  Rows created dynamically (e.g., ILMI-\n       registered addresses) cannot be deleted using this object.')
atmVclAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7), )
if mibBuilder.loadTexts: atmVclAddrTable.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrTable.setDescription('This table provides a mapping between the atmVclTable and\n            the ATM called party/calling party address.  This table can\n            be used to retrieve the calling party and called party ATM\n            address pair for a given VCL.  Note that there can be more\n            than one pair of calling party and called party ATM\n            addresses for a VCL in a point to multi-point call.')
atmVclAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM2-MIB", "atmVclAddrAddr"))
if mibBuilder.loadTexts: atmVclAddrEntry.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrEntry.setDescription('Each entry in this table represents a binding between a VCL\n            and an ATM address associated with this call.  This ATM\n\n            address can be either the called party address or the\n            calling party address.  There can be more than one pair of\n            calling/called party ATM addresses associated with the VCL\n            entry for point to multi-point calls.  Objects\n            atmVclAddrType, and atmVclAddrRowStatus are\n            required during row creation.')
atmVclAddrAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmVclAddrAddr.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrAddr.setDescription('An ATM address on one end of the VCL.  For SVCs, the agent\n            supplies the value of this object at creation time.  For PVC\n            VCL, the manager can supply the value of this object during\n            or after the PVC VCL creation.')
atmVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrType.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrType.setDescription('The type of ATM Address represented by the object\n            atmVclAddrAddr.  Choices are either the calling party ATM\n            address or the called party ATM address.')
atmVclAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrRowStatus.setDescription('This object is used to create or destroy an\n           entry from this table.  Note that the manager entity\n\n           can only destroy the PVC VCLs.')
atmAddrVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8), )
if mibBuilder.loadTexts: atmAddrVclTable.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclTable.setDescription('This table provides an alternative way to retrieve the\n            atmVclTable.  This table can be used to retrieve the\n            indexing to the atmVclTable by an ATM address.')
atmAddrVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1), ).setIndexNames((0, "ATM2-MIB", "atmVclAddrAddr"), (0, "ATM2-MIB", "atmAddrVclAtmIfIndex"), (0, "ATM2-MIB", "atmAddrVclVpi"), (0, "ATM2-MIB", "atmAddrVclVci"))
if mibBuilder.loadTexts: atmAddrVclEntry.setReference('Tesink, K., Editor, Definitions of Managed Objects\n             for ATM Management, RFC 2515, Bell Communications\n             Research, February, 1999.')
if mibBuilder.loadTexts: atmAddrVclEntry.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclEntry.setDescription('Each entry in this table represents an entry in the\n            atmVclTable of the ATM-MIB by its ATM address.  The ATM\n            address is either the calling or called party ATM address\n            of the call.  Entries in this table are read only.\n            They show up when entries are created in the\n            atmVclAddrTable.')
atmAddrVclAtmIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: atmAddrVclAtmIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclAtmIfIndex.setDescription('The interface index of the ATM interface to which this\n             VCL pertains.  This object combined with the\n             atmAddrVclVpi and atmAddrVclVci objects serves as an\n             index to the atmVclTable.')
atmAddrVclVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 2), AtmVpIdentifier())
if mibBuilder.loadTexts: atmAddrVclVpi.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclVpi.setDescription('The VPI value of the VCL.  This object combined with the\n            atmAddrVclAtmIfIndex and atmAddrVclVci objects serves as\n            an index to the atmVclTable.')
atmAddrVclVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 3), AtmVcIdentifier())
if mibBuilder.loadTexts: atmAddrVclVci.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclVci.setDescription('The VCI value of the VCL.  This object combined with the\n            atmAddrVclAtmIfIndex and atmAddrVclVpi objects serves as\n            an index to the atmVclTable.')
atmAddrVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAddrVclAddrType.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclAddrType.setDescription('The type of ATM Address represented by the object\n            atmVclAddrAddr.  Choices are either calling party address\n            or called party address.')
atmVplStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9), )
if mibBuilder.loadTexts: atmVplStatTable.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTable.setDescription('This table contains all statistics counters per VPL.  It is\n            used to monitor the usage of the VPL in terms of incoming\n            cells and outgoing cells.')
atmVplStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmVplStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmVplStatEntry.setDescription('Each entry in this table represents a VPL.')
atmVplStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellIns.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTotalCellIns.setDescription('The total number of valid ATM cells received by this VPL\n            including both CLP=0 and CLP=1 cells.  The cells are\n            counted prior to the application of the traffic policing.')
atmVplStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellIns.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0CellIns.setDescription('The number of valid ATM cells received by this VPL with\n            CLP=0.  The cells are counted prior to the application of\n            the traffic policing.')
atmVplStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTotalDiscards.setDescription('The total number of valid ATM cells discarded by the\n            traffic policing entity.  This includes cells originally\n            received with CLP=0 and CLP=1.')
atmVplStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0 and\n            discarded by the traffic policing entity.')
atmVplStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTotalCellOuts.setDescription('The total number of valid ATM cells transmitted  by this\n            VPL.  This includes both CLP=0 and CLP=1 cells.')
atmVplStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0\n            by this VPL.')
atmVplStatClp0Tagged = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0Tagged.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0Tagged.setDescription('The total number of valid ATM cells tagged by the traffic\n            policing entity from CLP=0 to CLP=1.')
atmVplLogicalPortTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10), )
if mibBuilder.loadTexts: atmVplLogicalPortTable.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortTable.setDescription('Indicates whether the VPL is an ATM Logical Port interface\n            (ifType=80).')
atmVplLogicalPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1), )
atmVplEntry.registerAugmentions(("ATM2-MIB", "atmVplLogicalPortEntry"))
atmVplLogicalPortEntry.setIndexNames(*atmVplEntry.getIndexNames())
if mibBuilder.loadTexts: atmVplLogicalPortEntry.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortEntry.setDescription('An entry with information about the ATM Logical Port\n            interface.')
atmVplLogicalPortDef = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notLogicalIf", 1), ("isLogicalIf", 2))).clone('notLogicalIf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplLogicalPortDef.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortDef.setDescription('Indicates whether the VPC at this VPL interface is an ATM\n            Logical Port interface.')
atmVplLogicalPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplLogicalPortIndex.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortIndex.setDescription('The ifTable index of the ATM logical port interface\n            associated with this VPL. The distinguished value of zero\n            indicates that the agent has not (yet) assigned such an\n            ifTable Index. The zero value must be assigned by the agent\n            if the value of atmVplLogicalPortDef is set to notLogicalIf,\n            or if the VPL row is not active.')
atmVclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11), )
if mibBuilder.loadTexts: atmVclStatTable.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTable.setDescription('This table contains all statistics counters per VCL.  It is\n            used to monitor the usage of the VCL in terms of incoming\n            cells and outgoing cells.')
atmVclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmVclStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmVclStatEntry.setDescription('Each entry in this table represents a VCL.')
atmVclStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellIns.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTotalCellIns.setDescription('The total number of valid ATM cells received by this VCL\n            including both CLP=0 and CLP=1 cells.  The cells are counted\n            prior to the application of the traffic policing.')
atmVclStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellIns.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0CellIns.setDescription('The number of valid ATM cells received by this VCL with\n            CLP=0.  The cells are counted prior to the application of\n            the traffic policing.')
atmVclStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTotalDiscards.setDescription('The total number of valid ATM cells discarded by the\n            traffic policing entity.  This includes cells originally\n            received with CLP=0 and CLP=1.')
atmVclStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0\n             and discarded by the traffic policing entity.')
atmVclStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTotalCellOuts.setDescription('The total number of valid ATM cells transmitted  by this\n            VCL.  This includes both CLP=0 and CLP=1 cells.')
atmVclStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0\n            by this VCL.')
atmVclStatClp0Tagged = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0Tagged.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0Tagged.setDescription('The total number of valid ATM cells tagged by the traffic\n            policing entity from CLP=0 to CLP=1.')
atmAal5VclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12), )
if mibBuilder.loadTexts: atmAal5VclStatTable.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclStatTable.setDescription('This table provides a collection of objects providing AAL5\n            configuration and performance statistics of a VCL.')
atmAal5VclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmAal5VclStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclStatEntry.setDescription('Each entry in this table represents an AAL5 VCL, and\n             is indexed by ifIndex values of AAL5 interfaces and\n             the associated VPI/VCI values.')
atmAal5VclInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInPkts.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclInPkts.setDescription('The number of AAL5 CPCS PDUs received on the AAL5 VCC at\n            the interface identified by the ifIndex.')
atmAal5VclOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutPkts.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclOutPkts.setDescription('The number of AAL5 CPCS PDUs transmitted on the AAL5 VCC\n             at the interface identified by the ifIndex.')
atmAal5VclInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInOctets.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclInOctets.setDescription('The number of octets contained in AAL5 CPCS PDUs received\n            on the AAL5 VCC at the interface identified by the ifIndex.')
atmAal5VclOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutOctets.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclOutOctets.setDescription('The number of octets contained in AAL5 CPCS PDUs\n            transmitted on the AAL5 VCC at the interface identified by\n            the ifIndex.')
atmVclGenTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13), )
if mibBuilder.loadTexts: atmVclGenTable.setStatus('current')
if mibBuilder.loadTexts: atmVclGenTable.setDescription('General Information for each VC.')
atmVclGenEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1), )
atmVclEntry.registerAugmentions(("ATM2-MIB", "atmVclGenEntry"))
atmVclGenEntry.setIndexNames(*atmVclEntry.getIndexNames())
if mibBuilder.loadTexts: atmVclGenEntry.setStatus('current')
if mibBuilder.loadTexts: atmVclGenEntry.setDescription('An entry with general information about the ATM VC.')
atmVclGenSigDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1, 1), AtmSigDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclGenSigDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmVclGenSigDescrIndex.setDescription('The value of this object identifies the row in the ATM\n            Signalling Descriptor Parameter Table which applies to this\n            VCL.')
atmInterfaceExtTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14), )
if mibBuilder.loadTexts: atmInterfaceExtTable.setReference('Tesink, K., Editor, Definitions of Managed Objects\n         for ATM Management, RFC 2515, Bell Communications\n         Research, February, 1999.')
if mibBuilder.loadTexts: atmInterfaceExtTable.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceExtTable.setDescription('This table contains ATM interface configuration and monitoring\n       information not defined in the atmInterfaceConfTable from the\n       ATM-MIB.  This includes the type of connection setup procedures,\n       ILMI information, and information on the VPI/VCI range.')
atmInterfaceExtEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1), )
if mibBuilder.loadTexts: atmInterfaceExtEntry.setReference('Tesink, K., Editor, Definitions of Managed Objects\n         for ATM Management, RFC 2515, Bell Communications\n         Research, February, 1999.')
atmInterfaceConfEntry.registerAugmentions(("ATM2-MIB", "atmInterfaceExtEntry"))
atmInterfaceExtEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: atmInterfaceExtEntry.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceExtEntry.setDescription('An entry extends the atmInterfaceConfEntry defined in the ATM-\n       MIB.  Each entry corresponds to an ATM interface.')
atmIntfConfigType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 1), AtmInterfaceType().clone('autoConfig')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigType.setStatus('current')
if mibBuilder.loadTexts: atmIntfConfigType.setDescription("The type of connection setup procedures configured for the ATM\n       interface.  Setting this variable to a value of 'other' is not\n       allowed.")
atmIntfActualType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 2), AtmInterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualType.setStatus('current')
if mibBuilder.loadTexts: atmIntfActualType.setDescription("The type of connection setup procedures currently being used on\n       the interface.  This may reflect a manually configured value for\n       the interface type, or may be determined by other means such as\n       auto-configuration.  A value of `autoConfig' indicates that\n       auto-configuration was requested but has not yet been completed.")
atmIntfConfigSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigSide.setStatus('current')
if mibBuilder.loadTexts: atmIntfConfigSide.setDescription("The configured role of the managed entity as one side of the ATM\n       interface.  This value does not apply when the object\n       atmIntfConfigType is set to `autoConfig', `atmfPnni1Dot0', or\n       `atmfBici2Dot0'.")
atmIntfActualSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3), ("symmetric", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualSide.setStatus('current')
if mibBuilder.loadTexts: atmIntfActualSide.setDescription('The current role used by the managed entity to represent one\n       side of the ATM interface.')
atmIntfIlmiAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 5), Bits().clone(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiAdminStatus.setDescription("Indicates which components of ILMI are administratively enabled\n       on this interface.  If the 'ilmi' bit is not set, then no ILMI\n       components are operational.  ILMI components other than auto-\n       configuration that are not represented in the value have their\n       administrative status determined according to the 'ilmi' bit.\n       The ILMI auto-configuration component is enabled/disabled by the\n       atmIntfConfigType object.")
atmIntfIlmiOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 6), Bits().clone(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiOperStatus.setDescription('Indicates which components of ILMI are operational on this\n       interface.')
atmIntfIlmiFsmState = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("stopped", 1), ("linkFailing", 2), ("establishing", 3), ("configuring", 4), ("retrievingNetworkPrefixes", 5), ("registeringNetworkPrefixes", 6), ("retrievingAddresses", 7), ("registeringAddresses", 8), ("verifying", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setReference('ATM Forum, Integrated Local Management Interface\n             (ILMI) Specification, Version 4.0, af-ilmi-0065.000,\n             September 1996, Appendix 1')
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setDescription('Indicates the state of the ILMI Finite State Machine associated\n       with this interface.')
atmIntfIlmiEstablishConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setReference('ATM Forum, Integrated Local Management Interface\n        (ILMI) Specification, Version 4.0, af-ilmi-0065.000,\n        September 1996, Section 8.3.1')
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setDescription('The amount of time S between successive transmissions of ILMI\n       messages on this interface for the purpose of detecting\n       establishment of ILMI connectivity.')
atmIntfIlmiCheckConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setReference('ATM Forum, Integrated Local Management Interface\n        (ILMI) Specification, Version 4.0, af-ilmi-0065.000,\n        September 1996, Section 8.3.1')
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setDescription('The amount of time T between successive transmissions of ILMI\n       messages on this interface for the purpose of detecting loss of\n       ILMI connectivity.  The distinguished value zero disables ILMI\n       connectivity procedures on this interface.')
atmIntfIlmiConPollInactFactor = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setReference('ATM Forum, Integrated Local Management Interface\n        (ILMI) Specification, Version 4.0, af-ilmi-0065.000,\n        September 1996, Section 8.3.1')
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setDescription('The number K of consecutive polls on this interface for which no\n       ILMI response message is received before ILMI connectivity is\n       declared lost.')
atmIntfIlmiPublicPrivateIndctr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("public", 2), ("private", 3))).clone('private')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiPublicPrivateIndctr.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiPublicPrivateIndctr.setDescription("Specifies whether this end of the interface is advertised in\n       ILMI as a device of the `public' or `private' type.")
atmInterfaceConfMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvpcVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface\n       is configured to support for allocation to switched virtual path\n       connections.')
atmInterfaceCurrentMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvpcVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvpcVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface\n       may currently allocate to switched virtual path connections.\n       This value is the minimum of atmInterfaceConfMaxSvpcVpi, and the\n       atmInterfaceMaxSvpcVpi of the interface's UNI/NNI peer.\n\n       If the interface does not negotiate with its peer to determine\n       the maximum VPI that can be allocated to SVPCs on the interface,\n       then the value of this object must equal\n       atmInterfaceConfMaxSvpcVpi. ")
atmInterfaceConfMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvccVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface\n       is configured to support for allocation to switched virtual\n       channel connections.')
atmInterfaceCurrentMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvccVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvccVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface\n       may currently allocate to switched virtual channel connections.\n       This value is the minimum of atmInterfaceConfMaxSvccVpi, and the\n       atmInterfaceConfMaxSvccVpi of the interface's UNI/NNI peer.\n\n       If the interface does not negotiate with its peer to determine\n       the maximum VPI that can be allocated to SVCCs on the interface,\n       then the value of this object must equal\n       atmInterfaceConfMaxSvccVpi.")
atmInterfaceConfMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMinSvccVci.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfMinSvccVci.setDescription('The minimum VCI that the signalling stack on the ATM interface\n       is configured to support for allocation to switched virtual\n       channel connections.')
atmInterfaceCurrentMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMinSvccVci.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceCurrentMinSvccVci.setDescription("The minimum VCI that the signalling stack on the ATM interface\n       may currently allocate to switched virtual channel connections.\n       This value is the maximum of atmInterfaceConfMinSvccVci, and the\n       atmInterfaceConfMinSvccVci of the interface's UNI/NNI peer.\n       If the interface does not negotiate with its peer to determine\n       the minimum VCI that can be allocated to SVCCs on the interface,\n       then the value of this object must equal\n       atmInterfaceConfMinSvccVci.")
atmIntfSigVccRxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 18), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccRxTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmIntfSigVccRxTrafficDescrIndex.setDescription('This object identifies the row in the atmTrafficDescrParamTable\n       used during ILMI auto-configuration to specify the advertised\n       signalling VCC traffic parameters for the receive direction.\n       The traffic descriptor resulting from ILMI auto-configuration of\n       the signalling VCC is indicated in the atmVclTable.')
atmIntfSigVccTxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 19), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccTxTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmIntfSigVccTxTrafficDescrIndex.setDescription('This object identifies the row in the atmTrafficDescrParamTable\n       used during ILMI auto-configuration to specify the advertised\n       signalling VCC traffic parameters for the transmit direction.\n       The traffic descriptor resulting from ILMI auto-configuration of\n       the signalling VCC is indicated in the atmVclTable.')
atmIntfPvcFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfPvcFailures.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcFailures.setDescription('The number of times the operational status of a PVPL or PVCL on\n       this interface has gone down.')
atmIntfCurrentlyFailingPVpls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVpls.setStatus('current')
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVpls.setDescription("The current number of VPLs on this interface for which there is\n       an active row in the atmVplTable having an atmVplConnKind value\n       of `pvc' and an atmVplOperStatus with a value other than `up'.")
atmIntfCurrentlyFailingPVcls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVcls.setStatus('current')
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVcls.setDescription("The current number of VCLs on this interface for which there is\n       an active row in the atmVclTable having an atmVclConnKind value\n       of `pvc' and an atmVclOperStatus with a value other than `up'.")
atmIntfPvcFailuresTrapEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 23), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcFailuresTrapEnable.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcFailuresTrapEnable.setDescription('Allows the generation of traps in response to PVCL or PVPL\n       failures on this interface.')
atmIntfPvcNotificationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcNotificationInterval.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcNotificationInterval.setDescription('The minimum interval between the sending of\n       atmIntfPvcFailuresTrap notifications for this interface.')
atmIntfLeafSetupFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfLeafSetupFailures.setStatus('current')
if mibBuilder.loadTexts: atmIntfLeafSetupFailures.setDescription('Number of setup failures.  For root, this is the number of\n       rejected setup requests and for leaf, this is the number of setup\n       failure received.')
atmIntfLeafSetupRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfLeafSetupRequests.setStatus('current')
if mibBuilder.loadTexts: atmIntfLeafSetupRequests.setDescription('Number of setup requests.  For root, this includes both incoming\n       setup request and root intiated setup requests.')
atmIlmiSrvcRegTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15), )
if mibBuilder.loadTexts: atmIlmiSrvcRegTable.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegTable.setDescription('This table contains a list of all the ATM network services known\n       by this device.\n\n       The characteristics of these services are made available through\n       the ILMI, using the ILMI general-purpose service registry MIB.\n       These services may be made available to all ATM interfaces\n       (atmIlmiSrvcRegIndex = 0) or to some specific ATM interfaces only\n       (atmIlmiSrvcRegIndex = ATM interface index).')
atmIlmiSrvcRegEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1), ).setIndexNames((0, "ATM2-MIB", "atmIlmiSrvcRegIndex"), (0, "ATM2-MIB", "atmIlmiSrvcRegServiceID"), (0, "ATM2-MIB", "atmIlmiSrvcRegAddressIndex"))
if mibBuilder.loadTexts: atmIlmiSrvcRegEntry.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegEntry.setDescription('Information about a single service provider that is available to\n       the user-side of an adjacent device through the ILMI.\n\n       Implementors need to be aware that if the size of the\n       atmIlmiSrvcRegServiceID exceeds 112 sub-identifiers then OIDs of\n\n       column instances in this table will have more than 128 sub-\n       identifiers and cannot be accessed using SNMPv1, SNMPv2, or\n       SNMPv3.')
atmIlmiSrvcRegIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: atmIlmiSrvcRegIndex.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegIndex.setDescription('The ATM interface where the service defined in this entry can be\n       made available to an ATM device attached to this interface.\n\n       The value of 0 has a special meaning: when an ATM service is\n       defined in an entry whose atmIlmiSrvcRegIndex is zero, the ATM\n       service is available to ATM devices connected to any ATM\n       interface.  (default value(s)).\n\n       When the user-side of an adjacent device queries the content of\n       the ILMI service registry MIB (using the ILMI protocol), the\n       local network-side responds with the ATM services defined in\n       atmIlmiSrvcRegTable entries, provided that these entries are\n       indexed by:\n\n       - the corresponding ifIndex value (atmIlmiSrvcRegIndex\n         equal to the ifIndex of the interface to which the\n         adjacent device is connected) - zero (atmIlmiSrvcRegIndex=0).')
atmIlmiSrvcRegServiceID = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 2), ObjectIdentifier())
if mibBuilder.loadTexts: atmIlmiSrvcRegServiceID.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegServiceID.setDescription('This is the service identifier which uniquely identifies the\n\n       type of service at the address provided in the table.  The object\n       identifiers for the LAN Emulation Configuration Server (LECS) and\n       the ATM Name Server (ANS) are defined in the ATM Forum ILMI\n       Service Registry MIB.  The object identifiers for the ATMARP\n       Server, the Multicast Address Resolution Server (MARS), and the\n       NHRP Server (NHS) are defined in RFC 2601, RFC 2602, and RFC\n       2603, respectively.')
atmIlmiSrvcRegAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmIlmiSrvcRegAddressIndex.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegAddressIndex.setDescription('An arbitrary integer to differentiate multiple rows containing\n       different ATM addresses for the same service on the same\n       interface.  This number need NOT be the same as the corresponding\n       ILMI atmfSrvcRegAddressIndex MIB object.')
atmIlmiSrvcRegATMAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 4), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegATMAddress.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegATMAddress.setDescription('This is the full address of the service.  The user-side of the\n       adjacent device may use this address to establish a connection\n       with the service.')
atmIlmiSrvcRegParm1 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegParm1.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegParm1.setDescription('An octet string used according to the value of\n       atmIlmiSrvcRegServiceID.')
atmIlmiSrvcRegRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegRowStatus.setDescription('This object is used to create or destroy an entry from this\n       table.')
atmIlmiNetworkPrefixTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16), )
if mibBuilder.loadTexts: atmIlmiNetworkPrefixTable.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetworkPrefixTable.setDescription('A table specifying per-interface network prefix(es) supplied by\n       the network side of the UNI during ILMI address registration.\n       When no network prefixes are specified for a particular\n       interface, one or more network prefixes based on the switch\n       address(es) may be used for ILMI address registration.')
atmIlmiNetworkPrefixEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIlmiNetPrefixPrefix"))
if mibBuilder.loadTexts: atmIlmiNetworkPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetworkPrefixEntry.setDescription('Information about a single network prefix supplied by the\n       network side of the UNI during ILMI address registration.  Note\n       that the index variable atmIlmiNetPrefixPrefix is a variable-\n       length string, and as such the rule for variable-length strings\n       in section 7.7 of RFC 2578 applies.')
atmIlmiNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 1), AtmIlmiNetworkPrefix())
if mibBuilder.loadTexts: atmIlmiNetPrefixPrefix.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetPrefixPrefix.setDescription('The network prefix specified for use in ILMI address\n       registration.')
atmIlmiNetPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiNetPrefixRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetPrefixRowStatus.setDescription('Used to create, delete, activate and de-activate network\n       prefixes used in ILMI address registration.')
atmSwitchAddressTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17), )
if mibBuilder.loadTexts: atmSwitchAddressTable.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressTable.setDescription('This table contains one or more ATM endsystem addresses on a\n       per-switch basis.  These addresses are used to identify the\n       switch.  When no ILMI network prefixes are configured for certain\n       interfaces, network prefixes based on the switch address(es) may\n       be used for ILMI address registration.')
atmSwitchAddressEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1), ).setIndexNames((0, "ATM2-MIB", "atmSwitchAddressIndex"))
if mibBuilder.loadTexts: atmSwitchAddressEntry.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressEntry.setDescription('An entry in the ATM Switch Address table.')
atmSwitchAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: atmSwitchAddressIndex.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressIndex.setDescription('An arbitrary index used to enumerate the ATM endsystem addresses\n       for this switch.')
atmSwitchAddressAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(13, 13), ValueSizeConstraint(20, 20), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressAddress.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressAddress.setDescription('An ATM endsystem address or address prefix used to identify this\n       switch.  When no ESI or SEL field is specified, the switch may\n       generate the ESI and SEL fields automatically to obtain a\n       complete 20-byte ATM endsystem address.')
atmSwitchAddressRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressRowStatus.setDescription('Used to create, delete, activate, and de-activate addresses used\n       to identify this switch.')
atmVpCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18), )
if mibBuilder.loadTexts: atmVpCrossConnectXTable.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectXTable.setDescription('This table contains one row per VP Cross-Connect represented in\n       the atmVpCrossConnectTable.')
atmVpCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1), )
atmVpCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVpCrossConnectXEntry"))
atmVpCrossConnectXEntry.setIndexNames(*atmVpCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVpCrossConnectXEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectXEntry.setDescription('Information about a particular ATM VP Cross-Connect.\n       Each entry provides an two objects that name the Cross-Connect.\n       One is assigned by the Service User and the other by the Service\n       Provider.')
atmVpCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectUserName.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectUserName.setDescription('This is a service user assigned textual representation of a VPC\n       PVC.')
atmVpCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectProviderName.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectProviderName.setDescription('This is a system supplied textual representation of VPC PVC.  It\n       is assigned by the service provider.')
atmVcCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19), )
if mibBuilder.loadTexts: atmVcCrossConnectXTable.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectXTable.setDescription('This table contains one row per VC Cross-Connect represented in\n       the atmVcCrossConnectTable.')
atmVcCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1), )
atmVcCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVcCrossConnectXEntry"))
atmVcCrossConnectXEntry.setIndexNames(*atmVcCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVcCrossConnectXEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectXEntry.setDescription('Information about a particular ATM VC Cross-Connect.\n       Each entry provides an two objects that name the Cross-Connect.\n       One is assigned by the Service User and the other by the Service\n       Provider.')
atmVcCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectUserName.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectUserName.setDescription('This is a service user assigned textual representation of a VCC\n\n       PVC.')
atmVcCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectProviderName.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectProviderName.setDescription('This is a system supplied textual representation of VCC PVC.  It\n       is assigned by the service provider.')
atmCurrentlyFailingPVplTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20), )
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTable.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTable.setDescription("A table indicating all VPLs for which there is an active row in\n       the atmVplTable having an atmVplConnKind value of `pvc' and an\n       atmVplOperStatus with a value other than `up'.")
atmCurrentlyFailingPVplEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVplEntry.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVplEntry.setDescription("Each entry in this table represents a VPL for which the\n       atmVplRowStatus is `active', the atmVplConnKind is `pvc', and the\n       atmVplOperStatus is other than `up'.")
atmCurrentlyFailingPVplTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTimeStamp.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTimeStamp.setDescription('The time at which this PVPL began to fail.')
atmCurrentlyFailingPVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21), )
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTable.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTable.setDescription("A table indicating all VCLs for which there is an active row in\n       the atmVclTable having an atmVclConnKind value of `pvc' and an\n       atmVclOperStatus with a value other than `up'.")
atmCurrentlyFailingPVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVclEntry.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVclEntry.setDescription("Each entry in this table represents a VCL for which the\n       atmVclRowStatus is `active', the atmVclConnKind is `pvc', and the\n       atmVclOperStatus is other than `up'.")
atmCurrentlyFailingPVclTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTimeStamp.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTimeStamp.setDescription('The time at which this PVCL began to fail.')
atmPvcTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1))
atmPvcTrapsPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0))
atmIntfPvcFailuresTrap = NotificationType((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("ATM2-MIB", "atmIntfPvcFailures"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"))
if mibBuilder.loadTexts: atmIntfPvcFailuresTrap.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcFailuresTrap.setDescription('A notification indicating that one or more PVPLs or PVCLs on\n       this interface has failed since the last atmPvcFailuresTrap was\n       sent.  If this trap has not been sent for the last\n       atmIntfPvcNotificationInterval, then it will be sent on the next\n       increment of atmIntfPvcFailures.')
atm2MIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3))
atm2MIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1))
atm2MIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2))
atm2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2, 1)).setObjects(("ATM2-MIB", "atmCommonGroup"), ("ATM2-MIB", "atmCommonStatsGroup"), ("ATM2-MIB", "atmSwitchServcGroup"), ("ATM2-MIB", "atmSwitchServcSigGroup"), ("ATM2-MIB", "atmSwitchServcNotifGroup"), ("ATM2-MIB", "atmSwitchGroup"), ("ATM2-MIB", "atmServcGroup"), ("ATM2-MIB", "atmHostGroup"), ("ATM2-MIB", "atmHostSigDescrGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atm2MIBCompliance = atm2MIBCompliance.setStatus('current')
if mibBuilder.loadTexts: atm2MIBCompliance.setDescription('The compliance statement for SNMP entities which represent ATM\n         interfaces.  The compliance statements are used to determine\n         if a particular group or object applies to hosts,\n         networks/switches, or both.  The Common group is defined as\n         applicable to all three.')
atmCommonGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 1)).setObjects(("ATM2-MIB", "atmSigSSCOPConEvents"), ("ATM2-MIB", "atmSigSSCOPErrdPdus"), ("ATM2-MIB", "atmSigDetectSetupAttempts"), ("ATM2-MIB", "atmSigEmitSetupAttempts"), ("ATM2-MIB", "atmSigDetectUnavailRoutes"), ("ATM2-MIB", "atmSigEmitUnavailRoutes"), ("ATM2-MIB", "atmSigDetectUnavailResrcs"), ("ATM2-MIB", "atmSigEmitUnavailResrcs"), ("ATM2-MIB", "atmSigDetectCldPtyEvents"), ("ATM2-MIB", "atmSigEmitCldPtyEvents"), ("ATM2-MIB", "atmSigDetectMsgErrors"), ("ATM2-MIB", "atmSigEmitMsgErrors"), ("ATM2-MIB", "atmSigDetectClgPtyEvents"), ("ATM2-MIB", "atmSigEmitClgPtyEvents"), ("ATM2-MIB", "atmSigDetectTimerExpireds"), ("ATM2-MIB", "atmSigEmitTimerExpireds"), ("ATM2-MIB", "atmSigDetectRestarts"), ("ATM2-MIB", "atmSigEmitRestarts"), ("ATM2-MIB", "atmSigInEstabls"), ("ATM2-MIB", "atmSigOutEstabls"), ("ATM2-MIB", "atmVplLogicalPortDef"), ("ATM2-MIB", "atmVplLogicalPortIndex"), ("ATM2-MIB", "atmInterfaceConfMaxSvpcVpi"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvpcVpi"), ("ATM2-MIB", "atmInterfaceConfMaxSvccVpi"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvccVpi"), ("ATM2-MIB", "atmInterfaceConfMinSvccVci"), ("ATM2-MIB", "atmInterfaceCurrentMinSvccVci"), ("ATM2-MIB", "atmIntfSigVccRxTrafficDescrIndex"), ("ATM2-MIB", "atmIntfSigVccTxTrafficDescrIndex"), ("ATM2-MIB", "atmIntfPvcFailures"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"), ("ATM2-MIB", "atmIntfPvcNotificationInterval"), ("ATM2-MIB", "atmIntfPvcFailuresTrapEnable"), ("ATM2-MIB", "atmIntfLeafSetupFailures"), ("ATM2-MIB", "atmIntfLeafSetupRequests"), ("ATM2-MIB", "atmIntfConfigType"), ("ATM2-MIB", "atmIntfActualType"), ("ATM2-MIB", "atmIntfConfigSide"), ("ATM2-MIB", "atmIntfActualSide"), ("ATM2-MIB", "atmIntfIlmiAdminStatus"), ("ATM2-MIB", "atmIntfIlmiOperStatus"), ("ATM2-MIB", "atmIntfIlmiFsmState"), ("ATM2-MIB", "atmIntfIlmiEstablishConPollIntvl"), ("ATM2-MIB", "atmIntfIlmiCheckConPollIntvl"), ("ATM2-MIB", "atmIntfIlmiConPollInactFactor"), ("ATM2-MIB", "atmIntfIlmiPublicPrivateIndctr"), ("ATM2-MIB", "atmCurrentlyFailingPVplTimeStamp"), ("ATM2-MIB", "atmCurrentlyFailingPVclTimeStamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmCommonGroup = atmCommonGroup.setStatus('current')
if mibBuilder.loadTexts: atmCommonGroup.setDescription('A collection of objects providing information\n    for a Switch/Service/Host that implements\n    ATM interfaces.')
atmCommonStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 2)).setObjects(("ATM2-MIB", "atmVclStatTotalCellIns"), ("ATM2-MIB", "atmVclStatClp0CellIns"), ("ATM2-MIB", "atmVclStatTotalDiscards"), ("ATM2-MIB", "atmVclStatClp0Discards"), ("ATM2-MIB", "atmVclStatTotalCellOuts"), ("ATM2-MIB", "atmVclStatClp0CellOuts"), ("ATM2-MIB", "atmVclStatClp0Tagged"), ("ATM2-MIB", "atmVplStatTotalCellIns"), ("ATM2-MIB", "atmVplStatClp0CellIns"), ("ATM2-MIB", "atmVplStatTotalDiscards"), ("ATM2-MIB", "atmVplStatClp0Discards"), ("ATM2-MIB", "atmVplStatTotalCellOuts"), ("ATM2-MIB", "atmVplStatClp0CellOuts"), ("ATM2-MIB", "atmVplStatClp0Tagged"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmCommonStatsGroup = atmCommonStatsGroup.setStatus('current')
if mibBuilder.loadTexts: atmCommonStatsGroup.setDescription('A collection of objects providing information\n\n    for a Switch/Service/Host that implements\n    ATM VCL and VPL Statistics')
atmSwitchServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 3)).setObjects(("ATM2-MIB", "atmIlmiSrvcRegATMAddress"), ("ATM2-MIB", "atmIlmiSrvcRegParm1"), ("ATM2-MIB", "atmIlmiSrvcRegRowStatus"), ("ATM2-MIB", "atmIlmiNetPrefixRowStatus"), ("ATM2-MIB", "atmSvcVpCrossConnectCreationTime"), ("ATM2-MIB", "atmSvcVpCrossConnectRowStatus"), ("ATM2-MIB", "atmSvcVcCrossConnectCreationTime"), ("ATM2-MIB", "atmSvcVcCrossConnectRowStatus"), ("ATM2-MIB", "atmIfRegAddrAddressSource"), ("ATM2-MIB", "atmIfRegAddrOrgScope"), ("ATM2-MIB", "atmIfRegAddrRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchServcGroup = atmSwitchServcGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchServcGroup.setDescription('A collection of objects providing information\n    for a Switch/Service that implements ATM interfaces.')
atmSwitchServcSigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 4)).setObjects(("ATM2-MIB", "atmSigSupportClgPtyNumDel"), ("ATM2-MIB", "atmSigSupportClgPtySubAddr"), ("ATM2-MIB", "atmSigSupportCldPtySubAddr"), ("ATM2-MIB", "atmSigSupportHiLyrInfo"), ("ATM2-MIB", "atmSigSupportLoLyrInfo"), ("ATM2-MIB", "atmSigSupportBlliRepeatInd"), ("ATM2-MIB", "atmSigSupportAALInfo"), ("ATM2-MIB", "atmSigSupportPrefCarrier"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchServcSigGroup = atmSwitchServcSigGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchServcSigGroup.setDescription('A collection of objects providing information\n    for a Switch/Service that implements ATM signalling.')
atmSwitchServcNotifGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 5)).setObjects(("ATM2-MIB", "atmIntfPvcFailuresTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchServcNotifGroup = atmSwitchServcNotifGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchServcNotifGroup.setDescription('A collection of notifications providing information\n        for a Switch/Service that implements ATM interfaces.')
atmSwitchGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 6)).setObjects(("ATM2-MIB", "atmSwitchAddressAddress"), ("ATM2-MIB", "atmSwitchAddressRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchGroup = atmSwitchGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchGroup.setDescription('A collection of objects providing information\n          for an ATM switch.')
atmServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 7)).setObjects(("ATM2-MIB", "atmVpCrossConnectUserName"), ("ATM2-MIB", "atmVpCrossConnectProviderName"), ("ATM2-MIB", "atmVcCrossConnectUserName"), ("ATM2-MIB", "atmVcCrossConnectProviderName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmServcGroup = atmServcGroup.setStatus('current')
if mibBuilder.loadTexts: atmServcGroup.setDescription('A collection of objects providing information\n        for an ATM Network Service.')
atmHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 8)).setObjects(("ATM2-MIB", "atmAal5VclInPkts"), ("ATM2-MIB", "atmAal5VclOutPkts"), ("ATM2-MIB", "atmAal5VclInOctets"), ("ATM2-MIB", "atmAal5VclOutOctets"), ("ATM2-MIB", "atmVclAddrType"), ("ATM2-MIB", "atmVclAddrRowStatus"), ("ATM2-MIB", "atmAddrVclAddrType"), ("ATM2-MIB", "atmVclGenSigDescrIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmHostGroup = atmHostGroup.setStatus('current')
if mibBuilder.loadTexts: atmHostGroup.setDescription('A collection of objects providing information\n      for a Host that implements ATM interfaces.')
atmHostSigDescrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 9)).setObjects(("ATM2-MIB", "atmSigDescrParamAalType"), ("ATM2-MIB", "atmSigDescrParamAalSscsType"), ("ATM2-MIB", "atmSigDescrParamBhliType"), ("ATM2-MIB", "atmSigDescrParamBhliInfo"), ("ATM2-MIB", "atmSigDescrParamBbcConnConf"), ("ATM2-MIB", "atmSigDescrParamBlliLayer2"), ("ATM2-MIB", "atmSigDescrParamBlliLayer3"), ("ATM2-MIB", "atmSigDescrParamBlliPktSize"), ("ATM2-MIB", "atmSigDescrParamBlliSnapId"), ("ATM2-MIB", "atmSigDescrParamBlliOuiPid"), ("ATM2-MIB", "atmSigDescrParamRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmHostSigDescrGroup = atmHostSigDescrGroup.setStatus('current')
if mibBuilder.loadTexts: atmHostSigDescrGroup.setDescription('A collection of objects providing information\n      for a Host that implements ATM interfaces.')
mibBuilder.exportSymbols("ATM2-MIB", atmVclGenEntry=atmVclGenEntry, atmAddrVclTable=atmAddrVclTable, atmSvcVpCrossConnectIndex=atmSvcVpCrossConnectIndex, atmSigSupportEntry=atmSigSupportEntry, atmSigDetectCldPtyEvents=atmSigDetectCldPtyEvents, atmVplLogicalPortDef=atmVplLogicalPortDef, atmVplStatClp0Tagged=atmVplStatClp0Tagged, atmCurrentlyFailingPVplEntry=atmCurrentlyFailingPVplEntry, atm2MIBCompliances=atm2MIBCompliances, atmInterfaceExtEntry=atmInterfaceExtEntry, atmAddrVclVci=atmAddrVclVci, atmSvcVpCrossConnectLowIfIndex=atmSvcVpCrossConnectLowIfIndex, atmVclStatTotalCellIns=atmVclStatTotalCellIns, atmSigDescrParamEntry=atmSigDescrParamEntry, atmAddrVclVpi=atmAddrVclVpi, atmIntfIlmiConPollInactFactor=atmIntfIlmiConPollInactFactor, atmIlmiSrvcRegIndex=atmIlmiSrvcRegIndex, atmSvcVcCrossConnectLowVpi=atmSvcVcCrossConnectLowVpi, atmIfRegAddrRowStatus=atmIfRegAddrRowStatus, atmSvcVcCrossConnectHighIfIndex=atmSvcVcCrossConnectHighIfIndex, atmIntfSigVccRxTrafficDescrIndex=atmIntfSigVccRxTrafficDescrIndex, atmSwitchAddressTable=atmSwitchAddressTable, atmVpCrossConnectXEntry=atmVpCrossConnectXEntry, atmCurrentlyFailingPVclTimeStamp=atmCurrentlyFailingPVclTimeStamp, atm2MIBCompliance=atm2MIBCompliance, atmIntfIlmiPublicPrivateIndctr=atmIntfIlmiPublicPrivateIndctr, atmVclStatClp0Tagged=atmVclStatClp0Tagged, atmAal5VclInOctets=atmAal5VclInOctets, atmSigSupportClgPtySubAddr=atmSigSupportClgPtySubAddr, atmSvcVcCrossConnectEntry=atmSvcVcCrossConnectEntry, atmInterfaceConfMinSvccVci=atmInterfaceConfMinSvccVci, atmVcCrossConnectProviderName=atmVcCrossConnectProviderName, atmAddrVclAtmIfIndex=atmAddrVclAtmIfIndex, atmVclStatTotalCellOuts=atmVclStatTotalCellOuts, atmVclStatTotalDiscards=atmVclStatTotalDiscards, atmCurrentlyFailingPVplTable=atmCurrentlyFailingPVplTable, atmIntfPvcFailuresTrap=atmIntfPvcFailuresTrap, atmIntfPvcFailures=atmIntfPvcFailures, atmSvcVcCrossConnectTable=atmSvcVcCrossConnectTable, atmSigDescrParamBbcConnConf=atmSigDescrParamBbcConnConf, atmPvcTrapsPrefix=atmPvcTrapsPrefix, atmSvcVpCrossConnectRowStatus=atmSvcVpCrossConnectRowStatus, atmSigStatEntry=atmSigStatEntry, atmIfRegAddrAddress=atmIfRegAddrAddress, atmIlmiNetPrefixPrefix=atmIlmiNetPrefixPrefix, atmSigDescrParamAalType=atmSigDescrParamAalType, atmSigDescrParamBhliType=atmSigDescrParamBhliType, atmVplStatEntry=atmVplStatEntry, atmIlmiSrvcRegServiceID=atmIlmiSrvcRegServiceID, atmVpCrossConnectProviderName=atmVpCrossConnectProviderName, atmSigStatTable=atmSigStatTable, atmSwitchAddressIndex=atmSwitchAddressIndex, atmIlmiSrvcRegATMAddress=atmIlmiSrvcRegATMAddress, atmIntfActualType=atmIntfActualType, atmIlmiNetworkPrefixEntry=atmIlmiNetworkPrefixEntry, atmCommonGroup=atmCommonGroup, atmSvcVcCrossConnectHighVpi=atmSvcVcCrossConnectHighVpi, atmServcGroup=atmServcGroup, atmVclAddrAddr=atmVclAddrAddr, atmAal5VclStatEntry=atmAal5VclStatEntry, atmSvcVcCrossConnectLowVci=atmSvcVcCrossConnectLowVci, atmSigEmitClgPtyEvents=atmSigEmitClgPtyEvents, atmVclStatClp0Discards=atmVclStatClp0Discards, atmCurrentlyFailingPVplTimeStamp=atmCurrentlyFailingPVplTimeStamp, atmAal5VclStatTable=atmAal5VclStatTable, atmIlmiSrvcRegParm1=atmIlmiSrvcRegParm1, atmSigDetectRestarts=atmSigDetectRestarts, atmIlmiNetworkPrefixTable=atmIlmiNetworkPrefixTable, atm2MIBObjects=atm2MIBObjects, atmIfRegAddrAddressSource=atmIfRegAddrAddressSource, atmInterfaceCurrentMinSvccVci=atmInterfaceCurrentMinSvccVci, atmIntfCurrentlyFailingPVcls=atmIntfCurrentlyFailingPVcls, atmCurrentlyFailingPVclEntry=atmCurrentlyFailingPVclEntry, atmVcCrossConnectUserName=atmVcCrossConnectUserName, atmHostGroup=atmHostGroup, atmSigEmitUnavailRoutes=atmSigEmitUnavailRoutes, atmVplStatClp0Discards=atmVplStatClp0Discards, atmSigEmitTimerExpireds=atmSigEmitTimerExpireds, atmSigDescrParamBlliLayer2=atmSigDescrParamBlliLayer2, atmSigDescrParamBlliSnapId=atmSigDescrParamBlliSnapId, atmSigDescrParamBlliOuiPid=atmSigDescrParamBlliOuiPid, atmVclStatClp0CellIns=atmVclStatClp0CellIns, atmSvcVcCrossConnectLowIfIndex=atmSvcVcCrossConnectLowIfIndex, atmInterfaceExtTable=atmInterfaceExtTable, atmSigDescrParamBhliInfo=atmSigDescrParamBhliInfo, atmVplStatTable=atmVplStatTable, atmSigDetectUnavailResrcs=atmSigDetectUnavailResrcs, atmSigSupportCldPtySubAddr=atmSigSupportCldPtySubAddr, atmVclStatEntry=atmVclStatEntry, atmSwitchAddressRowStatus=atmSwitchAddressRowStatus, atm2MIBGroups=atm2MIBGroups, atmIntfPvcFailuresTrapEnable=atmIntfPvcFailuresTrapEnable, atmSigEmitMsgErrors=atmSigEmitMsgErrors, atmVplStatTotalDiscards=atmVplStatTotalDiscards, atmVclGenSigDescrIndex=atmVclGenSigDescrIndex, atmSigDetectSetupAttempts=atmSigDetectSetupAttempts, atmVclAddrType=atmVclAddrType, atmAal5VclOutPkts=atmAal5VclOutPkts, atmSwitchGroup=atmSwitchGroup, atmSvcVcCrossConnectHighVci=atmSvcVcCrossConnectHighVci, atmSvcVpCrossConnectHighVpi=atmSvcVpCrossConnectHighVpi, atmSvcVcCrossConnectIndex=atmSvcVcCrossConnectIndex, PYSNMP_MODULE_ID=atm2MIB, atmVclAddrRowStatus=atmVclAddrRowStatus, atmSigDescrParamBlliLayer3=atmSigDescrParamBlliLayer3, atmInterfaceCurrentMaxSvccVpi=atmInterfaceCurrentMaxSvccVpi, atmAal5VclInPkts=atmAal5VclInPkts, atmIfRegisteredAddrTable=atmIfRegisteredAddrTable, atmSigSupportLoLyrInfo=atmSigSupportLoLyrInfo, atmAddrVclAddrType=atmAddrVclAddrType, atmSigSupportPrefCarrier=atmSigSupportPrefCarrier, atmIntfIlmiOperStatus=atmIntfIlmiOperStatus, atmIlmiSrvcRegAddressIndex=atmIlmiSrvcRegAddressIndex, atmIntfCurrentlyFailingPVpls=atmIntfCurrentlyFailingPVpls, atmSigEmitSetupAttempts=atmSigEmitSetupAttempts, atmCurrentlyFailingPVclTable=atmCurrentlyFailingPVclTable, atmVplStatTotalCellIns=atmVplStatTotalCellIns, atmSvcVpCrossConnectHighIfIndex=atmSvcVpCrossConnectHighIfIndex, atm2MIB=atm2MIB, atmSigDetectTimerExpireds=atmSigDetectTimerExpireds, atmIntfLeafSetupRequests=atmIntfLeafSetupRequests, atmIntfIlmiFsmState=atmIntfIlmiFsmState, atmSwitchServcSigGroup=atmSwitchServcSigGroup, atm2MIBConformance=atm2MIBConformance, atmVcCrossConnectXEntry=atmVcCrossConnectXEntry, atmIntfLeafSetupFailures=atmIntfLeafSetupFailures, atmIlmiNetPrefixRowStatus=atmIlmiNetPrefixRowStatus, atmSigEmitRestarts=atmSigEmitRestarts, atmCommonStatsGroup=atmCommonStatsGroup, atmVclStatTable=atmVclStatTable, atmSvcVpCrossConnectEntry=atmSvcVpCrossConnectEntry, atmIntfIlmiAdminStatus=atmIntfIlmiAdminStatus, atmSigOutEstabls=atmSigOutEstabls, atmVclGenTable=atmVclGenTable, atm2MIBTraps=atm2MIBTraps, atmSigEmitUnavailResrcs=atmSigEmitUnavailResrcs, atmSigSSCOPConEvents=atmSigSSCOPConEvents, atmAal5VclOutOctets=atmAal5VclOutOctets, atmSigDescrParamTable=atmSigDescrParamTable, atmSigSSCOPErrdPdus=atmSigSSCOPErrdPdus, atmSvcVpCrossConnectTable=atmSvcVpCrossConnectTable, atmSigDetectClgPtyEvents=atmSigDetectClgPtyEvents, atmSigDetectUnavailRoutes=atmSigDetectUnavailRoutes, atmVplStatClp0CellOuts=atmVplStatClp0CellOuts, atmInterfaceCurrentMaxSvpcVpi=atmInterfaceCurrentMaxSvpcVpi, atmSigEmitCldPtyEvents=atmSigEmitCldPtyEvents, atmIfRegAddrOrgScope=atmIfRegAddrOrgScope, atmSigDescrParamIndex=atmSigDescrParamIndex, atmIlmiSrvcRegTable=atmIlmiSrvcRegTable, atmSwitchAddressAddress=atmSwitchAddressAddress, atmVplLogicalPortIndex=atmVplLogicalPortIndex, atmInterfaceConfMaxSvpcVpi=atmInterfaceConfMaxSvpcVpi, atmSigDescrParamBlliPktSize=atmSigDescrParamBlliPktSize, atmIntfActualSide=atmIntfActualSide, atmVplLogicalPortEntry=atmVplLogicalPortEntry, atmSigDetectMsgErrors=atmSigDetectMsgErrors, atmSvcVpCrossConnectLowVpi=atmSvcVpCrossConnectLowVpi, atmSigDescrParamAalSscsType=atmSigDescrParamAalSscsType, atmIntfIlmiCheckConPollIntvl=atmIntfIlmiCheckConPollIntvl, atmSigInEstabls=atmSigInEstabls, atmSigSupportClgPtyNumDel=atmSigSupportClgPtyNumDel, atmSwitchServcGroup=atmSwitchServcGroup, atmPvcTraps=atmPvcTraps, atmIntfConfigType=atmIntfConfigType, atmHostSigDescrGroup=atmHostSigDescrGroup, atmVpCrossConnectXTable=atmVpCrossConnectXTable, atmVplStatTotalCellOuts=atmVplStatTotalCellOuts, atmVplLogicalPortTable=atmVplLogicalPortTable, atmIntfPvcNotificationInterval=atmIntfPvcNotificationInterval, atmAddrVclEntry=atmAddrVclEntry, atmInterfaceConfMaxSvccVpi=atmInterfaceConfMaxSvccVpi, atmSvcVpCrossConnectCreationTime=atmSvcVpCrossConnectCreationTime, atmVclAddrTable=atmVclAddrTable, atmIntfIlmiEstablishConPollIntvl=atmIntfIlmiEstablishConPollIntvl, atmSigSupportHiLyrInfo=atmSigSupportHiLyrInfo, atmSigSupportBlliRepeatInd=atmSigSupportBlliRepeatInd, atmSigSupportAALInfo=atmSigSupportAALInfo, atmIfRegisteredAddrEntry=atmIfRegisteredAddrEntry, atmSwitchServcNotifGroup=atmSwitchServcNotifGroup, atmVplStatClp0CellIns=atmVplStatClp0CellIns, atmIntfSigVccTxTrafficDescrIndex=atmIntfSigVccTxTrafficDescrIndex, atmSigSupportTable=atmSigSupportTable, atmIlmiSrvcRegRowStatus=atmIlmiSrvcRegRowStatus, atmIntfConfigSide=atmIntfConfigSide, atmVcCrossConnectXTable=atmVcCrossConnectXTable, atmVpCrossConnectUserName=atmVpCrossConnectUserName, atmSwitchAddressEntry=atmSwitchAddressEntry, atmIlmiSrvcRegEntry=atmIlmiSrvcRegEntry, atmVclAddrEntry=atmVclAddrEntry, atmVclStatClp0CellOuts=atmVclStatClp0CellOuts, atmSvcVcCrossConnectRowStatus=atmSvcVcCrossConnectRowStatus, atmSigDescrParamRowStatus=atmSigDescrParamRowStatus, atmSvcVcCrossConnectCreationTime=atmSvcVcCrossConnectCreationTime)
