#
# PySNMP MIB module LAN-EMULATION-LES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/LAN-EMULATION-LES-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 05:10:49 2022
# On host fv-az42-839 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
LeArpTableEntryType, atmfLanEmulation, VciInteger, VpiInteger = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "LeArpTableEntryType", "atmfLanEmulation", "VciInteger", "VpiInteger")
IfIndexOrZero, AtmLaneMask, TIMESTAMP, Integer = mibBuilder.importSymbols("LAN-EMULATION-ELAN-MIB", "IfIndexOrZero", "AtmLaneMask", "TIMESTAMP", "Integer")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, NotificationType, iso, IpAddress, TimeTicks, ModuleIdentity, Counter64, Unsigned32, Bits, Gauge32, ObjectIdentity, MibIdentifier, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "iso", "IpAddress", "TimeTicks", "ModuleIdentity", "Counter64", "Unsigned32", "Bits", "Gauge32", "ObjectIdentity", "MibIdentifier", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
lesMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3))
class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class RowStatus(Integer32):
    pass

class AtmLaneAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class LesLecDataFrameFormat(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3))
    namedValues = NamedValues(("aflane8023", 2), ("aflane8025", 3))

class LesLecDataFrameSize(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))
    namedValues = NamedValues(("max1516", 2), ("max4544", 3), ("max9234", 4), ("max18190", 5))

lesConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1))
lesStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2))
lesLecStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3))
lesFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4))
lesConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfNextId.setDescription('The next available LES index.  The\n                    value of this object can be used as\n                    the index by the network manager to\n                    create an entry in the lesConfTable.')
lesConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2), )
if mibBuilder.loadTexts: lesConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfTable.setDescription('This table contains all LAN Emulation\n                    Servers this agent manages.  The LES\n                    is one of the components in the Emulated\n                    LAN which implements the control coordination function.\n                    It is the address resolution server for a given ELAN.\n                    The LES provides a facility for registering and resolving \n                    MAC addresses and/or route descriptors to ATM\n                    addresses.  There can be multiple LES per ELAN \n                    but a LES can serve only one ELAN.')
lesConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: lesConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfEntry.setDescription('Each entry in this table represents a\n                    LES.  The parameters in each entry apply\n                    to one emulated LAN served by one LES.\n                    Objects lesLanType and lesMaxFrameSize\n                    are also required besides lesRowStatus\n                    during row creation.')
lesConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: lesConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfIndex.setDescription('A value which uniquely identifies a\n                  conceptual row in the lesConfTable.\n\n                  If the conceptual row identified by this value\n                  of lesConfIndex is recreated following an agent\n                  restart, the same value of lesConfIndex must be\n                  used to identify the recreated row.')
lesAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAtmAddrSpec.setReference('LAN Emulation Over ATM Specification -\n                   version 1.0. S1.')
if mibBuilder.loadTexts: lesAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrSpec.setDescription('An ATM  address specified by  the  \n                  network or local management that, \n                  with the ATM address mask, determines\n                  a  portion of  the  ATM address  that \n                  the  LES on the designated ATM interface  \n                  will use  to derive the actual ATM\n                  address from the network or ILMI.  The derived\n                  ATM address is specified in the object\n                  lesAtmAddrActual, which is used to\n                  receive ATM ARP requests.')
lesAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 3), AtmLaneMask().clone(hexValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAtmAddrMask.setReference('LAN Emulation Over ATM Specification -\n                   version 1.0. S1.')
if mibBuilder.loadTexts: lesAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrMask.setDescription("The ATM address mask associated with\n                  the object lesAtmAddrSpec.  The value\n                  of the mask is an ATM address with\n                  the don't care portion set to zero\n                  and the valid ATM address portion set to one.")
lesAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 4), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesAtmAddrActual.setReference('LAN Emulation Over ATM Specification -\n                   version 1.0. S1.')
if mibBuilder.loadTexts: lesAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrActual.setDescription(' The resultant ATM address  in use by  the LES.  This\n                    object is a product of the specified ATM address, mask\n                    and  interaction  with  the network.  This object is\n                    created by the agent.')
lesElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesElanName.setReference('LAN Emulation Over ATM Specification -\n                   version 1.0. C5.')
if mibBuilder.loadTexts: lesElanName.setStatus('mandatory')
if mibBuilder.loadTexts: lesElanName.setDescription('The name of the Emulated LAN this LES\n                  is providing service for.  This object\n                  may be used to identify the ELAN the LES\n                  is in.')
lesLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 6), LesLecDataFrameFormat()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLanType.setReference('LAN Emulation Over ATM Specification -\n                   version 1.0. S2.')
if mibBuilder.loadTexts: lesLanType.setStatus('mandatory')
if mibBuilder.loadTexts: lesLanType.setDescription('The type of the ATM Emulated LAN this\n                  LES is providing service to.')
lesLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 7), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: lesLastChange.setDescription('The  value of   sysUpTime  when  this LES \n                    has entered the state indicated by the \n                    object lesOperStatus.')
lesMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 8), LesLecDataFrameSize()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesMaxFrameSize.setReference('LAN Emulation Over ATM Specification -\n                   version 1.0. S3.')
if mibBuilder.loadTexts: lesMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: lesMaxFrameSize.setDescription('The maximum AAL-5 SDU size of a data\n                  frame that the LE service can guarantee\n                  not to drop because it is too large.\n')
lesControlTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesControlTimeOut.setReference('LAN Emulation Over ATM Specification -\n                   version 1.0. S4.')
if mibBuilder.loadTexts: lesControlTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: lesControlTimeOut.setDescription('Time out period used for timing out most\n                  request/response control frame interactions.\n                  This is the time a Client has to issue a join\n                  request to a LES after a control direct VCC is\n                  established with a LES.')
lesOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesOperStatus.setDescription("The operational state of this LES entry. \n                    When in 'up' state the LES will respond\n                    to LEC requests.  Any other state the\n                    LES is notavailable for service and may\n                    release all the existing VCCs and refuse\n                    service to all clients.")
lesAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("up", 2), ("down", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesAdminStatus.setDescription('  The  desired  state   of  the  designated   LES  as\n                    prescribed by the operator. The  actions of the  agent\n                    will, if at  all  possible, eventually  result  in the\n                    desired state being  reflected in  the lesOperStatus.')
lesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                    for version 2 of the Simple Network Management \n                    Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesRowStatus.setDescription('This object is used to create or\n                    delete entries in the elanConfTable.')
lesVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3), )
if mibBuilder.loadTexts: lesVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccTable.setDescription('This table contains all the Control Distribute \n                    VCCs used by the LES to distribute control traffic\n                    to the participating LECs.  The Control Distribute\n                    VCC can either be point-to-point or point-to-\n                    multipoint calls.  This table is read only if\n                    SVCs are used and writable if PVCs are used.')
lesVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesVccAtmIfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesVccCtlDistVpi"), (0, "LAN-EMULATION-LES-MIB", "lesVccCtlDistVci"))
if mibBuilder.loadTexts: lesVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccEntry.setDescription("Each entry in this table represents a\n                    LES entry and it's associated Control Distribute VCC. ")
lesVccAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 1), IfIndexOrZero())
if mibBuilder.loadTexts: lesVccAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccAtmIfIndex.setDescription('The ATM interface which the Control\n                      Distribute VCC is running on.\n                      This value must match an existing\n                      value  in the   ifTable.  \n                      The value of this object is set\n                      to zero when the ATM interface is\n                      an internal connection.')
lesVccCtlDistVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 2), VpiInteger())
if mibBuilder.loadTexts: lesVccCtlDistVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccCtlDistVpi.setDescription('The VPI value of the Control\n                      Distribute VCC.  The object\n                      lesVccAtmIfIndex, lesVccCtlDistVci\n                      and the value of this object uniquely\n                      identfies a VCC within a ATM host.')
lesVccCtlDistVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 3), VciInteger())
if mibBuilder.loadTexts: lesVccCtlDistVci.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccCtlDistVci.setDescription('The VCI value of the Control\n                      Distribute VCC.  The object\n                      lesVccAtmIfIndex, lesVccCtlDistVci\n                      and the value of this object uniquely\n                      identfies a VCC within a ATM host.')
lesVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesVccRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                        for version 2 of the Simple Network Management \n                        Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccRowStatus.setDescription('This object is used to create or\n                        delete entries in the elanConfTable.')
lesBusTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4), )
if mibBuilder.loadTexts: lesBusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusTable.setDescription('This table contains the BUSs paired\n                    with the LESs found in the lesConfTable.\n                    The BUS (Broadcast and Unknown Server)\n                    handles data sent by a LE client to\n                    the broadcast MAC address, all multicast\n                    traffic, and initial unicast frames\n                    which are sent by a LAN Emulation Client\n                    before the data direct target ATM address\n                    has been resolved.')
lesBusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesBusConfIndex"))
if mibBuilder.loadTexts: lesBusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusEntry.setDescription('Each entry in this table represents \n                    aLES/BUS pair. Object lesBusAddress is \n                    required duringrow creation. This table is \n                    indexed by lesConfIndex and \n                    lesBusConfIndexto show the pairing \n                    relationship betweenthe LES and BUS.')
lesBusConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: lesBusConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusConfIndex.setDescription('A value which uniquely identifies a\n                        BUS ATM address.\n                               \n                        If the BUS ATM address identified by this value\n                        of lesBusConfIndex is recreated following an agent\n                        restart, the same value of lesBusConfIndex must be\n                        used to identify the recreated BUS ATM address.')
lesBusAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesBusAddress.setReference('LAN Emulation Over ATM Specification -\n                       version 1.0. S6.')
if mibBuilder.loadTexts: lesBusAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusAddress.setDescription('The ATM address of the BUS. This BUS is associated\n                        with LES specified by the lesConfIndex. A BUS may\n                        have several ATM addresses, this object provides\n                        the ATM address the LES returns in response to the\n                        LE-ARP request by the LEC.')
lesLeArpMacTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5), )
if mibBuilder.loadTexts: lesLeArpMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpMacTable.setDescription("This table provides access to an ATM LAN Emulation\n                    Server's MAC-to-ATM ARP table.  It contains entries\n                    for unicast addressed, the broadcast address.\n\n                    When the entry is for broadcast MAC address the \n                    corresponding ATM address is of a BUS.\n                    When the entry is for unicast MAC \n                    address the corresponding ATM address represents\n                    a LEC.")
lesLeArpMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLeArpMacAddr"))
if mibBuilder.loadTexts: lesLeArpMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpMacEntry.setDescription('An ATM LAN Emulation ARP table entry containing\n                    information about the binding of one MAC address\n                    to one ATM address.')
lesLeArpMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 1), MacAddress())
if mibBuilder.loadTexts: lesLeArpMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpMacAddr.setDescription("The MAC address for which this table entry provides\n                         a translation.  Since ATM LAN Emulation uses an LE ARP\n                         protocol to locate the Broadcast and Unknown Server,\n                         the value of this object could be the broadcast MAC\n                         address.\n\n                         MAC addresses should be unique within any given ATM\n                         Emulated LAN.  However, there's no requirement that\n                         they be unique across disjoint emulated LANs.")
lesLeArpLecId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLeArpLecId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpLecId.setDescription('The LE Client Identifier (LECID) of this\n                        entry.  Each LE Client requires a LECID\n                        assigned by the LE Server during the\n                        Join phase.  \n                        If this entry is for a BUS then this object\n                        value will be zero.')
lesLeArpAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 3), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpAtmAddr.setDescription("The ATM address of the Broadcast & Unknown Server\n                         or LAN Emulation Client whose MAC address is stored\n                         in 'lesLeArpMacAddr'.\n                         This volume may be registered by a LAN Emulation\n                         Client or specified by network management.")
lesLeArpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 4), LeArpTableEntryType().clone('staticVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpEntryType.setReference('LAN Emulation Client MIB definition.')
if mibBuilder.loadTexts: lesLeArpEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpEntryType.setDescription('This object is used to indicate how\n                      this LE-ARP entry was created.\n                      The possible values for this object are:\n\n                        viaRegister(1),  -  agent\n                        staticVolatile(2), - network manager\n                        staticNonVolatile(3) - network manager\n\n                      This object is filled in by agent or network\n                      manager depending on the type.')
lesLeArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                      for version 2 of the Simple Network Management \n                      Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesLeArpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRowStatus.setDescription('This object is used to create or\n                      delete entries in the elanConfTable.')
lesLeArpRdTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6), )
if mibBuilder.loadTexts: lesLeArpRdTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdTable.setDescription("This table provides access to an ATM LAN Emulation\n                    Server's RouteDescriptor-to-ATM ARP cache.\n                    The entries in this table are set-up by the agent\n                    or network manager depending on the entry type.\n\n                    The Route Descriptors are presented as Segment Id \n                    (ring number) and Bridge number.")
lesLeArpRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLeArpRdSegId"), (0, "LAN-EMULATION-LES-MIB", "lesLeArpRdBridgeNum"))
if mibBuilder.loadTexts: lesLeArpRdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdEntry.setDescription('An ATM LAN Emulation ARP cache entry containing\n                    information about the binding of one Route\n                    Descriptor to one ATM address.')
lesLeArpRdSegId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: lesLeArpRdSegId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdSegId.setDescription('The LAN ID (ring number) portion of the \n                        IEEE 802.5 route descriptor associated \n                        with this LES.')
lesLeArpRdBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: lesLeArpRdBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdBridgeNum.setDescription('The Bridge Number portion of the \n                         IEEE 802.5 route descriptor associated \n                         with this LES.')
lesLeArpRdLecId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLeArpRdLecId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdLecId.setDescription('The LE Client Identifier (LECID) of this\n                        entry.  Each LE Client requires a LECID\n                        assigned by the LE Server during the\n                        Join phase.  \n')
lesLeArpRdAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 4), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRdAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdAtmAddr.setDescription('The ATM address associated with the \n                        Route Descriptor.')
lesLeArpRdEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 5), LeArpTableEntryType().clone('staticVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRdEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdEntryType.setDescription('This object is used to indicate how\n                      this LE-ARP entry was learned:\n\n                        viaRegister(1),  -  agent\n                        staticVolatile(2), - network manager\n                        staticNonVolatile(3) - network manager\n \n                      This object is filled in by agent or network\n                      manager depending on the type.')
lesLeArpRdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRdRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                      for version 2 of the Simple Network Management \n                      Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesLeArpRdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdRowStatus.setDescription('This object is used to create or\n                      delete entries in the elanConfTable.')
lesLecTableLastChange = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 7), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecTableLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecTableLastChange.setDescription('The value of sysUptime when an entry was created/deleted.')
lesLecTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8), )
if mibBuilder.loadTexts: lesLecTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecTable.setDescription('This table contains all LAN Emulation\n                    clients serviced by LESs specified in\n                    the lesConfTable.  This table can be\n                    used to retrieve the topology of an\n                    ELAN, in particular, the LES to LECs\n                    mapping information.\n\n                    An entry in this table is filled in \n                    by the agent when a LEC registers successfully \n                    with the LES.  Objects lesLecCtlDirectVpi\n                    and lesLecCtlDirectVci can be modified  by the\n                    network manager after creation if PVC is used.')
lesLecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLecIndex"))
if mibBuilder.loadTexts: lesLecEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecEntry.setDescription('Each entry represents a LANE client to LES\n                     binding.')
lesLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: lesLecIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecIndex.setDescription('An arbitrary integer which uniquely identifies\n                        a LEC in this table.')
lesLecAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecAtmAddr.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                         Section 5.4.3')
if mibBuilder.loadTexts: lesLecAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecAtmAddr.setDescription('The ATM address of the LANE client.  This\n                        is the primary ATM address of the LEC used\n                        in joining phase.')
lesLecProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecProxy.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                         Section 5.1.1')
if mibBuilder.loadTexts: lesLecProxy.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecProxy.setDescription('Whether this client is acting as a \n                         proxy.  Proxy clients are allowed \n                         to represent unregistered MAC addresses, \n                         and receive copies of LE_ARP_REQUEST\n                         packets for such addresses.')
lesLecId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecId.setDescription('The LE Client Identifier (LECID) of this\n                        entry.  Each LE Client requires a LECID \n                        assigned by the LE Server during the \n                        Join phase.  The LECID is placed\n                        in control requests by the LE Client and MAY be\n                        used for echo suppression on multicast data frames\n                        sent by that LE Client.')
lesLecAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 5), IfIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecAtmIfIndex.setDescription('The ifIndex of ATM port where this LEC entry\n                      has established the control direct VCC to \n                      the LES.  The value of this object \n                      maps to an existing ifIndex value in the \n                      ifTable of MIB-II. \n                      When an internal connection is used, this object is \n                      set to zero.')
lesLecCtlDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 6), VpiInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecCtlDirectVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecCtlDirectVpi.setDescription(' The VPI of the bi-directional control \n                        direct connection between the LEC and LES.')
lesLecCtlDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 7), VciInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecCtlDirectVci.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecCtlDirectVci.setDescription(' The VCI of the bi-directional control \n                        direct connection between the LEC and LES.')
lesLecLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 8), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecLastChange.setDescription('The value of sysUpTime of this entry when the LEC enters\n                      the state indicated by the object lesLecState.')
lesLecState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("noLesConnect", 2), ("lesConnect", 3), ("joining", 4), ("addLec", 5), ("joinedLes", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecState.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecState.setDescription("This object is used to indicate the\n                      status this LEC entry is in from the\n                      LES's perspective.  The state of this\n                      object is updated by the agent as \n                      it discovers various phases of this LEC.")
lesLecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecRowStatus.setReference('RFC 1443, [10] Textual Conventions\n                        for version 2 of the Simple Network Management \n                        Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesLecRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecRowStatus.setDescription(' This object provides a way for the network manager\n                        to selectively remove a LE Client from the designated\n                        LES.  Or in a system where PVCs are used, this table\n                        is used to configure Control Direct VCCs between LES\n                        and LEC.')
lesStatTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1), )
if mibBuilder.loadTexts: lesStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatTable.setDescription('This table contains all counters the\n                    LES maintain.  This table is an extention\n                    to the lesConfTable.  It provides performance\n                    and fault counters on a per LES basis.')
lesStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: lesStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatEntry.setDescription('Each entry in this table contains a\n                    LES and its counters.')
lesStatJoinOk = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatJoinOk.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatJoinOk.setDescription('Number of successful Join responses\n                       send out by the LAN Emulation Server.')
lesStatVerNotSup = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatVerNotSup.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatVerNotSup.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatVerNotSup.setDescription('Number of version not supported errors.\n')
lesStatInvalidReqParam = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidReqParam.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatInvalidReqParam.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidReqParam.setDescription('Number of invalid request parameters errors.\n')
lesStatDupLanDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatDupLanDest.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatDupLanDest.setDescription('Number of duplicate LAN destination errors.\n')
lesStatDupAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatDupAtmAddr.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatDupAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatDupAtmAddr.setDescription('Number of duplicate ATM address errors.\n')
lesStatInsRes = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInsRes.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatInsRes.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInsRes.setDescription('Number of insufficient resources to grant \n                       errors.\n')
lesStatAccDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatAccDenied.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatAccDenied.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatAccDenied.setDescription('Number of access denied for security \n                       reasons errors.')
lesStatInvalidReqId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidReqId.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatInvalidReqId.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidReqId.setDescription('Number of invalid LEC ID errors.')
lesStatInvalidLanDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidLanDest.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatInvalidLanDest.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidLanDest.setDescription('Number of invalid LAN destination errors.')
lesStatInvalidAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidAtmAddr.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0,\n                        Table 13.')
if mibBuilder.loadTexts: lesStatInvalidAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidAtmAddr.setDescription('Number of invalid ATM address errors.')
lesStatInBadPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInBadPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInBadPkts.setDescription('Number of mal formed ATM ARP requests\n                        received by the LES.')
lesStatOutRegFails = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatOutRegFails.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatOutRegFails.setDescription('Number of registration failures sent\n                        out by this LES.')
lesStatLeArpIn = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatLeArpIn.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatLeArpIn.setDescription('The total number of LE_ARP_REQUEST frames the LES has\n                        accepted since its last initialization.')
lesStatLeArpFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatLeArpFwd.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatLeArpFwd.setDescription("The number of LE_ARP_REQUESTs that the LES forwarded\n                        onto the clients (either via the control distribute or\n                        individually over each control direct) rather than\n                        answering directly.  This may be due to implementation\n                        decision (forward all requests) or because the resolution\n                        to the request did not reside in the LES's LE ARP cache.")
lesLecStatTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1), )
if mibBuilder.loadTexts: lesLecStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecStatTable.setDescription('This table contains all LE-ARP request\n                    related counters and error counts on \n                    a per LEC-LES pair basis.')
lesLecStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLecIndex"))
if mibBuilder.loadTexts: lesLecStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecStatEntry.setDescription('Each entry in this table represents a\n                    LEC and its ARP counters.  This table\n                    is an extention to the lesLecTable.')
lesLecRecvs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecRecvs.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecRecvs.setDescription('Number of requests received from this\n                   LEC.  This includes all control\n                   frames as well as LE-ARP requests.')
lesLecSends = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecSends.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecSends.setDescription('Number of requests or responses\n                   sent to the LEC entry from this\n                   LES.')
lesLecInRegReq = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInRegReq.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInRegReq.setDescription('Number of Register requests received \n                   from this LEC.  ')
lesLecInUnReg = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInUnReg.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInUnReg.setDescription('Number of UnRegister requests received \n                   from this LEC.  ')
lesLecInLeArpUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInLeArpUcast.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInLeArpUcast.setDescription('Number of LE-ARP requests for UNICAST\n                   address received from this LEC. ')
lesLecInLeArpBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInLeArpBcast.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInLeArpBcast.setDescription('Number of LE-ARP requests for MULTICAST\n                   and Broadcast address received from this LEC. ')
lesLecInLeArpResp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInLeArpResp.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInLeArpResp.setDescription('Number of LE-ARP responses \n                   received from this LEC. ')
lesLecInNArp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInNArp.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInNArp.setDescription('Number of NARP requests \n                   received from this LEC. ')
lesErrCtlTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1), )
if mibBuilder.loadTexts: lesErrCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlTable.setDescription('This table contains error log control \n                        information of all LES instances.\n                        This table is an extention to the\n                        lesConfTable.  It is used to enable\n                        or disable error logs for a particular\n                        LES entry.')
lesErrCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: lesErrCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlEntry.setDescription('Each entry represents a LES entry\n                      in the lesConfTable.')
lesErrCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesErrCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlAdminStatus.setDescription('This object is used to enable/disable error \n                        logging for the LES.')
lesErrCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("outOfRes", 3), ("failed", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlOperStatus.setDescription('This object is used to indicate\n                   the result of a set operation to the\n                   object lesErrCtlAdminStatus.\n                   If the error log was successfully\n                   started, it is in active(2) mode.\n                   Otherwise, it is set to either\n                   outOfRes(3) or failed(4) for\n                   the respective reasons.')
lesErrCtlClearLog = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesErrCtlClearLog.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlClearLog.setDescription('This object is used to clear the error log\n                     entries associated with this LES.')
lesErrCtlMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrCtlMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlMaxEntries.setDescription('The maximum entries of the error\n                   log a LES can support.')
lesErrCtlLastEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesErrCtlLastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlLastEntry.setDescription('The index to the last entry in the error\n                     log table for this LES.')
lesErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2), )
if mibBuilder.loadTexts: lesErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogTable.setDescription('This table contains error logs\n                    of the LES instances enabled\n                    in the lesErrCtlTable.  This table\n                    is indexed by the LES instance\n                    index and an arbitrary integer\n                    uniquely identifies an error\n                    log.')
lesErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesErrLogIndex"))
if mibBuilder.loadTexts: lesErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogEntry.setDescription('Each entry represents a JOIN or REGISTER that\n                     was rejected due to an error.')
lesErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: lesErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogIndex.setDescription('An arbitrary integer which uniquely\n                    identifies an error log entry. The first\n                    entry after reset or clearing the error\n                    log is an assigned value (2^32-1).  Succeding\n                    entries are assigned with descending values \n                    consecutively.  Entries after 1 are discarded. The \n                    enabling/disabling of\n                    the error log capability is done in\n                    the lesErrCtlTable.')
lesErrLogAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrLogAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogAtmAddr.setDescription('The ATM address of the requester\n                    which sends the JOIN or REGISTER request\n                    and causes the error to occur. \n                    The corresponding error code is\n                    specified in the object lesErrLogErrCode.')
lesErrLogErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrLogErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogErrCode.setDescription('The Error code which indicates the\n                    cause of the error triggered by the\n                    JOIN or REGISTER request sent by the\n                    requester indicated by the value of\n                    the object lesErrLogAtmAddr.')
lesErrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 4), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogTime.setDescription('The sysUpTime when this entry was logged by\n                     the LES.')
mibBuilder.exportSymbols("LAN-EMULATION-LES-MIB", lesLeArpMacAddr=lesLeArpMacAddr, lesErrCtlAdminStatus=lesErrCtlAdminStatus, lesVccAtmIfIndex=lesVccAtmIfIndex, lesElanName=lesElanName, lesControlTimeOut=lesControlTimeOut, lesLastChange=lesLastChange, lesLeArpLecId=lesLeArpLecId, RowStatus=RowStatus, lesLecProxy=lesLecProxy, lesLeArpRdSegId=lesLeArpRdSegId, lesLecCtlDirectVpi=lesLecCtlDirectVpi, lesLecInUnReg=lesLecInUnReg, lesErrLogIndex=lesErrLogIndex, lesLeArpRdRowStatus=lesLeArpRdRowStatus, lesLecStatTable=lesLecStatTable, lesLeArpRowStatus=lesLeArpRowStatus, lesAtmAddrSpec=lesAtmAddrSpec, lesVccCtlDistVpi=lesVccCtlDistVpi, lesErrLogErrCode=lesErrLogErrCode, lesLecAtmAddr=lesLecAtmAddr, lesStatInvalidReqParam=lesStatInvalidReqParam, lesLeArpRdAtmAddr=lesLeArpRdAtmAddr, lesStatLeArpIn=lesStatLeArpIn, lesOperStatus=lesOperStatus, lesErrLogAtmAddr=lesErrLogAtmAddr, lesLecTable=lesLecTable, lesLecTableLastChange=lesLecTableLastChange, lesLeArpRdEntryType=lesLeArpRdEntryType, lesErrLogTable=lesErrLogTable, lesLecRowStatus=lesLecRowStatus, lesConfNextId=lesConfNextId, lesStatDupAtmAddr=lesStatDupAtmAddr, lesStatGroup=lesStatGroup, lesLeArpRdLecId=lesLeArpRdLecId, lesErrCtlLastEntry=lesErrCtlLastEntry, lesLeArpRdBridgeNum=lesLeArpRdBridgeNum, lesErrCtlEntry=lesErrCtlEntry, MacAddress=MacAddress, lesErrLogTime=lesErrLogTime, lesLecState=lesLecState, lesStatInBadPkts=lesStatInBadPkts, lesStatEntry=lesStatEntry, lesStatInvalidReqId=lesStatInvalidReqId, lesBusConfIndex=lesBusConfIndex, lesVccEntry=lesVccEntry, lesVccCtlDistVci=lesVccCtlDistVci, lesLeArpEntryType=lesLeArpEntryType, lesBusTable=lesBusTable, lesLecInLeArpUcast=lesLecInLeArpUcast, lesStatLeArpFwd=lesStatLeArpFwd, lesVccRowStatus=lesVccRowStatus, lesAtmAddrActual=lesAtmAddrActual, lesStatAccDenied=lesStatAccDenied, lesLeArpRdEntry=lesLeArpRdEntry, lesErrCtlMaxEntries=lesErrCtlMaxEntries, lesAdminStatus=lesAdminStatus, lesErrCtlClearLog=lesErrCtlClearLog, lesStatInsRes=lesStatInsRes, lesStatInvalidLanDest=lesStatInvalidLanDest, lesLecEntry=lesLecEntry, lesFaultGroup=lesFaultGroup, lesLeArpAtmAddr=lesLeArpAtmAddr, lesConfIndex=lesConfIndex, lesMIB=lesMIB, lesLecCtlDirectVci=lesLecCtlDirectVci, TruthValue=TruthValue, AtmLaneAddress=AtmLaneAddress, lesLecInRegReq=lesLecInRegReq, lesLecSends=lesLecSends, lesConfEntry=lesConfEntry, lesBusAddress=lesBusAddress, lesLeArpMacEntry=lesLeArpMacEntry, lesMaxFrameSize=lesMaxFrameSize, lesLecAtmIfIndex=lesLecAtmIfIndex, lesStatVerNotSup=lesStatVerNotSup, lesConfTable=lesConfTable, lesBusEntry=lesBusEntry, lesLeArpRdTable=lesLeArpRdTable, lesLecInLeArpBcast=lesLecInLeArpBcast, lesAtmAddrMask=lesAtmAddrMask, lesErrCtlTable=lesErrCtlTable, lesConfGroup=lesConfGroup, lesLecStatEntry=lesLecStatEntry, lesErrLogEntry=lesErrLogEntry, lesErrCtlOperStatus=lesErrCtlOperStatus, lesLecIndex=lesLecIndex, lesStatDupLanDest=lesStatDupLanDest, lesLecStatGroup=lesLecStatGroup, lesStatTable=lesStatTable, lesLecId=lesLecId, lesStatJoinOk=lesStatJoinOk, lesLecLastChange=lesLecLastChange, LesLecDataFrameSize=LesLecDataFrameSize, lesRowStatus=lesRowStatus, lesLecRecvs=lesLecRecvs, lesLecInLeArpResp=lesLecInLeArpResp, lesStatOutRegFails=lesStatOutRegFails, lesVccTable=lesVccTable, lesLanType=lesLanType, lesLecInNArp=lesLecInNArp, lesStatInvalidAtmAddr=lesStatInvalidAtmAddr, LesLecDataFrameFormat=LesLecDataFrameFormat, lesLeArpMacTable=lesLeArpMacTable)
