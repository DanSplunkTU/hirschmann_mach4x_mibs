#
# PySNMP MIB module ALCATEL-IND1-TIMETRA-MPLS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nokia/aos7/ALCATEL-IND1-TIMETRA-MPLS-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 16:32:36 2022
# On host fv-az36-988 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
tmnxSRObjs, timetraSRMIBModules, tmnxSRNotifyPrefix, tmnxSRConfs = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-GLOBAL-MIB", "tmnxSRObjs", "timetraSRMIBModules", "tmnxSRNotifyPrefix", "tmnxSRConfs")
TNamedItem, TmnxOperState, TmnxAdminState, TmnxActionType, TNamedItemOrEmpty, TmnxVRtrMplsLspID = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-TC-MIB", "TNamedItem", "TmnxOperState", "TmnxAdminState", "TmnxActionType", "TNamedItemOrEmpty", "TmnxVRtrMplsLspID")
vRtrIfIndex, vRtrID = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex", "vRtrID")
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressIPv6, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6")
mplsXCLspId, MplsLSPID, MplsLabel = mibBuilder.importSymbols("MPLS-LSR-MIB", "mplsXCLspId", "MplsLSPID", "MplsLabel")
mplsTunnelARHopEntry, mplsTunnelIngressLSRId, mplsTunnelIndex, mplsTunnelInstance = mibBuilder.importSymbols("MPLS-TE-MIB", "mplsTunnelARHopEntry", "mplsTunnelIngressLSRId", "mplsTunnelIndex", "mplsTunnelInstance")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, IpAddress, iso, Bits, TimeTicks, Gauge32, Counter32, ObjectIdentity, MibIdentifier, ModuleIdentity, Integer32, Counter64, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "IpAddress", "iso", "Bits", "TimeTicks", "Gauge32", "Counter32", "ObjectIdentity", "MibIdentifier", "ModuleIdentity", "Integer32", "Counter64", "NotificationType")
RowStatus, TextualConvention, TruthValue, TimeStamp, TimeInterval, RowPointer, DisplayString, TestAndIncr = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "TimeStamp", "TimeInterval", "RowPointer", "DisplayString", "TestAndIncr")
timetraMplsMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 6))
timetraMplsMIBModule.setRevisions(('1908-01-01 00:00', '1907-01-01 00:00', '1906-03-23 00:00', '1905-08-31 00:00', '1905-01-24 00:00', '1904-01-15 00:00', '1903-08-15 00:00', '1900-09-07 00:00', '1900-08-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: timetraMplsMIBModule.setRevisionsDescriptions(('Rev 6.0                01 Jan 2008 00:00\n                         6.0 release of the TIMETRA-MPLS-MIB.', 'Rev 5.0                01 Jan 2007 00:00\n                         5.0 release of the TIMETRA-MPLS-MIB.', 'Rev 4.0                23 Mar 2006 00:00\n                         4.0 release of the TIMETRA-MPLS-MIB.', 'Rev 3.0                31 Aug 2005 00:00\n                         3.0 release of the TIMETRA-MPLS-MIB.', 'Rev 2.1                24 Jan 2005 00:00\n                         2.1 release of the TIMETRA-MPLS-MIB.', 'Rev 2.0                15 Jan 2004 00:00\n                         2.0 release of the TIMETRA-MPLS-MIB.', 'Rev 1.2                15 Aug 2003 00:00\n                         1.2 release of the TIMETRA-MPLS-MIB.', 'Rev 1.0                20 Jan 2003 00:00\n                         1.0 Release of the TIMETRA-MPLS-MIB.', 'Rev 0.1                14 Aug 2000 00:00\n                         Initial version of the TIMETRA-MPLS-MIB.',))
if mibBuilder.loadTexts: timetraMplsMIBModule.setLastUpdated('0801010000Z')
if mibBuilder.loadTexts: timetraMplsMIBModule.setOrganization('Alcatel')
if mibBuilder.loadTexts: timetraMplsMIBModule.setContactInfo('Alcatel 7x50 Support\n             Web: http://www.alcatel.com/comps/pages/carrier_support.jhtml')
if mibBuilder.loadTexts: timetraMplsMIBModule.setDescription("This document is the SNMP MIB module to manage and provision the \n        MPLS extensions for the Alcatel 7x50 device.\n         \n        Copyright 2003-2008 Alcatel-Lucent. All rights reserved.\n        Reproduction of this document is authorized on the condition that\n        the foregoing copyright notice is included.\n\n        This SNMP MIB module (Specification) embodies Alcatel's\n        proprietary intellectual property.  Alcatel retains \n        all title and ownership in the Specification, including any \n        revisions.\n\n        Alcatel grants all interested parties a non-exclusive \n        license to use and distribute an unmodified copy of this \n        Specification in connection with management of Alcatel \n        products, and without fee, provided this copyright notice and \n        license appear on all copies.\n\n        This Specification is supplied 'as is', and Alcatel \n        makes no warranty, either express or implied, as to the use, \n        operation, condition, or performance of the Specification.")
tmnxMplsObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6))
tmnxMplsConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6))
tmnxMplsNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6))
tmnxMplsNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0))
class TmnxMplsLspFailCode(TextualConvention, Integer32):
    description = 'TmnxMplsLspFailCode is an enumerated integer that defines the  \n         reason for LSP Path and LSP Crossconnect failure.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26))
    namedValues = NamedValues(("noError", 0), ("admissionControlError", 1), ("noRouteToDestination", 2), ("trafficControlSystemError", 3), ("routingError", 4), ("noResourcesAvailable", 5), ("badNode", 6), ("routingLoop", 7), ("labelAllocationError", 8), ("badL3PID", 9), ("tunnelLocallyRepaired", 10), ("unknownObjectClass", 11), ("unknownCType", 12), ("noEgressMplsInterface", 13), ("noEgressRsvpInterface", 14), ("looseHopsInFRRLsp", 15), ("unknown", 16), ("retryExceeded", 17), ("noCspfRouteOwner", 18), ("noCspfRouteToDestination", 19), ("hopLimitExceeded", 20), ("looseHopsInManualBypassLsp", 21), ("emptyPathInManualBypassLsp", 22), ("lspFlowControlled", 23), ("srlgSecondaryNotDisjoint", 24), ("srlgPrimaryCspfDisabled", 25), ("srlgPrimaryPathDown", 26))

class TmnxMplsLabelOwner(TextualConvention, Integer32):
    description = 'TmnxMplsLabelOwner is an enumerated integer that specifies\n        the module that owns a particular MPLS label.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("none", 0), ("rsvp", 1), ("tldp", 2), ("ildp", 3), ("svcmgr", 4), ("bgp", 5), ("mirror", 6), ("static", 7), ("vprn", 8))

class TmnxMplsOperDownReasonCode(TextualConvention, Integer32):
    description = 'TmnxMplsOperDownReasonCode is an enumerated integer that specifies \n         the reason that the MPLS instance is operationally down.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("operUp", 0), ("adminDown", 1), ("noResources", 2), ("systemIpDown", 3), ("iomFailure", 4), ("clearDown", 5))

vRtrMplsLspTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1), )
if mibBuilder.loadTexts: vRtrMplsLspTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTable.setDescription('The vRtrMplsLspTable has an entry for each Labeled Switch\n         Path (LSP) configured for a virtual router in the system.')
vRtrMplsLspEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"))
if mibBuilder.loadTexts: vRtrMplsLspEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspEntry.setDescription("Each row entry represents a Labeled Switch Path (LSP) configured\n         for a virtual router in the system.  Entries can be created and\n         deleted via SNMP SET operations.  Setting RowStatus to 'active'\n         requires vRtrMplsLspName to have been assigned a valid value.")
vRtrMplsLspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 1), TmnxVRtrMplsLspID()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsLspIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspIndex.setDescription('The unique value which identifies this Labeled Switch\n         Path (LSP) for this virtual router in the Alcatel 7x50 \n         SR system.  It is a unique value among entries with the \n         same value of vRtrID.')
vRtrMplsLspRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRowStatus.setDescription("The row status used for creation, deletion, or control\n         of vRtrMplsLspTable entries.  Before the row can be\n         placed into the 'active' state vRtrMplsLspName must\n         have been assigned a valid value.")
vRtrMplsLspLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspLastChange.setDescription('The sysUpTime when this row was last modified.')
vRtrMplsLspName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 4), TNamedItemOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspName.setDescription('Administrative name for this Labeled Switch Path.\n         The vRtrMplsLspName must be unique within a virtual\n         router instance.')
vRtrMplsLspAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 5), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdminState.setDescription('The desired administrative state for this LSP.')
vRtrMplsLspOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 6), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOperState.setDescription('The current operational state of this LSP.')
vRtrMplsLspFromAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 7), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFromAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFromAddr.setDescription('Source IP address of this LSP.  If vRtrMplsLspFromAddr has not\n         been explicitly set, the system IP address will be used.')
vRtrMplsLspToAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspToAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspToAddr.setDescription('Destination IP address of this LSP.  This LSP will not be\n         signaled until vRtrMplsLspToAddr is explicitly set.')
vRtrMplsLspType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("dynamic", 2), ("static", 3), ("bypass-only", 4))).clone('dynamic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspType.setDescription('The vRtrMplsLspType object is an enumerated value that indicates\n         whether the label value is statically or dynamically assigned or\n         whether the LSP will be used exclusively for bypass protection.')
vRtrMplsLspOutSegIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspOutSegIndx.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOutSegIndx.setDescription("The vRtrMplsLspOutSegIndx is the index value of the entry in \n         the mplsOutSegmentTable associated with this vRtrMplsLspEntry\n         when vRtrMplsLspType is 'static'.  If vRtrMplsLspType is\n         'dynamic', the value of this object will be zero (0).")
vRtrMplsLspRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRetryTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRetryTimer.setDescription('The value of vRtrMplsLspRetryTimer specifies the time in seconds\n         the software will wait before attempting the establish the\n         failed LSP.')
vRtrMplsLspRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRetryLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRetryLimit.setDescription('The value of vRtrMplsLspRetryLimit specifies the number of\n         attempts the software should make to reestablish a failed LSP\n         before the LSP is disabled.  A value of 0 indicates that an\n         infinite number of retry attempts should be made.')
vRtrMplsLspMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspMetric.setDescription('The value of vRtrMplsLspMetric specifies the metric for this\n         LSP which is used to select an LSP among a set of LSPs which are\n         destined to the same egress 7x50 router.  The LSP with the lowest\n         metric will be selected.\n\n         In LDP-over-RSVP, LDP performs a lookup in the Routing Table \n         Manager (RTM) which provides the next hop to the destination PE \n         and the advertising router (ABR or destination PE itself).  If the\n         advertising router matches the targeted LDP peer, LDP then \n         performs a second lookup for the advertising router in the Tunnel \n         Table Manager (TTM). This lookup returns the best RSVP LSP to use\n         to forward packets for an LDP FEC learned through the targeted \n         LDP session.  The lookup returns the LSP with the lowest metric.\n         If multiple LSPs have the same metric, then the result of the \n         lookup will be to select the first one available in the TTM.')
vRtrMplsLspDecrementTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 14), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspDecrementTtl.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspDecrementTtl.setDescription("When the value of vRtrMplsLspDecrementTtl is 'true', the ingress \n         ESR writes the TTL of the IP packet into the label and each \n         transit ESR decrements the TTL in the label.  At the egress ESR \n         the TTL value from the label is written into the IP packet.\n         \n         When the value of vRtrMplsLspDecrementTtl is 'false', the ingress\n         ESR ignores the IP packet TTL and writes the value of 255 into the\n         label; and the egress ESR does not write the label's TTL into the\n         IP packet.")
vRtrMplsLspCspf = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspCspf.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspCspf.setDescription("When the value of vRtrMplsLspCspf is 'true', CSPF computation\n         for constrained-path LSP is enabled.  When the value of\n         vRtrMplsLspCspf is 'false' CSPF computation is disabled.")
vRtrMplsLspFastReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFastReroute.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFastReroute.setDescription("When the value of vRtrMplsLspFastReroute is 'true', fast reroute\n         is enabled.  A pre-computed detour LSP is created from each node\n         in the primary path of this LSP.  In case of a failure of a link \n         or LSP between two nodes, traffic is immediately rerouted on the\n         pre-computed detour LSP thus avoiding packet loss.  Each node\n         along the primary path of the LSP tries to establish a detour LSP \n         as follows:  Each upstream node will setup a detour LSP that\n         avoids only the immediate downstream node and merges back onto\n         the actual path of the LSP as soon as possible.  The detour LSP\n         may take one or more hops (upto the value of vRtrMplsLspFRHopLimit)\n         before merging back onto the main LSP path.\n         \n         When the upstream node detects a downstream link or node failure,\n         it immediately send traffic for that LSP on the detour path and\n         at the same time signals back to the ingress ESR about the\n         failure.\n         \n         Fast reroute applies only to the primary path of this LSP.\n         No configuration is required on the transit hops of the LSP.\n         The ingress ESR will signal all intermediate ESRs using RSVP\n         to setup their detours.\n         \n         When the value of vRtrMplsLspFastReroute is 'false', fast\n         rerouting is disabled.")
vRtrMplsLspFRHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRHopLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRHopLimit.setDescription('The value of vRtrMplsLspFRHopLimit specifies the total number\n         of hops a detour LSP can take before merging back onto the\n         main LSP path.')
vRtrMplsLspFRBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 18), Unsigned32()).setUnits('mega-bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRBandwidth.setDescription('The value of vRtrMplsLspFRBandwidth specified the amount of\n         bandwidth in mega-bits per second (Mbps) to be reserved for the\n         detour LSP. A value of zero (0) indicates that no bandwidth\n         is reserved.')
vRtrMplsLspClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 19), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspClassOfService.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspClassOfService.setDescription("The name of the class of service value to be assigned to all\n         packets on the LSP is specified with vRtrMplsLspClassOfService.\n         The EXP bits in the MPLS header are set based on the global\n         mapping table that specified the mapping between the forwarding\n         class and the EXP bits.  When class of service is specified,\n         all packets will be marked with the same EXP bits that match\n         the vRtrMplsLspClassOfService name in the mapping table.\n         \n         An empty string, ''H, specifies no class of service.  Packets\n         are assigned EXP bits based on the same mapping table, however\n         each packet is marked with EXP bits based on the forwarding\n         class from which it is serviced.\n         \n         When the value of vRtrMplsLspPathCosSource is set to 'inherit',\n         the value of vRtrMplsLspClassOfService is applied to that\n         specific LSP/path.")
vRtrMplsLspSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspSetupPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspSetupPriority.setDescription("The value of vRtrMplsLspSetupPriority specifies the setup priority\n         to use when insufficient bandwidth is available to setup a LSP.\n         The setup priority is compared against the hold priority of\n         existing LSPs.  If the setup priority is higher than the hold\n         priority of the established LSPs, this LSP may preempt the other\n         LSPs.  A value of zero (0) is the highest priority and a value\n         of seven (7) is the lowest priority.\n         \n         When the value of vRtrMplsLspPathSetupPriority is set to '-1',\n         the value of vRtrMplsLspSetupPriority is applied to that specific\n         LSP/path.")
vRtrMplsLspHoldPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspHoldPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspHoldPriority.setDescription("The value of vRtrMplsLspHoldPriority specifies the hold priority\n         to use when insufficient bandwidth is available to setup a LSP.\n         The setup priority is compared against the hold priority of\n         existing LSPs.  If the setup priority is higher than the hold\n         priority of the established LSPs, this LSP may preempt the other\n         LSPs.  A value of zero (0) is the highest priority and a value\n         of seven (7) is the lowest priority.\n         \n         When the value of vRtrMplsLspPathHoldPriority is set to '-1',\n         the value of vRtrMplsLspHoldPriority is applied to that specific\n         LSP/path.")
vRtrMplsLspRecord = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 22), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRecord.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRecord.setDescription("When the value of vRtrMplsLspRecord is 'true', recording of all\n         the hops that a LSP traverses is enabled.\n         \n         When the value of vRtrMplsLspRecord is 'false, recording of all\n         the hops that a LSP traverses is disabled.")
vRtrMplsLspPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPreference.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPreference.setDescription('The value of vRtrMplsLspPreference specifies the preference for\n         the LSP.  This value is used for load balancing between multiple\n         LSPs that exist between the same ingress and egress routers.\n         By default, traffic is load balanced among the LSPs, since all\n         LSPs have the same preference.  To prefer one LSP over another,\n         change the preference value for that LSP.  The LSP with the\n         lowest preference is used.\n         \n         When the value of vRtrMplsLspPathPreference is set to zero (0),\n         the value of vRtrMplsLspPreference is applied to that specific\n         LSP/path.')
vRtrMplsLspBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 24), Integer32()).setUnits('mega-bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspBandwidth.setDescription('The value of vRtrMplsLspBandwidth specifies the amount of\n         bandwidth in mega-bits per second (Mbps) to be reserved for the LSP.\n         A value of zero (0) indicates that no bandwidth is reserved.\n         \n         When vRtrMplsLspPathBandwidth is set to -1, the value of\n         vRtrMplsLspBandwidth is applied to that specific LSP/path.')
vRtrMplsLspBwProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspBwProtect.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspBwProtect.setDescription("When vRtrMplsLspBwProtect has a value of 'true', bandwidth\n         protection is enabled on a LSP.  LSPs that reserve bandwidth\n         will be used for EF services where customers need guaranteed\n         bandwidth.  It is expected that multiple EF services will be\n         assigned to a single LSP.  When bandwidth protection is\n         enabled on an LSP, each time this LSP is used for a certain\n         service the bandwidth allocated on that service is deducted\n         from the bandwidth reserved for the LSP.  Once the bandwidth is\n         exhausted on the LSP, the ESR will provide feedback to the\n         provider indicating that this LSP has exhausted its resources.")
vRtrMplsLspHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspHopLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspHopLimit.setDescription('The value of vRtrMplsLspHopLimit specifies the maximum number\n         of hops that a LSP will traverse including the ingress and\n         egress ESRs.  A LSP will not be setup if the hop limit is\n         exceeded.\n         \n         When the value of vRtrMplsLspPathHopLimit is set to zero (0),\n         the value of vRtrMplsLspHopLimit is applied to that specific\n         LSP/path.')
vRtrMplsLspNegotiatedMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspNegotiatedMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspNegotiatedMTU.setDescription('The value of vRtrMplsLspNegotiatedMTU specifies the size \n         for the Maximum transmission unit (MTU) that is negotiated\n         during LSP establishment.')
vRtrMplsLspRsvpResvStyle = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("se", 1), ("ff", 2))).clone('se')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRsvpResvStyle.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRsvpResvStyle.setDescription("The value of vRtrMplsLspRsvpResvStyle specifies the reservation \n             style for RSVP. The reservation style can be set to 'Shared- \n             Explicit' (se) or 'Fixed-Filter' (ff).")
vRtrMplsLspRsvpAdspec = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 29), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRsvpAdspec.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRsvpAdspec.setDescription("When the value of vRtrMplsLspRsvpAdspec is 'true', the ADSPEC\n         object will be included in RSVP messages. \n         When the value of vRtrMplsLspRsvpAdspec is 'false', the ADSPEC\n         object will not be included in RSVP messages.")
vRtrMplsLspFRMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oneToOneBackup", 1), ("facilityBackup", 2))).clone('oneToOneBackup')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRMethod.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRMethod.setDescription("The value of vRtrMplsLspFRMethod specifies the fast reroute \n             method used. \n             \n             In the 'One-to-one Backup' method, a backup LSP is established \n             which will intersect the original LSP somewhere downstream\n             of the point of link or node failure. For each LSP that is \n             backed up, a separate backup LSP is established.\n             \n             In the 'Facility Backup' method, instead of creating a separate\n             LSP for every LSP that is to be backed up, a single LSP is \n             created which serves as a backup for a set of LSPs. Such an LSP\n             tunnel is called a 'bypass tunnel'.")
vRtrMplsLspFRNodeProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 31), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRNodeProtect.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRNodeProtect.setDescription("Setting the value of vRtrMplsLspFRNodeProtect to 'true' enables\n         node protection i.e. protection against the failure of a node on\n         the LSP. \n\n         Setting the value to 'false' disables node protection.")
vRtrMplsLspAdminGroupInclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 32), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupInclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupInclude.setDescription("The value of vRtrMplsLspAdminGroupInclude is a bit-map that\n         specifies a list of admin groups that should be included when\n         this LSP is setup. If bit 'n' is set, then the admin group \n         with value 'n' is included for this LSP. This implies that \n         each link that this LSP goes through must be associated with  \n         at least one of the admin groups in the include list.\n\n         By default, all admin groups are in the include list.")
vRtrMplsLspAdminGroupExclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 33), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupExclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupExclude.setDescription("The value of vRtrMplsLspAdminGroupExclude is a bit-map that\n         specifies a list of admin groups that should be excluded when\n         this LSP is setup. If bit 'n' is set, then the admin group \n         with value 'n' is excluded for this LSP. This implies that \n         each link that this LSP goes through must not be associated\n         with any of the admin groups in the exclude list.\n\n         By default, no admin groups are in the exclude list.")
vRtrMplsLspAdaptive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 34), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdaptive.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdaptive.setDescription("Setting the value of vRtrMplsLspAdaptive to 'true' enables\n         make-before-break functionality for the LSP. When the attributes\n         of an already established LSP are changed, either through manual \n         configuration or due to a change in network topology, \n         make-before-break functionality ensures that the resources of \n         the existing LSP will not be released until a new path (with the\n         same LSP Id) has been established and traffic flowing over the \n         existing path is seamlessly transferred to the new path.\n         \n         Setting the value to 'false' disables make-before-break \n         functionality.")
vRtrMplsLspInheritance = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 35), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspInheritance.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspInheritance.setDescription("For each writable object in this row that can be configured to\n         inherit its value from the corresponding object in the \n         vRtrMplsGeneralTable, there is bit within vRtrMplsLspInheritance\n         that controls whether to inherit the operational value of the\n         object or use the administratively set value. \n\n         This object is a bit-mask, with the following positions:\n\n         vRtrMplsLspOptimizeTimer                0x1\n         vRtrMplsLspFRObject                     0x2\n\n         When the bit for an object is set to one, then the object's \n         administrative and operational value are whatever the DEFVAL \n         or most recently SET value is.\n         \n         When the bit for an object is set to zero, then the object's \n         administrative and operational value are inherited from the \n         corresponding object in vRtrMplsGeneralTable.")
vRtrMplsLspOptimizeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspOptimizeTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOptimizeTimer.setDescription('The value of vRtrMplsLspOptimizeTimer specifies the time, in \n         seconds, the software will wait before attempting to re-optimize\n         the LSP.\n\n         When CSPF is enabled, changes in the network topology may cause\n         the existing path of a loose-hop LSP to become sub-optimal. Such\n         LSPs can be re-optimized and re-routed through more optimal paths\n         by recalculating the path for the LSP at periodic intervals. This\n         interval is controlled by the optimize timer.\n         \n         A value of 0 indicates that optimization has been disabled.\n\n         When the vRtrMplsLspOptimizeTimer bit in vRtrMplsLspInheritance\n         is cleared (0), the value returned in the GET request is inherited \n         from vRtrMplsGeneralOptimizeTimer.')
vRtrMplsLspOperFastReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 37), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOperFastReroute.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOperFastReroute.setDescription('The value of vRtrMplsLspOperFastReroute specifies whether the\n         operational LSP has fast reroute enabled or disabled. \n\n         When make-before-break functionality for the LSP is enabled and\n         if the fast reroute setting is changed, the resources for the \n         existing LSP will not be released until a new path with the new \n         attribute settings has been established. While a new path is \n         being signaled, the administrative value and the operational \n         values of fast reroute setting for the LSP may differ. The value\n         of vRtrMplsLspFastReroute specifies the setting used for the new\n         LSP path trying to be established whereas the value of \n         vRtrMplsLspOperFastReroute specifies the setting for the existing \n         LSP path.')
vRtrMplsLspFRObject = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 38), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRObject.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRObject.setDescription("The value of vRtrMplsLspFRObject specifies whether fast reroute,\n         for LSPs using 'Facility Backup', is signalled with or without\n         the fast reroute object. The value of vRtrMplsLspFRObject is\n         ignored if fast reroute is disabled for the LSP or if the LSP\n         is using 'One-to-one Backup'.\n\n         When the vRtrMplsLspFRObject bit in vRtrMplsLspInheritance is \n         cleared (0), the value returned in the GET request is inherited \n         from vRtrMplsGeneralFRObject.")
vRtrMplsLspHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 39), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspHoldTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspHoldTimer.setDescription('The value of vRtrMplsLspHoldTimer specifies the time, in \n         seconds, for which the ingress node holds a bit before \n         programming its data plane and declaring the lsp up to  \n         the service module. \n        \n         The value of vRtrMplsLspHoldTimer is inherited from \n         the value of vRtrMplsGeneralHoldTimer.')
vRtrMplsLspCspfTeMetricEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 40), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspCspfTeMetricEnabled.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspCspfTeMetricEnabled.setDescription("The value of vRtrMplsLspCspfTeMetricEnabled specifies whether the TE \n         metric would be used for the purpose of the LSP path computation by CSPF.\n         When the value of this object is 'false', the IGP metric is used to \n         compute the path of the LSP by CSPF.")
vRtrMplsLspStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2), )
if mibBuilder.loadTexts: vRtrMplsLspStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspStatTable.setDescription('The vRtrMplsLspStatTable has an entry for each Labeled Switch\n         Path (LSP) configured for a virtual router in the system.')
vRtrMplsLspStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1), )
vRtrMplsLspEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspStatEntry"))
vRtrMplsLspStatEntry.setIndexNames(*vRtrMplsLspEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsLspStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspStatEntry.setDescription('Each row entry represents a collection of statistics for a\n         Labeled Switch Path (LSP) configured for a virtual router in \n         the system.  \n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsLspOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOctets.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOctets.setDescription('The number of octets that have been forwarded over current \n         LSP active path. The number reported is not realtime, may \n         be subject to several minutes delay.  The delay is controllable\n         by MPLS statistics gathering interval, which by default is \n         once every 5 minutes.  If MPLS statistics gathering is not\n         enabled, this number will not increment.')
vRtrMplsLspPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPackets.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPackets.setDescription('The number of packets that have been forwarded over current \n         LSP active path. The number reported is not realtime, may \n         be subject to several minutes delay.  The delay is controllable\n         by MPLS statistics gathering interval, which by default is \n         once every 5 minutes.  If MPLS statistics gathering is not\n         enabled, this number will not increment.')
vRtrMplsLspAge = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 3), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspAge.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAge.setDescription('The age (i.e., time from creation till now) of this LSP in \n         10-millisecond periods.')
vRtrMplsLspTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 4), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspTimeUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTimeUp.setDescription('The total time in 10-millisecond units that this LSP has been\n         been operational.  For example, the percentage up time can be \n         determined by computing (vRtrMplsLspTimeUp/vRtrMplsLspAge * 100 %).')
vRtrMplsLspTimeDown = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 5), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspTimeDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTimeDown.setDescription('The total time in 10-millisecond units that this LSP has not \n         been operational.')
vRtrMplsLspPrimaryTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 6), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPrimaryTimeUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPrimaryTimeUp.setDescription("The total time in 10-millisecond units that this LSP's primary \n         path has been operational.  For example, the percentage \n         contribution of the primary path to the operational time is \n         given by (vRtrMplsLspPrimaryTimeUp/vRtrMplsLspTimeUp * 100) %.")
vRtrMplsLspTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspTransitions.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTransitions.setDescription('The number of state transitions (up -> down and down -> up) \n         this LSP has undergone.')
vRtrMplsLspLastTransition = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 8), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspLastTransition.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspLastTransition.setDescription('The time in 10-millisecond units since the last transition \n         occurred on this LSP.')
vRtrMplsLspPathChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathChanges.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathChanges.setDescription('The number of path changes this LSP has had. For every path \n         change (path down, path up, path change), a corresponding \n         syslog/trap (if enabled) is generated for it.')
vRtrMplsLspLastPathChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 10), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspLastPathChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspLastPathChange.setDescription('The time in 10-millisecond units since the last change \n         occurred on this LSP.')
vRtrMplsLspConfiguredPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspConfiguredPaths.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspConfiguredPaths.setDescription('The number of paths configured for this LSP.')
vRtrMplsLspStandbyPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspStandbyPaths.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspStandbyPaths.setDescription('The number of standby paths configured for this LSP.')
vRtrMplsLspOperationalPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOperationalPaths.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOperationalPaths.setDescription('The number of operational paths for this LSP. This includes\n         the path currently active, as well as operational standby \n         paths.')
vRtrMplsLspPathTableSpinlock = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 3), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrMplsLspPathTableSpinlock.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTableSpinlock.setDescription('voluntary serialization control for vRtrMplsLspPathTable.  \n         Primarily used by SNMP manager to coordinate changes to \n         vRtrMplsLspPathInheritance.')
vRtrMplsLspPathTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4), )
if mibBuilder.loadTexts: vRtrMplsLspPathTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTable.setDescription('The vRtrMplsLspPathTable provides an association between an\n         LSP and a path.  An LSP can have more than one path association,\n         but only one of those paths can be specified as the primary\n         path type.  Paths are defined in as Tunnel entries in the\n         mplsTunnelTable in the MPLS-TE-MIB.')
vRtrMplsLspPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), (0, "MPLS-TE-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-MIB", "mplsTunnelIngressLSRId"))
if mibBuilder.loadTexts: vRtrMplsLspPathEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathEntry.setDescription("Each row entry represents an association between a Labeled Switch\n         Path (LSP) in the vRtrMplsLspTable and a path (or tunnel) entry in\n         the mplsTunnelTable.  Entries in this table can be created and\n         deleted via SNMP SET operations.  Setting RowStatus to 'active'\n         requires vRtrMplsLspPathType to have been assigned a valid value.")
vRtrMplsLspPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRowStatus.setDescription("The row status used for creation, deletion, or control\n         of vRtrMplsLspPathTable entries.  Before the row can be\n         placed into the 'active' state vRtrMplsLspPathType must\n         have been assigned a valid value.")
vRtrMplsLspPathLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathLastChange.setDescription('The sysUpTime when this row was last modified.')
vRtrMplsLspPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("primary", 2), ("standby", 3), ("secondary", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathType.setDescription('This variable is an enum that represents the role this\n         path is taking within this LSP.')
vRtrMplsLspPathCos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(255, 255), )).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathCos.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathCos.setDescription('The configured Class Of Service (COS) for this path.  If\n         the value is between 0 and 7 inclusive, this value\n         will be inserted in the 3 bit COS field in the label.\n         If the value is 255, the value in the COS field of\n         the label will depend on other factors.')
vRtrMplsLspPathProperties = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 5), Bits().clone(namedValues=NamedValues(("record-route", 0), ("adaptive", 1), ("cspf", 2), ("mergeable", 3), ("fast-reroute", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathProperties.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathProperties.setDescription('The set of configured properties for this path expressed\n         as a bit map.  For example, if the path is an adaptive\n         path, the bit corresponding to bit value 1 is set.')
vRtrMplsLspPathBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 6), Integer32()).setUnits('mega-bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathBandwidth.setDescription('The value of vRtrMplsLspPathBandwidth specifies the amount\n         of bandwidth in mega-bits per seconds (Mbps) to be reserved\n         for this LSP path.  A value of zero (0) indicates that no\n         bandwidth is reserved.')
vRtrMplsLspPathBwProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathBwProtect.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathBwProtect.setDescription("When vRtrMplsLspPathBwProtect has a value of 'true', bandwidth\n         protection is enabled on a LSP.  LSPs that reserve bandwidth\n         will be used for EF services where customers need guaranteed\n         bandwidth.  It is expected that multiple EF services will be\n         assigned to a single LSP.  When bandwidth protection is\n         enabled on an LSP, each time this LSP is used for a certain\n         service the bandwidth allocated on that service is deducted\n         from the bandwidth reserved for the LSP.  Once the bandwidth is\n         exhausted on the LSP, the ESR will provide feedback to the\n         provider indicating that this LSP has exhausted its resources.")
vRtrMplsLspPathState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("inactive", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathState.setDescription('The current working state of this path within this LSP.')
vRtrMplsLspPathPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathPreference.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathPreference.setDescription("When there is no path in the LSP with vRtrMplsLspPathType\n         value of 'primary', 'secondary' type paths of this LSP \n         with the same value of vRtrMplsLspPathPreference are used\n         for load sharing.  When a 'primary' type path exists in\n         the LSP, vRtrMplsLspPathPreference is used to denote at\n         which priority one 'secondary' path will supercede another\n         when the 'primary' fails. 1 indicates the highest priority \n         value.\n         \n         When the vRtrMplsLspPathPreference bit in \n         vRtrMplsLspPathInheritance is cleared (0), the value returned \n         to a GET request is inherited from vRtrMplsLspPreference.")
vRtrMplsLspPathCosSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathCosSource.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathCosSource.setDescription("When vRtrMplsLspPathCosSource is set to 'true', the value of\n         vRtrMplsLspPathClassOfService overrides vRtrMplsLspClassOfService.\n         When 'false', the value of vRtrMplsLspClassOfService is used.")
vRtrMplsLspPathClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 11), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathClassOfService.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathClassOfService.setDescription("The name of the class of service value to be assigned to all\n         packets on the LSP is specified with vRtrMplsLspPathClassOfService.\n         The EXP bits in the MPLS header are set based on the global\n         mapping table that specified the mapping between the forwarding\n         class and the EXP bits.  When class of service is specified,\n         all packets will be marked with the same EXP bits that match\n         the vRtrMplsLspPathClassOfService name in the mapping table.\n         \n         An empty string, ''H, specifies no class of service.  Packets\n         are assigned EXP bits based on the same mapping table, however\n         each packet is marked with EXP bits based on the forwarding\n         class from which it is serviced.")
vRtrMplsLspPathSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathSetupPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathSetupPriority.setDescription('The value of vRtrMplsLspPathSetupPriority specifies the setup \n         priority to use when insufficient bandwidth is available to setup \n         a LSP.  The setup priority is compared against the hold priority of\n         existing LSPs.  If the setup priority is higher than the hold\n         priority of the established LSPs, this LSP may preempt the other\n         LSPs.  A value of zero (0) is the highest priority and a value\n         of seven (7) is the lowest priority.\n         \n         When the vRtrMplsLspPathHopLimit bit in vRtrMplsLspPathInheritance \n         is cleared (0), the value returned to a GET request is inherited \n         from vRtrMplsLspHopLimit.')
vRtrMplsLspPathHoldPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathHoldPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathHoldPriority.setDescription('The value of vRtrMplsLspPathHoldPriority specifies the hold \n         priority to use when insufficient bandwidth is available to setup \n         a LSP.  The setup priority is compared against the hold priority of\n         existing LSPs.  If the setup priority is higher than the hold\n         priority of the established LSPs, this LSP may preempt the other\n         LSPs.  A value of zero (0) is the highest priority and a value\n         of seven (7) is the lowest priority.\n         \n         When the vRtrMplsLspPathHopLimit bit in vRtrMplsLspPathInheritance \n         is cleared (0), the value returned to a GET request is inherited \n         from vRtrMplsLspHopLimit.')
vRtrMplsLspPathRecord = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("record", 1), ("noRecord", 2))).clone('record')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathRecord.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRecord.setDescription("When the value of vRtrMplsLspPathRecord is 'record', recording of \n         all the hops that a LSP traverses is enabled.\n         \n         When the value of vRtrMplsLspPathRecord is 'noRecord', recording \n         of all the hops that a LSP traverses is disabled.")
vRtrMplsLspPathHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathHopLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathHopLimit.setDescription('The value of vRtrMplsLspPathHopLimit specifies the maximum number\n         of hops that a LSP will traverse including the ingress and\n         egress ESRs.  A LSP will not be setup if the hop limit is\n         exceeded.  \n         \n         When the vRtrMplsLspPathHopLimit bit in vRtrMplsLspPathInheritance \n         is cleared (0), the value returned to a GET request is inherited \n         from vRtrMplsLspHopLimit.')
vRtrMplsLspPathSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathSharing.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathSharing.setDescription("When vRtrMplsLspPathSharing has a value of 'true', path-sharing\n         is enabled for the secondary path.  Path-sharing is used to\n         control the hops of the secondary path.\n         \n         When vRtrMplsLspPathSharing have a value of 'false', CSPF attempts\n         to find a path for the secondary that does not include any node\n         or link that is common to the active primary path.\n         \n         This variable is valid only if vRtrMplsLspPathType is set to\n         'secondary'.")
vRtrMplsLspPathAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 17), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdminState.setDescription('The desired administrative state for this LSP path.')
vRtrMplsLspPathOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 18), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOperState.setDescription('The current operational state of this LSP path.')
vRtrMplsLspPathInheritance = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 19), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathInheritance.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathInheritance.setDescription("For each writable object in this row that can be configured to\n         inherit its value from its corresponding object in the \n         vRtrMplsLspTable, controls whether to inherit the operational value \n         of that object, or use the administratively set value.\n        \n         This object is a bit-mask, with the following positions:\n\n         vRtrMplsLspPathBandwidth               0x10\n         vRtrMplsLspPathPreference              0x80\n         vRtrMplsLspPathSetupPriority          0x400\n         vRtrMplsLspPathHoldPriority           0x800\n         vRtrMplsLspPathHopLimit              0x2000\n         vRtrMplsLspPathAdminGroupInclude    0x20000\n         vRtrMplsLspPathAdminGroupExclude    0x40000\n         vRtrMplsLspPathAdaptive             0x80000\n         vRtrMplsLspPathOptimizeTimer       0x100000\n\n         When the bit for an object is set to one, then the\n         object's administrative and operational value are whatever\n         the DEFVAL or most recently SET value is.\n        \n         When the bit for an object is set to zero, then the\n         object's administrative and operational value are inherited\n         from the corresponding object in vRtrMplsLspTable.")
vRtrMplsLspPathLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 20), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathLspId.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathLspId.setDescription('This value identifies the label switched path that\n         is signaled for this entry.')
vRtrMplsLspPathRetryTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathRetryTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRetryTimeRemaining.setDescription('The time in 10-millisecond units to signal this path.')
vRtrMplsLspPathTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelARHopListIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelARHopListIndex.setDescription('Primary index into the mplsTunnelARHopTable identifying a\n         particular recorded hop list. A value of 0 implies that there\n         is no recored hop list associated with this LSP path.')
vRtrMplsLspPathNegotiatedMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathNegotiatedMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathNegotiatedMTU.setDescription('The value of vRtrMplsLspPathNegotiatedMTU specifies the size \n         for the Maximum transmission unit (MTU) that is negotiated\n         during establishment of this LSP Path.')
vRtrMplsLspPathFailCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 24), TmnxMplsLspFailCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathFailCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathFailCode.setDescription('The value of vRtrMplsLspPathFailCode specifies the reason code\n         for LSP Path failure. A value of 0 indicates that no failure \n         has occurred.')
vRtrMplsLspPathFailNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 25), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathFailNodeAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathFailNodeAddr.setDescription('The value of vRtrMplsLspPathFailNodeAddr specifies the IP address\n         of the node in the LSP path at which the LSP path failed. When \n         no failure has occurred, this value is 0.')
vRtrMplsLspPathAdminGroupInclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 26), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupInclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupInclude.setDescription("The value of vRtrMplsLspPathAdminGroupInclude is a bit-map that\n         specifies a list of admin groups that should be included when\n         this LSP path is setup. If bit 'n' is set, then the admin group \n         with value 'n' is included for this LSP path. This implies that \n         each link that this LSP path goes through must be associated with  \n         at least one of the admin groups in the include list.\n\n         When the vRtrMplsLspPathAdminGroupInclude bit in \n         vRtrMplsLspPathInheritance is cleared (0), the value returned \n         to a GET request is inherited from vRtrMplsLspAdminGroupInclude.")
vRtrMplsLspPathAdminGroupExclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 27), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupExclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupExclude.setDescription("The value of vRtrMplsLspPathAdminGroupExclude is a bit-map that\n         specifies a list of admin groups that should be excluded when\n         this LSP path is setup. If bit 'n' is set, then the admin group \n         with value 'n' is excluded for this LSP path. This implies that \n         each link that this LSP path goes through must not be associated\n         with any of the admin groups in the exclude list.\n\n         When the vRtrMplsLspPathAdminGroupExclude bit in \n         vRtrMplsLspPathInheritance is cleared (0), the value returned \n         to a GET request is inherited from vRtrMplsLspAdminGroupExclude.")
vRtrMplsLspPathAdaptive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 28), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdaptive.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdaptive.setDescription("Setting the value of vRtrMplsLspPathAdaptive to 'true', enables\n         make-before-break functionality for the LSP path.          \n         \n         Setting the value to 'false', disables make-before-break \n         functionality for the path.\n\n         When the vRtrMplsLspPathAdaptive bit in vRtrMplsLspPathInheritance \n         is cleared (0), the value returned to a GET request is inherited \n         from vRtrMplsLspAdaptive.")
vRtrMplsLspPathOptimizeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathOptimizeTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOptimizeTimer.setDescription('The value of vRtrMplsLspPathOptimizeTimer specifies the time, in \n         seconds, the software will wait before attempting to re-optimize\n         the LSP path.\n\n         When CSPF is enabled, changes in the network topology may cause\n         the existing path of a loose-hop LSP to become sub-optimal. Such\n         LSPs can be re-optimized and re-routed through more optimal paths\n         by recalculating the path for the LSP at periodic intervals. This\n         interval is controlled by the optimize timer.\n         \n         A value of 0 indicates that optimization has been disabled.\n\n         When the vRtrMplsLspPathOptimizeTimer bit in \n         vRtrMplsLspPathInheritance is cleared (0), the value returned in\n         the GET request is inherited from vRtrMplsLspOptimizeTimer.')
vRtrMplsLspPathNextOptimize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathNextOptimize.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathNextOptimize.setDescription('The value of vRtrMplsLspPathNextOptimize specifies the current value\n         of the optimize timer. This is the time, in seconds, remaining till\n         the optimize timer will expire and optimization will be started for\n         the LSP path.')
vRtrMplsLspPathOperBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 31), Integer32()).setUnits('mega-bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathOperBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOperBandwidth.setDescription('The value of vRtrMplsLspPathOperBandwidth specifies the amount of\n         bandwidth in mega-bits per seconds (Mbps) that has been reserved\n         for the operational LSP path.\n\n         When make-before-break functionality for the LSP is enabled and \n         if the path bandwidth is changed, the resources allocated to the \n         existing LSP paths will not be released until a new path with \n         the new bandwidth settings has been established. While a new path \n         is being signaled, the administrative value and the operational \n         values of the path bandwidth may differ. The value of \n         vRtrMplsLspPathBandwidth specifies the bandwidth requirements for \n         the new LSP path trying to be established whereas the value of \n         vRtrMplsLspPathOperBandwidth specifies the bandwidth reserved \n         for the existing LSP path.')
vRtrMplsLspPathMBBState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("inProgress", 3), ("fail", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathMBBState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathMBBState.setDescription('The value of vRtrMplsLspPathMBBState specifies the state of the \n         most recent invocation of the make-before-break functionality. \n\n         Possible states are:\n\n         none (1)        - no make-before-break invoked \n         success (2)     - make-before-break successful\n         inProgress (3)  - make-before-break in progress \n         fail (4)        - make-before-break failed.')
vRtrMplsLspPathResignal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 33), TmnxActionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathResignal.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathResignal.setDescription("Setting the value of vRtrMplsLspPathResignal to 'doAction' triggers\n         the re-signaling of the LSP path. \n\n         If the LSP path is operationally down either due to network failure\n         or due to the retry attempts count being exceeded, setting this \n         variable to 'doAction' will initiate the signaling for the path. A \n         make-before-break signaling for the path will be initiated if the \n         LSP is operationally up but the make-before-break retry attempts \n         count was exceeded. Make-before-break signaling will also be \n         initiated for any LSP that is operationally up. This may be used \n         to cause a loose-hop LSP to be optimized. \n\n         If a re-signal is triggered while a re-signaling is already in \n         progress, the old transient state will be destroyed and a new \n         transaction being triggered.\n         \n         An SNMP GET request on this object should return 'notApplicable'.")
vRtrMplsLspPathTunnelCRHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelCRHopListIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelCRHopListIndex.setDescription('Primary index into the vRtrMplsTunnelCHopTable identifying a\n         particular computed hop list. A value of 0 implies that there\n         is no computed hop list associated with this LSP path.')
vRtrMplsLspPathOperMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 35), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathOperMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOperMTU.setDescription('The value of vRtrMplsLspPathOperMTU specifies the size \n         for the Maximum transmission unit (MTU) that is currently\n         operation for this LSP Path.')
vRtrMplsLspPathRecordLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("record", 1), ("noRecord", 2))).clone('record')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathRecordLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRecordLabel.setDescription("When the value of vRtrMplsLspPathRecordLabel is 'record', \n         recording of labels at each node that a LSP traverses is \n         enabled.\n         \n         When the value of vRtrMplsLspPathRecordLabel is 'noRecord', \n         recording of labels at each node that a LSP traverses is \n         disabled.")
vRtrMplsLspPathStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5), )
if mibBuilder.loadTexts: vRtrMplsLspPathStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathStatTable.setDescription('The vRtrMplsLspPathStatTable has an entry for an association \n         between a Labeled Switch Path (LSP) in the vRtrMplsLspTable \n         and a path (or tunnel) entry in the mplsTunnelTable.')
vRtrMplsLspPathStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1), )
vRtrMplsLspPathEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathStatEntry"))
vRtrMplsLspPathStatEntry.setIndexNames(*vRtrMplsLspPathEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsLspPathStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathStatEntry.setDescription('Each row entry represents a collection of statistics for \n         an association between a Labeled Switch Path (LSP) in the \n         vRtrMplsLspTable and a path (or tunnel) entry in the \n         mplsTunnelTable. \n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsLspPathTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 1), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTimeUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTimeUp.setDescription('The total time in 10-millisecond units that this LSP path has\n         been operational.  For example, the percentage up time can be\n         determined by computing (vRtrMplsLspPathTimeUp/vRtrMplsLspAge * 100 %).')
vRtrMplsLspPathTimeDown = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 2), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTimeDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTimeDown.setDescription('The total time in 10-millisecond units that this LSP Path has \n         not been operational.')
vRtrMplsLspPathRetryAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathRetryAttempts.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRetryAttempts.setDescription('The number of unsuccessful attempts which have been made to \n         signal this path. As soon as the path gets signalled, this is\n         set to 0.')
vRtrMplsLspPathTransitionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTransitionCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTransitionCount.setDescription('The object vRtrMplsLspPathTransitionCount maintains the number\n         of transitions that have occurred for this LSP.')
vRtrMplsLspPathCspfQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathCspfQueries.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathCspfQueries.setDescription('The value of vRtrMplsLspPathCspfQueries specifies the number \n         of CSPF queries that have been made for this LSP path.')
vRtrMplsXCTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6), )
if mibBuilder.loadTexts: vRtrMplsXCTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCTable.setDescription('This table has an entry for each mplsXCEntry\n         in the mplsXCTable.  It serves as an another\n         indirect index to the mplsXCTable.')
vRtrMplsXCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsXCLspId"))
if mibBuilder.loadTexts: vRtrMplsXCEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCEntry.setDescription('An entry in this table represents the indices\n         to be used to search the mplsXCTable.')
vRtrMplsXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsXCIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCIndex.setDescription('An index of the mplsXCTable. It represents \n         mplsXCIndex, a field of the mplsXCTable.')
vRtrMplsInSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsInSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsInSegmentIfIndex.setDescription('An index of the mplsXCTable.  It represents\n         mplsInSegmentIfIndex of the mplsInSegmentTable.')
vRtrMplsInSegmentLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 3), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsInSegmentLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsInSegmentLabel.setDescription('An index of the mplsXCTable. It represents \n         mplsInSegmentLabel of the mplsInSegmentTable.')
vRtrMplsOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsOutSegmentIndex.setDescription('An index of the mplsXCTable. It represents \n         mplsOutSegmentIndex of the mplsOutSegmentTable.')
vRtrMplsERHopTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsERHopTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsERHopTunnelIndex.setDescription('Primary index into the mplsTunnelHopTable identifying a particular\n         recorded hop list (stores ERO in LSR).')
vRtrMplsARHopTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsARHopTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsARHopTunnelIndex.setDescription('Primary index into the mplsTunnelARHopTable identifying a particular\n         recorded hop list (stores RRO in LSR).')
vRtrMplsRsvpSessionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsRsvpSessionIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsRsvpSessionIndex.setDescription('An index into the vRtrRsvpSessionTable identifying a particular RSVP \n         session.')
vRtrMplsXCFailCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 8), TmnxMplsLspFailCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsXCFailCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCFailCode.setDescription('The value of vRtrMplsXCFailCode specifies the reason code for\n         cross-connect failure. A value of 0 indicates that no failure \n         occurred.')
vRtrMplsXCCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsXCCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCCHopTableIndex.setDescription('Index to the vRtrMplsTunnelCHopTable entries that specify \n         the hops for the CSPF path for a detour LSP for this tunnel.')
vRtrMplsGeneralTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7), )
if mibBuilder.loadTexts: vRtrMplsGeneralTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralTable.setDescription('The vRtrMplsGeneralTable contains objects for general control and\n         management of an MPLS protocol instance within a virtual router.')
vRtrMplsGeneralEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"))
if mibBuilder.loadTexts: vRtrMplsGeneralEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralEntry.setDescription("Each row entry represents an instance of the MPLS protocol running\n         within a virtual router.  Entries in this table cannot be \n         created and deleted via SNMP SET operations.  An entry in this table\n         is created by the agent when vRtrMplsStatus in the vRtrConfTable is\n         set to 'create'.  The entry is destroyed when vRtrMplsStatus is set\n         to 'delete'")
vRtrMplsGeneralLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralLastChange.setDescription('The sysUpTime when this row was last modified.')
vRtrMplsGeneralAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 2), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralAdminState.setDescription("When vRtrMplsGeneralAdminState is set to 'inService', the agent\n         attempts to enable the MPLS protocol instance on this router.\n         \n         When vRtrMplsGeneralAdminState is set to 'outOfService', the\n         agent attempts to disable the MPLS protocol instance on this\n         router.")
vRtrMplsGeneralOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 3), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralOperState.setDescription('vRtrMplsGeneralOperState indicates the current operating state\n         of this MPLS protocol instance on this router.')
vRtrMplsGeneralPropagateTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 4), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralPropagateTtl.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralPropagateTtl.setDescription("When vRtrMplsGeneralPropagateTtl is set to 'true', for all LSPs,\n         the ingress ESR writes the TTL of the IP packet in the label and \n         each transit ESR decrements the TTL in the label.  At the egress \n         ESR the TTL value from the label is written into the IP packet.\n         \n         When vRtrMplsGeneralPropagateTtl is set to 'false', the ingress\n         ESR ignores the IP packet TTl and writes the value of 255 into\n         the label, while the egress ESR does not write the label TTL\n         into the IP packet.  This assumes that all ESRs have been\n         configured to have vRtrMplsGeneralPropagateTtl set to 'false',\n         or this may result in unpredictable behavior.")
vRtrMplsGeneralTE = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("bgp", 2), ("bgpigp", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralTE.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralTE.setDescription('The value of vRtrMplsGeneralTE specifies the type of traffic\n         engineering used with this MPLS instance.')
vRtrMplsGeneralNewLspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 6), TestAndIncr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralNewLspIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralNewLspIndex.setDescription("This object is used to assign values to vRtrMplsLspIndex as\n         described in 'Textual Conventions for SNMPv2'.  The network\n         manager reads the object, and then writes the value back\n         in the SET request that creates a new instance of \n         vRtrMplsLspEntry.  If the SET fails with the code \n         'inconsistentValue', then the process must be repeated.  \n         If the the SET succeeds, then the object is incremented \n         and the new instance is created according to the manager's \n         directions.")
vRtrMplsGeneralOptimizeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralOptimizeTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralOptimizeTimer.setDescription('The value of vRtrMplsGeneralOptimizeTimer specifies the time, in \n         seconds, the software will wait before attempting to re-optimize\n         the LSPs.\n\n         When CSPF is enabled, changes in the network topology may cause\n         the existing path of a loose-hop LSP to become sub-optimal. Such\n         LSPs can be re-optimized and re-routed through more optimal paths\n         by recalculating the path for the LSP at periodic intervals. This\n         interval is controlled by the optimize timer.\n         \n         A value of 0 indicates that optimization has been disabled.\n\n         The value for vRtrMplsGeneralOptimizeTimer is by default inherited \n         by all LSPs and their paths.')
vRtrMplsGeneralFRObject = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralFRObject.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralFRObject.setDescription("The value of vRtrMplsGeneralFRObject specifies whether fast reroute, \n         for LSPs using 'Facility Backup', is signalled with or without the\n         fast reroute object. The value of vRtrMplsGeneralFRObject is ignored\n         if fast reroute is disabled for the LSP or if the LSP is using\n         'One-to-one Backup'.\n\n         The value for vRtrMplsGeneralFRObject is by default inherited by\n         all LSPs.")
vRtrMplsGeneralResignalTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 9), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(30, 10080), ))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralResignalTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralResignalTimer.setDescription('The value of vRtrMplsGeneralResignalTimer specifies the value \n         for the LSP resignal timer, that is the time, in minutes, the \n         software will wait before attempting to resignal the LSPs. \n\n         When the resignal timer expires, if the new recorded hop list\n         (RRO) for an LSP has a better metric than the current recorded \n         hop list, an attempt will be made to resignal that LSP using\n         the make-before-break mechanism. If the attempt to resignal\n         an LSP fails, the LSP will continue to use the existing path \n         and a resignal will be attempted the next time the timer expires.\n         \n         A value of 0 for the resignal timer indicates that timer-based\n         LSP resignalling has been disabled.')
vRtrMplsGeneralHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralHoldTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralHoldTimer.setDescription('The value of vRtrMplsGeneralHoldTimer specifies the time, in \n        seconds, for which the ingress node holds a bit before \n        programming its data plane and declaring the lsp up to \n        the service module. \n        \n        A value of 0 indicates that the hold timer has been disabled.')
vRtrMplsGeneralDynamicBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 11), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicBypass.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicBypass.setDescription('The value of vRtrMplsGeneralDynamicBypass specifies whether \n         dynamic bypass tunnels are enabled.  \n\n         By default, dynamic bypass tunnels are enabled.')
vRtrMplsGeneralNextResignal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralNextResignal.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralNextResignal.setDescription('The value of vRtrMplsGeneralNextResignal indicates the time \n        remaining, in minutes, for the vRtrMplsGeneralResignalTimer to expire.')
vRtrMplsGeneralOperDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 13), TmnxMplsOperDownReasonCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralOperDownReason.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralOperDownReason.setDescription('The value of vRtrMplsGeneralOperDownReason indicates the reason \n         due to which the MPLS instance is operationally down.')
vRtrMplsGeneralSrlgFrr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrr.setDescription("The value of vRtrMplsGeneralSrlgFrr specifies whether Shared Risk\n         Link Group (SRLG) constraint will be used in the computation of \n         FRR bypass or detour to be associated with any primary LSP path \n         on the system.  When the value of vRtrMplsGeneralSrlgFrr is \n         'true' the use of SRLG constraint is enabled. \n\n         By default, the use of SRLG constraint is disabled.")
vRtrMplsGeneralSrlgFrrStrict = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrrStrict.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrrStrict.setDescription("The value of vRtrMplsGeneralSrlgFrrStrict specifies whether \n         to associate the LSP with a bypass or signal a detour if a \n         bypass or detour satisfies all other constraints except the SRLG \n         constraints.  When the value of vRtrMplsGeneralSrlgFrrStrict is\n         'true' and a path that meets SRLG constraints is not found, the \n         bypass or detour is not setup. If this value is set to 'true'\n         when vRtrMplsGeneralSrlgFrr is set to 'false', vRtrMplsGeneralSrlgFrr\n         is set to 'true' also.\n\n         By default, the value of vRtrMplsGeneralSrlgFrrStrict is 'false'.")
vRtrMplsGeneralStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8), )
if mibBuilder.loadTexts: vRtrMplsGeneralStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStatTable.setDescription('The vRtrMplsGeneralStatTable contains statistics for an MPLS \n         protocol instance within a virtual router.')
vRtrMplsGeneralStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1), )
vRtrMplsGeneralEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStatEntry"))
vRtrMplsGeneralStatEntry.setIndexNames(*vRtrMplsGeneralEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsGeneralStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStatEntry.setDescription('Each row entry represents a collection of statistics for an \n         instance of the MPLS protocol running within a virtual router.\n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsGeneralStaticLspOriginate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspOriginate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspOriginate.setDescription('This object counts the number of static LSPs that originate\n         at this virtual router.')
vRtrMplsGeneralStaticLspTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTransit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTransit.setDescription('This object counts the number of static LSPs that transit \n         through this virtual router.')
vRtrMplsGeneralStaticLspTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTerminate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTerminate.setDescription('This object counts the number of static LSPs that terminate\n         at this virtual router.')
vRtrMplsGeneralDynamicLspOriginate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspOriginate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspOriginate.setDescription('This object counts the number of dynamic LSPs that originate \n         at this virtual router.')
vRtrMplsGeneralDynamicLspTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTransit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTransit.setDescription('This object counts the number of dynamic LSPs that transit\n         through this virtual router.')
vRtrMplsGeneralDynamicLspTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTerminate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTerminate.setDescription('This object counts the number of dynamic LSPs that terminate \n         at this virtual router.')
vRtrMplsGeneralDetourLspOriginate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspOriginate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspOriginate.setDescription('This object counts the number of detour LSPs that originate\n         at this virtual router.')
vRtrMplsGeneralDetourLspTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTransit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTransit.setDescription('This object counts the number of detour LSPs that transit\n         through this virtual router.')
vRtrMplsGeneralDetourLspTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTerminate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTerminate.setDescription('This object counts the number of detour LSPs that terminate\n         at this virtual router.')
vRtrMplsIfTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9), )
if mibBuilder.loadTexts: vRtrMplsIfTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTable.setDescription('The vRtrMplsIfTable has an entry for each router interface \n         configured for MPLS in the system.')
vRtrMplsIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"))
if mibBuilder.loadTexts: vRtrMplsIfEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfEntry.setDescription("Each row entry represents an interface on this virtual router\n         that participates in the MPLS protocol.  A row cannot be created\n         or deleted via SNMP SET requests.  A row with default attribute\n         values is created by setting the vRtrIfEntry attribute, \n         vRtrIfMplsStatus, to 'create'.  A row is removed if \n         vRtrIfMplsStatus is set to 'delete'.  However, an attempt to \n         destroy a row will fail if vRtrMplsIfAdminState has\n         not first been set to 'outOfService'.")
vRtrMplsIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 1), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfAdminState.setDescription('The desired administrative state for the MPLS protocol\n         running on this MPLS interface.')
vRtrMplsIfOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 2), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfOperState.setDescription('This variable indicates the current status of the MPLS protocol\n         running on this MPLS interface.')
vRtrMplsIfAdminGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 3), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfAdminGroup.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfAdminGroup.setDescription("The value of vRtrMplsIfAdminGroup is a bit-map that identifies the\n         admin groups to which the interface belongs. If bit 'n' is set,\n         then the interface belongs to the admin group with value 'n'. \n         \n         By default, the interface does not belong to any admin groups.")
vRtrMplsIfTeMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16777215), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfTeMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTeMetric.setDescription('The value of vRtrMplsIfTeMetric specifies the traffic engineering metric\n         for this interface. The TE metric is exchanged in addition to the IGP \n         metric by the IGPs. Depending on the value configured for \n         vRtrMplsLspCspfTeMetricEnabled, either the TE metric or the native \n         IGP metric is used in CSPF computations of the LSP paths. The maximum \n         value that can be configured is a 24 bit value.')
vRtrMplsIfStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10), )
if mibBuilder.loadTexts: vRtrMplsIfStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfStatTable.setDescription('The vRtrMplsIfStatTable has an entry for each router interface \n         configured for MPLS in the system.')
vRtrMplsIfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1), )
vRtrMplsIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfStatEntry"))
vRtrMplsIfStatEntry.setIndexNames(*vRtrMplsIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsIfStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfStatEntry.setDescription('Each row entry represents a collection of statistics for an\n         interface on this virtual router that participates in the \n         MPLS protocol.  \n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsIfTxPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfTxPktCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTxPktCount.setDescription('The total number of MPLS labeled packets transmitted from this\n         interface.')
vRtrMplsIfRxPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfRxPktCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfRxPktCount.setDescription('The total number of MPLS labeled packets received on this\n         interface.')
vRtrMplsIfTxOctetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfTxOctetCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTxOctetCount.setDescription('The total number of bytes in MPLS labeled packets transmitted\n         on this interface.')
vRtrMplsIfRxOctetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfRxOctetCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfRxOctetCount.setDescription('The total number of bytes in MPLS labeled packets received on\n         this interface.')
vRtrMplsTunnelARHopTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11), )
if mibBuilder.loadTexts: vRtrMplsTunnelARHopTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopTable.setDescription('The vRtrMplsTunnelARHopTable augments the mplsTunnelARHopEntry  \n         in the MPLS-TE-MIB.')
vRtrMplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1), )
mplsTunnelARHopEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopEntry"))
vRtrMplsTunnelARHopEntry.setIndexNames(*mplsTunnelARHopEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsTunnelARHopEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopEntry.setDescription('A row entry in this table corresponds to a row entry in the \n         mplsTunnelARHopTable and adds to the information contained in \n         that table')
vRtrMplsTunnelARHopProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1, 1), Bits().clone(namedValues=NamedValues(("localAvailable", 0), ("localInUse", 1), ("bandwidthProtected", 2), ("nodeProtected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelARHopProtection.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopProtection.setDescription("If the 'localAvailable' bit is set, it indicates that the link \n         downstream of this node has been protected by means of a local\n         repair mechanism. This mechanism can be either the one-to-one \n         backup method or the facility backup method.\n         \n         If the 'localInUse' bit is set, then it indicates that the local\n         protection mechanism is being used to maintain this tunnel.\n\n         If the 'bandwidthProtected' bit is set, then it indicates that \n         the backup path is guaranteed to provide the desired bandwidth.\n         \n         If the 'nodeProtected' bit is set, then it indicates that the\n         backup path provides protection against the failure of the next\n         LSR along the LSP.")
vRtrMplsTunnelARHopRecordLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1, 2), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRecordLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRecordLabel.setDescription('If label recording is enabled, vRtrMplsTunnelARHopRecordLabel \n         specifies the label that is advertised to the previous hop in \n         the hop list. If label recording is disabled, \n         vRtrMplsTunnelARHopRecordLabel will have a value of 4294967295')
vRtrMplsTunnelARHopRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRouterId.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRouterId.setDescription('vRtrMplsTunnelARHopRouterId specifies the router ID of the node\n         corresponding to this hop.')
vRtrMplsTunnelCHopTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12), )
if mibBuilder.loadTexts: vRtrMplsTunnelCHopTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopTable.setDescription('The vRtrMplsTunnelCHopTable is used to hold the CSPF\n         path for a detour LSP. Each entry indicates a single\n         hop.\n\n         Primary index is the vRtrMplsTunnelCHopListIndex which associates \n         multiple entries (hops) in the vRtrMplsTunnelCHopTable to a single \n         mplsTunnelEntry specified in the mplsTunnelTable.\n\n         The first row in the table is the first hop after the\n         origination point of the tunnel.')
vRtrMplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopListIndex"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIndex"))
if mibBuilder.loadTexts: vRtrMplsTunnelCHopEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopEntry.setDescription('An entry in this table represents a CSPF tunnel hop.\n         Entries are created and deleted by the system.')
vRtrMplsTunnelCHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: vRtrMplsTunnelCHopListIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopListIndex.setDescription('Primary index into this table identifying a particular explicit route\n         object.')
vRtrMplsTunnelCHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIndex.setDescription('Secondary index into this table identifying a particular hop.')
vRtrMplsTunnelCHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3), ("lspid", 4))).clone('ipV4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
vRtrMplsTunnelCHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4Addr.setDescription('If vRtrMplsTunnelCHopAddrType is set to ipV4(1), then this value will\n         contain the IPv4 address of this hop. This object is otherwise \n         insignificant and should contain a value of 0.')
vRtrMplsTunnelCHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4PrefixLen.setDescription("If vRtrMplsTunnelCHopAddrType is ipV4(1), then the prefix length for \n         this hop's IPv4 address is contained herein. This object is otherwise\n         insignificant and should contain a value of 0.")
vRtrMplsTunnelCHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6Addr.setDescription('If the vRtrMplsTunnelCHopAddrType is set to ipV6(2), then this \n         variable contains the IPv6 address of this hop. This object is \n         otherwise insignificant and should contain a value of 0.')
vRtrMplsTunnelCHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6PrefixLen.setDescription("If vRtrMplsTunnelCHopAddrType is set to ipV6(2), this value will \n         contain the prefix length for this hop's IPv6 address. This object is\n         otherwise insignificant and should contain a value of 0.")
vRtrMplsTunnelCHopAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAsNumber.setDescription('If vRtrMplsTunnelCHopAddrType is set to asNumber(3), then this value \n         will contain the AS number of this hop. This object is otherwise     \n         insignificant and should contain a value of 0 to indicate this fact.')
vRtrMplsTunnelCHopLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 9), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopLspId.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopLspId.setDescription('If vRtrMplsTunnelCHopAddrType is set to lspid(4), then this value will\n         contain the LSPID of a tunnel of this hop. The present tunnel being \n         configured is tunneled through this hop (using label stacking). This \n         object is otherwise insignificant and should contain a value of 0 to\n         indicate this fact.')
vRtrMplsTunnelCHopStrictOrLoose = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopStrictOrLoose.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopStrictOrLoose.setDescription('Denotes whether this tunnel hop is routed in a strict or loose \n         fashion.')
vRtrMplsAdminGroupTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13), )
if mibBuilder.loadTexts: vRtrMplsAdminGroupTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupTable.setDescription('The vRtrMplsAdminGroupTable has an entry for each administrative\n         group configured for the virtual router in the system. \n         \n         Administrative groups are resource constructs that define a link\n         color or resource class. They provide the ability to classify \n         network resources (links) into groups or colors based on zones, \n         geographic location, link location, etc. By doing so, network\n         administrators are able to do more granular traffic engineering\n         of LSPs.')
vRtrMplsAdminGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (1, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsAdminGroupName"))
if mibBuilder.loadTexts: vRtrMplsAdminGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupEntry.setDescription("Each row entry in the vRtrMplsAdminGroupTable represents an \n         administrative group which is simply a mapping between a group\n         name (an ASCII string) and a group value (a number in the range\n         0 to 31).\n         \n         Entries in this table are created and deleted via SNMP SET \n         operations. An entry is created by setting the value of \n         vRtrMplsAdminGroupRowStatus to 'createAndWait'. The row status\n         for this entry can be set to active only once the value of \n         vRtrMplsAdminGroupValue has been set to a valid number in the\n         range 0 to 31. The entry is destroyed when \n         vRtrMplsAdminGroupRowStatus is set to 'destroy'.")
vRtrMplsAdminGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsAdminGroupName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupName.setDescription('The value of vRtrMplsAdminGroupName uniquely identifies the\n         name of the administrative group within a virtual router \n         instance.')
vRtrMplsAdminGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsAdminGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupRowStatus.setDescription("vRtrMplsAdminGroupRowStatus is used to create, delete or \n         control entries in the vRtrMplsAdminGroupTable. To create \n         a row entry, the row status should be set to 'createAndWait'. \n         Before the row can be placed into the 'active' state, \n         vRtrMplsAdminGroupValue must be set to a value between 0 \n         and 31. To delete a row entry, the row status should be set\n         to 'destroy'")
vRtrMplsAdminGroupValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 31), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsAdminGroupValue.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupValue.setDescription('The value of vRtrMplsAdminGroupValue specifies the group value\n         associated with this administrative group. This value is unique \n         within a virtual router instance.\n\n         A value of -1 indicates that the group value for this entry has\n         not been set.')
vRtrMplsFSGroupTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14), )
if mibBuilder.loadTexts: vRtrMplsFSGroupTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupTable.setDescription('The vRtrMplsFSGroupTable has an entry for each group that is \n         a part of the fate sharing database configured for the virtual \n         router in the system. \n         \n         A fate sharing group is used to define a group of links and \n         nodes in the network that share common risk attributes. To\n         minimize a single point of failure, backup paths can be created\n         that not only avoid the nodes and links of the primary path but\n         also any other nodes and links that share risk with the nodes \n         and links of the primary path.')
vRtrMplsFSGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupName"))
if mibBuilder.loadTexts: vRtrMplsFSGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupEntry.setDescription("Each row entry in the vRtrMplsFSGroupTable represents a \n         fate sharing group which is a database of nodes and links \n         that share common risk attributes.\n         \n         Entries in this table are created and deleted via SNMP SET \n         operations. An entry is created by setting the value of \n         vRtrMplsFSGroupRowStatus to 'createAndGo'. An entry can \n         be deleted by setting vRtrMplsFSGroupRowStatus to 'destroy'.")
vRtrMplsFSGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsFSGroupName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupName.setDescription('The value of vRtrMplsFSGroupName uniquely identifies the\n         name of the fate sharing group within a virtual router \n         instance.')
vRtrMplsFSGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsFSGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupRowStatus.setDescription("vRtrMplsFSGroupRowStatus is used to create, delete or \n         control entries in the vRtrMplsFSGroupTable. To create \n         a row entry, the row status should be set to 'createAndGo'. \n         To delete a row entry, the row status should be set to\n         'destroy'")
vRtrMplsFSGroupCost = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsFSGroupCost.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupCost.setDescription('The value of vRtrMplsFSGroupCost specifies the cost assigned \n         to the fate sharing group. This cost is applied to all nodes \n         and links that are part of this group and used for CSPF \n         calculations. The higher the cost of the node or link, the \n         lesser its chance of being selected as part of the path.')
vRtrMplsFSGroupParamsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15), )
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsTable.setDescription('The vRtrMplsFSGroupParamsTable has an entry for each node\n         or link that is part of a fate sharing group on this virtual \n         router.')
vRtrMplsFSGroupParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupName"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupParamsFromAddr"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupParamsToAddr"))
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsEntry.setDescription("Each row entry in the vRtrMplsFSGroupParamsTable represents\n         either a node or a link that is a part of a fate sharing group\n         defined in the vRtrMplsFSGroupTable.\n         \n         Entries in this table are created and deleted via SNMP SET \n         operations. An entry is created by setting the value of \n         vRtrMplsFSGroupParamsRowStatus to 'createAndGo'. An entry \n         can be deleted by setting vRtrMplsFSGroupParamsRowStatus to\n         'destroy'.\n         \n         To configure a node to be part of the group, create an entry\n         in this table with vRtrMplsFSGroupParamsFromAddr set to a \n         valid non-zero IP address and vRtrMplsFSGroupParamsToAddr set\n         to 0. To configure a link to be part of the group, create an\n         entry in this table with both vRtrMplsFSGroupParamsFromAddr\n         and vRtrMplsFSGroupParamsToAddr set to valid non-zero IP \n         addresses.")
vRtrMplsFSGroupParamsFromAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1, 1), IpAddress())
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsFromAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsFromAddr.setDescription('The value of vRtrMplsFSGroupParamsFromAddr along with the \n         value of vRtrMplsFSGroupParamsToAddr uniquely identifies a \n         link or node within a fate sharing group. \n\n         This value must be non-zero for all row entries whether it\n         represents a node or a link.')
vRtrMplsFSGroupParamsToAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1, 2), IpAddress())
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsToAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsToAddr.setDescription('The value of vRtrMplsFSGroupParamsToAddr along with the \n         value of vRtrMplsFSGroupParamsFromAddr uniquely identifies \n         a link or node within a fate sharing group. \n         \n         This value must be 0 for row entries that represent a node\n         and must be non-zero for row entries that represent a link.')
vRtrMplsFSGroupParamsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsRowStatus.setDescription("vRtrMplsFSGroupParamsRowStatus is used to create, delete or \n         control entries in the vRtrMplsFSGroupParamsTable. To create \n         a row entry, the row status should be set to 'createAndGo'. \n         To delete a row entry, the row status should be set to\n         'destroy'")
vRtrMplsLabelRangeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17), )
if mibBuilder.loadTexts: vRtrMplsLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeTable.setDescription('The vRtrMplsLabelRangeTable has an entry for each type of\n         label, the minimum and maximum value in the label range and \n         information on total available and aging labels in each range.\n         \n         This is a read-only table.')
vRtrMplsLabelRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelType"))
if mibBuilder.loadTexts: vRtrMplsLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeEntry.setDescription('Each row entry in the vRtrMplsLabelRangeTable represents \n         a type of label. Each entry contains the label range used \n         by that label type and the number of aging and allocated \n         labels in the range.')
vRtrMplsLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("staticLsp", 1), ("staticSvc", 2), ("dynamic", 3))))
if mibBuilder.loadTexts: vRtrMplsLabelType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelType.setDescription('The value of vRtrMplsLabelType specifies the type of\n        label and is the index for this table.')
vRtrMplsLabelRangeMin = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeMin.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeMin.setDescription('The value of vRtrMplsLabelRangeMin specifies the minimum\n        label value in the range for a particular label type.')
vRtrMplsLabelRangeMax = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeMax.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeMax.setDescription('The value of vRtrMplsLabelRangeMax specifies the maximum\n        label value in the range for a particular label type.')
vRtrMplsLabelRangeAging = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeAging.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeAging.setDescription('The value of vRtrMplsLabelRangeAging represents the \n        number of labels that are currently allocated and aging.')
vRtrMplsLabelRangeAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeAvailable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeAvailable.setDescription('The value of vRtrMplsLabelRangeAvailable represents the \n        number of labels that are currently available for each \n        label type.')
vRtrMplsStaticLSPLabelTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18), )
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelTable.setDescription('The vRtrMplsStaticLSPLabelTable has an entry for each allocated \n        label that is part of the static LSP label range. This is a \n        read-only table.')
vRtrMplsStaticLSPLabelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticLSPLabel"))
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelEntry.setDescription('Each row entry in the vRtrMplsStaticLSPLabelTable represents \n         a label of type static LSP that is currently allocated.\n         The entry includes information about the current owner\n         for that label.')
vRtrMplsStaticLSPLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18, 1, 1), MplsLabel().subtype(subtypeSpec=ValueRangeConstraint(32, 1023)))
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabel.setDescription('The value of vRtrMplsStaticLSPLabel specifies the label\n        value.')
vRtrMplsStaticLSPLabelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18, 1, 2), TmnxMplsLabelOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelOwner.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelOwner.setDescription('The value of vRtrMplsStaticLSPLabelOwner specifies the owner\n        for the label value vRtrMplsStaticLSPLabel.')
vRtrMplsStaticSvcLabelTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19), )
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelTable.setDescription('The vRtrMplsStaticSvcLabelTable has an entry for each allocated \n        label that is part of the static service label range. This \n        is a read-only table.')
vRtrMplsStaticSvcLabelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticSvcLabel"))
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelEntry.setDescription('Each row entry in the vRtrMplsStaticSvcLabelTable represents \n         a label of type static-svc that is currently allocated.\n         The entry includes information about the current owner\n         for that label.')
vRtrMplsStaticSvcLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19, 1, 1), MplsLabel().subtype(subtypeSpec=ValueRangeConstraint(2048, 18431)))
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabel.setDescription('The value of vRtrMplsStaticSvcLabel specifies the label\n        value.')
vRtrMplsStaticSvcLabelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19, 1, 2), TmnxMplsLabelOwner().clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelOwner.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelOwner.setDescription('The value of vRtrMplsStaticSvcLabelOwner specifies \n        the owner for the label value vRtrMplsStaticSvcLabel.')
vRtrMplsSrlgGrpTableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTableLastChanged.setDescription('The value of vRtrMplsSrlgGrpTableLastChanged indicates the\n         sysUpTime at the time of the last modification to \n         vRtrMplsSrlgGrpTable by adding, deleting an entry or change\n         to a writable object in the table.\n\n         If no changes were made to the table since the last \n         re-initialization of the local network management subsystem, \n         then this object contains a zero value.')
vRtrMplsSrlgGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21), )
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTable.setDescription('The vRtrMplsSrlgGrpTable has an entry for each Shared Risk Link \n         Groups (SRLG) group configured for MPLS in the system.')
vRtrMplsSrlgGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (1, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpName"))
if mibBuilder.loadTexts: vRtrMplsSrlgGrpEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpEntry.setDescription('Each row entry represents a SRLG group on this virtual router\n         that participates in the MPLS protocol.  A row can be created\n         or deleted via SNMP SET requests.')
vRtrMplsSrlgGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsSrlgGrpName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpName.setDescription('The value of vRtrMplsSrlgGrpName indicates the SRLG group name.')
vRtrMplsSrlgGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpRowStatus.setDescription("vRtrMplsSrlgGrpRowStatus is used to create, delete or \n         control entries in the vRtrMplsSrlgGrpTable.  A value must \n         also be set for vRtrMplsSrlgGrpValue before the row entry can\n         transition to the 'active' state.")
vRtrMplsSrlgGrpLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpLastChanged.setDescription('The value of vRtrMplsSrlgGrpLastChanged indicates the timestamp of \n         last change to this row in vRtrMplsSrlgGrpTable.')
vRtrMplsSrlgGrpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpValue.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpValue.setDescription('The value of vRtrMplsSrlgGrpValue specifies the group value \n         associated with vRtrMplsSrlgGrpName.  This value is unique \n         within a virtual router instance.\n\n         At the time of row creation, a value for vRtrMplsSrlgGrpValue \n         must be specified or else row creation would fail.')
vRtrMplsIfSrlgGrpTblLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 22), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTblLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTblLastChanged.setDescription('The value of vRtrMplsIfSrlgGrpTblLastChanged indicates the\n         sysUpTime at the time of the last modification to \n         vRtrMplsIfSrlgGrpTable by adding, deleting an entry or change\n         to a writable object in the table.\n\n         If no changes were made to the table since the last \n         re-initialization of the local network management subsystem, \n         then this object contains a zero value.')
vRtrMplsIfSrlgGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23), )
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTable.setDescription('The vRtrMplsIfSrlgGrpTable has an entry for each Shared Risk \n         Link Group (SRLG) groups associated with a router interface \n         configured for MPLS in the system.')
vRtrMplsIfSrlgGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), (1, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpName"))
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpEntry.setDescription('Each row entry represents an SRLG group associated with a interface\n         on this virtual router that participates in the MPLS protocol.\n  \n         A row can be created or deleted via SNMP SET requests.')
vRtrMplsIfSrlgGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpName.setDescription('The value of vRtrMplsIfSrlgGrpName indicates the SRLG group name.')
vRtrMplsIfSrlgGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpRowStatus.setDescription('vRtrMplsIfSrlgGrpRowStatus is used to create, delete or \n         control entries in the vRtrMplsIfSrlgGrpTable.')
vRtrMplsIfSrlgGrpLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpLastChanged.setDescription('The value of vRtrMplsIfSrlgGrpLastChanged indicates the timestamp\n         of last change to this row in vRtrMplsIfSrlgGrpTable.')
tmnxMplsNotificationlObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16))
vRtrMplsLspNotificationReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("noPathIsOperational", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsLspNotificationReasonCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspNotificationReasonCode.setDescription('Used by vRtrMplsLspDown, the value indicates the reason for the \n         LSP going down.')
vRtrMplsLspPathNotificationReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16, 2), TmnxMplsLspFailCode()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsLspPathNotificationReasonCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathNotificationReasonCode.setDescription('Used by vRtrMplsLspPathDown, the value indicates the reason for the \n         LSP path going down.')
vRtrMplsNotifyRow = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16, 3), RowPointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsNotifyRow.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsNotifyRow.setDescription('used by Alcatel 7x50 SR series MPLS Configuration change \n         Notifications, the object ID indicates the MPLS table and entry.')
vRtrMplsStateChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 1)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"))
if mibBuilder.loadTexts: vRtrMplsStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStateChange.setDescription('This Notification is generated when the MPLS\n         module changes state')
vRtrMplsIfStateChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 2)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfOperState"))
if mibBuilder.loadTexts: vRtrMplsIfStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfStateChange.setDescription('This Notification is generated when the MPLS\n         interface changes state')
vRtrMplsLspUp = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 3)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"))
if mibBuilder.loadTexts: vRtrMplsLspUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspUp.setDescription("This Notification is generated when a LSP transitions\n         to the 'inService' state from any other state.")
vRtrMplsLspDown = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 4)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNotificationReasonCode"))
if mibBuilder.loadTexts: vRtrMplsLspDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspDown.setDescription("This Notification is generated when a LSP transitions\n         out of 'inService' state to any other state.")
vRtrMplsLspPathUp = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 5)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelIngressLSRId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"))
if mibBuilder.loadTexts: vRtrMplsLspPathUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathUp.setDescription("This Notification is generated when a LSP Path transitions\n         to the 'inService' state from any other state.")
vRtrMplsLspPathDown = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 6)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelIngressLSRId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNotificationReasonCode"))
if mibBuilder.loadTexts: vRtrMplsLspPathDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathDown.setDescription("This Notification is generated when a LSP Path transitions\n         out of 'inService' state to any other state.")
vRtrMplsLspPathRerouted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 7)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"))
if mibBuilder.loadTexts: vRtrMplsLspPathRerouted.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRerouted.setDescription('The vRtrMplsLspPathRerouted notification is generated when \n         an LSP Path is rerouted.')
vRtrMplsLspPathResignaled = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 8)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"))
if mibBuilder.loadTexts: vRtrMplsLspPathResignaled.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathResignaled.setDescription('The vRtrMplsLspPathResignaled notification is generated when \n         an LSP Path is resignaled.')
tmnxMplsCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1))
tmnxMplsGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2))
tmnxMplsV3v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1, 3)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsGlobalR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspPathGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsXCGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelARHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelCHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsAdminGroupGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsNotificationR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLabelRangeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsV3v0Compliance = tmnxMplsV3v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsV3v0Compliance.setDescription('The compliance statement for management of extended MPLS\n             on Alcatel 7x50 SR series systems 3.0 Release.')
tmnxMplsV5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1, 4)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsGlobalV5v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspV5v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspPathGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsXCGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelARHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelCHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsAdminGroupGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsNotificationR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLabelRangeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsV5v0Compliance = tmnxMplsV5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsV5v0Compliance.setDescription('The compliance statement for management of extended MPLS\n             on Alcatel 7xxx SR series systems 5.0 Release.')
tmnxMplsV6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1, 5)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsGlobalV6v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspV5v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspPathGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsXCGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelARHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelCHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsAdminGroupGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsNotificationR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLabelRangeGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsSrlgV6v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfV6v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsV6v0Compliance = tmnxMplsV6v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsV6v0Compliance.setDescription('The compliance statement for management of extended MPLS\n             on Alcatel 7xxx SR series systems 6.0 Release.')
tmnxMplsLspPathGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 3)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTableSpinlock"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathCos"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathProperties"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathBwProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathPreference"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathCosSource"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathClassOfService"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathSetupPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathHoldPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRecord"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathSharing"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathInheritance"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathLspId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRetryTimeRemaining"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTunnelARHopListIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNegotiatedMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathFailCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathFailNodeAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminGroupInclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminGroupExclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdaptive"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNextOptimize"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathMBBState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathResignal"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTunnelCRHopListIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRecordLabel"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTimeDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRetryAttempts"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTransitionCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathCspfQueries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspPathGroup = tmnxMplsLspPathGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLspPathGroup.setDescription('The group of objects supporting management of extended MPLS LSP\n         to path mapping on Alcatel 7x50 SR series systems.')
tmnxMplsXCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 4)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsXCIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsInSegmentIfIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsInSegmentLabel"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsOutSegmentIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsERHopTunnelIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsARHopTunnelIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsRsvpSessionIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsXCFailCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsXCCHopTableIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsXCGroup = tmnxMplsXCGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsXCGroup.setDescription('The group of objects supporting management of extended MPLS LSP\n         to cross-connection mapping on Alcatel 7x50 SR series systems.')
tmnxMplsIfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 5)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfAdminGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfTxPktCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfRxPktCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfTxOctetCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfRxOctetCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsIfGroup = tmnxMplsIfGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsIfGroup.setDescription('The group of objects supporting management of extended MPLS\n         interfaces on Alcatel 7x50 SR series systems.')
tmnxMplsTunnelARHopGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 6)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopProtection"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopRecordLabel"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopRouterId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsTunnelARHopGroup = tmnxMplsTunnelARHopGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsTunnelARHopGroup.setDescription('The group of objects supporting management of extended MPLS\n         Tunnel AR hops on Alcatel 7x50 SR series systems.')
tmnxMplsTunnelCHopGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 7)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopAddrType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv4Addr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv4PrefixLen"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv6Addr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv6PrefixLen"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopAsNumber"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopLspId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopStrictOrLoose"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsTunnelCHopGroup = tmnxMplsTunnelCHopGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsTunnelCHopGroup.setDescription('The group of objects supporting management of extended MPLS\n         CSPF Tunnel hops on Alcatel 7x50 SR series systems.')
tmnxMplsAdminGroupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 8)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsAdminGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsAdminGroupValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsAdminGroupGroup = tmnxMplsAdminGroupGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsAdminGroupGroup.setDescription('The group of objects supporting management of extended MPLS\n         administrative groups on Alcatel 7x50 SR series systems.')
tmnxMplsFSGroupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 9)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupCost"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupParamsRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsFSGroupGroup = tmnxMplsFSGroupGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsFSGroupGroup.setDescription('The group of objects supporting management of extended MPLS\n         fate sharing groups on Alcatel 7x50 SR series systems.')
tmnxMplsNotifyObjsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 10)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNotificationReasonCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNotificationReasonCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsNotifyRow"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsNotifyObjsGroup = tmnxMplsNotifyObjsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsNotifyObjsGroup.setDescription('The group of objects supporting extended MPLS notifications \n         on Alcatel 7x50 SR series systems.')
tmnxMplsGlobalR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 12)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralPropagateTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralTE"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNewLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralResignalTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTerminate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsGlobalR2r1Group = tmnxMplsGlobalR2r1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsGlobalR2r1Group.setDescription('The group of objects supporting general management of extended MPLS\n         on Alcatel 7x50 SR series systems 2.1 Release.')
tmnxMplsLspR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 13)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspName"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFromAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspToAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOutSegIndx"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspMetric"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspDecrementTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspCspf"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspClassOfService"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspSetupPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHoldPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRecord"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPreference"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBwProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNegotiatedMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpResvStyle"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpAdspec"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRMethod"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRNodeProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupInclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupExclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdaptive"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspInheritance"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOctets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPackets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAge"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPrimaryTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTransitions"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastTransition"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathChanges"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastPathChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspConfiguredPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspStandbyPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperationalPaths"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspR2r1Group = tmnxMplsLspR2r1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsLspR2r1Group.setDescription('The group of objects supporting management of extended MPLS LSPs \n         on Alcatel 7x50 SR series systems 2.1 Release.')
tmnxMplsNotificationR2r1Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 14)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStateChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfStateChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRerouted"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathResignaled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsNotificationR2r1Group = tmnxMplsNotificationR2r1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsNotificationR2r1Group.setDescription('The group of notifications supporting the extended MPLS feature\n         on Alcatel 7x50 SR series systems 2.1 Release.')
tmnxMplsLabelRangeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 15)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeMin"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeMax"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeAging"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeAvailable"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticLSPLabelOwner"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticSvcLabelOwner"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLabelRangeGroup = tmnxMplsLabelRangeGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLabelRangeGroup.setDescription('The group of objects supporting management of extended MPLS \n         label ranges on Alcatel 7x50 SR series systems.')
tmnxMplsGlobalV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 16)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralPropagateTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralTE"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNewLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralResignalTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralHoldTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicBypass"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsGlobalV5v0Group = tmnxMplsGlobalV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsGlobalV5v0Group.setDescription('The group of objects supporting general management of extended MPLS\n         on Alcatel 7x50 SR series systems 5.0 Release.')
tmnxMplsLspV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 17)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspName"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFromAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspToAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOutSegIndx"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspMetric"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspDecrementTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspCspf"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspClassOfService"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspSetupPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHoldPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRecord"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPreference"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBwProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNegotiatedMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpResvStyle"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpAdspec"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRMethod"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRNodeProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupInclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupExclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdaptive"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspInheritance"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOctets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPackets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAge"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPrimaryTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTransitions"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastTransition"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathChanges"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastPathChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspConfiguredPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspStandbyPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperationalPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHoldTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspV5v0Group = tmnxMplsLspV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLspV5v0Group.setDescription('The group of objects supporting management of extended MPLS LSPs \n         on Alcatel 7x50 SR series systems 5.0 Release.')
tmnxMplsGlobalV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 18)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralPropagateTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralTE"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNewLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralResignalTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralHoldTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicBypass"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNextResignal"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperDownReason"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralSrlgFrr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralSrlgFrrStrict"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsGlobalV6v0Group = tmnxMplsGlobalV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsGlobalV6v0Group.setDescription('The group of objects supporting general management of extended MPLS\n         on Alcatel 7x50 SR series systems 6.0 Release.')
tmnxMplsSrlgV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 19)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpTableLastChanged"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpLastChanged"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpValue"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpTblLastChanged"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpLastChanged"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsSrlgV6v0Group = tmnxMplsSrlgV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsSrlgV6v0Group.setDescription('The group of objects supporting management of SRLG on Alcatel \n         7xxx SR series systems release 6.0.')
tmnxMplsIfV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 21)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfTeMetric"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsIfV6v0Group = tmnxMplsIfV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsIfV6v0Group.setDescription('The group of objects supporting management of Te metric feature on \n         extended MPLS interfaces on 6.0 release Alcatel 7xxx SR series systems.')
tmnxMplsLspV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 22)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspCspfTeMetricEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspV6v0Group = tmnxMplsLspV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLspV6v0Group.setDescription('The group of objects supporting management of Te metric feature extended\n         MPLS LSPs on 6.0 release Alcatel 7xxx SR series systems.')
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-MPLS-MIB", vRtrMplsGeneralDetourLspTerminate=vRtrMplsGeneralDetourLspTerminate, vRtrMplsLspPathLastChange=vRtrMplsLspPathLastChange, tmnxMplsNotificationR2r1Group=tmnxMplsNotificationR2r1Group, tmnxMplsXCGroup=tmnxMplsXCGroup, vRtrMplsIfStatTable=vRtrMplsIfStatTable, vRtrMplsLspToAddr=vRtrMplsLspToAddr, vRtrMplsIfRxPktCount=vRtrMplsIfRxPktCount, vRtrMplsTunnelCHopStrictOrLoose=vRtrMplsTunnelCHopStrictOrLoose, vRtrMplsLspClassOfService=vRtrMplsLspClassOfService, vRtrMplsLspCspfTeMetricEnabled=vRtrMplsLspCspfTeMetricEnabled, vRtrMplsLspPackets=vRtrMplsLspPackets, vRtrMplsIfStateChange=vRtrMplsIfStateChange, tmnxMplsGlobalV5v0Group=tmnxMplsGlobalV5v0Group, vRtrMplsNotifyRow=vRtrMplsNotifyRow, vRtrMplsSrlgGrpValue=vRtrMplsSrlgGrpValue, vRtrMplsTunnelCHopIpv4Addr=vRtrMplsTunnelCHopIpv4Addr, vRtrMplsIfSrlgGrpTable=vRtrMplsIfSrlgGrpTable, vRtrMplsLspPathUp=vRtrMplsLspPathUp, vRtrMplsLspPathDown=vRtrMplsLspPathDown, vRtrMplsLspFRBandwidth=vRtrMplsLspFRBandwidth, vRtrMplsGeneralOperState=vRtrMplsGeneralOperState, vRtrMplsLspPathProperties=vRtrMplsLspPathProperties, vRtrMplsLspPathAdaptive=vRtrMplsLspPathAdaptive, vRtrMplsERHopTunnelIndex=vRtrMplsERHopTunnelIndex, vRtrMplsFSGroupRowStatus=vRtrMplsFSGroupRowStatus, vRtrMplsSrlgGrpName=vRtrMplsSrlgGrpName, vRtrMplsLspPrimaryTimeUp=vRtrMplsLspPrimaryTimeUp, vRtrMplsLspOctets=vRtrMplsLspOctets, vRtrMplsLspPathCosSource=vRtrMplsLspPathCosSource, vRtrMplsStaticLSPLabelOwner=vRtrMplsStaticLSPLabelOwner, vRtrMplsTunnelARHopRecordLabel=vRtrMplsTunnelARHopRecordLabel, vRtrMplsLspRsvpAdspec=vRtrMplsLspRsvpAdspec, vRtrMplsLspPathOperMTU=vRtrMplsLspPathOperMTU, vRtrMplsTunnelARHopProtection=vRtrMplsTunnelARHopProtection, vRtrMplsGeneralDynamicLspTransit=vRtrMplsGeneralDynamicLspTransit, vRtrMplsIfEntry=vRtrMplsIfEntry, vRtrMplsXCTable=vRtrMplsXCTable, vRtrMplsLspFromAddr=vRtrMplsLspFromAddr, vRtrMplsXCIndex=vRtrMplsXCIndex, vRtrMplsTunnelCHopAsNumber=vRtrMplsTunnelCHopAsNumber, vRtrMplsFSGroupCost=vRtrMplsFSGroupCost, vRtrMplsRsvpSessionIndex=vRtrMplsRsvpSessionIndex, vRtrMplsFSGroupName=vRtrMplsFSGroupName, vRtrMplsFSGroupParamsToAddr=vRtrMplsFSGroupParamsToAddr, vRtrMplsLspOperFastReroute=vRtrMplsLspOperFastReroute, vRtrMplsStaticSvcLabelOwner=vRtrMplsStaticSvcLabelOwner, vRtrMplsGeneralDetourLspTransit=vRtrMplsGeneralDetourLspTransit, vRtrMplsLspPathChanges=vRtrMplsLspPathChanges, vRtrMplsLspPathTableSpinlock=vRtrMplsLspPathTableSpinlock, vRtrMplsStaticSvcLabel=vRtrMplsStaticSvcLabel, vRtrMplsLspBwProtect=vRtrMplsLspBwProtect, vRtrMplsGeneralStaticLspTransit=vRtrMplsGeneralStaticLspTransit, vRtrMplsLspPathFailNodeAddr=vRtrMplsLspPathFailNodeAddr, vRtrMplsFSGroupParamsFromAddr=vRtrMplsFSGroupParamsFromAddr, vRtrMplsLspTable=vRtrMplsLspTable, vRtrMplsAdminGroupRowStatus=vRtrMplsAdminGroupRowStatus, vRtrMplsGeneralDynamicLspTerminate=vRtrMplsGeneralDynamicLspTerminate, vRtrMplsTunnelCHopIpv6PrefixLen=vRtrMplsTunnelCHopIpv6PrefixLen, vRtrMplsLspPathSharing=vRtrMplsLspPathSharing, vRtrMplsARHopTunnelIndex=vRtrMplsARHopTunnelIndex, vRtrMplsIfTable=vRtrMplsIfTable, vRtrMplsTunnelCHopTable=vRtrMplsTunnelCHopTable, vRtrMplsLabelRangeAging=vRtrMplsLabelRangeAging, vRtrMplsIfSrlgGrpName=vRtrMplsIfSrlgGrpName, vRtrMplsLspRsvpResvStyle=vRtrMplsLspRsvpResvStyle, vRtrMplsLspPathRowStatus=vRtrMplsLspPathRowStatus, vRtrMplsLspAdaptive=vRtrMplsLspAdaptive, tmnxMplsConformance=tmnxMplsConformance, tmnxMplsLspV5v0Group=tmnxMplsLspV5v0Group, timetraMplsMIBModule=timetraMplsMIBModule, vRtrMplsLspMetric=vRtrMplsLspMetric, vRtrMplsLspTimeDown=vRtrMplsLspTimeDown, vRtrMplsLspPathOperState=vRtrMplsLspPathOperState, vRtrMplsTunnelCHopLspId=vRtrMplsTunnelCHopLspId, vRtrMplsLspIndex=vRtrMplsLspIndex, tmnxMplsTunnelARHopGroup=tmnxMplsTunnelARHopGroup, vRtrMplsGeneralEntry=vRtrMplsGeneralEntry, PYSNMP_MODULE_ID=timetraMplsMIBModule, vRtrMplsLspFRHopLimit=vRtrMplsLspFRHopLimit, vRtrMplsLspNegotiatedMTU=vRtrMplsLspNegotiatedMTU, vRtrMplsLspPathBandwidth=vRtrMplsLspPathBandwidth, vRtrMplsGeneralSrlgFrr=vRtrMplsGeneralSrlgFrr, vRtrMplsLspPathOperBandwidth=vRtrMplsLspPathOperBandwidth, vRtrMplsLspFastReroute=vRtrMplsLspFastReroute, vRtrMplsLspPathCos=vRtrMplsLspPathCos, vRtrMplsStaticLSPLabelEntry=vRtrMplsStaticLSPLabelEntry, vRtrMplsFSGroupTable=vRtrMplsFSGroupTable, vRtrMplsIfRxOctetCount=vRtrMplsIfRxOctetCount, vRtrMplsTunnelARHopEntry=vRtrMplsTunnelARHopEntry, tmnxMplsV3v0Compliance=tmnxMplsV3v0Compliance, vRtrMplsLspHoldTimer=vRtrMplsLspHoldTimer, vRtrMplsLspPathResignal=vRtrMplsLspPathResignal, vRtrMplsLspPathStatTable=vRtrMplsLspPathStatTable, TmnxMplsOperDownReasonCode=TmnxMplsOperDownReasonCode, vRtrMplsLspLastChange=vRtrMplsLspLastChange, vRtrMplsLspPathTunnelARHopListIndex=vRtrMplsLspPathTunnelARHopListIndex, tmnxMplsNotificationlObjects=tmnxMplsNotificationlObjects, vRtrMplsIfSrlgGrpLastChanged=vRtrMplsIfSrlgGrpLastChanged, vRtrMplsLspOutSegIndx=vRtrMplsLspOutSegIndx, vRtrMplsLspPathNotificationReasonCode=vRtrMplsLspPathNotificationReasonCode, vRtrMplsInSegmentLabel=vRtrMplsInSegmentLabel, vRtrMplsGeneralTable=vRtrMplsGeneralTable, vRtrMplsLspDecrementTtl=vRtrMplsLspDecrementTtl, vRtrMplsLspPathType=vRtrMplsLspPathType, vRtrMplsLspPathState=vRtrMplsLspPathState, vRtrMplsIfTeMetric=vRtrMplsIfTeMetric, vRtrMplsLspPathRetryTimeRemaining=vRtrMplsLspPathRetryTimeRemaining, vRtrMplsTunnelARHopTable=vRtrMplsTunnelARHopTable, vRtrMplsLspPathAdminGroupInclude=vRtrMplsLspPathAdminGroupInclude, tmnxMplsAdminGroupGroup=tmnxMplsAdminGroupGroup, vRtrMplsLspFRMethod=vRtrMplsLspFRMethod, vRtrMplsLspAdminState=vRtrMplsLspAdminState, vRtrMplsLspPathResignaled=vRtrMplsLspPathResignaled, tmnxMplsV5v0Compliance=tmnxMplsV5v0Compliance, vRtrMplsGeneralStatTable=vRtrMplsGeneralStatTable, vRtrMplsGeneralLastChange=vRtrMplsGeneralLastChange, vRtrMplsLspPathRecord=vRtrMplsLspPathRecord, vRtrMplsGeneralSrlgFrrStrict=vRtrMplsGeneralSrlgFrrStrict, vRtrMplsLspConfiguredPaths=vRtrMplsLspConfiguredPaths, vRtrMplsGeneralOperDownReason=vRtrMplsGeneralOperDownReason, vRtrMplsLspName=vRtrMplsLspName, tmnxMplsTunnelCHopGroup=tmnxMplsTunnelCHopGroup, tmnxMplsLspV6v0Group=tmnxMplsLspV6v0Group, vRtrMplsLspPathTimeUp=vRtrMplsLspPathTimeUp, vRtrMplsGeneralHoldTimer=vRtrMplsGeneralHoldTimer, vRtrMplsGeneralDynamicBypass=vRtrMplsGeneralDynamicBypass, vRtrMplsLspPathMBBState=vRtrMplsLspPathMBBState, vRtrMplsLspPathTunnelCRHopListIndex=vRtrMplsLspPathTunnelCRHopListIndex, vRtrMplsSrlgGrpLastChanged=vRtrMplsSrlgGrpLastChanged, vRtrMplsLspStandbyPaths=vRtrMplsLspStandbyPaths, tmnxMplsLspR2r1Group=tmnxMplsLspR2r1Group, vRtrMplsLspPathRecordLabel=vRtrMplsLspPathRecordLabel, vRtrMplsLspPathStatEntry=vRtrMplsLspPathStatEntry, vRtrMplsGeneralNextResignal=vRtrMplsGeneralNextResignal, vRtrMplsLspLastTransition=vRtrMplsLspLastTransition, vRtrMplsLspPathFailCode=vRtrMplsLspPathFailCode, vRtrMplsLabelRangeTable=vRtrMplsLabelRangeTable, vRtrMplsLspRetryTimer=vRtrMplsLspRetryTimer, vRtrMplsGeneralFRObject=vRtrMplsGeneralFRObject, vRtrMplsLspRowStatus=vRtrMplsLspRowStatus, tmnxMplsGlobalV6v0Group=tmnxMplsGlobalV6v0Group, vRtrMplsLspBandwidth=vRtrMplsLspBandwidth, vRtrMplsLspPreference=vRtrMplsLspPreference, vRtrMplsLspPathHopLimit=vRtrMplsLspPathHopLimit, vRtrMplsIfStatEntry=vRtrMplsIfStatEntry, vRtrMplsStaticLSPLabel=vRtrMplsStaticLSPLabel, vRtrMplsIfAdminState=vRtrMplsIfAdminState, vRtrMplsLspCspf=vRtrMplsLspCspf, vRtrMplsLspPathInheritance=vRtrMplsLspPathInheritance, vRtrMplsLabelType=vRtrMplsLabelType, vRtrMplsGeneralPropagateTtl=vRtrMplsGeneralPropagateTtl, vRtrMplsLspPathAdminState=vRtrMplsLspPathAdminState, vRtrMplsInSegmentIfIndex=vRtrMplsInSegmentIfIndex, vRtrMplsLspPathBwProtect=vRtrMplsLspPathBwProtect, vRtrMplsLspPathPreference=vRtrMplsLspPathPreference, TmnxMplsLabelOwner=TmnxMplsLabelOwner, vRtrMplsLspPathTimeDown=vRtrMplsLspPathTimeDown, vRtrMplsGeneralResignalTimer=vRtrMplsGeneralResignalTimer, vRtrMplsTunnelCHopEntry=vRtrMplsTunnelCHopEntry, vRtrMplsLabelRangeEntry=vRtrMplsLabelRangeEntry, vRtrMplsAdminGroupValue=vRtrMplsAdminGroupValue, vRtrMplsLspLastPathChange=vRtrMplsLspLastPathChange, vRtrMplsXCCHopTableIndex=vRtrMplsXCCHopTableIndex, vRtrMplsIfAdminGroup=vRtrMplsIfAdminGroup, vRtrMplsStaticSvcLabelTable=vRtrMplsStaticSvcLabelTable, vRtrMplsGeneralDynamicLspOriginate=vRtrMplsGeneralDynamicLspOriginate, vRtrMplsSrlgGrpTableLastChanged=vRtrMplsSrlgGrpTableLastChanged, vRtrMplsLspNotificationReasonCode=vRtrMplsLspNotificationReasonCode, vRtrMplsLabelRangeMin=vRtrMplsLabelRangeMin, vRtrMplsAdminGroupName=vRtrMplsAdminGroupName, tmnxMplsNotifications=tmnxMplsNotifications, vRtrMplsLspOperationalPaths=vRtrMplsLspOperationalPaths, vRtrMplsFSGroupParamsRowStatus=vRtrMplsFSGroupParamsRowStatus, vRtrMplsLspPathNextOptimize=vRtrMplsLspPathNextOptimize, vRtrMplsSrlgGrpRowStatus=vRtrMplsSrlgGrpRowStatus, vRtrMplsLspPathRetryAttempts=vRtrMplsLspPathRetryAttempts, vRtrMplsGeneralDetourLspOriginate=vRtrMplsGeneralDetourLspOriginate, vRtrMplsLabelRangeMax=vRtrMplsLabelRangeMax, vRtrMplsStaticLSPLabelTable=vRtrMplsStaticLSPLabelTable, tmnxMplsLabelRangeGroup=tmnxMplsLabelRangeGroup, vRtrMplsGeneralStatEntry=vRtrMplsGeneralStatEntry, vRtrMplsLspFRNodeProtect=vRtrMplsLspFRNodeProtect, vRtrMplsGeneralAdminState=vRtrMplsGeneralAdminState, vRtrMplsTunnelCHopIpv6Addr=vRtrMplsTunnelCHopIpv6Addr, vRtrMplsGeneralTE=vRtrMplsGeneralTE, vRtrMplsLspPathRerouted=vRtrMplsLspPathRerouted, tmnxMplsGroups=tmnxMplsGroups, vRtrMplsLspPathNegotiatedMTU=vRtrMplsLspPathNegotiatedMTU, vRtrMplsLspAdminGroupInclude=vRtrMplsLspAdminGroupInclude, vRtrMplsLspRetryLimit=vRtrMplsLspRetryLimit, vRtrMplsLspPathOptimizeTimer=vRtrMplsLspPathOptimizeTimer, vRtrMplsLspPathClassOfService=vRtrMplsLspPathClassOfService, vRtrMplsIfTxPktCount=vRtrMplsIfTxPktCount, vRtrMplsTunnelCHopAddrType=vRtrMplsTunnelCHopAddrType, vRtrMplsAdminGroupTable=vRtrMplsAdminGroupTable, vRtrMplsLspUp=vRtrMplsLspUp, tmnxMplsIfGroup=tmnxMplsIfGroup, vRtrMplsIfSrlgGrpRowStatus=vRtrMplsIfSrlgGrpRowStatus, tmnxMplsIfV6v0Group=tmnxMplsIfV6v0Group, vRtrMplsIfOperState=vRtrMplsIfOperState, vRtrMplsLspDown=vRtrMplsLspDown, vRtrMplsLspPathTable=vRtrMplsLspPathTable, vRtrMplsLspRecord=vRtrMplsLspRecord, vRtrMplsStaticSvcLabelEntry=vRtrMplsStaticSvcLabelEntry, vRtrMplsXCFailCode=vRtrMplsXCFailCode, vRtrMplsStateChange=vRtrMplsStateChange, vRtrMplsLspPathAdminGroupExclude=vRtrMplsLspPathAdminGroupExclude, vRtrMplsLspOptimizeTimer=vRtrMplsLspOptimizeTimer, tmnxMplsCompliances=tmnxMplsCompliances, vRtrMplsOutSegmentIndex=vRtrMplsOutSegmentIndex, vRtrMplsLspTimeUp=vRtrMplsLspTimeUp, vRtrMplsGeneralStaticLspTerminate=vRtrMplsGeneralStaticLspTerminate, tmnxMplsLspPathGroup=tmnxMplsLspPathGroup, vRtrMplsLspPathCspfQueries=vRtrMplsLspPathCspfQueries, vRtrMplsTunnelARHopRouterId=vRtrMplsTunnelARHopRouterId, vRtrMplsLspPathSetupPriority=vRtrMplsLspPathSetupPriority, vRtrMplsXCEntry=vRtrMplsXCEntry, vRtrMplsGeneralOptimizeTimer=vRtrMplsGeneralOptimizeTimer, vRtrMplsSrlgGrpTable=vRtrMplsSrlgGrpTable, vRtrMplsIfSrlgGrpTblLastChanged=vRtrMplsIfSrlgGrpTblLastChanged, vRtrMplsIfSrlgGrpEntry=vRtrMplsIfSrlgGrpEntry, vRtrMplsLspTransitions=vRtrMplsLspTransitions, vRtrMplsGeneralStaticLspOriginate=vRtrMplsGeneralStaticLspOriginate, vRtrMplsSrlgGrpEntry=vRtrMplsSrlgGrpEntry, vRtrMplsTunnelCHopListIndex=vRtrMplsTunnelCHopListIndex, vRtrMplsLspOperState=vRtrMplsLspOperState, vRtrMplsLabelRangeAvailable=vRtrMplsLabelRangeAvailable, vRtrMplsIfTxOctetCount=vRtrMplsIfTxOctetCount, tmnxMplsV6v0Compliance=tmnxMplsV6v0Compliance, vRtrMplsLspInheritance=vRtrMplsLspInheritance, vRtrMplsGeneralNewLspIndex=vRtrMplsGeneralNewLspIndex, vRtrMplsFSGroupEntry=vRtrMplsFSGroupEntry, vRtrMplsLspEntry=vRtrMplsLspEntry, tmnxMplsObjs=tmnxMplsObjs, vRtrMplsLspPathEntry=vRtrMplsLspPathEntry, vRtrMplsTunnelCHopIndex=vRtrMplsTunnelCHopIndex, vRtrMplsLspPathLspId=vRtrMplsLspPathLspId, vRtrMplsFSGroupParamsEntry=vRtrMplsFSGroupParamsEntry, TmnxMplsLspFailCode=TmnxMplsLspFailCode, vRtrMplsTunnelCHopIpv4PrefixLen=vRtrMplsTunnelCHopIpv4PrefixLen, vRtrMplsLspType=vRtrMplsLspType, vRtrMplsAdminGroupEntry=vRtrMplsAdminGroupEntry, vRtrMplsLspStatEntry=vRtrMplsLspStatEntry, tmnxMplsFSGroupGroup=tmnxMplsFSGroupGroup, tmnxMplsGlobalR2r1Group=tmnxMplsGlobalR2r1Group, vRtrMplsLspSetupPriority=vRtrMplsLspSetupPriority, vRtrMplsLspAge=vRtrMplsLspAge, vRtrMplsLspFRObject=vRtrMplsLspFRObject, vRtrMplsLspAdminGroupExclude=vRtrMplsLspAdminGroupExclude, tmnxMplsNotifyObjsGroup=tmnxMplsNotifyObjsGroup, tmnxMplsNotifyPrefix=tmnxMplsNotifyPrefix, tmnxMplsSrlgV6v0Group=tmnxMplsSrlgV6v0Group, vRtrMplsLspHopLimit=vRtrMplsLspHopLimit, vRtrMplsLspStatTable=vRtrMplsLspStatTable)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-MPLS-MIB", vRtrMplsLspPathTransitionCount=vRtrMplsLspPathTransitionCount, vRtrMplsFSGroupParamsTable=vRtrMplsFSGroupParamsTable, vRtrMplsLspHoldPriority=vRtrMplsLspHoldPriority, vRtrMplsLspPathHoldPriority=vRtrMplsLspPathHoldPriority)
