#
# PySNMP MIB module PRVT-MPLS-IF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-MPLS-IF-MIB
# Produced by pysmi-1.1.3 at Sat Nov 20 17:22:42 2021
# On host fv-az121-977 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
ifIndex, ifEntry = mibBuilder.importSymbols("IF-MIB", "ifIndex", "ifEntry")
InetAddress, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress")
mpls, = mibBuilder.importSymbols("PRVT-CR-LDP-MIB", "mpls")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, IpAddress, Counter32, Counter64, ObjectIdentity, MibIdentifier, Unsigned32, NotificationType, Gauge32, Integer32, Bits, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "IpAddress", "Counter32", "Counter64", "ObjectIdentity", "MibIdentifier", "Unsigned32", "NotificationType", "Gauge32", "Integer32", "Bits", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
DisplayString, TruthValue, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "RowStatus", "TextualConvention")
prvtMPLSIfMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6))
prvtMPLSIfMib.setRevisions(('2008-01-01 00:00', '2007-01-23 00:00', '2006-06-27 00:00', '2006-01-08 00:00', '2005-11-11 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtMPLSIfMib.setRevisionsDescriptions(('Removed redefined OIDs in private vendor extension definitions.', 'Changed ifaceRsvpHelloTolerance, ifaceRsvpHelloPersist to Unsigned32.', 'Changes the ingress and egress label ranges.', 'Added the global label space object and changed augmentation to ifTable.', 'Initial version.',))
if mibBuilder.loadTexts: prvtMPLSIfMib.setLastUpdated('200801010000Z')
if mibBuilder.loadTexts: prvtMPLSIfMib.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtMPLSIfMib.setContactInfo(' BATM/Telco Systems Support team\n\t\t\t\tEmail: \n\t\t\t\tFor North America: techsupport@telco.com\n\t\t\t\tFor North Europe: support@batm.de, info@batm.de\n\t\t\t\tFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtMPLSIfMib.setDescription('This module includes configuration parameters for MPLS and RSVP interface specific parameters.')
prvtMPLSIfaceObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1))
prvtMPLSRouteObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2))
prvtMplsIfaceTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1), )
if mibBuilder.loadTexts: prvtMplsIfaceTable.setStatus('current')
if mibBuilder.loadTexts: prvtMplsIfaceTable.setDescription('This table contains object for configuring MPLS and LDP interface specific parameters.')
prvtMplsIfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prvtMplsIfaceEntry.setStatus('current')
if mibBuilder.loadTexts: prvtMplsIfaceEntry.setDescription('The MPLS/LDP configuration of an IP interface.')
ifaceMplsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsEnable.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsEnable.setDescription('Enable or disable MPLS on this interface.')
ifaceMplsPHPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsPHPEnable.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsPHPEnable.setDescription('Enable or disable Penultimate Hop Popping on this interface.')
ifaceMplsIngressLblRangeLow = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32768, 131071))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsIngressLblRangeLow.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsIngressLblRangeLow.setDescription('This is the lower border of the Ingress Lable Range for this interface.')
ifaceMplsIngressLblRangeHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32768, 131071))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsIngressLblRangeHigh.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsIngressLblRangeHigh.setDescription('This is the higher border of the Ingress Lable Range for this interface.')
ifaceMplsEgressLblRangeLow = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32768, 131071))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsEgressLblRangeLow.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsEgressLblRangeLow.setDescription('This is the lower border of the Egress Lable Range for this interface.')
ifaceMplsEgressLblRangeHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32768, 131071))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsEgressLblRangeHigh.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsEgressLblRangeHigh.setDescription('This is the higher border of the Egress Lable Range for this interface.')
ifaceMplsLdpHelloHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsLdpHelloHoldTimer.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsLdpHelloHoldTimer.setDescription('LDP Hello Hold Time.')
ifaceMplsLdpKeepaliveHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsLdpKeepaliveHoldTimer.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsLdpKeepaliveHoldTimer.setDescription('LDP Hello Keep-alive Time.')
ifaceMplsLdpUseGlobalLabelSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 1, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceMplsLdpUseGlobalLabelSpace.setStatus('current')
if mibBuilder.loadTexts: ifaceMplsLdpUseGlobalLabelSpace.setDescription('Default value is true and correct value is true.')
prvtRsvpIfaceTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2), )
if mibBuilder.loadTexts: prvtRsvpIfaceTable.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpIfaceTable.setDescription('This table contains object for configuring RSVP interface specific parameters.')
prvtRsvpIfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1), )
ifEntry.registerAugmentions(("PRVT-MPLS-IF-MIB", "prvtRsvpIfaceEntry"))
prvtRsvpIfaceEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: prvtRsvpIfaceEntry.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpIfaceEntry.setDescription('The MPLS/LDP configuration of an IP interface.')
ifaceRsvpRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpRefreshInterval.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpRefreshInterval.setDescription('The RSVP value, R,  which is used to set the average\n     \t\tinterval between refresh path and resv messages.')
ifaceRsvpRefreshMultiple = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpRefreshMultiple.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpRefreshMultiple.setDescription('The RSVP value, K, which is the number of unresponded Path\n     \tor Resv refresh attempts which must be made, spaced by\n     \tthe refresh interval before the state is deemed to have\n     \ttimed out.')
ifaceRsvpSlewNumerator = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpSlewNumerator.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpSlewNumerator.setDescription('The numerator of the fraction, SlewMax, which is the maximum\n     \t\tallowable increase in the refresh interval, R, to prevent\n     \t\tstate timeout while changing R.  R is increased by this\n     \t\tfraction until it reaches the new desired value.')
ifaceRsvpSlewDenom = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpSlewDenom.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpSlewDenom.setDescription('The denominator of the fraction, SlewMax, which is the\n     \tmaximum allowable increase in the refresh interval, R, to\n     \tprevent state timeout while changing R.  R is increased by\n     \tthis fraction until it reaches the new desired value.')
ifaceRsvpBlockadeMultiple = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpBlockadeMultiple.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpBlockadeMultiple.setDescription('The RSVP value, Kb, which is the number of refresh timeout\n     \t\tperiods after which blockade state is deleted.')
ifaceRsvpNotifyRRDecay = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpNotifyRRDecay.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpNotifyRRDecay.setDescription('The percentage increase in the rapid retransmission\n     \t\tinterval for each consecutive unacknowledged RSVP Notify\n    \t\t message.  A value of 0 indicates a constant retransmission\n     \t\trate.')
ifaceRsvpNotifyRRInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpNotifyRRInterval.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpNotifyRRInterval.setDescription('The interval in milliseconds before a Notify message is\n     \t\tfirst resent if no acknowledgement is received.')
ifaceRsvpNotifyRRLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpNotifyRRLimit.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpNotifyRRLimit.setDescription('The maximum number of times a Notify message is resent if\n     \t\tno acknowledgement is received.')
ifaceRsvpHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpHelloInterval.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpHelloInterval.setDescription('The interval between sending consecutive Hello messages.')
ifaceRsvpHelloDecay = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpHelloDecay.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpHelloDecay.setDescription('Percentage increase of hello interval after each Hello message\n \t\t\tsent when the hello session with the neighbor has timed out.')
ifaceRsvpHelloTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpHelloTolerance.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpHelloTolerance.setDescription('The number of hello periods which may pass without receiving a successful \n            Hello message from a partner before the Hello session times out.')
ifaceRsvpHelloPersist = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpHelloPersist.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpHelloPersist.setDescription('The number of hello periods which may pass after the Hello session times out before Hello messages cease.')
ifaceRsvpHelloTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifaceRsvpHelloTTL.setStatus('current')
if mibBuilder.loadTexts: ifaceRsvpHelloTTL.setDescription('The Time To Live that will be set in the IP header of all Hello packets sent to the neighbor associated with this interface.')
prvtMplsRouteProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 1), )
if mibBuilder.loadTexts: prvtMplsRouteProtocolTable.setStatus('current')
if mibBuilder.loadTexts: prvtMplsRouteProtocolTable.setDescription('This table contains for configuring the egress and ingress routes for LDP label\n            packets. It supports all CLI route types - bgp, isis, ospf, rip, static, kernel and \n            connected.')
prvtMplsRouteProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 1, 1), ).setIndexNames((0, "PRVT-MPLS-IF-MIB", "prvtMplsRouteDirection"), (0, "PRVT-MPLS-IF-MIB", "prvtMplsRouteType"))
if mibBuilder.loadTexts: prvtMplsRouteProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: prvtMplsRouteProtocolEntry.setDescription('An entry in the table represents the configuration of a particular route type for ingress\n\t\t    or egress.')
prvtMplsRouteDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsRouteDirection.setStatus('current')
if mibBuilder.loadTexts: prvtMplsRouteDirection.setDescription('The direction of the route that will be used to receive or send LDP packets.')
prvtMplsRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("bgp", 1), ("connected", 2), ("isis", 3), ("kernel", 4), ("ospf", 5), ("rip", 6), ("static", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsRouteType.setStatus('current')
if mibBuilder.loadTexts: prvtMplsRouteType.setDescription('The type of the route which will be used to send or receive LDP packets.')
prvtMplsRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtMplsRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtMplsRouteRowStatus.setDescription('This object is used to create an entry in the table. Only createAndGo(4) should be \n            used.')
prvtMplsRouteAddressTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 2), )
if mibBuilder.loadTexts: prvtMplsRouteAddressTable.setStatus('current')
if mibBuilder.loadTexts: prvtMplsRouteAddressTable.setDescription('This table contains for configuring the egress and ingress routes for LDP label\n            packets. It supports all CLI route types - bgp, isis, ospf, rip, static, kernel and \n            connected.')
prvtMplsRouteAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 2, 1), ).setIndexNames((0, "PRVT-MPLS-IF-MIB", "prvtMplsAddressDirection"), (0, "PRVT-MPLS-IF-MIB", "prvtMplsAddressIPAddr"), (0, "PRVT-MPLS-IF-MIB", "prvtMplsAddressMask"))
if mibBuilder.loadTexts: prvtMplsRouteAddressEntry.setStatus('current')
if mibBuilder.loadTexts: prvtMplsRouteAddressEntry.setDescription('An entry in the table represents the configuration of a particular route type for ingress\n\t\t    or egress.')
prvtMplsAddressDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsAddressDirection.setStatus('current')
if mibBuilder.loadTexts: prvtMplsAddressDirection.setDescription('The direction of the route that will be used to receive or send LDP packets.')
prvtMplsAddressIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 2, 1, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsAddressIPAddr.setStatus('current')
if mibBuilder.loadTexts: prvtMplsAddressIPAddr.setDescription('The IP address of the route that will be used to send or receive LDP packets.')
prvtMplsAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtMplsAddressMask.setStatus('current')
if mibBuilder.loadTexts: prvtMplsAddressMask.setDescription('The mask for the IP address of the route that will be used to send or receive LDP packets.')
prvtMplsAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 6, 2, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtMplsAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtMplsAddressRowStatus.setDescription('This object is used to create an entry in the table. Only createAndGo(4) should be \n            used.')
mibBuilder.exportSymbols("PRVT-MPLS-IF-MIB", ifaceRsvpRefreshMultiple=ifaceRsvpRefreshMultiple, prvtRsvpIfaceEntry=prvtRsvpIfaceEntry, ifaceMplsLdpHelloHoldTimer=ifaceMplsLdpHelloHoldTimer, prvtMPLSRouteObjs=prvtMPLSRouteObjs, prvtMplsAddressIPAddr=prvtMplsAddressIPAddr, prvtMplsRouteProtocolEntry=prvtMplsRouteProtocolEntry, ifaceRsvpNotifyRRDecay=ifaceRsvpNotifyRRDecay, ifaceRsvpHelloTolerance=ifaceRsvpHelloTolerance, prvtMplsAddressDirection=prvtMplsAddressDirection, prvtMplsIfaceEntry=prvtMplsIfaceEntry, ifaceMplsLdpUseGlobalLabelSpace=ifaceMplsLdpUseGlobalLabelSpace, prvtMplsRouteAddressEntry=prvtMplsRouteAddressEntry, ifaceMplsLdpKeepaliveHoldTimer=ifaceMplsLdpKeepaliveHoldTimer, prvtMplsRouteAddressTable=prvtMplsRouteAddressTable, ifaceRsvpRefreshInterval=ifaceRsvpRefreshInterval, ifaceRsvpHelloPersist=ifaceRsvpHelloPersist, prvtMPLSIfMib=prvtMPLSIfMib, prvtMPLSIfaceObjs=prvtMPLSIfaceObjs, ifaceRsvpNotifyRRInterval=ifaceRsvpNotifyRRInterval, prvtRsvpIfaceTable=prvtRsvpIfaceTable, prvtMplsRouteType=prvtMplsRouteType, ifaceMplsIngressLblRangeLow=ifaceMplsIngressLblRangeLow, ifaceMplsEnable=ifaceMplsEnable, ifaceMplsEgressLblRangeLow=ifaceMplsEgressLblRangeLow, ifaceMplsIngressLblRangeHigh=ifaceMplsIngressLblRangeHigh, ifaceMplsEgressLblRangeHigh=ifaceMplsEgressLblRangeHigh, prvtMplsRouteProtocolTable=prvtMplsRouteProtocolTable, ifaceRsvpBlockadeMultiple=ifaceRsvpBlockadeMultiple, ifaceRsvpHelloDecay=ifaceRsvpHelloDecay, prvtMplsRouteDirection=prvtMplsRouteDirection, ifaceRsvpNotifyRRLimit=ifaceRsvpNotifyRRLimit, PYSNMP_MODULE_ID=prvtMPLSIfMib, ifaceRsvpSlewNumerator=ifaceRsvpSlewNumerator, ifaceRsvpHelloTTL=ifaceRsvpHelloTTL, ifaceRsvpSlewDenom=ifaceRsvpSlewDenom, prvtMplsAddressRowStatus=prvtMplsAddressRowStatus, prvtMplsAddressMask=prvtMplsAddressMask, prvtMplsIfaceTable=prvtMplsIfaceTable, ifaceMplsPHPEnable=ifaceMplsPHPEnable, ifaceRsvpHelloInterval=ifaceRsvpHelloInterval, prvtMplsRouteRowStatus=prvtMplsRouteRowStatus)
