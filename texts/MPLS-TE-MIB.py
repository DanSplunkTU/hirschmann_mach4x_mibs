#
# PySNMP MIB module MPLS-TE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/MPLS-TE-MIB
# Produced by pysmi-1.1.3 at Thu Dec  9 15:04:16 2021
# On host fv-az39-899 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressIPv4, InetAddressIPv6 = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4", "InetAddressIPv6")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
ObjectIdentity, NotificationType, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter64, Bits, Integer32, Unsigned32, Counter32, ModuleIdentity, MibIdentifier, experimental, TimeTicks, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "NotificationType", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter64", "Bits", "Integer32", "Unsigned32", "Counter32", "ModuleIdentity", "MibIdentifier", "experimental", "TimeTicks", "IpAddress")
StorageType, RowPointer, TruthValue, TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "RowPointer", "TruthValue", "TextualConvention", "RowStatus", "DisplayString")
mplsTeMIB = ModuleIdentity((1, 3, 6, 1, 3, 95))
mplsTeMIB.setRevisions(('2000-07-14 12:00', '2000-05-26 12:00', '2000-03-03 12:00', '1999-07-16 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsTeMIB.setRevisionsDescriptions(('Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Initial draft version.',))
if mibBuilder.loadTexts: mplsTeMIB.setLastUpdated('200007141200Z')
if mibBuilder.loadTexts: mplsTeMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsTeMIB.setContactInfo('        Cheenu Srinivasan\n         Postal: Tachion Networks, Inc.\n                 Monmouth Park Corporate Center I\n                 Building C, 185 Monmouth Park Highway\n                 West Long Branch, NJ 07764\n         Tel:    +1-732-542-7750 x1234\n         Email:  cheenu@tachion.com\n        \n                 Arun Viswanathan\n         Postal: Force10 Networks, Inc.\n                 1440 McCarthy Blvd\n                 Milpitas, CA 95035\n         Tel:    +1-408-571-3516\n         Email:  arun@force10networks.com\n        \n                 Thomas D. Nadeau\n         Postal: Cisco Systems, Inc.\n                 250 Apollo Drive\n                 Chelmsford, MA 01824\n         Tel:    +1-978-244-3051\n         Email:  tnadeau@cisco.com')
if mibBuilder.loadTexts: mplsTeMIB.setDescription("This MIB module contains managed object definitions\n         for MPLS Traffic Engineering (TE) as defined in:\n         Extensions to RSVP for LSP Tunnels, Awduche et al,\n         Internet Draft <draft-mpls-rsvp-lsp-tunnel-02.txt>,\n         March 1999; Constraint-Based LSP Setup using LDP, B.\n         Jamoussi, Internet Draft <draft-ietf-mpls-cr-ldp-\n         01.txt>, Feb. 1999; Requirements for Traffic\n         Engineering Over MPLS, Awduche, D., J. Malcolm, J.,\n         Agogbua, J., O'Dell, M., J. McManus, <rfc2702.txt>,\n         September 1999.")
class MplsLSPID(TextualConvention, OctetString):
    description = 'An identifier that is assigned to each LSP and is\n        used to uniquely identify it.  This is assigned at\n        the head end of the LSP and can be used by all LSRs\n        to identify this LSP.  This value is piggybacked by\n        the signaling protocol when this LSP is signaled\n        within the network.  This identifier can then be\n        used at each LSR to identify which labels are being\n        swapped to other labels for this LSP.  For IPv4\n        addresses this results in a 6-octet long cookie.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 31)

class MplsBitRate(TextualConvention, Integer32):
    description = "An estimate of bandwidth in units of 1,000 bits per\n        second.  If this object reports a value of 'n' then\n        the rate of the object is somewhere in the range of\n        'n-500' to 'n+499'. For objects which do not vary in\n        bitrate, or for those where no accurate estimation\n        can be made, this object should contain the nominal\n        bitrate."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MplsBurstSize(TextualConvention, Integer32):
    description = 'The number of octets of MPLS data that the stream\n        may send back-to-back without concern for policing.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MplsTunnelIndex(TextualConvention, Integer32):
    description = 'Index into mplsTunnelTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

mplsTeObjects = MibIdentifier((1, 3, 6, 1, 3, 95, 1))
mplsTeNotifications = MibIdentifier((1, 3, 6, 1, 3, 95, 2))
mplsTeNotifyPrefix = MibIdentifier((1, 3, 6, 1, 3, 95, 2, 0))
mplsTeConformance = MibIdentifier((1, 3, 6, 1, 3, 95, 3))
mplsTunnelIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndexNext.setDescription('This object contains the next appropriate value to\n         be used for mplsTunnelIndex when creating entries in\n         mplsTunnelTable. If the number of unassigned entries\n         is exhausted, a retrival operation will return a\n         value of 0.  This object may also return a value of\n         0 when the LSR is unable to accept conceptual row\n         creation, for example, if the mplsTunnelTable is\n         implemented as read-only. To obtain the value of\n         mplsTunnelIndex for a new entry, the manager must\n         first issue a management protocol retrieval\n         operation to obtain the current value of this\n         object. The agent should modify the value to reflect\n         the next unassigned index after each retrieval\n         operation. After a manager retrieves a value the\n         agent will determine through its local policy when\n         this index value will be made available for reuse.')
mplsTunnelTable = MibTable((1, 3, 6, 1, 3, 95, 1, 2), )
if mibBuilder.loadTexts: mplsTunnelTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTable.setDescription('The mplsTunnelTable allows new MPLS tunnels to be\n         created between an LSR and a remote endpoint, and\n         existing tunnels to be reconfigured or removed.\n         Note that only point-to-point tunnel segments are\n         supported, although multi-point-to-point and point-\n         to-multi-point connections are supported by an LSR\n         acting as a cross-connect.  Each MPLS tunnel can\n         thus have one out-segment originating at this LSR\n         and/or one in-segment terminating at this LSR.')
mplsTunnelEntry = MibTableRow((1, 3, 6, 1, 3, 95, 1, 2, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-MIB", "mplsTunnelIngressLSRId"))
if mibBuilder.loadTexts: mplsTunnelEntry.setReference('1. RFC 2233 - The Interfaces Group MIB using SMIv2,\n         McCloghrie, K., and F. Kastenholtz, Nov. 1997\n         2. RFC 1700 - Assigned Numbers, Reynolds, J. and J.\n         Postel, Oct. 1994')
if mibBuilder.loadTexts: mplsTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEntry.setDescription('An entry in this table represents an MPLS tunnel.\n         An entry can be created by a network administrator\n         or by an SNMP agent as instructed by an MPLS\n         signaling protocol. Whenever a new entry is created\n         with mplsTunnelIsIf set to true(1), then a\n         corresponding entry is created in ifTable as well\n         (see RFC 2233). The ifType of this entry is\n         mplsTunnel(150).')
mplsTunnelIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 1), MplsTunnelIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: mplsTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndex.setDescription('Uniquely identifies this row.')
mplsTunnelInstance = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 2), MplsTunnelIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: mplsTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstance.setDescription('Uniquely identifies an instance of a tunnel. It is\n         useful to identify multiple instances of tunnels for\n         the purposes of backup and parallel tunnels.')
mplsTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, Internet Draft <draft-mpls-rsvp-lsp-\n         tunnel-05.txt>, February 2000.,\n         2. Constraint-Based LSP Setup using LDP, Jamoussi,\n         Internet Draft <draft-ietf-mpls-cr-ldp-03.txt>,\n         September 1999.')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setDescription('The purpose of this object is to uniquely identity a\n         tunnel within a network. When the MPLS signalling\n         protoocol is rsvp(2) this value should mimic the\n         Extended Tunnel Id field in the Session object. When\n         the MPLS signalling protoocol is crldp(3) this value\n         should mimic the Ingress LSR Router ID field in the\n         LSPID TLV object.')
mplsTunnelName = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 4), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelName.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n         McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelName.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelName.setDescription("The canonical name assigned to the tunnel. This name\n         can be used to refer to the tunnel on the LSR's\n         console port.  If mplsTunnelIsIf is set to true then\n         the ifName of the interface corresponding to this\n         tunnel should have a value equal to mplsTunnelName.\n         Also see the description of ifName in RFC 2233.")
mplsTunnelDescr = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDescr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDescr.setDescription('A textual string containing information about the\n         tunnel.  If there is no description this object\n         contains a zero length string.')
mplsTunnelIsIf = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsIf.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n         McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelIsIf.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIf.setDescription('Denotes whether or not this tunnel corresponds to an\n         interface represented in the interfaces group table.\n         Note that if this variable is set to true then the\n         ifName of the interface corresponding to this tunnel\n         should have a value equal to mplsTunnelName.  Also\n         see the description of ifName in RFC 2233.')
mplsTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n         McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setDescription('If mplsTunnelIsIf is set to true, then this value\n         contains the LSR-assigned ifIndex which corresponds\n         to an entry in the interfaces table.  Otherwise this\n         variable should contain the value of zero indicating\n         that a valid ifIndex was not assigned to this tunnel\n         interface.')
mplsTunnelXCPointer = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 8), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelXCPointer.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS\n         Label Switch Router Management Information Base\n         Using SMIv2, Internet Draft <draft-ietf-mpls-lsr-mib-\n         04.txt>, April 26, 2000.')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setDescription('This variable points to a row in the mplsXCTable.\n         This table identifies the segments that compose this\n         tunnel, their characteristics, and relationships to\n         each other. A value of zeroDotZero indicates that no\n         LSP has been associated with this tunnel yet.')
mplsTunnelSignallingProto = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("rsvp", 2), ("crldp", 3), ("other", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setDescription('The signaling protocol, if any, which was used to\n         setup this tunnel.')
mplsTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, Internet Draft <draft-mpls-rsvp-lsp-\n         tunnel-05.txt>, February 2000.,\n         2. Constraint-Based LSP Setup using LDP, Jamoussi,\n         Internet Draft <draft-ietf-mpls-cr-ldp-03.txt>,\n         September 1999.')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setDescription('Indicates the setup priority of this tunnel.')
mplsTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, Internet Draft <draft-mpls-rsvp-lsp-\n         tunnel-05.txt>, February 2000.,\n         2. Constraint-Based LSP Setup using LDP, Jamoussi,\n         Internet Draft <draft-ietf-mpls-cr-ldp-03.txt>,\n         September 1999.')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setDescription('Indicates the holding priority for this tunnel.')
mplsTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 12), Bits().clone(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("localProtectionAvailable", 3), ("isPinned", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n         Awduche et al, Internet Draft <draft-mpls-rsvp-lsp-\n         tunnel-05.txt>, February 2000.')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setDescription('This bitmask indicates optional session values for\n         this tunnel. The following describes these\n         bitfields:\n          \n          fastReroute          This flag indicates that the\n                               any tunnel hop may choose to\n                               reroute this tunnel without\n                               tearing it down.\n          \n          mergingPermitted     This flag permits transit\n                               routers to merge this session\n                               with other RSVP sessions for\n                               the purpose of reducing\n                               resource overhead on\n                               downstream transit routers,\n                               thereby providing better\n                               network scalability.\n          \n          isPersistant         Indicates whether this tunnel\n                               should be restored\n                               automatically after a failure\n                               occurs.\n          \n          localProtectionAvailable This flag permits transit\n                               routers to use a local repair\n                               mechanism which may result in\n                               violation of the explicit\n                               routing of this tunnel. When a\n                               fault is detected on an\n                               adjacent downstream link or\n                               node, a transit router can\n                               reroute traffic for fast\n                               service restoration.\n                               \n          isPinned             This flag indicates whether\n                               the loose-routed hops of this\n                               tunnel are to be pinned.')
mplsTunnelOwner = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("admin", 1), ("rsvp", 2), ("crldp", 3), ("policyAgent", 4), ("other", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelOwner.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOwner.setDescription('Indicates which protocol created and is responsible\n         for managing this tunnel. Values rsvp(2) and\n         crldp(3) should not be used at the head-end of a\n         MPLS tunnel.')
mplsTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 14), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setDescription('Indicates that the local repair mechanism is in use\n         to maintain this tunnel (usually in the face of an\n         outage of the link it was previously routed over).')
mplsTunnelResourcePointer = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 15), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setDescription('This variable represents a pointer to the traffic\n         parameter specification for this tunnel.  This value\n         may point at an entry in the mplsTunnelResourceEntry\n         to indicate which mplsTunnelResourceEntry is to be\n         assigned to this segment.  This value may optionally\n         point at an externally defined traffic parameter\n         specification table.  A value of zeroDotZero\n         indicates best-effort treatment.  By having the same\n         value of this object, two or more segments can\n         indicate resource sharing.')
mplsTunnelInstancePriority = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setDescription('This value indicates which priority, in descending\n         order with 0 indicating the lowest priority, within\n         a group of tunnel instances. A group of tunnel\n         instances is defined as a set of tunnels with the\n         same mplsTunnelIndex in this table, but with a\n         different mplsTunnelInstance.  Tunnel group\n         priorities are used to denote the priority at which\n         a particular tunnel instance will supercede another.\n         Instances of tunnels containing the same\n         mplsTunnelInstancePriority will be used for load\n         sharing.')
mplsTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setDescription('Index into the mplsTunnelHopTable entry that\n         specifies the explicit route hops for this tunnel.')
mplsTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setDescription('Index into the mplsTunnelARHopTable entry that\n         specifies the actual hops traversed by the tunnel.')
mplsTunnelAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setDescription('Indicates the desired operational status of this\n         tunnel.')
mplsTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOperStatus.setDescription('Indicates the actual operational status of this\n         tunnel, which is typically but not limited to, a\n         function of the state of individual segments of this\n         tunnel.')
mplsTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 21), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRowStatus.setDescription('This variable is used to create, modify, and/or\n         delete a row in this table.')
mplsTunnelStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 2, 1, 22), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelStorageType.setDescription('This variable indicates the storage type for this\n         object.')
mplsTunnelMaxHops = MibScalar((1, 3, 6, 1, 3, 95, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelMaxHops.setDescription('The maximum number of hops that can be specified for\n         a tunnel on this device.')
mplsTunnelHopIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelHopIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndexNext.setDescription('This object contains an appropriate value to be used\n         for mplsTunnelHopListIndex when creating entries in\n         the mplsTunnelHopTable.  If the number of unassigned\n         entries is exhausted, a retrival operation will\n         return a value of 0.  This object may also return a\n         value of 0 when the LSR is unable to accept\n         conceptual row creation, for example, if the\n         mplsTunnelHopTable is implemented as read-only.  To\n         obtain the value of mplsTunnelHopListIndex for a new\n         entry in the mplsTunnelHopTable, the manager issues\n         a management protocol retrieval operation to obtain\n         the current value of mplsTunnelHopIndex.  After each\n         retrieval operation, the agent should modify the\n         value to reflect the next unassigned index.  After a\n         manager retrieves a value the agent will determine\n         through its local policy when this index value will\n         be made available for reuse.')
mplsTunnelHopTable = MibTable((1, 3, 6, 1, 3, 95, 1, 5), )
if mibBuilder.loadTexts: mplsTunnelHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTable.setDescription('The mplsTunnelHopTable is used to indicate the hops,\n         strict or loose, for an MPLS tunnel defined in\n         mplsTunnelTable, when it is established via\n         signaling, for the outgoing direction of the tunnel.\n         Each row in this table is indexed primarily by the\n         same index, mplsTunnelIndex, as the row of the\n         corresponding tunnel in mplsTunnelTable.  Each row\n         also has a secondary index mplsTunnelHopIndex\n         corresponding to the next hop that this row\n         corresponds to.  The first row in the table is the\n         first hop after the origination point of the tunnel.\n         In case we want to specify a particular interface on\n         the originating LSR of an outgoing tunnel by which\n         we want packets to exit the LSR, we specify this as\n         the first hop for this tunnel in\n         mplsTunnelHopTable.')
mplsTunnelHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 1, 5, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelHopListIndex"), (0, "MPLS-TE-MIB", "mplsTunnelHopIndex"))
if mibBuilder.loadTexts: mplsTunnelHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopEntry.setDescription('An entry in this table represents a tunnel hop.  An\n         entry is created by a network administrator for\n         signaled ERLSP set up by an MPLS signaling\n         protocol.')
mplsTunnelHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setDescription('Primary index into this table identifying a\n         particular explicit route object.')
mplsTunnelHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndex.setDescription('Secondary index into this table identifying a\n         particular hop.')
mplsTunnelHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3), ("lspid", 4))).clone('ipV4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv4Addr.setDescription('If mplsTunnelHopAddrType is set to ipV4(1), then\n         this value will contain the IPv4 address of this\n         hop. This object is otherwise insignificant and\n         should contain a value of 0.')
mplsTunnelHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv4PrefixLen.setDescription("If mplsTunnelHopAddrType is ipV4(1), then the prefix\n         length for this hop's IPv4 address is contained\n         herein. This object is otherwise insignificant and\n         should contain a value of 0.")
mplsTunnelHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 6), InetAddressIPv6()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv6Addr.setDescription('If the mplsTunnelHopAddrType is set to ipV6(2), then\n         this variable contains the IPv6 address of this hop.\n         This object is otherwise insignificant and should\n         contain a value of 0.')
mplsTunnelHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv6PrefixLen.setDescription("If mplsTunnelHopAddrType is set to ipV6(2), this\n         value will contain the prefix length for this hop's\n         IPv6 address. This object is otherwise insignificant\n         and should contain a value of 0.")
mplsTunnelHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setDescription('If mplsTunnelHopAddrType is set to asNumber(3), then\n         this value will contain the AS number of this hop.\n         This object is otherwise insignificant and should\n         contain a value of 0 to indicate this fact.')
mplsTunnelHopLspId = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 9), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopLspId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopLspId.setDescription("If mplsTunnelHopAddrType is set to lspid(4), then\n         this value will contain the LSPID of a tunnel of\n         this hop. The present tuunel being configured is\n         'tunneled' through this hop (using label stacking).\n         This object is otherwise insignificant and should\n         contain a value of 0 to indicate this fact.")
mplsTunnelHopStrictOrLoose = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopStrictOrLoose.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopStrictOrLoose.setDescription('Denotes whether this tunnel hop is routed in a\n         strict or loose fashion.')
mplsTunnelHopRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setDescription('This variable is used to create, modify, and/or\n         delete a row in this table.')
mplsTunnelHopStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 5, 1, 12), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setDescription('This variable indicates the storage type for this\n         object.')
mplsTunnelResourceIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelResourceIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndexNext.setDescription('This object contains the next appropriate value to\n         be used for mplsTunnelResourceIndex when creating\n         entries in the mplsTunnelResourceTable. If the\n         number of unassigned entries is exhausted, a\n         retrival operation will return a value of 0.  This\n         object may also return a value of 0 when the LSR is\n         unable to accept conceptual row creation, for\n         example, if the mplsTunnelTable is implemented as\n         read-only.  To obtain the mplsTunnelResourceIndex\n         value for a new entry, the manager must first issue\n         a management protocol retrieval operation to obtain\n         the current value of this object. The agent should\n         modify the value to reflect the next unassigned\n         index after each retrieval operation. After a\n         manager retrieves a value the agent will determine\n         through its local policy when this index value will\n         be made available for reuse.')
mplsTunnelResourceTable = MibTable((1, 3, 6, 1, 3, 95, 1, 7), )
if mibBuilder.loadTexts: mplsTunnelResourceTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceTable.setDescription('The mplsTunnelResourceTable allows a manager to\n         specify which resources are desired for an MPLS\n         tunnel.  This table also allows several tunnels to\n         point to a single entry in this table, implying that\n         these tunnels should share resources.')
mplsTunnelResourceEntry = MibTableRow((1, 3, 6, 1, 3, 95, 1, 7, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setDescription('An entry in this table represents a set of resources\n         for an MPLS tunnel.  An entry can be created by a\n         network administrator or by an SNMP agent as\n         instructed by any MPLS signaling protocol.')
mplsTunnelResourceIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setDescription('Uniquely identifies this row.')
mplsTunnelResourceMaxRate = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 7, 1, 2), MplsBitRate()).setUnits('bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS\n         Label Switch Router Management Information Base\n         Using SMIv2, Internet Draft <draft-ietf-mpls-lsr-mib-\n         04.txt>, April 26,  2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setDescription('The maximum rate in bits/second.  Note that setting\n         mplsTunnelResourceMaxRate,\n         mplsTunnelResourceMeanRate, and\n         mplsTunnelResourceMaxBurstSize to 0 indicates best-\n         effort treatment.\n         This object is copied to an instance of\n         mplsTSpecMaxRate in mplsTSpecTable the index of\n         which is copied into the corresponding\n         mplsInSegmentTSpecIndex.')
mplsTunnelResourceMeanRate = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 7, 1, 3), MplsBitRate()).setUnits('bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS\n         Label Switch Router Management Information Base\n         Using SMIv2, Internet Draft <draft-ietf-mpls-lsr-mib-\n         04.txt>, April 26,  2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setDescription("This object is copied into an instance of\n         mplsTSpecMeanRate in the mplsTSpecTable. The index\n         of this table is then copied into the corresponding\n         mplsInSegmentTSpecIndex.\n        \n         When resource allocation is performed as requested\n         by this TSpec object, it is copied into an entry in\n         mplsTSpecTable [LSRMIB]: mplsTunnelInMeanRate to\n         mplsTSpecMeanRate. The mplsTSpecDirection of this\n         entry is set to 'in'(1).  The mplsTSpecIndex value\n         of this entry is copied to mplsInSegmentTSpecIndex\n         of the corresponding in-segment entry.")
mplsTunnelResourceMaxBurstSize = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 7, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau, MPLS\n         Label Switch Router Management Information Base\n         Using SMIv2, Internet Draft <draft-ietf-mpls-lsr-mib-\n         04.txt>, April 26, 2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setDescription("The maximum burst size in bytes.  This object is\n         copied to mplsInSegmentMaxBurstSize of the\n         corresponding in-segment.\n        \n         When resource allocation is performed as requested\n         by this TSpec object, it is copied into an entry in\n         mplsTSpecTable [LSRMIB]: mplsTunnelInMaxBurstSize to\n         mplsTSpecMaxBurstSize. The mplsTSpecDirection of\n         this entry is set to 'in'(1).  The mplsTSpecIndex\n         value of this entry is copied to\n         mplsInSegmentTSpecIndex of the corresponding in-\n         segment entry.")
mplsTunnelResourceRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 7, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setDescription('This variable is used to create, modify, and/or\n         delete a row in this table.')
mplsTunnelResourceStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 7, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setDescription('This variable indicates the storage type for this\n         object.')
mplsTunnelARHopTable = MibTable((1, 3, 6, 1, 3, 95, 1, 8), )
if mibBuilder.loadTexts: mplsTunnelARHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTable.setDescription('The mplsTunnelARHopTable is used to indicate the\n         hops, strict or loose, for an MPLS tunnel defined in\n         mplsTunnelTable, as reported by the MPLS signaling\n         protocol, for the outgoing direction of the tunnel.\n         Each row in this table is indexed primarily by the\n         same indices, mplsTunnelIndex and\n         mplsTunnelInstance, as the row of the corresponding\n         tunnel in mplsTunnelTable.  Each row also has a\n         third index mplsTunnelARHopIndex, corresponding to\n         the next hop that this row corresponds to.  The\n         first row in the table is the first hop after the\n         origination point of the tunnel.  In case we want to\n         specify a particular interface on the originating\n         LSR of an outgoing tunnel by which we want packets\n         to exit the LSR, we specify this as the first hop\n         for this tunnel in mplsTunnelARHopTable.\n        \n         Please note that since the information necessary to\n         build entries within this table are not provided by\n         some MPLS signaling protocols, implementation of\n         this table is optional. Furthermore, since the\n         information in this table is actually provided by\n         the MPLS signaling protocol after the path has been\n         set-up, the entries in this table are provided only\n         for observation, and hence, all variables in this\n         table are accessible exclusively as read-only.')
mplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 1, 8, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelARHopListIndex"), (0, "MPLS-TE-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setDescription('An entry in this table represents a tunnel hop.  An\n         entry is created by a network administrator for\n         signaled ERLSP set up by an MPLS signaling\n         protocol.')
mplsTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setDescription('Primary index into this table identifying a\n         particular recorded hop list.')
mplsTunnelARHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setDescription('Secondary index into this table identifying the\n         particular hop.')
mplsTunnelARHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3))).clone('ipV4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelARHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv4Addr.setDescription('If mplsTunnelARHopAddrType is set to ipV4(1), then\n         this value will contain the IPv4 address of this\n         hop. This object is otherwise insignificant and\n         should contain a value of 0.')
mplsTunnelARHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv4PrefixLen.setDescription("If mplsTunnelARHopAddrType is ipV4(1), then the\n         prefix length for this hop's IPv4 address is\n         contained herein. This object is otherwise\n         insignificant and should contain a value of 0.")
mplsTunnelARHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv6Addr.setDescription('If the mplsTunnelARHopAddrType is set to ipV6(2),\n         then this variable contains the IPv6 address of this\n         hop.  This object is otherwise insignificant and\n         should contain a value of 0.')
mplsTunnelARHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv6PrefixLen.setDescription("If mplsTunnelARHopAddrType is set to ipV6(2), this\n         value will contain the prefix length for this hop's\n         IPv6 address. This object is otherwise insignificant\n         and should contain a value of 0.")
mplsTunnelARHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAsNumber.setDescription('If mplsTunnelARHopAddrType is set to asNumber(3),\n         then this value will contain the AS number of this\n         hop. This object is otherwise insignificant and\n         should contain a value of 0 to indicate this fact.')
mplsTunnelARHopStrictOrLoose = MibTableColumn((1, 3, 6, 1, 3, 95, 1, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopStrictOrLoose.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopStrictOrLoose.setDescription('Denotes whether this is tunnel hop is routed in a\n         strict or loose fashion.')
mplsTunnelTrapEnable = MibScalar((1, 3, 6, 1, 3, 95, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setDescription('If this object is true, then it enables the\n         generation of mplsTunnelUp and mplsTunnelDown traps,\n         otherwise these traps are not emitted.')
mplsTunnelUp = NotificationType((1, 3, 6, 1, 3, 95, 2, 0, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelUp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUp.setDescription('This notification is generated when a\n         mplsTunnelOperStatus object for one of the\n         configured tunnels is about to leave the down state\n         and transition into some other state (but not into\n         the notPresent state).  This other state is\n         indicated by the included value of\n         mplsTunnelOperStatus.')
mplsTunnelDown = NotificationType((1, 3, 6, 1, 3, 95, 2, 0, 2)).setObjects(("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelDown.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDown.setDescription('This notification is generated when a\n         mplsTunnelOperStatus object for one of the\n         configured tunnels is about to enter the down state\n         from some other state (but not from the notPresent\n         state).  This other state is indicated by the\n         included value of mplsTunnelOperStatus.')
mplsTunnelRerouted = NotificationType((1, 3, 6, 1, 3, 95, 2, 0, 3)).setObjects(("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelRerouted.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRerouted.setDescription('This notification is generated when a tunnel is\n         rerouted or re-optimized. If the Actual Path is\n         used, then this object MAY contain the new path for\n         this tunnel some time after this trap is issued by\n         the agent.')
mplsTunnelReoptimized = NotificationType((1, 3, 6, 1, 3, 95, 2, 0, 4)).setObjects(("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelIngressLSRId"), ("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelReoptimized.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelReoptimized.setDescription('This notification is generated when a tunnel is\n          reoptimized. If the actual path is used, then this\n          object MAY contain the new path for this tunnel\n          some time after this trap is issued by the agent.')
mplsTeGroups = MibIdentifier((1, 3, 6, 1, 3, 95, 3, 1))
mplsTeCompliances = MibIdentifier((1, 3, 6, 1, 3, 95, 3, 2))
mplsTeModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 95, 3, 2, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelGroup"), ("MPLS-TE-MIB", "mplsTunnelManualGroup"), ("MPLS-TE-MIB", "mplsTunnelSignaledGroup"), ("MPLS-TE-MIB", "mplsTunnelIsNotIntfcGroup"), ("MPLS-TE-MIB", "mplsTunnelIsIntfcGroup"), ("MPLS-TE-MIB", "mplsTunnelOptionalGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeModuleCompliance = mplsTeModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsTeModuleCompliance.setDescription('Compliance statement for agents that support the\n         MPLS TE MIB.')
mplsTunnelGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 3, 1, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelIndexNext"), ("MPLS-TE-MIB", "mplsTunnelName"), ("MPLS-TE-MIB", "mplsTunnelDescr"), ("MPLS-TE-MIB", "mplsTunnelOwner"), ("MPLS-TE-MIB", "mplsTunnelXCPointer"), ("MPLS-TE-MIB", "mplsTunnelIfIndex"), ("MPLS-TE-MIB", "mplsTunnelHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelARHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-MIB", "mplsTunnelRowStatus"), ("MPLS-TE-MIB", "mplsTunnelTrapEnable"), ("MPLS-TE-MIB", "mplsTunnelStorageType"), ("MPLS-TE-MIB", "mplsTunnelMaxHops"), ("MPLS-TE-MIB", "mplsTunnelResourcePointer"), ("MPLS-TE-MIB", "mplsTunnelInstancePriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelGroup = mplsTunnelGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelGroup.setDescription('Necessary, but not sufficient, set of objects to\n         implement tunnels.  In addition, depending on the\n         type of the tunnels supported (for example, manually\n         configured or signaled, persistent or non-\n         persistent, etc.), the following other groups\n         defined below are mandatory: mplsTunnelManualGroup\n         and/or mplsTunnelSignaledGroup,\n         mplsTunnelIsNotIntfcGroup and/or\n         mplsTunnelIsIntfcGroup.')
mplsTunnelManualGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 3, 1, 2)).setObjects(("MPLS-TE-MIB", "mplsTunnelSignallingProto"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelManualGroup = mplsTunnelManualGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManualGroup.setDescription('Object(s) needed to implement manually configured\n         tunnels.')
mplsTunnelSignaledGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 3, 1, 3)).setObjects(("MPLS-TE-MIB", "mplsTunnelSetupPrio"), ("MPLS-TE-MIB", "mplsTunnelHoldingPrio"), ("MPLS-TE-MIB", "mplsTunnelSignallingProto"), ("MPLS-TE-MIB", "mplsTunnelLocalProtectInUse"), ("MPLS-TE-MIB", "mplsTunnelSessionAttributes"), ("MPLS-TE-MIB", "mplsTunnelHopIndexNext"), ("MPLS-TE-MIB", "mplsTunnelHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelHopLspId"), ("MPLS-TE-MIB", "mplsTunnelHopStrictOrLoose"), ("MPLS-TE-MIB", "mplsTunnelHopRowStatus"), ("MPLS-TE-MIB", "mplsTunnelHopStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelSignaledGroup = mplsTunnelSignaledGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignaledGroup.setDescription('Object needed to implement signaled tunnels.')
mplsTunnelIsIntfcGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 3, 1, 4)).setObjects(("MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsIntfcGroup = mplsTunnelIsIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIntfcGroup.setDescription('Objects needed to implement tunnels that are\n         interfaces.')
mplsTunnelIsNotIntfcGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 3, 1, 5)).setObjects(("MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsNotIntfcGroup = mplsTunnelIsNotIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsNotIntfcGroup.setDescription('Objects needed to implement tunnels that are not\n         interfaces.')
mplsTunnelOptionalGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 3, 1, 6)).setObjects(("MPLS-TE-MIB", "mplsTunnelResourceIndexNext"), ("MPLS-TE-MIB", "mplsTunnelResourceMaxRate"), ("MPLS-TE-MIB", "mplsTunnelResourceMeanRate"), ("MPLS-TE-MIB", "mplsTunnelResourceMaxBurstSize"), ("MPLS-TE-MIB", "mplsTunnelResourceRowStatus"), ("MPLS-TE-MIB", "mplsTunnelResourceStorageType"), ("MPLS-TE-MIB", "mplsTunnelARHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelARHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelARHopStrictOrLoose"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelOptionalGroup = mplsTunnelOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOptionalGroup.setDescription('The objects in this group are optional.')
mplsTeNotificationGroup = NotificationGroup((1, 3, 6, 1, 3, 95, 3, 1, 7)).setObjects(("MPLS-TE-MIB", "mplsTunnelUp"), ("MPLS-TE-MIB", "mplsTunnelDown"), ("MPLS-TE-MIB", "mplsTunnelRerouted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeNotificationGroup = mplsTeNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTeNotificationGroup.setDescription('Set of notifications implemented in this module.\n         None is mandatory.')
mibBuilder.exportSymbols("MPLS-TE-MIB", mplsTunnelARHopIpv6Addr=mplsTunnelARHopIpv6Addr, MplsTunnelIndex=MplsTunnelIndex, mplsTunnelRerouted=mplsTunnelRerouted, mplsTunnelResourceMaxRate=mplsTunnelResourceMaxRate, mplsTunnelAdminStatus=mplsTunnelAdminStatus, mplsTunnelRowStatus=mplsTunnelRowStatus, mplsTunnelTable=mplsTunnelTable, mplsTunnelEntry=mplsTunnelEntry, mplsTeNotifications=mplsTeNotifications, mplsTunnelHopIpv4Addr=mplsTunnelHopIpv4Addr, mplsTunnelHopLspId=mplsTunnelHopLspId, mplsTunnelHoldingPrio=mplsTunnelHoldingPrio, mplsTunnelIndexNext=mplsTunnelIndexNext, mplsTunnelName=mplsTunnelName, mplsTeCompliances=mplsTeCompliances, mplsTunnelHopTableIndex=mplsTunnelHopTableIndex, MplsBurstSize=MplsBurstSize, mplsTunnelStorageType=mplsTunnelStorageType, mplsTunnelHopStorageType=mplsTunnelHopStorageType, mplsTunnelSignaledGroup=mplsTunnelSignaledGroup, mplsTunnelHopEntry=mplsTunnelHopEntry, mplsTunnelARHopStrictOrLoose=mplsTunnelARHopStrictOrLoose, mplsTunnelResourceEntry=mplsTunnelResourceEntry, mplsTunnelIndex=mplsTunnelIndex, mplsTunnelHopIpv6Addr=mplsTunnelHopIpv6Addr, mplsTunnelManualGroup=mplsTunnelManualGroup, mplsTunnelHopIndexNext=mplsTunnelHopIndexNext, mplsTunnelOperStatus=mplsTunnelOperStatus, mplsTunnelOwner=mplsTunnelOwner, mplsTunnelIsIf=mplsTunnelIsIf, mplsTunnelHopListIndex=mplsTunnelHopListIndex, mplsTunnelIngressLSRId=mplsTunnelIngressLSRId, mplsTeModuleCompliance=mplsTeModuleCompliance, mplsTeObjects=mplsTeObjects, mplsTunnelMaxHops=mplsTunnelMaxHops, mplsTunnelARHopIpv4Addr=mplsTunnelARHopIpv4Addr, PYSNMP_MODULE_ID=mplsTeMIB, mplsTunnelInstancePriority=mplsTunnelInstancePriority, mplsTunnelResourcePointer=mplsTunnelResourcePointer, mplsTunnelHopStrictOrLoose=mplsTunnelHopStrictOrLoose, mplsTunnelARHopAddrType=mplsTunnelARHopAddrType, mplsTeMIB=mplsTeMIB, mplsTeGroups=mplsTeGroups, mplsTunnelResourceMeanRate=mplsTunnelResourceMeanRate, mplsTunnelUp=mplsTunnelUp, mplsTeNotificationGroup=mplsTeNotificationGroup, mplsTunnelGroup=mplsTunnelGroup, MplsBitRate=MplsBitRate, mplsTunnelARHopTable=mplsTunnelARHopTable, mplsTunnelLocalProtectInUse=mplsTunnelLocalProtectInUse, mplsTunnelInstance=mplsTunnelInstance, mplsTunnelIfIndex=mplsTunnelIfIndex, mplsTunnelResourceStorageType=mplsTunnelResourceStorageType, mplsTunnelDown=mplsTunnelDown, mplsTunnelARHopIndex=mplsTunnelARHopIndex, mplsTunnelSessionAttributes=mplsTunnelSessionAttributes, mplsTunnelARHopAsNumber=mplsTunnelARHopAsNumber, mplsTunnelHopIpv4PrefixLen=mplsTunnelHopIpv4PrefixLen, mplsTunnelARHopTableIndex=mplsTunnelARHopTableIndex, mplsTunnelHopAsNumber=mplsTunnelHopAsNumber, mplsTeNotifyPrefix=mplsTeNotifyPrefix, mplsTunnelResourceIndexNext=mplsTunnelResourceIndexNext, mplsTunnelXCPointer=mplsTunnelXCPointer, mplsTunnelResourceRowStatus=mplsTunnelResourceRowStatus, mplsTunnelReoptimized=mplsTunnelReoptimized, mplsTunnelSetupPrio=mplsTunnelSetupPrio, mplsTunnelSignallingProto=mplsTunnelSignallingProto, mplsTunnelOptionalGroup=mplsTunnelOptionalGroup, mplsTunnelARHopIpv6PrefixLen=mplsTunnelARHopIpv6PrefixLen, mplsTunnelIsIntfcGroup=mplsTunnelIsIntfcGroup, mplsTeConformance=mplsTeConformance, mplsTunnelHopIndex=mplsTunnelHopIndex, MplsLSPID=MplsLSPID, mplsTunnelHopRowStatus=mplsTunnelHopRowStatus, mplsTunnelHopAddrType=mplsTunnelHopAddrType, mplsTunnelResourceTable=mplsTunnelResourceTable, mplsTunnelResourceMaxBurstSize=mplsTunnelResourceMaxBurstSize, mplsTunnelARHopEntry=mplsTunnelARHopEntry, mplsTunnelResourceIndex=mplsTunnelResourceIndex, mplsTunnelHopTable=mplsTunnelHopTable, mplsTunnelHopIpv6PrefixLen=mplsTunnelHopIpv6PrefixLen, mplsTunnelARHopIpv4PrefixLen=mplsTunnelARHopIpv4PrefixLen, mplsTunnelTrapEnable=mplsTunnelTrapEnable, mplsTunnelDescr=mplsTunnelDescr, mplsTunnelIsNotIntfcGroup=mplsTunnelIsNotIntfcGroup, mplsTunnelARHopListIndex=mplsTunnelARHopListIndex)
