#
# PySNMP MIB module MPLS-TE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/MPLS-TE-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 15:51:03 2022
# On host fv-az77-763 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressIPv6, InetAddressIPv4 = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6", "InetAddressIPv4")
MplsBurstSize, MplsBitRate, MplsLSPID = mibBuilder.importSymbols("MPLS-LSR-MIB", "MplsBurstSize", "MplsBitRate", "MplsLSPID")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter32, ModuleIdentity, TimeTicks, MibIdentifier, Bits, NotificationType, Gauge32, IpAddress, Unsigned32, Counter64, ObjectIdentity, iso, experimental, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "TimeTicks", "MibIdentifier", "Bits", "NotificationType", "Gauge32", "IpAddress", "Unsigned32", "Counter64", "ObjectIdentity", "iso", "experimental", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, StorageType, TextualConvention, TimeStamp, TruthValue, RowPointer, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "StorageType", "TextualConvention", "TimeStamp", "TruthValue", "RowPointer", "RowStatus")
mplsTeMIB = ModuleIdentity((1, 3, 6, 1, 3, 95))
mplsTeMIB.setRevisions(('2000-11-21 12:00', '2000-07-14 12:00', '2000-05-26 12:00', '2000-03-03 12:00', '1999-07-16 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsTeMIB.setRevisionsDescriptions(('Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Updates based on MPLS WG feedback', 'Initial draft version.',))
if mibBuilder.loadTexts: mplsTeMIB.setLastUpdated('200011211200Z')
if mibBuilder.loadTexts: mplsTeMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsTeMIB.setContactInfo('        Cheenu Srinivasan\n           Postal: Tachion Networks, Inc.\n                 Monmouth Park Corporate Center I\n                 Building C, 185 Monmouth Park Highway\n                 West Long Branch, NJ 07764\n           Tel:    +1-732-542-7750 x1234\n           Email:  cheenu@tachion.com\n\n                   Arun Viswanathan\n           Postal: Force10 Networks, Inc.\n                   1440 McCarthy Blvd\n                   Milpitas, CA 95035\n           Tel:    +1-408-571-3516\n           Email:  arun@force10networks.com\n\n                 Thomas D. Nadeau\n         Postal: Cisco Systems, Inc.\n                 250 Apollo Drive\n                 Chelmsford, MA 01824\n         Tel:    +1-978-244-3051\n           Email:  tnadeau@cisco.com')
if mibBuilder.loadTexts: mplsTeMIB.setDescription("This MIB module contains managed object\n           definitions for MPLS Traffic Engineering (TE) as\n           defined in: Extensions to RSVP for LSP Tunnels,\n           Awduche et al, Internet Draft <draft-ietf-mpls-\n           rsvp-lsp-tunnel-07.txt>, August 2000; Constraint-\n           Based LSP Setup using LDP, B. Jamoussi, Internet\n           Draft <draft-ietf-mpls-cr-ldp-04.txt>, July 2000;\n           Requirements for Traffic Engineering Over MPLS,\n           Awduche, D., J. Malcolm, J., Agogbua, J., O'Dell,\n           M., J. McManus, <rfc2702.txt>, September 1999.")
class MplsTunnelIndex(TextualConvention, Integer32):
    description = 'Index into mplsTunnelTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

class MplsTunnelInstanceIndex(TextualConvention, Unsigned32):
    description = 'Instance index into mplsTunnelTable.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class MplsLsrId(TextualConvention, Unsigned32):
    description = 'A unique identifier for an MPLS LSR. This MAY\n           represent an IpV4 address.'
    status = 'current'

class MplsPathIndex(TextualConvention, Unsigned32):
    description = 'A unique identifier used to identify a specific\n           path used by a tunnel.'
    status = 'current'

class MplsPathIndexOrZero(TextualConvention, Unsigned32):
    description = 'A unique identifier used to identify a specific\n           path used by a tunnel. If this value is set to 0,\n           it indicates that no path is in use.'
    status = 'current'

mplsTeScalars = MibIdentifier((1, 3, 6, 1, 3, 95, 1))
mplsTeObjects = MibIdentifier((1, 3, 6, 1, 3, 95, 2))
mplsTeNotifications = MibIdentifier((1, 3, 6, 1, 3, 95, 3))
mplsTeNotifyPrefix = MibIdentifier((1, 3, 6, 1, 3, 95, 3, 0))
mplsTeConformance = MibIdentifier((1, 3, 6, 1, 3, 95, 4))
mplsTunnelConfigured = MibScalar((1, 3, 6, 1, 3, 95, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelConfigured.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelConfigured.setDescription('The number of tunnels configured on this device. A\n           tunnel is considered configured if the\n           mplsTunnelRowStatus is active(1).')
mplsTunnelActive = MibScalar((1, 3, 6, 1, 3, 95, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelActive.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelActive.setDescription('The number of tunnels active on this device. A\n           tunnel is considered active if the\n           mplsTunnelOperStatus is up(1).')
mplsTunnelTEDistProto = MibScalar((1, 3, 6, 1, 3, 95, 1, 3), Bits().clone(namedValues=NamedValues(("other", 0), ("ospf", 1), ("isis", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelTEDistProto.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTEDistProto.setDescription('The traffic engineering distribution protocol(s)\n           used by this LSR. Note that an LSR may support\n           more than one distribution protocols\n           simultaneously.')
mplsTunnelMaxHops = MibScalar((1, 3, 6, 1, 3, 95, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelMaxHops.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelMaxHops.setDescription('The maximum number of hops that can be specified\n           for a tunnel on this device.')
mplsTunnelIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndexNext.setDescription('This object contains the next appropriate value to\n           be used for mplsTunnelIndex when creating entries\n           in  mplsTunnelTable. If the number of unassigned\n           entries is exhausted, a retrival operation will\n           return a value of 0.  This object may also return\n           a value of 0 when the LSR is unable to accept\n           conceptual row creation, for example, if the\n           mplsTunnelTable is implemented as read-only. To\n           obtain the value of mplsTunnelIndex for a new\n           entry, the manager must first issue a management\n           protocol retrieval operation to obtain the current\n           value of this object. The agent should modify the\n           value to reflect the next unassigned index after\n           each retrieval operation. After a manager\n           retrieves a value the agent will determine through\n           its local policy when this index value will be\n           made available for reuse.')
mplsTunnelTable = MibTable((1, 3, 6, 1, 3, 95, 2, 2), )
if mibBuilder.loadTexts: mplsTunnelTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTable.setDescription('The mplsTunnelTable allows new MPLS tunnels to be\n           created between an LSR and a remote endpoint, and\n           existing tunnels to be reconfigured or removed.\n           Note that only point-to-point tunnel segments are\n           supported, although multi-point-to-point and point-\n           to-multi-point connections are supported by an LSR\n           acting as a cross-connect.  Each MPLS tunnel can\n           thus have one out-segment originating at this LSR\n           and/or one in-segment terminating at this LSR.')
mplsTunnelEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 2, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: mplsTunnelEntry.setReference('1. RFC 2233 - The Interfaces Group MIB using\n           SMIv2, McCloghrie, K., and F. Kastenholtz, Nov.\n           1997\n           2. RFC 1700 - Assigned Numbers, Reynolds, J. and\n           J. Postel, Oct. 1994')
if mibBuilder.loadTexts: mplsTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEntry.setDescription('An entry in this table represents an MPLS tunnel.\n           An entry can be created by a network administrator\n           or by an SNMP agent as instructed by an MPLS\n           signaling protocol. Whenever a new entry is\n           created with mplsTunnelIsIf set to true(1), then a\n           corresponding entry is created in ifTable as well\n           (see RFC 2233). The ifType of this entry is\n           mplsTunnel(150).')
mplsTunnelIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 1), MplsTunnelIndex())
if mibBuilder.loadTexts: mplsTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIndex.setDescription('Uniquely identifies this row.')
mplsTunnelInstance = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 2), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: mplsTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstance.setDescription('Uniquely identifies an instance of a tunnel. It is\n           useful to identify multiple instances of tunnels\n           for the purposes of backup and parallel tunnels.')
mplsTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 3), MplsLsrId())
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n           Awduche et al, Internet Draft <draft-ietf-mpls-\n           rsvp-lsp-tunnel-07.txt>, August 2000.,\n           2. Constraint-Based LSP Setup using LDP, Jamoussi,\n           Internet Draft <draft-ietf-mpls-cr-ldp-04.txt>,\n           July 2000.')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setDescription('The purpose of this object is to uniquely identity\n           a tunnel within a network. When the MPLS\n           signalling protoocol is rsvp(2) this value should\n           mimic the Extended Tunnel Id field in the Session\n           object. When the MPLS signalling protoocol is\n           crldp(3) this value should mimic the Ingress LSR\n           Router ID field in the LSPID TLV object.')
mplsTunnelEgressLSRId = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 4), MplsLsrId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelEgressLSRId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelEgressLSRId.setDescription('Specifies the egress LSR Id.')
mplsTunnelName = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelName.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n           McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelName.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelName.setDescription('The canonical name assigned to the tunnel. This\n           name can be used to refer to the tunnel on the\n           LSRs console port.  If mplsTunnelIsIf is set to\n           true then the ifName of the interface\n           corresponding to this tunnel should have a value\n           equal to mplsTunnelName.  Also see the description\n           of ifName in RFC 2233.')
mplsTunnelDescr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 6), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDescr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDescr.setDescription('A textual string containing information about the\n           tunnel.  If there is no description this object\n           contains a zero length string.')
mplsTunnelIsIf = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsIf.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n           McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelIsIf.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIf.setDescription('Denotes whether or not this tunnel corresponds to\n           an interface represented in the interfaces group\n           table. Note that if this variable is set to true\n           then the ifName of the interface corresponding to\n           this tunnel should have a value equal to\n           mplsTunnelName.  Also see the description of\n           ifName in RFC 2233.')
mplsTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n           McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIfIndex.setDescription('If mplsTunnelIsIf is set to true, then this value\n           contains the LSR-assigned ifIndex which\n           corresponds to an entry in the interfaces table.\n           Otherwise this variable should contain the value\n           of zero indicating that a valid ifIndex was not\n           assigned to this tunnel interface.')
mplsTunnelXCPointer = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 9), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelXCPointer.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau,\n           MPLS Label Switch Router Management Information\n           Base Using SMIv2, Internet Draft <draft-ietf-mpls-\n           lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelXCPointer.setDescription('This variable points to a row in the mplsXCTable.\n           This table identifies the segments that compose\n           this tunnel, their characteristics, and\n           relationships to each other. A value of\n           zeroDotZero indicates that no LSP has been\n           associated with this tunnel yet.')
mplsTunnelSignallingProto = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("rsvp", 2), ("crldp", 3), ("other", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setDescription('The signaling protocol, if any, which was used to\n           setup this tunnel.')
mplsTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n           Awduche et al, Internet Draft <draft-ietf-mpls-\n           rsvp-lsp-tunnel-07.txt>, August 2000.,\n           2. Constraint-Based LSP Setup using LDP, Jamoussi,\n           Internet Draft <draft-ietf-mpls-cr-ldp-04.txt>,\n           July 2000.')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setDescription('Indicates the setup priority of this tunnel.')
mplsTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n           Awduche et al, Internet Draft <draft-ietf-mpls-\n           rsvp-lsp-tunnel-07.txt>, August 2000.,\n           2. Constraint-Based LSP Setup using LDP, Jamoussi,\n           Internet Draft <draft-ietf-mpls-cr-ldp-04.txt>,\n           July 2000.')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setDescription('Indicates the holding priority for this tunnel.')
mplsTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 13), Bits().clone(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("isPinned", 3), ("isComputed", 4), ("recordRoute", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setReference('1. RSVP-TE: Extensions to RSVP for LSP Tunnels,\n           Awduche et al, Internet Draft <draft-ietf-mpls-\n           rsvp-lsp-tunnel-07.txt>, August 2000.')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setDescription('This bitmask indicates optional session values for\n           this tunnel. The following describes these\n           bitfields:\n\n          fastRerouteThis flag indicates that the any tunnel\n           hop may choose to reroute this tunnel without\n           tearing it down.\n          This flag permits transit routers to use a local\n           repair mechanism which may result in violation of\n           the explicit routing of this tunnel. When a fault\n           is detected on an adjacent downstream link or\n           node, a transit router can reroute traffic for\n           fast service restoration.\n\n          mergingPermitted This flag permits transit routers\n           to merge this session with other RSVP sessions for\n           the purpose of reducing resource overhead on\n           downstream transit routers, thereby providing\n           better network scalability.\n\n          isPersistent  Indicates whether this tunnel should\n           be restored automatically after a failure occurs.\n\n          isPinned   This flag indicates whether the loose-\n           routed hops of this tunnel are to be pinned.\n\n          isComputed This flag indicates whether the tunnel\n           path is computed using a constraint-based routing\n           algorithm based on the mplsTunnelHopTable entries.\n\n          recordRoute               This flag indicates\n           whether or not the signaling protocol should\n           remember the tunnel path after it has been\n           signaled.')
mplsTunnelOwner = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("admin", 1), ("rsvp", 2), ("crldp", 3), ("policyAgent", 4), ("other", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelOwner.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOwner.setDescription('Indicates which protocol created and is\n           responsible for managing this tunnel. Values\n           rsvp(2) and crldp(3) should not be used at the\n           head-end of a MPLS tunnel.')
mplsTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 15), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setDescription('Indicates that the local repair mechanism is in\n           use to maintain this tunnel (usually in the face\n           of an outage of the link it was previously routed\n           over).')
mplsTunnelResourcePointer = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 16), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setDescription('This variable represents a pointer to the traffic\n           parameter specification for this tunnel.  This\n           value may point at an entry in the\n           mplsTunnelResourceEntry to indicate which\n           mplsTunnelResourceEntry is to be assigned to this\n           segment.  This value may optionally point at an\n           externally defined traffic parameter specification\n           table.  A value of zeroDotZero indicates best-\n           effort treatment.  By having the same value of\n           this object, two or more segments can indicate\n\n\n           resource sharing.')
mplsTunnelInstancePriority = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 17), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setDescription('This value indicates which priority, in descending\n           order, with 0 indicating the lowest priority,\n           within a group of tunnel instances. A group of\n           tunnel instances is defined as a set of tunnels\n           with the same mplsTunnelIndex in this table, but\n           with a different mplsTunnelInstance. Tunnel group\n           priorities are used to denote the priority at\n           which a particular tunnel instance will supercede\n           another. Instances of tunnels containing the same\n           mplsTunnelInstancePriority will be used for load\n           sharing.')
mplsTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 18), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setDescription('Index into the mplsTunnelHopTable entry that\n           specifies the explicit route hops for this\n           tunnel.')
mplsTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 19), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setDescription('Index into the mplsTunnelARHopTable entry that\n           specifies the actual hops traversed by the\n           tunnel.')
mplsTunnelCHopTableIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 20), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopTableIndex.setDescription('Index into the mplsTunnelCHopTable entry that\n           specifies the computed hops traversed by the\n           tunnel.')
mplsTunnelPrimaryInstance = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 21), MplsTunnelInstanceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryInstance.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPrimaryInstance.setDescription('Specifies the instance index of the primary\n           instance of this tunnel.')
mplsTunnelPrimaryTimeUp = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryTimeUp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPrimaryTimeUp.setDescription('Specifies the total time the primary instance of\n           this tunnel has been active. The primary instance\n           of this tunnel is defined in\n           mplsTunnelPrimaryInstance.')
mplsTunnelPathChanges = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPathChanges.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPathChanges.setDescription('Specifies the number of times the paths has\n           changed for this tunnel.')
mplsTunnelLastPathChange = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelLastPathChange.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelLastPathChange.setDescription('Specifies the time since the last path change for\n           this tunnel.')
mplsTunnelCreationTime = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 25), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCreationTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCreationTime.setDescription('Specifies the value of SysUpTime when the first\n           instance of this tunnel came into existence.')
mplsTunnelStateTransitions = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelStateTransitions.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelStateTransitions.setDescription('Specifies the number of times the state of this\n           tunnel instance has changed.')
mplsTunnelIncludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 27), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setReference('RSVP-TE: Extensions to RSVP for LSP\n           Tunnels,\n                     draft-ietf-mpls-rsvp-lsp-tunnel-07.txt')
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setDescription('A link satisfies the include-any constraint if and\n           only if the constraint is zero, or the link and\n           the constraint have a resource class in common.')
mplsTunnelIncludeAllAffinity = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 28), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setReference('RSVP-TE: Extensions to RSVP for LSP\n           Tunnels, draft-ietf-mpls-rsvp-lsp-tunnel-07.txt')
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setDescription('A link satisfies the include-all constraint if and\n           only if the link contains all of the adminstrative\n           groups specified in the constraint.')
mplsTunnelExcludeAllAffinity = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 29), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelExcludeAllAffinity.setReference('RSVP-TE: Extensions to RSVP for LSP\n           Tunnels, draft-ietf-mpls-rsvp-lsp-tunnel-07.txt')
if mibBuilder.loadTexts: mplsTunnelExcludeAllAffinity.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelExcludeAllAffinity.setDescription('A link satisfies the exclude-all constraint if and\n           only if the link contains none of the\n           adminstrative groups specifie in the constraint.')
mplsTunnelPathInUse = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 30), MplsPathIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelPathInUse.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPathInUse.setDescription('This value denotes the configured path that was\n           chosen for this tunnel. This value reflects the\n           secondary index into the TunnelHopTable. This path\n           may not exactly match the one in the ARHopTable\n           due to the fact that some CSPF modification may\n           have taken place. See the ARHopTable for the\n           actual path being taken by the tunnel. A value of\n           zero denotes that no path is currently in use or\n           available.')
mplsTunnelRole = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("head", 1), ("transit", 2), ("tail", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRole.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRole.setDescription('This value signifies the role that this tunnel\n           entry/instance represents. This value MUST be set\n           to head(1) at the originating point of the tunnel.\n           This value MUST be set to transit(2) at transit\n           points along the tunnel, if transit points are\n           supported. This value MUST be set to tail(3) at\n           the terminating point of the tunnel if tunnel\n           tails are supported.')
mplsTunnelTotalUpTime = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 32), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelTotalUpTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTotalUpTime.setDescription('This value represents the aggregate up time for\n           all instances of this tunnel, if available. If\n           this value is unavailable, it MUST return a value\n           of 0.')
mplsTunnelInstanceUpTime = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 33), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelInstanceUpTime.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelInstanceUpTime.setDescription("This value identifies the total time that this\n           tunnel instance's operStatus has been Up(1).")
mplsTunnelAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setDescription('Indicates the desired operational status of this\n           tunnel.')
mplsTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOperStatus.setDescription('Indicates the actual operational status of this\n           tunnel, which is typically but not limited to, a\n           function of the state of individual segments of\n           this tunnel.')
mplsTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 36), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRowStatus.setDescription('This variable is used to create, modify, and/or\n           delete a row in this table.')
mplsTunnelStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 2, 1, 37), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelStorageType.setDescription('This variable indicates the storage type for this\n           object.')
mplsTunnelHopListIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelHopListIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopListIndexNext.setDescription('This object contains an appropriate value to be\n           used for mplsTunnelHopListIndex when creating\n           entries in the mplsTunnelHopTable.  If the number\n           of unassigned entries is exhausted, a retrival\n           operation will return a value of 0.  This object\n           may also return a value of 0 when the LSR is\n           unable to accept conceptual row creation, for\n           example, if the mplsTunnelHopTable is implemented\n           as read-only.  To obtain the value of\n           mplsTunnelHopListIndex for a new entry in the\n           mplsTunnelHopTable, the manager issues a\n           management protocol retrieval operation to obtain\n           the current value of mplsTunnelHopIndex.  After\n           each retrieval operation, the agent should modify\n           the value to reflect the next unassigned index.\n           After a manager retrieves a value the agent will\n           determine through its local policy when this index\n           value will be made available for reuse.')
mplsTunnelHopTable = MibTable((1, 3, 6, 1, 3, 95, 2, 4), )
if mibBuilder.loadTexts: mplsTunnelHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopTable.setDescription('The mplsTunnelHopTable is used to indicate the\n           hops, strict or loose, for an MPLS tunnel defined\n           in mplsTunnelTable, when it is established via\n           signaling, for the outgoing direction of the\n           tunnel.  Each row in this table is indexed by\n           mplsTunnelHopListIndex.  Each row also has a\n           secondary index mplsTunnelHopIndex corresponding\n           to the next hop that this row corresponds to.  The\n           first row in the table is the first hop after the\n           origination point of the tunnel.  In case we want\n           to specify a particular interface on the\n           originating LSR of an outgoing tunnel by which we\n           want packets to exit the LSR, we specify this as\n           the first hop for this tunnel in\n\n\n           mplsTunnelHopTable.')
mplsTunnelHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 4, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelHopListIndex"), (0, "MPLS-TE-MIB", "mplsPathOptionIndex"), (0, "MPLS-TE-MIB", "mplsTunnelHopIndex"))
if mibBuilder.loadTexts: mplsTunnelHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopEntry.setDescription('An entry in this table represents a tunnel hop.\n           An entry is created by a network administrator for\n           signaled ERLSP set up by an MPLS signaling\n           protocol.')
mplsTunnelHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 1), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setDescription('Primary index into this table identifying a\n           particular explicit route object.')
mplsPathOptionIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 2), MplsPathIndex())
if mibBuilder.loadTexts: mplsPathOptionIndex.setStatus('current')
if mibBuilder.loadTexts: mplsPathOptionIndex.setDescription('Secondary index into this table identifying a\n           particular group of hops representing a particular\n           configured path. This is otherwise known as a path\n           option.')
mplsTunnelHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 3), MplsPathIndex())
if mibBuilder.loadTexts: mplsTunnelHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIndex.setDescription('Secondary index into this table identifying a\n           particular hop.')
mplsTunnelHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3), ("lspid", 4))).clone('ipV4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 5), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv4Addr.setDescription('If mplsTunnelHopAddrType is set to ipV4(1), then\n           this value will contain the IPv4 address of this\n           hop. This object is otherwise insignificant and\n           should contain a value of 0.')
mplsTunnelHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv4PrefixLen.setDescription("If mplsTunnelHopAddrType is ipV4(1), then the\n           prefix length for this hop's IPv4 address is\n           contained herein. This object is otherwise\n           insignificant and should contain a value of 0.")
mplsTunnelHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 7), InetAddressIPv6()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv6Addr.setDescription('If the mplsTunnelHopAddrType is set to ipV6(2),\n           then this variable contains the IPv6 address of\n           this hop.  This object is otherwise insignificant\n           and should contain a value of 0.')
mplsTunnelHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopIpv6PrefixLen.setDescription("If mplsTunnelHopAddrType is set to ipV6(2), this\n           value will contain the prefix length for this\n           hop's IPv6 address. This object is otherwise\n           insignificant and should contain a value of 0.")
mplsTunnelHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setDescription('If mplsTunnelHopAddrType is set to asNumber(3),\n           then this value will contain the AS number of this\n           hop. This object is otherwise insignificant and\n           should contain a value of 0 to indicate this\n           fact.')
mplsTunnelHopLspId = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 10), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopLspId.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopLspId.setDescription('If mplsTunnelHopAddrType is set to lspid(4), then\n           this value will contain the LSPID of a tunnel of\n           this hop. The present tunnel being configured is\n           tunneled through this hop (using label\n           stacking). This object is otherwise insignificant\n           and should contain a value of 0 to indicate this\n           fact.')
mplsTunnelHopType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopType.setDescription('Denotes whether this tunnel hop is routed in a\n           strict or loose fashion.')
mplsTunnelHopRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setDescription('This variable is used to create, modify, and/or\n           delete a row in this table.')
mplsTunnelHopStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 4, 1, 13), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setDescription('This variable indicates the storage type for this\n           object.')
mplsTunnelResourceIndexNext = MibScalar((1, 3, 6, 1, 3, 95, 2, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelResourceIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndexNext.setDescription('This object contains the next appropriate value to\n           be used for mplsTunnelResourceIndex when creating\n           entries in the mplsTunnelResourceTable. If the\n           number of unassigned entries is exhausted, a\n           retrival operation will return a value of 0.  This\n           object may also return a value of 0 when the LSR\n           is unable to accept conceptual row creation, for\n           example, if the mplsTunnelTable is implemented as\n           read-only.  To obtain the mplsTunnelResourceIndex\n           value for a new entry, the manager must first\n           issue a management protocol retrieval operation to\n           obtain the current value of this object. The agent\n           should modify the value to reflect the next\n           unassigned index after each retrieval operation.\n           After a manager retrieves a value the agent will\n           determine through its local policy when this index\n\n\n           value will be made available for reuse.')
mplsTunnelResourceTable = MibTable((1, 3, 6, 1, 3, 95, 2, 6), )
if mibBuilder.loadTexts: mplsTunnelResourceTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceTable.setDescription('The mplsTunnelResourceTable allows a manager to\n           specify which resources are desired for an MPLS\n           tunnel.  This table also allows several tunnels to\n           point to a single entry in this table, implying\n           that these tunnels should share resources.')
mplsTunnelResourceEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 6, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setDescription('An entry in this table represents a set of\n           resources for an MPLS tunnel.  An entry can be\n           created by a network administrator or by an SNMP\n           agent as instructed by any MPLS signaling\n           protocol.')
mplsTunnelResourceIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setDescription('Uniquely identifies this row.')
mplsTunnelResourceMaxRate = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 2), MplsBitRate()).setUnits('bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau,\n           MPLS Label Switch Router Management Information\n           Base Using SMIv2, Internet Draft <draft-ietf-mpls-\n           lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setDescription('The maximum rate in bits/second.  Note that\n           setting mplsTunnelResourceMaxRate,\n           mplsTunnelResourceMeanRate, and\n           mplsTunnelResourceMaxBurstSize to 0 indicates best-\n           effort treatment.\n           This object is copied to an instance of\n           mplsTrafficParamMaxRate in mplsTrafficParamTable\n           the OID of which is copied into the corresponding\n           mplsInSegmentTrafficParamPtr.')
mplsTunnelResourceMeanRate = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 3), MplsBitRate()).setUnits('bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau,\n           MPLS Label Switch Router Management Information\n           Base Using SMIv2, Internet Draft <draft-ietf-mpls-\n           lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setDescription('This object is copied into an instance of\n           mplsTrafficParamMeanRate in the\n           mplsTrafficParamTable. The OID of this table entry\n           is then copied into the corresponding\n           mplsInSegmentTrafficParamPtr.\n\n           When resource allocation is performed as requested\n           by this TSpec object, it is copied into an entry\n           in mplsTrafficParamTable [LSRMIB]:\n           mplsTunnelInMeanRate to mplsTrafficParamMeanRate.\n           The OID of this entry is copied to\n           mplsInSegmentTrafficParamPtr of the corresponding\n           in-segment entry.')
mplsTunnelResourceMaxBurstSize = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setReference('Srinivasan, C., Viswanathan, A., and T. Nadeau,\n           MPLS Label Switch Router Management Information\n           Base Using SMIv2, Internet Draft <draft-ietf-mpls-\n           lsr-mib-06.txt>, July 2000.')
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setDescription('The maximum burst size in bytes.  This object is\n           copied to mplsInSegmentMaxBurstSize of the\n           corresponding in-segment.\n\n           When resource allocation is performed as requested\n           by this TSpec object, it is copied into an entry\n           in mplsTrafficParamTable [LSRMIB]:\n           mplsTunnelInMaxBurstSize to\n           mplsTrafficParamMaxBurstSize. The OID of this\n           entry is copied to mplsInSegmentTrafficParamPtr of\n           the corresponding in-segment entry.')
mplsTunnelResourceRowStatus = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setDescription('This variable is used to create, modify, and/or\n           delete a row in this table.')
mplsTunnelResourceStorageType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 6, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setDescription('This variable indicates the storage type for this\n           object.')
mplsTunnelARHopTable = MibTable((1, 3, 6, 1, 3, 95, 2, 7), )
if mibBuilder.loadTexts: mplsTunnelARHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopTable.setDescription('The mplsTunnelARHopTable is used to indicate the\n           hops, strict or loose, for an MPLS tunnel defined\n           in mplsTunnelTable, as reported by the MPLS\n           signaling protocol, for the outgoing direction of\n\n\n           the tunnel.  Each row in this table is indexed by\n           mplsTunnelARHopListIndex.  Each row also has a\n           secondary index mplsTunnelARHopIndex,\n           corresponding to the next hop that this row\n           corresponds to.  The first row in the table is the\n           first hop after the origination point of the\n           tunnel.  In case we want to specify a particular\n           interface on the originating LSR of an outgoing\n           tunnel by which we want packets to exit the LSR,\n           we specify this as the first hop for this tunnel\n           in mplsTunnelARHopTable.\n\n           Please note that since the information necessary\n           to build entries within this table are not\n           provided by some MPLS signaling protocols,\n           implementation of this table is optional.\n           Furthermore, since the information in this table\n           is actually provided by the MPLS signaling\n           protocol after the path has been set-up, the\n           entries in this table are provided only for\n           observation, and hence, all variables in this\n           table are accessible exclusively as read-only.')
mplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 7, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelARHopListIndex"), (0, "MPLS-TE-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setDescription('An entry in this table represents a tunnel hop.\n           An entry is created by a network administrator for\n           signaled ERLSP set up by an MPLS signaling\n           protocol.')
mplsTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setDescription('Primary index into this table identifying a\n           particular recorded hop list.')
mplsTunnelARHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setDescription('Secondary index into this table identifying the\n           particular hop.')
mplsTunnelARHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3))).clone('ipV4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelARHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 4), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv4Addr.setDescription('If mplsTunnelARHopAddrType is set to ipV4(1), then\n           this value will contain the IPv4 address of this\n           hop. This object is otherwise insignificant and\n           should contain a value of 0.')
mplsTunnelARHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv4PrefixLen.setDescription("If mplsTunnelARHopAddrType is ipV4(1), then the\n           prefix length for this hop's IPv4 address is\n           contained herein. This object is otherwise\n           insignificant and should contain a value of 0.")
mplsTunnelARHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv6Addr.setDescription('If the mplsTunnelARHopAddrType is set to ipV6(2),\n           then this variable contains the IPv6 address of\n           this hop.  This object is otherwise insignificant\n           and should contain a value of 0.')
mplsTunnelARHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopIpv6PrefixLen.setDescription("If mplsTunnelARHopAddrType is set to ipV6(2), this\n           value will contain the prefix length for this\n           hop's IPv6 address. This object is otherwise\n           insignificant and should contain a value of 0.")
mplsTunnelARHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopAsNumber.setDescription('If mplsTunnelARHopAddrType is set to asNumber(3),\n           then this value will contain the AS number of this\n           hop. This object is otherwise insignificant and\n           should contain a value of 0 to indicate this\n           fact.')
mplsTunnelARHopType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelARHopType.setDescription('Denotes whether this is tunnel hop is routed in a\n           strict or loose fashion.')
mplsTunnelCHopTable = MibTable((1, 3, 6, 1, 3, 95, 2, 8), )
if mibBuilder.loadTexts: mplsTunnelCHopTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopTable.setDescription('The mplsTunnelCHopTable is used to indicate the\n           hops, strict or loose, for an MPLS tunnel defined\n           in mplsTunnelTable, as computed by a constraint-\n           based routing protocol, based on the\n           mplsTunnelHopTable for the outgoing direction of\n           the tunnel.  Each row in this table is indexed by\n           mplsTunnelCHopListIndex.  Each row also has a\n           secondary index mplsTunnelCHopIndex, corresponding\n           to the next hop that this row corresponds to.  The\n           first row in the table is the first hop after the\n           origination point of the tunnel.  In case we want\n           to specify a particular interface on the\n           originating LSR of an outgoing tunnel by which we\n           want packets to exit the LSR, we specify this as\n           the first hop for this tunnel in\n           mplsTunnelCHopTable.\n\n           Please note that since the information necessary\n           to build entries within this table may not be\n           supported by some LSRs, implementation of this\n           table is optional. Furthermore, since the\n           information in this table is actually provided by\n           routing protocol after the path has been computed,\n           the entries in this table are provided only for\n           observation, and hence, all variables in this\n           table are accessible exclusively as read-only.')
mplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 8, 1), ).setIndexNames((0, "MPLS-TE-MIB", "mplsTunnelCHopListIndex"), (0, "MPLS-TE-MIB", "mplsTunnelCHopIndex"))
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setDescription('An entry in this table represents a tunnel hop.\n           An entry in this table is created by a constraint-\n           based routing protocol based on the hops specified\n           in the corresponding mplsTunnelHopTable.')
mplsTunnelCHopListIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setDescription('Primary index into this table identifying a\n           particular computed hop list.')
mplsTunnelCHopIndex = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setDescription('Secondary index into this table identifying the\n           particular hop.')
mplsTunnelCHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3))).clone('ipV4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
mplsTunnelCHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 4), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv4Addr.setDescription('If mplsTunnelCHopAddrType is set to ipV4(1), then\n           this value will contain the IPv4 address of this\n           hop. This object is otherwise insignificant and\n           should contain a value of 0.')
mplsTunnelCHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv4PrefixLen.setDescription("If mplsTunnelCHopAddrType is ipV4(1), then the\n           prefix length for this hop's IPv4 address is\n           contained herein. This object is otherwise\n           insignificant and should contain a value of 0.")
mplsTunnelCHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv6Addr.setDescription('If the mplsTunnelCHopAddrType is set to ipV6(2),\n           then this variable contains the IPv6 address of\n           this hop.  This object is otherwise insignificant\n           and should contain a value of 0.')
mplsTunnelCHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopIpv6PrefixLen.setDescription("If mplsTunnelCHopAddrType is set to ipV6(2), this\n           value will contain the prefix length for this\n           hop's IPv6 address. This object is otherwise\n           insignificant and should contain a value of 0.")
mplsTunnelCHopAsNumber = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopAsNumber.setDescription('If mplsTunnelCHopAddrType is set to asNumber(3),\n           then this value will contain the AS number of this\n           hop. This object is otherwise insignificant and\n           should contain a value of 0 to indicate this\n           fact.')
mplsTunnelCHopType = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelCHopType.setDescription('Denotes whether this is tunnel hop is routed in a\n           strict or loose fashion.')
mplsTunnelPerfTable = MibTable((1, 3, 6, 1, 3, 95, 2, 9), )
if mibBuilder.loadTexts: mplsTunnelPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfTable.setDescription('This table provides per-tunnel MPLS performance\n           information.')
mplsTunnelPerfEntry = MibTableRow((1, 3, 6, 1, 3, 95, 2, 9, 1), )
mplsTunnelEntry.registerAugmentions(("MPLS-TE-MIB", "mplsTunnelPerfEntry"))
mplsTunnelPerfEntry.setIndexNames(*mplsTunnelEntry.getIndexNames())
if mibBuilder.loadTexts: mplsTunnelPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfEntry.setDescription('An entry in this table is created by the LSR for\n           every tunnel.  Its is an extension to\n           mplsTunnelEntry.')
mplsTunnelPerfPackets = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfPackets.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfPackets.setDescription('Number of packets forwarded by the tunnel.')
mplsTunnelPerfHCPackets = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCPackets.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfHCPackets.setDescription('High capacity counter for number of packets\n           forwarded by the tunnel.')
mplsTunnelPerfErrors = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfErrors.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfErrors.setDescription('Number of errored packets.')
mplsTunnelPerfBytes = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfBytes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfBytes.setDescription('Number of bytes forwarded by the tunnel.')
mplsTunnelPerfHCBytes = MibTableColumn((1, 3, 6, 1, 3, 95, 2, 9, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCBytes.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelPerfHCBytes.setDescription('High capacity counter for number of bytes\n           forwarded by the tunnel.')
mplsTunnelTrapEnable = MibScalar((1, 3, 6, 1, 3, 95, 2, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTrapEnable.setDescription('If this object is true, then it enables the\n           generation of mplsTunnelUp and mplsTunnelDown\n           traps, otherwise these traps are not emitted.')
mplsTunnelUp = NotificationType((1, 3, 6, 1, 3, 95, 3, 0, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelUp.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelUp.setDescription('This notification is generated when a\n           mplsTunnelOperStatus object for one of the\n           configured tunnels is about to leave the down\n           state and transition into some other state (but\n           not into the notPresent state).  This other state\n           is indicated by the included value of\n           mplsTunnelOperStatus.')
mplsTunnelDown = NotificationType((1, 3, 6, 1, 3, 95, 3, 0, 2)).setObjects(("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelDown.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelDown.setDescription('This notification is generated when a\n           mplsTunnelOperStatus object for one of the\n           configured tunnels is about to enter the down\n           state from some other state (but not from the\n           notPresent state).  This other state is indicated\n           by the included value of mplsTunnelOperStatus.')
mplsTunnelRerouted = NotificationType((1, 3, 6, 1, 3, 95, 3, 0, 3)).setObjects(("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"))
if mibBuilder.loadTexts: mplsTunnelRerouted.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRerouted.setDescription('This notification is generated when a tunnel is\n           rerouted or re-optimized. If the Actual Path is\n           used, then this object MAY contain the new path\n           for this tunnel some time after this trap is\n\n\n           issued by the agent.')
mplsTeGroups = MibIdentifier((1, 3, 6, 1, 3, 95, 4, 1))
mplsTeCompliances = MibIdentifier((1, 3, 6, 1, 3, 95, 4, 2))
mplsTeModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 95, 4, 2, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelGroup"), ("MPLS-TE-MIB", "mplsTunnelScalarGroup"), ("MPLS-TE-MIB", "mplsTunnelManualGroup"), ("MPLS-TE-MIB", "mplsTunnelSignaledGroup"), ("MPLS-TE-MIB", "mplsTunnelIsNotIntfcGroup"), ("MPLS-TE-MIB", "mplsTunnelIsIntfcGroup"), ("MPLS-TE-MIB", "mplsTunnelOptionalGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeModuleCompliance = mplsTeModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsTeModuleCompliance.setDescription('Compliance statement for agents that support the\n           MPLS TE MIB.')
mplsTunnelGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 1)).setObjects(("MPLS-TE-MIB", "mplsTunnelIndexNext"), ("MPLS-TE-MIB", "mplsTunnelName"), ("MPLS-TE-MIB", "mplsTunnelDescr"), ("MPLS-TE-MIB", "mplsTunnelOwner"), ("MPLS-TE-MIB", "mplsTunnelXCPointer"), ("MPLS-TE-MIB", "mplsTunnelIfIndex"), ("MPLS-TE-MIB", "mplsTunnelHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelARHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelCHopTableIndex"), ("MPLS-TE-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-MIB", "mplsTunnelRowStatus"), ("MPLS-TE-MIB", "mplsTunnelTrapEnable"), ("MPLS-TE-MIB", "mplsTunnelStorageType"), ("MPLS-TE-MIB", "mplsTunnelConfigured"), ("MPLS-TE-MIB", "mplsTunnelActive"), ("MPLS-TE-MIB", "mplsTunnelPrimaryInstance"), ("MPLS-TE-MIB", "mplsTunnelPrimaryTimeUp"), ("MPLS-TE-MIB", "mplsTunnelPathChanges"), ("MPLS-TE-MIB", "mplsTunnelLastPathChange"), ("MPLS-TE-MIB", "mplsTunnelCreationTime"), ("MPLS-TE-MIB", "mplsTunnelStateTransitions"), ("MPLS-TE-MIB", "mplsTunnelEgressLSRId"), ("MPLS-TE-MIB", "mplsTunnelIncludeAnyAffinity"), ("MPLS-TE-MIB", "mplsTunnelIncludeAllAffinity"), ("MPLS-TE-MIB", "mplsTunnelExcludeAllAffinity"), ("MPLS-TE-MIB", "mplsTunnelPerfPackets"), ("MPLS-TE-MIB", "mplsTunnelPerfHCPackets"), ("MPLS-TE-MIB", "mplsTunnelPerfErrors"), ("MPLS-TE-MIB", "mplsTunnelPerfBytes"), ("MPLS-TE-MIB", "mplsTunnelPerfHCBytes"), ("MPLS-TE-MIB", "mplsTunnelResourcePointer"), ("MPLS-TE-MIB", "mplsTunnelInstancePriority"), ("MPLS-TE-MIB", "mplsTunnelPathInUse"), ("MPLS-TE-MIB", "mplsTunnelRole"), ("MPLS-TE-MIB", "mplsTunnelTotalUpTime"), ("MPLS-TE-MIB", "mplsTunnelInstanceUpTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelGroup = mplsTunnelGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelGroup.setDescription('Necessary, but not sufficient, set of objects to\n           implement tunnels.  In addition, depending on the\n           type of the tunnels supported (for example,\n           manually configured or signaled, persistent or non-\n           persistent, etc.), the following other groups\n           defined below are mandatory: mplsTunnelManualGroup\n           and/or mplsTunnelSignaledGroup,\n           mplsTunnelIsNotIntfcGroup and/or\n           mplsTunnelIsIntfcGroup.')
mplsTunnelManualGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 2)).setObjects(("MPLS-TE-MIB", "mplsTunnelSignallingProto"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelManualGroup = mplsTunnelManualGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelManualGroup.setDescription('Object(s) needed to implement manually configured\n           tunnels.')
mplsTunnelSignaledGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 3)).setObjects(("MPLS-TE-MIB", "mplsTunnelSetupPrio"), ("MPLS-TE-MIB", "mplsTunnelHoldingPrio"), ("MPLS-TE-MIB", "mplsTunnelSignallingProto"), ("MPLS-TE-MIB", "mplsTunnelLocalProtectInUse"), ("MPLS-TE-MIB", "mplsTunnelSessionAttributes"), ("MPLS-TE-MIB", "mplsTunnelHopListIndexNext"), ("MPLS-TE-MIB", "mplsTunnelHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelHopLspId"), ("MPLS-TE-MIB", "mplsTunnelHopType"), ("MPLS-TE-MIB", "mplsTunnelHopRowStatus"), ("MPLS-TE-MIB", "mplsTunnelHopStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelSignaledGroup = mplsTunnelSignaledGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelSignaledGroup.setDescription('Object needed to implement signaled tunnels.')
mplsTunnelScalarGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 4)).setObjects(("MPLS-TE-MIB", "mplsTunnelConfigured"), ("MPLS-TE-MIB", "mplsTunnelActive"), ("MPLS-TE-MIB", "mplsTunnelTEDistProto"), ("MPLS-TE-MIB", "mplsTunnelMaxHops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelScalarGroup = mplsTunnelScalarGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelScalarGroup.setDescription('Scalar object needed to implement MPLS tunnels.')
mplsTunnelIsIntfcGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 5)).setObjects(("MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsIntfcGroup = mplsTunnelIsIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsIntfcGroup.setDescription('Objects needed to implement tunnels that are\n           interfaces.')
mplsTunnelIsNotIntfcGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 6)).setObjects(("MPLS-TE-MIB", "mplsTunnelIsIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelIsNotIntfcGroup = mplsTunnelIsNotIntfcGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelIsNotIntfcGroup.setDescription('Objects needed to implement tunnels that are not\n           interfaces.')
mplsTunnelOptionalGroup = ObjectGroup((1, 3, 6, 1, 3, 95, 4, 1, 7)).setObjects(("MPLS-TE-MIB", "mplsTunnelResourceIndexNext"), ("MPLS-TE-MIB", "mplsTunnelResourceMaxRate"), ("MPLS-TE-MIB", "mplsTunnelResourceMeanRate"), ("MPLS-TE-MIB", "mplsTunnelResourceMaxBurstSize"), ("MPLS-TE-MIB", "mplsTunnelResourceRowStatus"), ("MPLS-TE-MIB", "mplsTunnelResourceStorageType"), ("MPLS-TE-MIB", "mplsTunnelARHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelARHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelARHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelARHopType"), ("MPLS-TE-MIB", "mplsTunnelCHopAddrType"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv4Addr"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv4PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv6Addr"), ("MPLS-TE-MIB", "mplsTunnelCHopIpv6PrefixLen"), ("MPLS-TE-MIB", "mplsTunnelCHopAsNumber"), ("MPLS-TE-MIB", "mplsTunnelCHopType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTunnelOptionalGroup = mplsTunnelOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelOptionalGroup.setDescription('The objects in this group are optional.')
mplsTeNotificationGroup = NotificationGroup((1, 3, 6, 1, 3, 95, 4, 1, 8)).setObjects(("MPLS-TE-MIB", "mplsTunnelUp"), ("MPLS-TE-MIB", "mplsTunnelDown"), ("MPLS-TE-MIB", "mplsTunnelRerouted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTeNotificationGroup = mplsTeNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTeNotificationGroup.setDescription('Set of notifications implemented in this module.\n           None is mandatory.')
mibBuilder.exportSymbols("MPLS-TE-MIB", mplsTunnelIncludeAllAffinity=mplsTunnelIncludeAllAffinity, mplsTeNotifyPrefix=mplsTeNotifyPrefix, mplsTunnelIsIf=mplsTunnelIsIf, mplsTunnelResourceMaxRate=mplsTunnelResourceMaxRate, mplsTunnelARHopAsNumber=mplsTunnelARHopAsNumber, mplsTunnelDown=mplsTunnelDown, mplsTunnelHopAsNumber=mplsTunnelHopAsNumber, mplsTeScalars=mplsTeScalars, mplsTunnelUp=mplsTunnelUp, mplsTeMIB=mplsTeMIB, mplsTunnelHopRowStatus=mplsTunnelHopRowStatus, mplsTunnelSignallingProto=mplsTunnelSignallingProto, mplsTunnelResourceTable=mplsTunnelResourceTable, mplsTunnelDescr=mplsTunnelDescr, mplsTunnelSetupPrio=mplsTunnelSetupPrio, mplsTunnelIsNotIntfcGroup=mplsTunnelIsNotIntfcGroup, mplsTunnelResourceEntry=mplsTunnelResourceEntry, mplsTunnelIngressLSRId=mplsTunnelIngressLSRId, mplsTunnelPathInUse=mplsTunnelPathInUse, mplsTunnelHopStorageType=mplsTunnelHopStorageType, mplsTunnelResourceMaxBurstSize=mplsTunnelResourceMaxBurstSize, mplsTunnelCHopListIndex=mplsTunnelCHopListIndex, mplsTunnelARHopListIndex=mplsTunnelARHopListIndex, mplsTunnelOperStatus=mplsTunnelOperStatus, mplsTunnelARHopEntry=mplsTunnelARHopEntry, mplsTeConformance=mplsTeConformance, mplsPathOptionIndex=mplsPathOptionIndex, mplsTunnelARHopAddrType=mplsTunnelARHopAddrType, mplsTunnelHopLspId=mplsTunnelHopLspId, mplsTunnelEgressLSRId=mplsTunnelEgressLSRId, mplsTunnelHopListIndex=mplsTunnelHopListIndex, mplsTunnelIndexNext=mplsTunnelIndexNext, mplsTunnelLastPathChange=mplsTunnelLastPathChange, mplsTunnelHopIndex=mplsTunnelHopIndex, mplsTunnelHopIpv6PrefixLen=mplsTunnelHopIpv6PrefixLen, mplsTunnelCHopIpv4Addr=mplsTunnelCHopIpv4Addr, mplsTunnelResourceIndexNext=mplsTunnelResourceIndexNext, mplsTunnelPerfPackets=mplsTunnelPerfPackets, mplsTunnelLocalProtectInUse=mplsTunnelLocalProtectInUse, mplsTunnelRerouted=mplsTunnelRerouted, mplsTunnelCHopAsNumber=mplsTunnelCHopAsNumber, mplsTunnelCHopIpv4PrefixLen=mplsTunnelCHopIpv4PrefixLen, mplsTunnelRole=mplsTunnelRole, mplsTunnelHopType=mplsTunnelHopType, mplsTunnelStateTransitions=mplsTunnelStateTransitions, mplsTunnelXCPointer=mplsTunnelXCPointer, mplsTunnelExcludeAllAffinity=mplsTunnelExcludeAllAffinity, mplsTunnelResourceMeanRate=mplsTunnelResourceMeanRate, mplsTunnelCreationTime=mplsTunnelCreationTime, mplsTunnelConfigured=mplsTunnelConfigured, MplsPathIndex=MplsPathIndex, MplsPathIndexOrZero=MplsPathIndexOrZero, mplsTunnelSessionAttributes=mplsTunnelSessionAttributes, mplsTunnelARHopTable=mplsTunnelARHopTable, mplsTunnelPrimaryInstance=mplsTunnelPrimaryInstance, mplsTunnelHopAddrType=mplsTunnelHopAddrType, mplsTunnelIndex=mplsTunnelIndex, mplsTunnelIncludeAnyAffinity=mplsTunnelIncludeAnyAffinity, mplsTunnelCHopTableIndex=mplsTunnelCHopTableIndex, mplsTunnelMaxHops=mplsTunnelMaxHops, mplsTunnelResourceStorageType=mplsTunnelResourceStorageType, mplsTunnelTrapEnable=mplsTunnelTrapEnable, mplsTunnelRowStatus=mplsTunnelRowStatus, mplsTunnelActive=mplsTunnelActive, mplsTunnelInstanceUpTime=mplsTunnelInstanceUpTime, mplsTunnelPerfHCPackets=mplsTunnelPerfHCPackets, mplsTunnelPathChanges=mplsTunnelPathChanges, mplsTunnelResourceRowStatus=mplsTunnelResourceRowStatus, mplsTunnelCHopIpv6Addr=mplsTunnelCHopIpv6Addr, mplsTeCompliances=mplsTeCompliances, MplsLsrId=MplsLsrId, mplsTunnelHopTableIndex=mplsTunnelHopTableIndex, mplsTunnelCHopEntry=mplsTunnelCHopEntry, mplsTunnelOptionalGroup=mplsTunnelOptionalGroup, mplsTunnelHopIpv6Addr=mplsTunnelHopIpv6Addr, mplsTunnelPerfTable=mplsTunnelPerfTable, mplsTunnelInstancePriority=mplsTunnelInstancePriority, mplsTunnelPrimaryTimeUp=mplsTunnelPrimaryTimeUp, mplsTunnelManualGroup=mplsTunnelManualGroup, mplsTunnelPerfBytes=mplsTunnelPerfBytes, mplsTunnelIsIntfcGroup=mplsTunnelIsIntfcGroup, mplsTunnelOwner=mplsTunnelOwner, mplsTunnelSignaledGroup=mplsTunnelSignaledGroup, mplsTunnelStorageType=mplsTunnelStorageType, mplsTunnelHopIpv4PrefixLen=mplsTunnelHopIpv4PrefixLen, mplsTunnelARHopIpv4Addr=mplsTunnelARHopIpv4Addr, mplsTunnelTotalUpTime=mplsTunnelTotalUpTime, mplsTunnelPerfEntry=mplsTunnelPerfEntry, mplsTunnelARHopIndex=mplsTunnelARHopIndex, mplsTunnelPerfHCBytes=mplsTunnelPerfHCBytes, mplsTunnelCHopIpv6PrefixLen=mplsTunnelCHopIpv6PrefixLen, PYSNMP_MODULE_ID=mplsTeMIB, mplsTunnelCHopIndex=mplsTunnelCHopIndex, mplsTunnelAdminStatus=mplsTunnelAdminStatus, mplsTunnelARHopIpv4PrefixLen=mplsTunnelARHopIpv4PrefixLen, mplsTeModuleCompliance=mplsTeModuleCompliance, mplsTunnelInstance=mplsTunnelInstance, mplsTunnelPerfErrors=mplsTunnelPerfErrors, mplsTunnelARHopTableIndex=mplsTunnelARHopTableIndex, mplsTunnelARHopIpv6Addr=mplsTunnelARHopIpv6Addr, mplsTeNotifications=mplsTeNotifications, mplsTunnelIfIndex=mplsTunnelIfIndex, mplsTunnelHopTable=mplsTunnelHopTable, mplsTunnelARHopIpv6PrefixLen=mplsTunnelARHopIpv6PrefixLen, mplsTeGroups=mplsTeGroups, mplsTunnelCHopType=mplsTunnelCHopType, mplsTunnelName=mplsTunnelName, MplsTunnelInstanceIndex=MplsTunnelInstanceIndex, mplsTunnelTEDistProto=mplsTunnelTEDistProto, mplsTunnelCHopAddrType=mplsTunnelCHopAddrType, mplsTunnelHopIpv4Addr=mplsTunnelHopIpv4Addr, mplsTunnelARHopType=mplsTunnelARHopType, mplsTeObjects=mplsTeObjects, mplsTunnelCHopTable=mplsTunnelCHopTable, mplsTunnelHoldingPrio=mplsTunnelHoldingPrio, MplsTunnelIndex=MplsTunnelIndex, mplsTunnelTable=mplsTunnelTable, mplsTeNotificationGroup=mplsTeNotificationGroup, mplsTunnelHopListIndexNext=mplsTunnelHopListIndexNext, mplsTunnelScalarGroup=mplsTunnelScalarGroup, mplsTunnelGroup=mplsTunnelGroup, mplsTunnelResourcePointer=mplsTunnelResourcePointer, mplsTunnelEntry=mplsTunnelEntry, mplsTunnelHopEntry=mplsTunnelHopEntry, mplsTunnelResourceIndex=mplsTunnelResourceIndex)
