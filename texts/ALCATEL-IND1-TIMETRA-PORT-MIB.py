#
# PySNMP MIB module ALCATEL-IND1-TIMETRA-PORT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nokia/aos7/ALCATEL-IND1-TIMETRA-PORT-MIB
# Produced by pysmi-1.1.8 at Tue Jan 11 21:37:12 2022
# On host fv-az121-779 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
TmnxPortAdminStatus, tmnxHwNotification, TmnxMDAChanType, TmnxAlarmState, tmnxChassisIndex, tmnxChassisNotifyChassisId, tmnxHwConformance, tmnxHwObjs = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "TmnxPortAdminStatus", "tmnxHwNotification", "TmnxMDAChanType", "TmnxAlarmState", "tmnxChassisIndex", "tmnxChassisNotifyChassisId", "tmnxHwConformance", "tmnxHwObjs")
timetraSRMIBModules, = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-GLOBAL-MIB", "timetraSRMIBModules")
TNamedItem, TmnxPortID, TQueueId, TmnxActionType, TSecondaryShaper10GPIRRate, TmnxOperState, TPortSchedulerPIR, TMlpppQoSProfileId, TItemLongDescription, TItemDescription, TFCName, TNamedItemOrEmpty, TPortSchedulerCIR = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-TC-MIB", "TNamedItem", "TmnxPortID", "TQueueId", "TmnxActionType", "TSecondaryShaper10GPIRRate", "TmnxOperState", "TPortSchedulerPIR", "TMlpppQoSProfileId", "TItemLongDescription", "TItemDescription", "TFCName", "TNamedItemOrEmpty", "TPortSchedulerCIR")
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Unsigned32, Gauge32, TimeTicks, Counter32, Counter64, Bits, ObjectIdentity, NotificationType, MibIdentifier, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, IpAddress, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Gauge32", "TimeTicks", "Counter32", "Counter64", "Bits", "ObjectIdentity", "NotificationType", "MibIdentifier", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "IpAddress", "ModuleIdentity")
DateAndTime, RowPointer, RowStatus, TimeStamp, TextualConvention, MacAddress, TimeInterval, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "RowPointer", "RowStatus", "TimeStamp", "TextualConvention", "MacAddress", "TimeInterval", "DisplayString", "TruthValue")
tmnxPortMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 25))
tmnxPortMIBModule.setRevisions(('1908-01-01 00:00', '1907-01-01 00:00', '1906-03-16 00:00', '1905-08-31 00:00', '1905-01-24 00:00', '1904-03-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: tmnxPortMIBModule.setRevisionsDescriptions(('Rev 6.0                01 Jan 2008 00:00\n                         6.0 release of the TIMETRA-PORT-MIB.', 'Rev 5.0                01 Jan 2007 00:00\n                         5.0 release of the TIMETRA-PORT-MIB.', 'Rev 4.0                16 Mar 2006 00:00\n                         4.0 release of the TIMETRA-PORT-MIB.', 'Rev 3.0                31 Aug 2005 00:00\n                         3.0 release of the TIMETRA-PORT-MIB.', 'Rev 2.1                24 Jan 2005 00:00\n                         2.1 release of the TIMETRA-PORT-MIB.', 'Rev 2.0                01 Mar 2004 00:00 \n                         2.0 release of the TIMETRA-PORT-MIB.',))
if mibBuilder.loadTexts: tmnxPortMIBModule.setLastUpdated('0801010000Z')
if mibBuilder.loadTexts: tmnxPortMIBModule.setOrganization('Alcatel')
if mibBuilder.loadTexts: tmnxPortMIBModule.setContactInfo('Alcatel 7x50 Support\n             Web: http://www.alcatel.com/comps/pages/carrier_support.jhtml')
if mibBuilder.loadTexts: tmnxPortMIBModule.setDescription("This document is the SNMP MIB module to manage and provision the \n        hardware components of the Alcatel 7x50 device.\n        \n        Copyright 2003-2008 Alcatel-Lucent.  All rights reserved.\n        Reproduction of this document is authorized on the condition that\n        the foregoing copyright notice is included.\n\n        This SNMP MIB module (Specification) embodies Alcatel's\n        proprietary intellectual property.  Alcatel retains \n        all title and ownership in the Specification, including any \n        revisions.\n\n        Alcatel grants all interested parties a non-exclusive \n        license to use and distribute an unmodified copy of this \n        Specification in connection with management of Alcatel \n        products, and without fee, provided this copyright notice and \n        license appear on all copies.\n\n        This Specification is supplied 'as is', and Alcatel \n        makes no warranty, either express or implied, as to the use, \n        operation, condition, or performance of the Specification.")
tmnxPortObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4))
tmnxPortNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7))
tmnxFRObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9))
tmnxQosAppObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10))
tmnxATMObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 11))
tmnxPortStatsObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12))
tmnxPortNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2))
tmnxPortNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0))
tmnxPortConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2))
class TmnxPortOperStatus(TextualConvention, Integer32):
    description = 'The current operational status of this port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("unknown", 1), ("inService", 2), ("outOfService", 3), ("diagnosing", 4), ("failed", 5))

class TmnxPortEtherReportValue(TextualConvention, Integer32):
    description = 'The TmnxPortEtherReportValue is an enumerated integer that describes\n        the values used to identify the reason an alarm has been raised on an\n        Ethernet Port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("notUsed", 0), ("signalFailure", 1), ("remoteFault", 2), ("localFault", 3), ("noFrameLock", 4), ("highBer", 5))

class TmnxPortEtherReportStatus(TextualConvention, Bits):
    description = 'The TmnxPortEtherReportStatus is a bitmask that describes alarms that\n        can be raised/cleared on an Ethernet Port.'
    status = 'current'
    namedValues = NamedValues(("notUsed", 0), ("signalFailure", 1), ("remoteFault", 2), ("localFault", 3), ("noFrameLock", 4), ("highBer", 5))

class TmnxPortClass(TextualConvention, Integer32):
    description = 'The TmnxPortClass data type is an enumerated integer that \n         describes the values used to identify the class of interface \n         provided by this port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("none", 1), ("faste", 2), ("gige", 3), ("xgige", 4), ("sonet", 5), ("vport", 6), ("unused", 7), ("xcme", 8), ("tdm", 9))

class TmnxPortConnectorType(TextualConvention, Unsigned32):
    description = "The TmnxPortConnectorType data type is an enumerated integer that \n         describes the values used to identify the connector type used on \n         a port.  A TmnxPortConnectorType value specifies the index value \n         for the entry in the tmnxPortConnectTypeTable used to identify a \n         specific type of port connector.  Some example port connector types \n         are: 'unknown', 'rj45', 'bncCoax', 'mtrj', 'scDuplex', 'sffp',\n         'lcDuplex'."
    status = 'current'

class TmnxPortState(TextualConvention, Integer32):
    description = "The state level of this port.  A value of 'none' indicates the \n         port is either in its initial creation state or is just about to \n         be deleted.  A value of 'ghost' represents a port that is not \n         physically present.  This state may represent a pre-provisioned \n         port.  A value of 'linkDown' represents a port that is physically \n         present but does not have a link.  The 'linkUp' state represents a \n         port that is physically present and has physical link present.\n         A port in 'up' state is ready to pass some kinds of traffic.\n         The tmnxPortUpProtocols variable indicates the actual type(s) of \n         traffic that can be passed on this 'up' link. The 'diagnose' state\n         represents the port undergoing diagnostic test."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("none", 1), ("ghost", 2), ("linkDown", 3), ("linkUp", 4), ("up", 5), ("diagnose", 6))

class TmnxPortType(TextualConvention, Unsigned32):
    description = 'The TmnxPortType data type is an enumerated integer that describes \n         the values used to identify the specific type of hardware port.\n         A TmnxPortType value specifies the index value for the entry in the \n         tmnxPortTypeTable used to identify a specific type of port.\n         Some example port types are: \n            -- unknown            - no port installed or unidentified\n            -- portType100Tx      - 10/100 base copper\n            -- portType100F       - 10/100 base fiber\n            -- portType1000Tx     - 1000 base copper\n            -- portType1000F      - 1000 base fiber\n            -- portType1000dF     - 1000 base dual fiber\n            -- portTypeOC3sonet   - OC-3\n            -- portTypeOC12sonet  - OC-12\n            -- portTypeOC48sonet  - OC-48\n            -- portTypeOC192sonet - OC-192\n            -- portType10000F     - 10 Gig Ethernet LAN\n            -- portTypeXgigWan    - 10 Gig Ethernet WAN\n            -- portTypeVport      - Virtual port\n            -- portTypeDS3E3      - DS3/E3 port\n            -- portTypeDS1E1      - DS1/E1 port\n         '
    status = 'current'

class TmnxDs0ChannelList(TextualConvention, OctetString):
    description = 'A list of ds0 timeslots on a DS1 line.\n\n            The list is specified as an OCTET STRING in which each ds0\n            timeslot is represented by a single bit, where  timeslots 1\n            through 8 are represented by the bits in the first octet,\n            timeslots 9 through 16 by the bits in the second octet,\n            etc.  In each octet, the lowest numbered timeslot is\n            represented by the most significant bit, and the highest\n            numbered timeslot by the least significant bit.  A timeslot\n            is present in the list when its bit is 1, and absent\n            when its bit is 0. \n\n            If the OCTET STRING value has more bits than required to \n            represent the timeslots on a DS1, then the extra bits \n            are ignored.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 4)

class TmnxBundleID(TextualConvention, Unsigned32):
    description = 'A TmnxBundleID is an unique 32 bit number encoded as shown below.\n\n            |32 30| 29 26 | 25 22 | 21 16 | 15     13 | 12   1|\n            +-----+-------+-------+-------+-----------+-------+\n            |001  |  slot |  mda  |   0   | bndl type | bndlid|\n            +-----+-------+-------+-------+-----------+-------+\n\n         The bundle id is unique for a MDA.  The bndlid must fall in one of\n         the following ranges depending on MDA type:\n\n           mda-type             range\n           m4-choc3-as-sfp      1-256 \n           m1-choc12-as-sfp     1-256 \n           m12-chds3-as         1-256 \n           m4-chds3-as          1-112\n           m4-chds3             1-56\n           m12-chds3            1-56\n           m1-choc12-sfp        1-56\n           m4-choc3-sfp         1-56\n           c8-chds1             1-56\n           c8-atmds1            1-8\n         \n         A slot value of 15 (Invalid slot) and mda value of 0 (invalid mda)\n         represents a bundle protection group. \n         Otherwise, the bundle is considered associated with a valid slot \n         and mda.\n         \n         The following bundle types are supported:\n         \n         bndl type     value\n           MLPPP        000\n           IMA          001'
    status = 'current'

class TmnxDSXBertPattern(TextualConvention, Integer32):
    description = 'The TmnxDSXBertPattern data type is an enumerated integer that \n         indicates the pattern used for the Bit Error Rate Test (BERT).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("none", 0), ("ones", 1), ("zeros", 2), ("alternating", 3), ("twoexp3", 4), ("twoexp9", 5), ("twoexp15", 6), ("twoexp20", 7), ("twoexp11", 8), ("twoexp20q", 9), ("twoexp23", 10))

class TmnxDSXBertOperStatus(TextualConvention, Integer32):
    description = "The TmnxDSXBertOperStatus data type is an enumerated integer that \n         indicates the status of Bit Error Rate Test (BERT).\n         When BERT is activated, the status will be 'active'. Otherwise\n         the status will be 'idle' or 'noMdaResources' if the last BERT test\n         could not be executed because of an MDA concurrent BERT test limit."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("none", 0), ("active", 1), ("idle", 2), ("noMdaResources", 3))

class TmnxDSXIdleCycleFlags(TextualConvention, Integer32):
    description = "The TmnxDSXIdleCycleFlags data type is an enumerated integer that \n         indicates the value that the DS3/DS1 port/channel or a DS0 channel\n         group transmits during idle cycle.\n\n         The value of 'none' is applicable to ATM and CEM ports/channels only,\n         which transmits idle cells and not octets defined by the below values.\n \n         If the value is set to 'flags', a value of 0x7E is used.\n         If the value is set to 'ones', a value of 0xFF is used."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("none", 0), ("flags", 1), ("ones", 2))

class TmnxDSXIdleFillType(TextualConvention, Integer32):
    description = "The TmnxDSXIdleFillType data type is an enumerated integer that \n         indicates the type of data fill that a CEM DS3/DS1 channel or a DS0\n         channel group plays out when the channel experiences underun.\n         \n         - The value of 'notApplicable' indicates that this object is not\n           applicable to the channel.\n         - The value of 'allOnes' indicates that all 1's will be played out.\n         - The value of 'userDefinedPattern' indicates that a user defined\n           pattern will be played out."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("notApplicable", 0), ("allOnes", 1), ("userDefinedPattern", 2))

class TmnxDSXLoopback(TextualConvention, Integer32):
    description = 'The TmnxDSXLoopback data type is an enumerated integer that \n         indicates the type of loopback the DS3/DS1 port/channel \n         currently is in.'
    status = 'obsolete'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("none", 0), ("line", 1), ("internal", 2), ("remote", 3))

class TmnxDSXReportAlarm(TextualConvention, Bits):
    description = 'The TmnxDSXReportAlarm data type indicates the type of TDM alarm:\n         ais - alarm indication signal errors. \n         los - loss of signal errors.\n         oof - out-of-frame errors. \n         rai - resource availability indicator events.\n         looped - far end wants the read end to loopback\n         berSd - DSX bit error signal degradation\n         berSf - DSX bit error signal failure'
    status = 'current'
    namedValues = NamedValues(("notUsed", 0), ("ais", 1), ("los", 2), ("oof", 3), ("rai", 4), ("looped", 5), ("berSd", 6), ("berSf", 7))

class TmnxDSXClockSource(TextualConvention, Integer32):
    description = "The TmnxDSXClockSource data type is an enumerated type\n         that indicates the clock for transmitted data on a DS3 or DS1 channel.\n         loopTimed(1)     - The clock is recovered from the line's receive\n                            data stream\n         nodeTimed(2)     - The clock is internal\n         adaptive(3)      - The clock is adaptively recovered from the rate at\n                            which data is received and not from the physical\n                            layer.\n         differential(4)  - The clock is recovered from differential RTP\n                            timestamp header."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("loopTimed", 1), ("nodeTimed", 2), ("adaptive", 3), ("differential", 4))

class TmnxDSXClockSyncState(TextualConvention, Integer32):
    description = 'The TmnxDSXClockSyncState data type is an enumeration type that\n         indicates the clock synchronization state on a DS3 or DS1 channel.\n         unknown(0)       - Unsupported or unknown state\n         normal(1)        - Normal (locked) state\n         holdOver(2)      - Synchronization with reference has been lost\n         freeRun(3)       - Synchronized with internal reference'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("unknown", 0), ("normal", 1), ("holdOver", 2), ("freeRun", 3))

class TmnxDS1Loopback(TextualConvention, Integer32):
    description = "The TmnxDS1Loopback data type is an enumerated integer that \n         indicates the type of loopback the DS1 port/channel \n         currently is in.\n         A 'line' loopback loops frames received on this port back to the \n         remote system.\n         A 'internal' loopback loops frames from the local system back at\n         the framer.        \n         A 'fdlAnsi' requests a line loopback of type FDL ANSI T1.403.\n         A 'fdlBellcore' requests a line loopback of type FDL Bellcore \n         TR-TSY-000312.        \n         A 'payloadAnsi' requests a payload loopback of type FDL ANSI T1.403.\n         A 'inbandAnsi' requests a line loopback of type inband ANSI T1.403.\n         A 'inbandBellcore' requests a line loopback of type inband Bellcore \n         TR-TSY-000312."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("none", 0), ("line", 1), ("internal", 2), ("fdlAnsi", 3), ("fdlBellcore", 4), ("payloadAnsi", 5), ("inbandAnsi", 6), ("inbandBellcore", 7))

class TmnxDS3Loopback(TextualConvention, Integer32):
    description = "The TmnxDS3Loopback data type is an enumerated integer that \n         indicates the type of loopback the DS3 port/channel \n         currently is in.\n         A 'line' loopback loops frames received on this port back to the \n         remote system.\n         A 'internal' loopback loops the frames from the local system back at\n         the framer.\n         When the value is set to 'remote', a signal is sent to the remote \n         system to provide a line loopback."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("none", 0), ("line", 1), ("internal", 2), ("remote", 3))

class TmnxImaGrpState(TextualConvention, Integer32):
    description = 'The TmnxImaGrpState indicates the current state \n         of the IMA Group State Machine.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("invalid", 0), ("notConfigured", 1), ("startUp", 2), ("startUpAck", 3), ("configAbortUnsupportedM", 4), ("configAbortIncompatibleSymmetry", 5), ("configAbortOther", 6), ("insufficientLinks", 7), ("blocked", 8), ("operational", 9), ("configAbortUnsupportedImaVersion", 10))

class TmnxImaGrpFailState(TextualConvention, Integer32):
    description = 'The TmnxImaGrpFailState indcates the failure \n         reason of an IMA group.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))
    namedValues = NamedValues(("noFailure", 1), ("startUpNe", 2), ("startUpFe", 3), ("invalidMValueNe", 4), ("invalidMValueFe", 5), ("failedAssymetricNe", 6), ("failedAssymetricFe", 7), ("insufficientLinksNe", 8), ("insufficientLinksFe", 9), ("blockedNe", 10), ("blockedFe", 11), ("otherFailure", 12), ("invalidImaVersionNe", 13), ("invalidImaVersionFe", 14))

class TmnxImaLnkState(TextualConvention, Integer32):
    description = 'The TmnxImaLnkState indicates the current \n         state of an IMA link.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("notInGroup", 1), ("unusableNoGivenReason", 2), ("unusableFault", 3), ("unusableMisconnected", 4), ("unusableInhibited", 5), ("unusableFailed", 6), ("usable", 7), ("active", 8))

class TmnxImaLnkFailState(TextualConvention, Integer32):
    description = 'The TmnxImaLnkFailState indicates the local failure \n         status of a link belonging to an IMA group.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("noFailure", 1), ("imaLinkFailure", 2), ("lifFailure", 3), ("lodsFailure", 4), ("misConnected", 5), ("blocked", 6), ("fault", 7), ("farEndTxLinkUnusable", 8), ("farEndRxLinkUnusable", 9))

class TmnxImaTestState(TextualConvention, Integer32):
    description = 'The TmnxImaTestState indicates the current state \n         of the test pattern procedure.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("disabled", 1), ("operating", 2), ("failed", 3))

class TmnxImaGrpClockModes(TextualConvention, Integer32):
    description = 'The TmnxImaGrpClockModes lists the types of \n         clock modes available to IMA Groups.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ctc", 1), ("itc", 2))

class TmnxImaGrpVersion(TextualConvention, Integer32):
    description = 'The TmnxImaGrpVersion lists the types of \n         Ima versions available per IMA Groups.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("oneDotZero", 1), ("oneDotOne", 2))

class TmnxMcMlpppClassIndex(TextualConvention, Integer32):
    description = 'The TmnxMcMlpppClassIndex indicates the class\n         of a Multiclass MLPPP bundle.\n         \n         For Multiclass MLPPP bundles with a non-zero \n         tmnxBundleMlpppClassCount of classes, class index takes \n         valid values from 0 to (tmnxBundleMlpppClassCount - 1) \n         inclusive. For example a 4-class MLPPP bundle has 4 classes \n         with indices 0, 1, 2, and 3.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 15)

class TmnxMlpppEndpointIdClass(TextualConvention, Integer32):
    description = 'TmnxMlpppEndpointIdClass indicates the MLPPP Endpoint\n         Discriminator Class Field Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("nullClass", 0), ("localAddress", 1), ("ipAddress", 2), ("ieee802dot1GlobalMacAddress", 3), ("pppMagicNumberBlock", 4), ("publicSwitchedNetworkDirNumber", 5))

tmnxPortTableLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTableLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTableLastChange.setDescription('The value of sysUpTime when the tmnxPortTable was last changed.')
tmnxPortTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2), )
if mibBuilder.loadTexts: tmnxPortTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTable.setDescription('The port table has an entry for each port on each IOM card in each \n         chassis in the TMNX system.')
tmnxPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxPortEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEntry.setDescription('Each row entry represents a port on a IOM card in a chassis in the \n         system.  Entries cannot be created and deleted via SNMP SET \n         operations.  Before an IOM tmnxMDAEntry can be deleted from the \n         tmnxMDATable, its supported tmnxPortEntry rows must be in the proper \n         state for removal.')
tmnxPortPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 1), TmnxPortID())
if mibBuilder.loadTexts: tmnxPortPortID.setStatus('current')
if mibBuilder.loadTexts: tmnxPortPortID.setDescription('tmnxPortPortID is an index into this table. It maps this port to its \n         entry in the mib-2 interfaces table.')
tmnxPortLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxPortLastChangeTime.setDescription('The tmnxPortLastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxPortEntry row for this port.')
tmnxPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 3), TmnxPortType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortType.setStatus('current')
if mibBuilder.loadTexts: tmnxPortType.setDescription('The type of port or optical pack installed.')
tmnxPortClass = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 4), TmnxPortClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortClass.setStatus('current')
if mibBuilder.loadTexts: tmnxPortClass.setDescription('The class of port or optical pack installed.  This can be\n         derived from tmnxPortType.')
tmnxPortDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 5), TItemLongDescription().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxPortDescription.setDescription('A textual string containing user supplied information about the\n         interface.')
tmnxPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 6), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortName.setStatus('current')
if mibBuilder.loadTexts: tmnxPortName.setDescription("The textual name of the interface.  The value of this\n         object should be the name of the interface as assigned by\n         the local device and should be suitable for use in commands\n         entered at the device's `console'.  This might be a text\n         name, such as `le0' or 'sys171-2/1.")
tmnxPortAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 7), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortAlias.setStatus('current')
if mibBuilder.loadTexts: tmnxPortAlias.setDescription("This object is an 'alias' name for the interface as\n         specified by a network manager, and provides a non-volatile\n         'handle' for the interface.\n\n         On the first instantiation of an interface, the value of\n         tmnxPortAlias associated with that interface is the zero-length\n         string.  As and when a value is written into an instance of\n         tmnxPortAlias through a network management set operation, then the\n         agent must retain the supplied value in the tmnxPortAlias instance\n         associated with the same interface for as long as that\n         interface remains instantiated, including across all re-\n         initializations/reboots of the network management system.")
tmnxPortUserAssignedMac = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 8), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortUserAssignedMac.setStatus('current')
if mibBuilder.loadTexts: tmnxPortUserAssignedMac.setDescription("When tmnxPortUserAssignedMac has a value of 'true', the value of\n         tmnxPortMacAddress has been explicitly assigned by a SNMP SET\n         request.  When tmnxPortUserAssignedMac is set to 'false',\n         tmnxPortMacAddress returns the system assigned MAC address.")
tmnxPortMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 9), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortMacAddress.setStatus('current')
if mibBuilder.loadTexts: tmnxPortMacAddress.setDescription("When tmnxPortUserAssignedMac has a value of 'true', \n         tmnxPortMacAddress has the value that has been explicitly\n         assigned by a SNMP SET request.  When tmnxPortUserAssignedMac\n         has a value of 'false', tmnxPortMacAddress returns the same\n         value as tmnxPortMacAddress, the hardware or system assigned\n         MAC address.  When tmnxPortMacAddress is modified by a SET \n         request, the agent sets tmnxPortUserAssignedMac to 'true'.\n             \n         Setting tmnxPortMacAddress to all zeros causes the agent to\n         revert to using the default tmnxPortHwMacAddress and also to\n         return tmnxPortUserAssignedMac as 'false'.")
tmnxPortHwMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortHwMacAddress.setStatus('current')
if mibBuilder.loadTexts: tmnxPortHwMacAddress.setDescription("The interface's hardware or system assigned MAC address at its \n         protocol sub-layer.  When tmnxPortUserAssignedMac has a value of \n         'true', the value of tmnxPortMacAddress is used instead of \n         tmnxPortHwMacAddress.\n             \n         In the case of a pre-provisioned port that is not yet physically\n         in the system, the MAC address may not be known.  In this case\n         a MAC address of all zeros is returned.")
tmnxPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("undefined", 0), ("access", 1), ("network", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortMode.setStatus('current')
if mibBuilder.loadTexts: tmnxPortMode.setDescription("The tmnxPortMode variable indicates if the interface on this port\n         is configured as a service access port or a network access\n         port.  \n\n         If the port mode equals 'access', and the tmnxMDAAssignedType\n         is of ATM MDA family, then tmnxPortEncapType is automatically \n         set to 'atmEncap'.\n\n         If port mode equals 'access', tmnxPortEncapType must also\n         be configured to 'qEncap' (For Ethernet MDAs) or to\n         'bcpNullEncap' for Sonet/SDH MDAs.  \n\n         Once the port's operation mode has been configured \n         for 'access' mode, multiple services may be configured \n         on the port.  \n\n         If the port mode equals 'network', tmnxPortEncapType must also\n         be configured to 'nullEncap' (Ethernet MDAs), or 'pppAutoEncap'\n         (Sonet/SDH MDAs) and tmnxPortEncapType is defaulted to those\n         values on the mode change.")
tmnxPortEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("unknown", 0), ("nullEncap", 1), ("qEncap", 2), ("mplsEncap", 3), ("bcpNullEncap", 4), ("bcpDot1qEncap", 5), ("ipcpEncap", 6), ("frEncap", 7), ("pppAutoEncap", 8), ("atmEncap", 9), ("qinqEncap", 10), ("wanMirrorEncap", 11), ("ciscoHDLCEncap", 12), ("cemEncap", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEncapType.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEncapType.setDescription("The type of encapsulation protocol configured on this\n         port's network interface.  If tmnxPortEncapType has a value\n         of 'nullEncap', frames received will not carry any tags\n         or labels and as a result only one service can be\n         configured on this port.  Sometimes this is referred to\n         as raw Ethernet packets. \n                 \n         If tmnxPortEncapType has a value of 'qEncap', ingress frames \n         carry 802.1q tags where each different tag can signify a \n         different service. This is not a valid value if\n         tmnxPortClass has a value of 'sonetPath'. \n                 \n         If tmnxPortEncapType has a value of 'bcpNullEncap',\n         Bcp is used on the sonet path as the NCP control protocol.\n         The BCP IEEE 802 Tagged Frame Configuration Option (type 8)\n         is negotiated to 'enabled'.  VLAN tagged frames are\n         allowed into the sonet path.  Only a single SAP can\n         be associated with the sonet path.  'bcpNullEncap' is \n         valid only if tmnxPortClass has a value of 'sonetPath'.\n                 \n         If tmnxPortEncapType has a value of 'bcpDot1qEncap',\n         BCP is used as the NCP control protocol.  The BCP IEEE 802\n         Tagged Frame Configuration Option (type 8) is negotiated to\n         'enabled'.  VLAN tagged frames are allowed on the sonet path.\n         This encapsulation type is required when multiple SAPs are\n         defined on the sonet path where each one is service\n         delimited by a provisioned Dot1q tag.  When 'bcpDot1qEncap'\n         is specified, BCP does not enter the 'open' state unless\n         the far end peer also supports 'bcpDot1qEncap'.  This allows\n         a LCP negotiation to transmit configuration request and\n         confirmation messages to enable this feature.  'bcpDot1qEncap'\n         is a valid value only if tmnxPortClass has a value of 'sonetPath'.\n \n         If tmnxPortEncapType has a value of 'ipcpEncap',\n         BCP will not be used on this sonet path.  IPCP NCP is used\n         instead.  'ipcpEncap' is a valid only if tmnxPortClass has\n         a value of 'sonetPath'.\n         \n         If tmnxPortEncapType has a value of 'frEncap', Frame Relay is\n         the expected encapsulation.\n\n         If tmnxPortEncapType has a value of 'pppAutoEncap', IPCP is \n         automatically enabled. This encap type is only valid on \n         ports/paths in network mode.\n\n         If tmnxPortEncapType has a value of 'atmEncap', the encapsulation\n         on the port is ATM. The 'atmEncap' is also used when mirroring\n         ATM ports.\n\n         If tmnxPortEncapType has a value of 'wanMirrorEncap', the \n         port is used for mirroring of frame-relay and POS ports. On such \n         ports no link management protocol would run.\n\n         If tmnxPortEncapType has a value of 'ciscoHDLCEncap', the Cisco HDLC\n         encapsulation is applied. This encap type is only valid if \n         TmnxPortClass has a value of 'tdm' or 'sonet'.\n         \n         If tmnxPortEncapType has a value of 'cemEncap', encapsulation of\n         frames will be circuit emulation.  This is used to support transparent\n         transmission of frames.  This encap type is only valid\n         if TmnxPortClass has a value of 'tdm' or 'sonet' in access mode.\n\n         tmnxPortEncapType is set to 'unknown' for physical SONET/SDH and\n         TDM ports.\n         ")
tmnxPortLagId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortLagId.setStatus('current')
if mibBuilder.loadTexts: tmnxPortLagId.setDescription("The value of tmnxPortLagId indicates which LAG or multi-link trunk\n         (MLT) this port is assigned to. If this port is not associated\n         with any LAG, this value will be set to zero(0).\n\n         The maximum value of this object is '64', when the value of\n         ALCATEL-IND1-TIMETRA-CHASSIS-MIB::tmnxChassisType is '5' (ESS-1/SR-1).")
tmnxPortHoldTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortHoldTimeUp.setStatus('current')
if mibBuilder.loadTexts: tmnxPortHoldTimeUp.setDescription("The value of tmnxPortHoldTimeUp is used to configure the \n         hold-timer for link up event dampening. This guards against \n         reporting excessive interface transitions. This is implemented \n         by not advertising subsequent transitions of the interface to \n         upper layer protocols until the configured timer has expired. \n         A value of zero (0) indicates that an up transition is reported\n         immediately.  The value of tmnxPortHoldTimeUp is not applicable \n         when tmnxPortClass has a value of 'sonet (5)'. In that case,\n         tmnxSonetHoldTimeUp is used instead.")
tmnxPortHoldTimeDown = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortHoldTimeDown.setStatus('current')
if mibBuilder.loadTexts: tmnxPortHoldTimeDown.setDescription("The value of tmnxPortHoldTimeDown is used to configure the \n         hold-timer for link down event dampening. This guards against \n         reporting excessive interface transitions. This is implemented \n         by not advertising subsequent transitions of the interface to \n         upper layer protocols until the configured timer has expired. \n         A value of zero (0) indicates that a down transition is reported\n         immediately. The value of tmnxPortHoldTimeDown is not applicable \n         when tmnxPortClass has a value of 'sonet (5)'. In that case,\n         tmnxSonetHoldTimeDown is used instead.")
tmnxPortUpProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 16), Bits().clone(namedValues=NamedValues(("portUpIpv4", 0), ("portUpMpls", 1), ("portUpBcp", 2), ("portUpIso", 3), ("portUpFr", 4), ("portUpAtm", 5), ("portUpChdlc", 6), ("portUpIma", 7), ("portUpIpv6", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortUpProtocols.setStatus('current')
if mibBuilder.loadTexts: tmnxPortUpProtocols.setDescription('The tmnxPortUpProtocols variable is a bitmap that indicates what\n         protocols can be used on this port type.')
tmnxPortConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 17), TmnxPortConnectorType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortConnectorType.setStatus('current')
if mibBuilder.loadTexts: tmnxPortConnectorType.setDescription('The type of connector installed on this port.')
tmnxPortTransceiverType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unknown", 0), ("gbic", 1), ("moduleConnectorSolderedToMotherboard", 2), ("sfpTransceiver", 3), ("xbiTransceiver", 4), ("xenpakTransceiver", 5), ("xfpTransceiver", 6), ("xffTransceiver", 7), ("xfpeTransceiver", 8), ("xpakTransceiver", 9), ("x2Transceiver", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTransceiverType.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTransceiverType.setDescription('Type of the transceiver.')
tmnxPortTransceiverCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 26), Bits().clone(namedValues=NamedValues(("unknown", 0), ("oc48-longreach", 1), ("oc48-intermediatereach", 2), ("oc48-shortreach", 3), ("oc12-singlemodelongreach", 4), ("oc12-singlemodeinterreach", 5), ("oc12-multimodeshortreach", 6), ("oc3-singlemodelongreach", 7), ("oc3-singlemodeinterreach", 8), ("oc3-multi-modeshortreach", 9), ("gige-1000base-t", 10), ("gige-1000base-cx", 11), ("gige-1000base-lx", 12), ("gige-1000base-sx", 13), ("faste-100base-mm-fx", 14), ("faste-100base-sm-fx", 15), ("xgige-10gbase-sr", 16), ("xgige-10gbase-lr", 17), ("xgige-10gbase-er", 18), ("xgige-10gbase-sw", 19), ("xgige-10gbase-lw", 20), ("xgige-10gbase-ew", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTransceiverCode.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortTransceiverCode.setDescription('The code for the transmission media.\n\n         tmnxPortOpticalCompliance is used instead of \n         tmnxPortTransceiverCode.tmnxPortOpticalCompliance  contains the \n         same information and is defined by an industry standard.')
tmnxPortTransceiverLaserWaveLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTransceiverLaserWaveLen.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTransceiverLaserWaveLen.setDescription("The light wavelength transmitted by the transceiver's laser.\n         A value of zero indicates that the port is not equipped with\n         the transceiver.")
tmnxPortTransceiverDiagCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTransceiverDiagCapable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTransceiverDiagCapable.setDescription('Indicates if the transceiver is capable of doing diagnostics.')
tmnxPortTransceiverModelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 29), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTransceiverModelNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTransceiverModelNumber.setDescription('Model number of the transceiver.')
tmnxPortSFPConnectorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 32, 33, 128))).clone(namedValues=NamedValues(("unknown", 0), ("sc", 1), ("fiberChannel-Style1-CopperConnector", 2), ("fiberChannel-Style2-CopperConnector", 3), ("bncortnc", 4), ("fiberChannelCoaxialHeaders", 5), ("fiberJack", 6), ("lc", 7), ("mt-rj", 8), ("mu", 9), ("sg", 10), ("opticalPigtail", 11), ("hssdcII", 32), ("copperPigtail", 33), ("copperGigE", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPConnectorCode.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPConnectorCode.setDescription('The external connector provided on the interface.')
tmnxPortSFPVendorOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPVendorOUI.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPVendorOUI.setDescription('The vendor organizationally unique identifier field (OUI) \n         contains the IEEE company identifier for the vendor. \n         A value of all zero indicates that the vendor OUI \n         is unspecified.')
tmnxPortSFPVendorManufactureDate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 32), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPVendorManufactureDate.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPVendorManufactureDate.setDescription("The vendor's date code.")
tmnxPortSFPMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ethernet", 1), ("sonetsdh", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPMedia.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPMedia.setDescription('The media supported for the SFP.')
tmnxPortSFPEquipped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 34), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPEquipped.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPEquipped.setDescription('Indicates if the SFP is equipped.')
tmnxPortEquipped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 35), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEquipped.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEquipped.setDescription('Indicates if there is an optics pack installed in this\n         port or not.')
tmnxPortLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 36), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortLinkStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortLinkStatus.setDescription('Indicates whether or not the port has a physical link.')
tmnxPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 37), TmnxPortAdminStatus().clone('inService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortAdminStatus.setDescription('The desired administrative status of this port.')
tmnxPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 38), TmnxPortOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortOperStatus.setDescription('The current operational status of this port.')
tmnxPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 39), TmnxPortState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortState.setStatus('current')
if mibBuilder.loadTexts: tmnxPortState.setDescription("The state level of this port.  A value of 'none' indicates\n         the port is either in its initial creation state or is\n         just about to be deleted.  A value of 'ghost' represents\n         a port that is not physically present.  This state may\n         represent a pre-provisioned port.  A value of 'linkDown'\n         represents a port that is physically present but does\n         not have a link.  The 'linkUp' state represents a port\n         that is physically present and has physical link present.\n         A port in 'up' state is ready to pass some kinds of traffic.\n         The tmnxPortUpProtocols variable indicates the actual type(s)\n         of traffic can be passed on this 'up' link.")
tmnxPortPrevState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 40), TmnxPortState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortPrevState.setStatus('current')
if mibBuilder.loadTexts: tmnxPortPrevState.setDescription('The tmnxPortPrevState indicates the state level that the port\n         transitioned from into the current tmnxPortState level.')
tmnxPortNumAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 41), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNumAlarms.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNumAlarms.setDescription('The number of alarms currently outstanding on this port.')
tmnxPortAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 42), TmnxAlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortAlarmState.setStatus('current')
if mibBuilder.loadTexts: tmnxPortAlarmState.setDescription('The value of tmnxPortAlarmState indicates the current alarm\n         state for this port.')
tmnxPortLastAlarmEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 43), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortLastAlarmEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxPortLastAlarmEvent.setDescription("The value of tmnxPortLastAlarmEvent is an object identifier whose\n         object name and instance values point to the row entry in the \n         ALARM-MIB that contains the most recent alarm event associated with \n         this port.  If the tmnxPortAlarmState has a value of \n         'alarmCleared', the most recent alarm event will be in the \n         nlmAlarmClearedTable.  If it has a value of 'alarmActive', the \n         entry pointed to is in the nlmAlarmActiveTable.  If the value of \n         tmnxPortLastAlarmEvent is '0.0', then either there have not been any \n         alarm events associated with this chassis since the system was\n         last booted, or the last alarm event has aged out and its entry is \n         no longer available in the ALARM-MIB tables.")
tmnxPortClearAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 44), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortClearAlarms.setStatus('current')
if mibBuilder.loadTexts: tmnxPortClearAlarms.setDescription('Setting this action variable causes all the alarms\n         associated with this port to be moved from the current\n         alarm log to the history alarm log. Primarily meant\n         for use in development.  This object will most likely\n         be removed from the MIB before product release.')
tmnxPortSFPVendorSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 45), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPVendorSerialNum.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPVendorSerialNum.setDescription('tmnxPortSFPVendorSerialNum contains ASCII characters, \n         defining the vendor serial number.\n         A value of all zero indicates that the vendor SN \n         is unspecified.')
tmnxPortSFPVendorPartNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 46), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPVendorPartNum.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPVendorPartNum.setDescription('The vendor part number contains ASCII characters, \n         defining the vendor part number or product name.\n         A value of all zero indicates that the vendor PN \n         is unspecified. ')
tmnxPortLastStateChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 48), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortLastStateChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxPortLastStateChanged.setDescription('The tmnxPortLastStateChanged variable contains the \n         value of the sysUpTime the last time the operational status \n         of the port changed state.')
tmnxPortNumChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 49), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNumChannels.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNumChannels.setDescription('For SONET/SDH paths or TDM channels, tmnxPortNumChannels\n         contains the number of possible immediate children. For\n         leaf paths or channels, the value of this object will be zero.\n         For SONET/SDH or TDM physical ports, tmnxPortNumChannels\n         contains the total number of channels on the physical port.\n         For all other entries in the tmnxPortTable, the value of\n         this object will be zero.')
tmnxPortNetworkEgrQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 50), TNamedItemOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortNetworkEgrQueues.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetworkEgrQueues.setDescription('tmnxPortNetworkEgrQueues contains the network egress queue policy \n        if the tmnxPortMode is network. Otherwise this object has no \n        significance.')
tmnxPortBundleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1280))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortBundleNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxPortBundleNumber.setDescription('tmnxPortBundleNumber identifies the bundle for which this port is\n         a member. If this port is not a member of any bundle, the value of\n         tmnxPortBundleNumber will be zero.')
tmnxPortIsLeaf = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 52), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIsLeaf.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIsLeaf.setDescription("tmnxPortIsLeaf is applicable only when the 'isSonet' and/or 'isTDM'\n         bits in ALCATEL-IND1-TIMETRA-CHASSIS-MIB:tmnxMDACapabilities are set.\n         When the value of this object is 'true', it indicates that the channel \n         is capable of passing traffic.\n\n         The value of this object is 'false' for:\n         1. Physical ports on SONET/TDM MDA's\n         2. Intermediate channels on a channelized MDA\n         3. Leaf channels which belong to a bundle\n\n         For ports on Ethernet MDA's or for LAG ports, the value of this object\n         will be 'false'.")
tmnxPortChanType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 53), TmnxMDAChanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortChanType.setStatus('current')
if mibBuilder.loadTexts: tmnxPortChanType.setDescription("tmnxPortChanType is applicable only when the 'isSonet' and/or 'isTDM'\n         bits in ALCATEL-IND1-TIMETRA-CHASSIS-MIB:tmnxMDACapabilities are set. It indicates\n         the type of the channel.\n         For ports on Ethernet MDA's, the value of this object will \n         be 'unknown'.")
tmnxPortParentPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 54), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortParentPortID.setStatus('current')
if mibBuilder.loadTexts: tmnxPortParentPortID.setDescription("tmnxPortParentPortID  is applicable only when the 'isSonet' \n         and/or 'isTDM' bits in ALCATEL-IND1-TIMETRA-CHASSIS-MIB:tmnxMDACapabilities are set.\n         For SONET or TDM channel, it indicates the port ID of its parent\n         channel or port.")
tmnxPortOpticalCompliance = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 55), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortOpticalCompliance.setStatus('current')
if mibBuilder.loadTexts: tmnxPortOpticalCompliance.setDescription("tmnxPortOpticalCompliance is applicable only when the \n         tmnxPortSFPEquipped is set to 'true'. The value of\n         tmnxPortOpticalCompliance indicates the 8 bytes of optical compliance \n         bits stored in SFP and XFP eeproms.")
tmnxPortLoadBalanceAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("default", 1), ("includeL4", 2), ("excludeL4", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortLoadBalanceAlgorithm.setStatus('current')
if mibBuilder.loadTexts: tmnxPortLoadBalanceAlgorithm.setDescription("The value of tmnxPortLoadBalanceAlgorithm specifies the load\n         balancing algorithm to be used on this port. When the\n         value is 'includeL4', the src and dst port are used in the \n         hashing algorithm. When it's 'excludeL4', they are not included.\n         When the value is 'default', the port inherits the global settings\n         in tmnxL4LoadBalancing. The value is 'notApplicable' for ports that\n         do not pass any traffic. An attempt to modify this object when it is\n         set to 'notApplicable' will return an inconsistentValue error.")
tmnxPortEgrPortSchedPlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 57), TNamedItemOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEgrPortSchedPlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEgrPortSchedPlcy.setDescription('The value of tmnxPortEgrPortSchedPlcy specifies the egress QoS \n         port-scheduler policy for this port. This object must correspond\n         to the index of a row in ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyTable.')
tmnxPortLastClearedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 58), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortLastClearedTime.setStatus('current')
if mibBuilder.loadTexts: tmnxPortLastClearedTime.setDescription('The value of tmnxPortLastClearedTime indicates the sysUpTime\n         when the counters in the IF-MIB:ifTable were last cleared.')
tmnxPortIngNamedPoolPlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 60), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortIngNamedPoolPlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngNamedPoolPlcy.setDescription('The value of tmnxPortIngNamedPoolPlcy specifies a named pool \n         policy associated with an port ingress context. The policy \n         governs the way named pools are created at the port level.')
tmnxPortEgrNamedPoolPlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 61), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEgrNamedPoolPlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEgrNamedPoolPlcy.setDescription('The value of tmnxPortEgrNamedPoolPlcy specifies a named pool \n         policy associated with an port egress context. The policy \n         governs the way named pools are created at the port level.')
tmnxPortIngPoolPercentRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 62), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortIngPoolPercentRate.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngPoolPercentRate.setDescription('The value of tmnxPortIngPoolPercentRate specifies increment or \n         decrement of the active bandwidth associated with the ingress port.\n         This active bandwidth affects the amount of ingress buffer space \n         managed by the port.')
tmnxPortEgrPoolPercentRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 63), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEgrPoolPercentRate.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEgrPoolPercentRate.setDescription('The value of tmnxPortEgrPoolPercentRate specifies increment or \n         decrement of the active bandwidth associated with the egress port.\n         This active bandwidth affects the amount of egress buffer space \n         managed by the port.')
tmnxPortDDMEventSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 64), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortDDMEventSuppression.setStatus('current')
if mibBuilder.loadTexts: tmnxPortDDMEventSuppression.setDescription('The value of tmnxPortDDMEventSuppression specifies whether or not an\n         inserted SFP/XFP that supports Digital Diagnostic Monitoring\n         raises traps and events (false) or suppresses all notifications\n         (true).')
tmnxPortSFPStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 2, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-equipped", 0), ("operational", 1), ("read-error", 2), ("data-corrupt", 3), ("ddm-corrupt", 4), ("unsupported", 5))).clone('not-equipped')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSFPStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSFPStatus.setDescription("The value of tmnxPortSFPStatus indicates the operational status of \n         the inserted SFP/XFP. If tmnxPortSFPEquipped is false, the\n         tmnxPortSFPStatus will be 'not-equipped (0)', otherwise\n         'operational (1)' if no failure is detected.\n         \n         A failure to read the SFP data will result in a 'read-error (2)',\n         while corrupted information on the SFP will result in either\n         'data-corrupt (3)', or 'ddm-corrupt (4)' if an SFP read results in\n         invalid data or DDM information respectively.  An insertion of an\n         unsupported SFP will result in 'unsupported (5)'.\n\n         A trap will be raised if the value of tmnxPortSFPStatus indicates a\n         failure; that is the tmnxPortSFPStatus is neither 'not-equipped (0)',\n         nor 'operational (1)'.")
tmnxPortTestTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3), )
if mibBuilder.loadTexts: tmnxPortTestTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestTable.setDescription('The tmnxPortTestTable has an entry for each port on each IOM\n         card in each chassis in the TMNX system.')
tmnxPortTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1), )
tmnxPortEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestEntry"))
tmnxPortTestEntry.setIndexNames(*tmnxPortEntry.getIndexNames())
if mibBuilder.loadTexts: tmnxPortTestEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestEntry.setDescription('Each row entry represents a port on a IOM card in a\n         chassis in the system.  Entries cannot be created and\n         deleted via SNMP SET operations.')
tmnxPortTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInTest", 1), ("inTest", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTestState.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestState.setDescription('The current testing status of this port.')
tmnxPortTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("loopback1", 1), ("loopback2", 2), ("loopback3", 3), ("singalInsertion", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortTestMode.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestMode.setDescription('The type of test to be executed on this port.')
tmnxPortTestParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortTestParameter.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestParameter.setDescription('A parameter to be passed to the test program.')
tmnxPortTestLastResult = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("success", 1), ("failure", 2), ("timeout", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTestLastResult.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestLastResult.setDescription('The status of the last test executed on this port.')
tmnxPortTestStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTestStartTime.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestStartTime.setDescription('The date and time the test started on this port.\n         Returns 0 if tmnxPortTestState is notInTest.')
tmnxPortTestEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTestEndTime.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestEndTime.setDescription('The date and time the last test completed.  Returns 0\n         if a test is in progress or no tests have yet to be run on\n         this port.')
tmnxPortTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortTestDuration.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestDuration.setDescription('The number of seconds the port test is anticipated to last.')
tmnxPortTestAction = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("startTest", 2), ("stopTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortTestAction.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestAction.setDescription('The operator sets this variable to perform the appropriate\n         type of testing.')
tmnxPortEtherTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4), )
if mibBuilder.loadTexts: tmnxPortEtherTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherTable.setDescription('The tmnxPortEtherTable has an entry for each Ethernet \n         (faste, gige, xcme or xgige) port on each IOM card in each chassis \n         in the TMNX system.')
tmnxPortEtherEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxPortEtherEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherEntry.setDescription('Each row entry represents an Ethernet port on a IOM card in a\n         chassis in the system.  Entries cannot be created and\n         deleted via SNMP SET operations.  Before an IOM card entry\n         can be deleted from the tmnxMDATable, its supported\n         tmnxPortEntry and tmnxPortEtherEntry rows must be in the proper\n         state for removal.  The tmnxPortEtherEntry contains attributes\n         that are unique to the Ethernet TmnxPortType.')
tmnxPortEtherMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 9212), ))).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherMTU.setDescription('The size of the largest packet which can be sent/received\n         on the Ethernet physical interface, specified in octets.  For \n         interfaces that are used for transmitting network datagrams, \n         this is the size of the largest network datagram that can be \n         sent on the interface.  \n             \n         Setting tmnxPortEtherMTU to a value of zero (0), causes the agent \n         to recalculate the default MTU size which can vary based on the \n         current setting of tmnxPortMode and tmnxPortEncapType variables.  \n         Some typical default values are:\n                1514 with mode access and encap-type null\n                1518 with mode access and encap-type dot1q\n                1518 with mode access and encap-type mpls\n                9198 with mode network\n        ')
tmnxPortEtherDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("fullDuplex", 1), ("halfDuplex", 2))).clone('fullDuplex')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherDuplex.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherDuplex.setDescription("The tmnxPortEtherDuplex variable specifies the duplex mode used by\n         the Ethernet interface if tmnxPortEtherAutoNegotiate has a value of\n         'false' or 'limited'. If tmnxPortEtherAutoNegotiate has a value of\n         'true', the link parameters are negotiated with the far end and\n         the tmnxPortEtherDuplex variable is ignored. A value of 'fullDuplex'\n         sets the link to full duplex mode.  A value of 'halfDuplex' sets\n         the link to half duplex mode. tmnxPortEtherDuplex is only valid on\n         Ethernet interfaces that support multiple duplex modes.")
tmnxPortEtherSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("speed10", 1), ("speed100", 2), ("speed1000", 3), ("speed10000", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherSpeed.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherSpeed.setDescription("The tmnxPortEtherSpeed variable specifies the link speed of the\n         Ethernet interface if tmnxPortEtherAutoNegotiate has a value of\n         'false' or 'limited'.  If tmnxPortEtherAutoNegotiate has a value of\n         'true', the link parameters are negotiated with the far end and\n         the tmnxPortEtherSpeed variable is ignored. A value of 'speed10' \n         sets the link to 10 mbps.  A value of 'speed100' sets the link to\n         100 mbps.  A value of 'speed1000' sets the link to 1000 mbps (1 gbps).\n         tmnxPortEtherSpeed is only valid on Ethernet interfaces that support\n         multiple link speeds.")
tmnxPortEtherAutoNegotiate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("true", 1), ("false", 2), ("limited", 3))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherAutoNegotiate.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherAutoNegotiate.setDescription("When the value of tmnxPortEtherAutoNegotiate is 'true', the Ethernet\n         interface will automatically negotiate link parameters with the far\n         end (including speed and duplex), and will advertise all speeds and\n         duplex modes supported by the interface. When the value of \n         tmnxPortEtherAutoNegotiate is 'limited', the Ethernet interface will\n         automatically negotiate link parameters with the far end, but will\n         only advertise the speed and duplex mode specified by tmnxPortEtherSpeed\n         and tmnxPortEtherDuplex. If tmnxPortEtherAutoNegotiate is 'false',\n         the Ethernet interface won't negotiate link parameters with the far\n         end and will instead force the speed and duplex mode to the values specified\n         by tmnxPortEtherSpeed and tmnxPortEtherDuplex respectively.")
tmnxPortEtherOperDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("fullDuplex", 1), ("halfDuplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherOperDuplex.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherOperDuplex.setDescription("The tmnxPortEtherOperDuplex variable indicates the operational duplex\n         mode of the Ethernet interface. A value of 'fullDuplex' indicates that\n         the link is in full duplex mode.  A value of 'halfDuplex' indicates\n         that the link is in half duplex mode. tmnxPortEtherOperDuplex is only\n         valid if tmnxPortClass is 'faste' or 'xcme'.")
tmnxPortEtherOperSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 6), Unsigned32()).setUnits('mega-bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherOperSpeed.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherOperSpeed.setDescription("The tmnxPortEtherOperSpeed variable indicates the operational speed\n         of the Ethernet interface in mega-bits per second (mbps).  If the value of \n         tmnxPortEtherAutoNegotiate is 'true', the link autonegotiates the link \n         parameters with the far end side.  The value of tmnxPortEtherOperSpeed is \n         only valid if tmnxPortClass is one of the Ethernet classes.")
tmnxPortEtherAcctPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherAcctPolicyId.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherAcctPolicyId.setDescription('The value of the accounting policy must be defined prior to associating\n         the policy with the ethernet port. Accounting policies can only be \n         associated with network ports.\n         A non-zero value indicates the tmnxLogApPolicyId index identifying the\n         policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is\n         associated with this port.  A zero value indicates that there is no\n         accounting policy associated with this port')
tmnxPortEtherCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 8), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherCollectStats.setDescription('Enable/disable the collection of accounting and statistical data\n         for the network ethernet port. When applying accounting policies the \n         data by default will be collected in the appropriate records and \n         written to the designated billing file. \n         When the value is set to false, the statistics are still accumulated \n         by the IOM cards, however, the CPU will not obtain the results and\n         write them to the billing file.')
tmnxPortEtherMDIMDIX = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("mdi", 1), ("mdix", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherMDIMDIX.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherMDIMDIX.setDescription("The tmnxPortEtherMDIMDIX variable indicates whether the Ethernet \n         interface is of type 'mdi' (Media Dependent Interface) or \n         'mdix' (Media Dependent Interface with crossover). If the agent \n         cannot identify the type of Ethernet interface the value \n         'unknown (0)' is indicated. tmnxPortEtherMDIMDIX is only valid if\n         tmnxPortClass is 'faste' or 'xcme'.")
tmnxPortEtherXGigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("lan", 1), ("wan", 2))).clone('lan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherXGigMode.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherXGigMode.setDescription("The tmnxPortEtherXGigMode variable specifies whether the Ethernet \n         interface is in LAN or WAN mode. tmnxPortEtherXGigMode must be\n         'notApplicable' if tmnxPortClass is not 'xgige'.")
tmnxPortEtherEgressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 10000000), )).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherEgressRate.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherEgressRate.setDescription('The tmnxPortEtherEgressRate variable specifies the maximum egress\n         bandwidth (in kilobits per second) that the Ethernet interface\n         can generate. A value of -1 means that the limit is the actual \n         physical limit. If the provisioned sub-rate bandwidth is larger than \n         the actual physical bandwidth of the interface, the latter applies.')
tmnxPortEtherDot1qEtype = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535)).clone(33024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherDot1qEtype.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherDot1qEtype.setDescription("The tmnxPortEtherDot1qEtype variable indicates the ethertype expected\n         when the port's encapsulation type is dot1qEncap.")
tmnxPortEtherQinqEtype = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535)).clone(33024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherQinqEtype.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherQinqEtype.setDescription("The tmnxPortEtherQinqEtype variable indicates the ethertype expected\n         when the port's encapsulation type is qinqEncap.")
tmnxPortEtherIngressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 10000), )).clone(-1)).setUnits('mega-bits per second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherIngressRate.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherIngressRate.setDescription('The tmnxPortEtherIngressRate variable specifies the maximum ingress\n         bandwidth (in mega-bits per second) that the Ethernet interface\n         can receive. A value of -1 means that the limit is the actual\n         physical limit. If the provisioned sub-rate bandwidth is larger than\n         the actual physical bandwidth of the interface, the latter applies.')
tmnxPortEtherReportAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 15), TmnxPortEtherReportStatus().clone(namedValues=NamedValues(("remoteFault", 2), ("localFault", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherReportAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherReportAlarm.setDescription('The value of tmnxPortEtherReportAlarm determines when and if to\n         generate tmnxEqPortEtherAlarm and tmnxEqPortEtherAlarmClear.')
tmnxPortEtherReportAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 16), TmnxPortEtherReportStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherReportAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherReportAlarmStatus.setDescription('The value of tmnxPortEtherReportAlarmStatus indicates the alarms on \n         this port.')
tmnxPortEtherPkts1519toMax = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 17), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherPkts1519toMax.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherPkts1519toMax.setDescription('The total number of packets received that were longer than 1518 octets \n         but less than the maximum frame size for the particular medium, usually\n         12287 octets (excluding framing bits, but including FCS octets) and were\n         otherwise well formed.')
tmnxPortEtherHCOverPkts1519toMax = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 18), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherHCOverPkts1519toMax.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherHCOverPkts1519toMax.setDescription('The number of times the associated tmnxPortEtherPkts1519toMax \n        counter has overflowed.')
tmnxPortEtherHCPkts1519toMax = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 19), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherHCPkts1519toMax.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherHCPkts1519toMax.setDescription('The total number of packets (including bad packets) received that were \n         between 1519 octets in length and the maximum frame size, usually 12287\n         octets inclusive (excluding framing bits but including FCS octets).\n\n         The lower 32-bits of this 64-bit counter will equal the value of \n         tmnxPortEtherHCPkts1519toMax.  The high 32-bits of this counter will\n         equal the value of tmnxPortEtherHCOverPkts1519toMax.')
tmnxPortEtherLacpTunnel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 20), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherLacpTunnel.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherLacpTunnel.setDescription('The value of tmnxPortEtherLacpTunnel specifies whether the LACP\n         packet tunneling for the ethernet port is enabled or disabled.\n         When tunneling is enabled, the port will not process any LACP \n         packets but will tunnel them through instead. Also, the port \n         cannot be added as a member to a LAG group, and vice versa.')
tmnxPortEtherDownWhenLoopedEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 21), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedEnabled.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedEnabled.setDescription("The value of tmnxPortEtherDownWhenLoopedEnabled specifies whether \n         physical loop detection for the Ethernet port is enabled or\n         disabled.  When enabled, the port will periodically send out\n         keep-alive PDUs with an EtherType of 0x9000.  If the port\n         receives a keep-alive that it transmitted, tmnxPortState will be\n         set to 'linkUp' if it was previously 'up'. The port will not move \n         back to tmnxPortState 'up' for a period of time defined by \n         tmnxPortEtherDownWhenLoopedRetry, but will continue to periodically\n         send out keep-alive PDUs.  Every time the port receives a keep alive\n         it sent while a loop has been detected, it will reset the time\n         period that it will remain down as defined by \n         tmnxPortEtherDownWhenLoopedRetry.")
tmnxPortEtherDownWhenLoopedKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedKeepAlive.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedKeepAlive.setDescription('The tmnxPortEtherDownWhenLoopedKeepAlive variable specifies the\n         number of seconds between each keep alive PDU transmission.')
tmnxPortEtherDownWhenLoopedRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 23), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(10, 160), )).clone(120)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedRetry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedRetry.setDescription("The tmnxPortEtherDownWhenLoopedRetry variable specifies the minimum\n         number of seconds the port should wait after detecting a loop before \n         tmnxPortState can be set to 'up'.  A value of 0 specifies the the \n         port should not set tmnxPortState to 'up' until the user \n         administratively disables and re-enables the port by setting \n         tmnxPortAdminStatus to 'outOfService' and then to 'inService'.")
tmnxPortEtherDownWhenLoopedState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noLoopDetected", 1), ("loopDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedState.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherDownWhenLoopedState.setDescription("The value of tmnxPortEtherDownWhenLoopedState indicates whether \n         a physical loop has been detected on the port or not.  If\n         tmnxPortEtherDownWhenLoopedEnabled is set to 'false', this value\n         will be 'noLoopDetected'.")
tmnxPortEtherPBBEtype = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535)).clone(35047)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxPortEtherPBBEtype.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherPBBEtype.setDescription('The tmnxPortEtherPBBEtype variable indicates the Ethertype expected\n        for Provider Backbone Bridging Frames.')
tmnxPortEtherReasonDownFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 4, 1, 26), Bits().clone(namedValues=NamedValues(("unknown", 0), ("linklossFwd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortEtherReasonDownFlags.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEtherReasonDownFlags.setDescription("The tmnxPortEtherReasonDownFlags indicates why an ethernet port may\n        be in the operationally 'down' state. The following reasons are\n        detected through this object:\n                unknown(0)     - Unspecified (or unknown)\n                linklossFwd(1) - A sap using this port has the object \n                                 'sapEthernetLLFOperStatus' set to 'fault'")
tmnxSonetTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5), )
if mibBuilder.loadTexts: tmnxSonetTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetTable.setDescription('The tmnxSonetTable has an entry for each packet over Sonet\n         port on each IOM card in each chassis in the TMNX system.')
tmnxSonetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxSonetEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetEntry.setDescription("Each row entry represents a packet over Sonet port on a \n         IOM card in a chassis in the system.  Entries cannot be \n         created and deleted via SNMP SET operations.  Before an IOM \n         tmnxMDAEntry can be deleted from the tmnxMDATable, its \n         supported tmnxPortEntry rows must be in the proper state for \n         removal.  The tmnxSonetEntry contains attributes that are \n         unique to the 'sonet' TmnxPortType.  It also contains attributes\n         that are common to all sonet paths configured on a sonet port.\n         The tmnxPortPortID for a sonet port includes a sonet path number \n         in the lower bits.   If the sonet path number is zero, '0', it \n         represents a single (clear) sonet path on the port that uses \n         the full bandwidth of the sonet port.  All entries in this table \n         have the sonet path number part of their tmnxPortPortID index \n         value set to zero.")
tmnxSonetSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("oc3", 1), ("oc12", 2), ("oc48", 3), ("oc192", 4), ("oc768", 5), ("oc1", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetSpeed.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetSpeed.setDescription('The rate of this optical facility.')
tmnxSonetClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopTimed", 1), ("nodeTimed", 2))).clone('loopTimed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetClockSource.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetClockSource.setDescription("tmnxSonetClockSource configures the clock for transmitted data from \n         either the internal clock ('nodeTimed') or from a clock recovered \n         from the line's receive data stream ('loopTimed').")
tmnxSonetFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("sonet", 2), ("sdh", 3))).clone('sonet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetFraming.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetFraming.setDescription('The value of tmnxSonetFraming indicates the type of framing used\n         on this interface.')
tmnxSonetReportAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 4), Bits().clone(namedValues=NamedValues(("notUsed", 0), ("loc", 1), ("lais", 2), ("lrdi", 3), ("ss1f", 4), ("sb1err", 5), ("lb2erSd", 6), ("lb2erSf", 7), ("slof", 8), ("slos", 9), ("stxptr", 10), ("srxptr", 11), ("lrei", 12))).clone(namedValues=NamedValues(("loc", 1), ("lrdi", 3), ("lb2erSf", 7), ("slof", 8), ("slos", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetReportAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetReportAlarm.setDescription('The value of tmnxSonetReportAlarm determines when and if to\n         generate tmnxEqPortSonetAlarm and tmnxEqPortSonetAlarmClear \n         notifications for this port:\n            loc(1)      Reports a loss of clock which causes the operational \n                        state of the port to be downed.  Set by default. \n            lais(2)     Reports line alarm indication signal errors. Not set\n                        by default. \n            lrdi(3)     Reports line remote defect initiation errors.  LRDIs\n                        are caused by remote LOF, LOC, and LOS.  Set by default.\n            ss1f(4)     Reports section synchronization failure as reported by\n                        the S1 byte.  Not set by default.\n            sb1err(5)   Reports section B1 errors.  Not set by default.\n            lb2erSd(6)  Reports line signal degradation BER errors.  Not set\n                        by default.\n            lb2erSf(7)  Reports line signal failure BER errors.  Set by default.\n            slof(8)     Reports section loss of frame errors.  Set by default\n            slos(9)     Reports section loss of signal errors. Set by default.\n            stxptr(10)  Reports a section synchronization error on the transmit\n                        side.  Indicates if there is a positive or negative\n                        justification count per channel.  Not set by default.\n            srxptr(11)  Reports a section synchronization error on the receive\n                        side.  Indicates if there is a positive or negative\n                        justification count per path.  Not set by default.\n            lrei(12)    Reports a line error condition raised by the remote\n                        as a result of B1 errors received from this node.\n                        Not set by default.\n        ')
tmnxSonetBerSdThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 9)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetBerSdThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetBerSdThreshold.setDescription('The value of tmnxSonetBerSdThreshold specifies a bit error rate (BER)\n         threshold used to determine when to send a tmnxEqPortSonetAlarm \n         notification for a BER SD failure and tmnxEqPortSonetAlarmClear\n         notification for a BER SD failure clear.  tmnxSonetBerSdThreshold is \n         the absolute value of the exponent of the rate expressed as 10e-n.')
tmnxSonetBerSfThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 6)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetBerSfThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetBerSfThreshold.setDescription('The value of tmnxSonetBerSfThreshold specifies a bit error rate (BER)\n         threshold used to determine when to send a tmnxEqPortSonetAlarm \n         notification for a BER SF failure and tmnxEqPortSonetAlarmClear\n         notification for a BER SF failure clear.  tmnxSonetBerSdThreshold is \n         the absolute value of the exponent of the rate expressed as 10e-n.')
tmnxSonetAps = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetAps.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetAps.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 8), TmnxPortAdminStatus().clone('inService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetApsAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsAdminStatus.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 9), TmnxPortOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetApsOperStatus.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsOperStatus.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue="0000000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetApsAuthKey.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsAuthKey.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsNeighborAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 11), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetApsNeighborAddr.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsNeighborAddr.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsAdvertiseInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 12), TimeInterval().clone(1000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetApsAdvertiseInterval.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsAdvertiseInterval.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsAdvertiseTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 13), TimeInterval()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetApsAdvertiseTimeLeft.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsAdvertiseTimeLeft.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 14), TimeInterval().clone(3000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetApsHoldTime.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsHoldTime.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetApsHoldTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 15), TimeInterval()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetApsHoldTimeLeft.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetApsHoldTimeLeft.setDescription('Automatic Protection Switching (APS) is supported on 7x50 systems\n         by the APS-MIB and TIMETRA-APS-MIB.')
tmnxSonetLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("line", 1), ("internal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetLoopback.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetLoopback.setDescription('Activate a loopback on the SONET port. The SONET port must be in a\n        shutdown state to activate any type of loopback.')
tmnxSonetReportAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 17), Bits().clone(namedValues=NamedValues(("notUsed", 0), ("loc", 1), ("lais", 2), ("lrdi", 3), ("ss1f", 4), ("sb1err", 5), ("lb2erSd", 6), ("lb2erSf", 7), ("slof", 8), ("slos", 9), ("stxptr", 10), ("srxptr", 11), ("lrei", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetReportAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetReportAlarmStatus.setDescription('The bits in this object are used for indicating the alarms. The bits\n         are explained as follows:\n            loc(1)      Indicates a loss of clock which causes the operational \n                        state of the port to be downed. \n            lais(2)     Indicates line alarm indication signal errors. \n            lrdi(3)     Indicates line remote defect indication errors.  LRDIs\n                        are caused by remote LOF, LOC, and LOS.\n            ss1f(4)     Indicates section synchronization failure as reported by\n                        the S1 byte.\n            sb1err(5)   Indicates section B1 errors.\n            lb2erSd(6)  Indicates line signal degradation BER errors.\n            lb2erSf(7)  Indicates line signal failure BER errors.\n            slof(8)     Indicates section loss of frame errors.\n            slos(9)     Indicates section loss of signal errors.\n            stxptr(10)  Indicates a section synchronization error on the \n                        transmit side. Indicates if there is a positive or \n                        negative justification count per channel.\n            srxptr(11)  Indicates a section synchronization error on the receive\n                        side.  Indicates if there is a positive or negative\n                        justification count per sonet path.\n            lrei(12)    Indicates a line error condition raised by the remote\n                        as a result of B1 errors received from this node.\n        ')
tmnxSonetSectionTraceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("increment-z0", 1), ("byte", 2), ("string", 3))).clone('byte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetSectionTraceMode.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetSectionTraceMode.setDescription("The tmnxSonetSectionTraceMode variable along with the\n        tmnxSonetJ0String object determines the contents of\n        the section trace bytes (j0/z0) in the SONET Section Header. If the\n        mode is set to 'increment-z0', then the j0 byte is 0x01, and the\n        z0 byte increments. If the mode is set to 'byte', then the j0 byte is\n        the first octet of the tmnxSonetJ0String object and the z0 byte\n        is 0xcc. If the mode is set to 'string', then the J0 byte is set to\n        the 16 values in the tmnxSonetJ0String object and the z0 byte is\n        0xcc.")
tmnxSonetJ0String = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone(hexValue="01")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetJ0String.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetJ0String.setDescription('The tmnxSonetJ0String is used with the tmnxSonetSectionTraceMode\n        variable to determine the contents of the j0 byte in the SONET Section\n        Header. If the tmnxSonetSectionTraceMode is increment-z0, this object\n        is ignored. If the mode is byte, then the first octet of this object is\n        used for the J0 byte. If the mode is string, then the 16 bytes in this\n        object are used for the J0 byte. If set to less than 16 bytes it, will\n        be padded out to 16 with zeros. The default value is 0x01 and 15 NULLs')
tmnxSonetMonS1Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(204)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetMonS1Byte.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetMonS1Byte.setDescription('The tmnxSonetMonS1Byte variable reports the Synchronization Status\n        Message from the S1 byte in the Line Overhead Header. A value of 0x00 \n        indicates unknown quality. A value of 0xF0 indicates \n        `Do not use for synchronization`. Other values are documented in \n        Tellcordia GR253 and ITU G.707')
tmnxSonetMonJ0String = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetMonJ0String.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetMonJ0String.setDescription('The tmnxSonetMonJ0String variable reports the contents of the j0 byte \n         in the SONET Section Header.')
tmnxSonetMonK1Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetMonK1Byte.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetMonK1Byte.setDescription('The tmnxSonetMonK1Byte variable reports the Automatic Protection \n         Switching(APS) signalling status from the K1 byte in the SONET\n         Line Overhead Header.')
tmnxSonetMonK2Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetMonK2Byte.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetMonK2Byte.setDescription('The tmnxSonetMonK1Byte variable reports the Automatic Protection \n         Switching(APS) signalling status from the K2 byte in the SONET\n         Line Overhead Header.')
tmnxSonetSingleFiber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 24), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetSingleFiber.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetSingleFiber.setDescription('tmnxSonetSingleFiber is used to enable/disable packet gathering and \n         redirection of IP packets from a single fiber on RX port of the \n         SONET interface and redistribute packets to other interfaces \n         through either state routes or policy-based forwarding.')
tmnxSonetHoldTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(5)).setUnits('100s of milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetHoldTimeUp.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetHoldTimeUp.setDescription('The value of tmnxSonetHoldTimeUp is used to configure the \n         hold-timer for link up event dampening. This guards against \n         reporting excessive interface transitions. This is implemented \n         by not advertising subsequent transitions of the interface to \n         upper layer protocols until the configured timer has expired. \n         A value of zero (0) indicates that an up transition is reported\n         immediately.')
tmnxSonetHoldTimeDown = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 5, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('100s of milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetHoldTimeDown.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetHoldTimeDown.setDescription('The value of tmnxSonetHoldTimeDown is used to configure the \n         hold-timer for link down event dampening. This guards against \n         reporting excessive interface transitions. This is implemented \n         by not advertising subsequent transitions of the interface to \n         upper layer protocols until the configured timer has expired. \n         A value of zero (0) indicates that a down transition is reported\n         immediately.')
tmnxSonetPathTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6), )
if mibBuilder.loadTexts: tmnxSonetPathTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathTable.setDescription('The tmnxSonetPathTable has an entry for each sonet path\n         configured in each packet over Sonet port on each IOM card \n         in each chassis in the TMNX system.')
tmnxSonetPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxSonetPathEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathEntry.setDescription("Each row entry represents a configured sonet path in a packet \n         over Sonet port on a IOM card in a chassis in the system.\n         The tmnxSonetPathEntry contains attributes that are \n         unique to a sonet path of a 'sonet' TmnxPortType. The \n         tmnxPortPortID for a sonet port includes a sonet path number \n         in the lower bits.  If the sonet path number is zero, '0', it \n         represents a single (clear) sonet path on the port that uses \n         the full bandwidth of the sonet port.  Entries in this table \n         that have the sonet path number part of their tmnxPortPortID \n         index value set to zero cannot be created and deleted via \n         SNMP SET operations.  They are created by the SNMP agent \n         when the corresponding entry in the tmnxSonetTable is \n         created.  \n                 \n         Entries with non-zero sonet path numbers can be created and \n         deleted via SNMP SET operations using tmnxSonetPathRowStatus.\n         When a row is created in the tmnxSonetPathTable, the\n         agent also creates a row with the same index values in the\n         tmnxPortTable.  In order to delete an entry, \n         tmnxPortAdminStatus must first be set to 'outOfService'.  When\n         the tmnxSonetPathEntry is deleted, the agent also deletes\n         the corresponding row in the tmnxPortTable.")
tmnxSonetPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathRowStatus.setDescription("tmnxSonetPathRowStatus controls the creation and deletion of\n         row entries in the tmnxSonetPathTable. The tmnxPortPortID \n         for a sonet port includes a sonet path number in the lower bits.  \n         If the sonet path number is zero, '0', it represents a single \n         (clear) sonet path on the port that uses the full bandwidth of \n         the sonet port.  Entries in this table that have the sonet path \n         number part of their tmnxPortPortID index value set to zero \n         cannot be created and deleted via SNMP SET operations. They\n         are created by the SNMP agent when the corresponding entry in\n         the tmnxSonetTable is created. \n             \n         Entries with non-zero sonet path numbers can be created and deleted \n         via SNMP SET operations.  When a row is created in the \n         tmnxSonetPathTable, the agent also creates a row with the \n         same index values in the tmnxPortTable.  In order to delete an \n         entry, tmnxPortAdminStatus must first be set to 'outOfService'.  \n         When the tmnxSonetPathEntry is deleted, the agent also \n         deletes the corresponding row in the tmnxPortTable for this\n         sonet path port.")
tmnxSonetPathLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetPathLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathLastChangeTime.setDescription('The tmnxSonetPathLastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxSonetPathEntry row for this sonet path.')
tmnxSonetPathMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 9208), ))).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathMTU.setDescription('The size of the largest packet which can be sent/received\n         on the sonet path, specified in octets.  For paths that\n         are used for transmitting network datagrams, this is the\n         size of the largest network datagram that can be sent on the\n         sonet path.\n            \n         Setting tmnxSonetPathMTU to a value of zero (0), causes the agent \n         to recalculate the default MTU size which can vary based on the \n         current setting of tmnxPortMode and tmnxPortEncapType variables.  \n         Some typical default values are:\n                1522 with mode access and encap-type bcp-null\n                1526 with mode access and encap-type bcp-dot1q\n                1502 with mode access and encap-type ipcp\n                1506 with mode access and encap-type mplscp\n                1524 with mode access and encap-type atm\n                9208 with mode network\n        ')
tmnxSonetPathScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 4), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathScramble.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathScramble.setDescription("If the tmnxSonetPathScramble variable is set to 'true', \n         SONET (SDH) payload scrambling is enabled on this sonet path.  \n         Both ends of the connection must use the same scrambling \n         algorithm.  If tmnxSonetPathScramble is set to 'false', \n         scrambling is disabled.\n         The default value for non-ATM paths is 'false'.\n         The default value for ATM paths is 'true'\n\n         If the value of tmnxSonetPathC2Byte is set to the default for\n         the currently configured tmnxSonetPathScramble, then changing \n         the value of tmnxSonetPathScramble  for non-ATM paths causes a change\n         to tmnxSonetPathC2Byte to a default value for a new scrambling \n         option. The default values are as follows:\n         scrambled non-ATM sonet/sdh path - C2 Byte value is 0x16\n         unscrambled non-ATM sonet/sdh path - C2 Byte value is 0xCF")
tmnxSonetPathC2Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathC2Byte.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathC2Byte.setDescription("The tmnxSonetPathC2Byte variable is used configure the value\n         used in the SONET/SDH C2 header byte. \n         \n         For paths on an MDA that does not support channelization:\n         Setting C2 equal to 0x16 indicates scrambled sonet.\n\n         Setting C2 equal to 0xCF indicates unscrambled sonet.\n\n         Setting C2 equal to 0x13 indicates ATM.\n\n         For paths on an MDA that supports channelization, the default\n         value is based on the value of tmnxMDAMaxChannelization. \n         For 'pdhDs3' or 'pdhE3' channelization, the default value is 0x04.\n\n         Setting tmnxSonetPathC2Byte to a value of zero(0) causes the agent\n         to assign the default value to this object.")
tmnxSonetPathJ1String = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 62))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathJ1String.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathJ1String.setDescription("The tmnxSonetPathJ1String variable is used to configure the sonet path\n        trace string to be sent in the J1 Path Overhead bytes. The bytes\n        must be printable ASCII. If the string is less than 62 bytes, it\n        will be padded with NULLs. For SONET framing, an additional CR (0x0D)\n        / LF (0x0A) pair will be added by the driver. For SDH framing only\n        16 bytes are sent in the J1 bytes. The driver will set the MSB of \n        the first byte, and put the first 15 bytes of the user configured string \n        as the following bytes. The driver will set the CRC-7 of the 16 bytes \n        into the other 7 bits of the first byte. \n\n        The default value is `Alcatel 7x50 SR`. \n        Setting a 1-byte long string containing 0xFF will restore the default. \n        Setting the string 'zeros' will send all-zeros (ASCII NULL characters \n        without CR/LF or CRC-7)in the J1 bytes.")
tmnxSonetPathCRC = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16", 1), ("crc32", 2))).clone('crc32')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathCRC.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathCRC.setDescription("The value of tmnxSonetPathCRC variable indicates the precision of\n         the cyclic redundancy check.  A value of 'crc16' is a 16-bit\n         CRC calculation.  A value of 'crc32' is a 32-bit CRC\n         calculation.  32-bit CRC increases the error detection ability,\n         but it also adds some performance overhead.\n\n         For paths with encapsulation set to ATM the default and only \n         supported value is crc32 and applies to AAL5 CRC calculations\n         on that path.")
tmnxSonetPathOperMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 8), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetPathOperMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathOperMTU.setDescription('The negotiated size of the largest packet which can be sent on \n         the sonet path, specified in octets.  For sonet paths that are used \n         for transmitting network datagrams, this is the size of the largest\n         network datagram that can be sent on the sonet path.')
tmnxSonetPathOperMRU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 9), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetPathOperMRU.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathOperMRU.setDescription('The negotiated size of the largest packet that can be received\n         on the sonet path, specified in octets.')
tmnxSonetPathReportAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 10), Bits().clone(namedValues=NamedValues(("notUsed", 0), ("pais", 1), ("plop", 2), ("prdi", 3), ("pb3err", 4), ("pplm", 5), ("prei", 6), ("puneq", 7), ("plcd", 8))).clone(namedValues=NamedValues(("plop", 2), ("pplm", 5), ("puneq", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathReportAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathReportAlarm.setDescription("The value of tmnxSonetPathReportAlarm determines when and if to\n         generate tmnxEqPortSonetPathAlarm and tmnxEqPortSonetPathAlarmClear \n         notifications for this port:\n            pais(1)     Reports path alarm indication signal errors. Not set by\n                        default.\n            plop(2)     Reports path loss of pointer (per tributary) errors.\n                        Set by default.\n            prdi(3)     Reports path remote defect indication errors.  Not set\n                        by default.\n            pb3err(4)   Reports path B3 errors.  Not set by default.\n            pplm(5)     Reports a path payload mismatch.  As a result the\n                        path will be operationally downed.  Set by default.\n            prei(6)     Reports a path error condition raised by the remote as\n                        a result of B3 errors received from this node.  Not\n                        set by default.\n            puneq(7)    Reports unequipped path errors. Set by default.\n            plcd(8)     Reports path loss of codegroup delineation error. \n                        It is applicable only when the value of \n                        tmnxPortEtherXGigMode is set to 'wan'. \n                        Not set by default.\n        ")
tmnxSonetPathAcctPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathAcctPolicyId.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathAcctPolicyId.setDescription('The value of the accounting policy must be defined prior to associating\n         the policy with the sonet path. Accounting policies can only be \n         associated with network sonet path.\n         A non-zero value indicates the tmnxLogApPolicyId index identifying the\n         policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is\n         associated with this port.  A zero value indicates that there is no\n         accounting policy associated with this port')
tmnxSonetPathCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 12), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathCollectStats.setDescription('Enable/disable the collection of accounting and statistical data\n         for the network sonet path. When applying accounting policies the \n         data by default will be collected in the appropriate records and \n         written to the designated billing file. \n         When the value is set to false, the statistics are still accumulated \n         by the IOM cards, however, the CPU will not obtain the results and\n         write them to the billing file.')
tmnxSonetPathReportAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 13), Bits().clone(namedValues=NamedValues(("notUsed", 0), ("pais", 1), ("plop", 2), ("prdi", 3), ("pb3err", 4), ("pplm", 5), ("prei", 6), ("puneq", 7), ("plcd", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetPathReportAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathReportAlarmStatus.setDescription("The bits in this object are used for indicating the alarms. The bits\n         are explained as follows:\n            pais(1)     Indicates path alarm indication signal errors.\n            plop(2)     Indicates path loss of pointer (per tributary) errors.\n            prdi(3)     Indicates path remote defect indication errors.\n            pb3err(4)   Indicates path B3 errors.\n            pplm(5)     Indicates a path payload mismatch.\n            prei(6)     Indicates a path error condition raised by the remote as\n                        a result of B3 errors received from this node.\n            puneq(7)    Indicates a far-end unequipped error.\n            plcd(8)     Indicates a path loss of codegroup delineation error.\n                        It is applicable only when the value of \n                        tmnxPortEtherXGigMode is set to 'wan'. \n                        Not set by default.\n        ")
tmnxSonetPathMonC2Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetPathMonC2Byte.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathMonC2Byte.setDescription('The tmnxSonetPathC2Byte variable reports the value in the SONET/SDH \n         C2 header byte.')
tmnxSonetPathMonJ1String = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetPathMonJ1String.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathMonJ1String.setDescription('The tmnxSonetPathJ1String variable reports the sonet path\n         trace string received in the J1 Path Overhead bytes.')
tmnxSonetPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ds3", 1), ("e3", 2), ("vtg", 3), ("tug-2", 4), ("tug-3", 5))).clone('ds3')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathType.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSonetPathType.setDescription('tmnxSonetPathType specifies if the associated SONET/SDH Path \n         is an asynchronous circuit, a virtual tributary group or \n         a tributary unit group.\n            ds3   - Configures the port or channel as service access(ds3)\n            e3    - Configures the port or channel as service access(e3)\n            vtg   - Configures the path as a virtual tributary group.\n            tug-2 - Configures the path as a tributary unit group.\n            tug-3 - Configures the port or channel for transport network use.')
tmnxSonetPathChildType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 6, 1, 17), TmnxMDAChanType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSonetPathChildType.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetPathChildType.setDescription('tmnxSonetPathChildType is used to configure the type of this path.\n         Some typical default values are:\n           pdhDs3 for STS-1 paths\n           pdhE3 for TU3 paths\n           pdhE1 for VT2 paths\n           pdhDs1 for VT15 paths\n         Examples of valid child path types are sonetSts3, sdhTug3,\n         pdhDs3, pdhE3, sonetVt15, sonetVt2, pdhDs1 and pdhE1.')
tmnxPortTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 7), )
if mibBuilder.loadTexts: tmnxPortTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTypeTable.setDescription('The Port type table has an entry for each Alcatel 7x50 SR series\n         port model.')
tmnxPortTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 7, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeIndex"))
if mibBuilder.loadTexts: tmnxPortTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTypeEntry.setDescription('Each row entry represents an Alcatel 7x50 SR series port model.  \n         Rows in this table are created by the agent at initialization and\n         cannot be created or destroyed by SNMP Get or Set requests.')
tmnxPortTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 7, 1, 1), TmnxPortType())
if mibBuilder.loadTexts: tmnxPortTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTypeIndex.setDescription('The unique index value which identifies this type of Alcatel 7x50\n         SR series port model.')
tmnxPortTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 7, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTypeName.setDescription('The administrative name that identifies this type of Alcatel\n         7x50 SR series port model.  This name string may be used in CLI \n         commands to specify a particular Port model type.')
tmnxPortTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 7, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTypeDescription.setDescription('A detailed description of this Alcatel 7x50 SR series port model.')
tmnxPortTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 7, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTypeStatus.setDescription("When tmnxPortTypeStatus has a value of 'true' it indicates that\n         this port model is supported in this revision of the management\n         software.  When it has a value of 'false' there is no support.")
tmnxPortConnectTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 8), )
if mibBuilder.loadTexts: tmnxPortConnectTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortConnectTypeTable.setDescription('The Port Connector type table has an entry for each Alcatel \n         7x50 SR series port connector model.')
tmnxPortConnectTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 8, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeIndex"))
if mibBuilder.loadTexts: tmnxPortConnectTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortConnectTypeEntry.setDescription('Each row entry represents an Alcatel 7x50 SR series port \n         Connector model.  Rows in this table are created by the agent \n         at initialization and cannot be created or destroyed by SNMP \n         Get or Set requests.')
tmnxPortConnectTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 8, 1, 1), TmnxPortConnectorType())
if mibBuilder.loadTexts: tmnxPortConnectTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxPortConnectTypeIndex.setDescription('The unique index value which identifies this type of Alcatel\n         7x50 SR series port connector model.')
tmnxPortConnectTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 8, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortConnectTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxPortConnectTypeName.setDescription('The administrative name that identifies this type of Alcatel\n         7x50 SR series port connector model.  This name string may be \n         used in CLI commands to specify a particular port connector \n         model type.')
tmnxPortConnectTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 8, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortConnectTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxPortConnectTypeDescription.setDescription('A detailed description of this Alcatel 7x50 SR series port \n         connector model.')
tmnxPortConnectTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 8, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortConnectTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortConnectTypeStatus.setDescription("When tmnxPortConnectTypeStatus has a value of 'true' it indicates that\n         this port connector model is supported in this revision of the \n         chassis management software.  When it has a value of 'false' there \n         is no support.")
tmnxPortFCStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9), )
if mibBuilder.loadTexts: tmnxPortFCStatsTable.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsTable.setDescription('The Network Port FC Stats table has an entry for each forwarding \n         class defined on each network port.')
tmnxPortFCStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIndex"))
if mibBuilder.loadTexts: tmnxPortFCStatsEntry.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEntry.setDescription('Each row entry represents a set of ingress and egress packet and\n         octet statistics for the given network port and forwarding class.\n         Rows in this table are created by the agent when the network port\n         is provisioned and cannot be created or destroyed by SNMP Get or\n         Set requests.')
tmnxPortFCStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 1), TFCName())
if mibBuilder.loadTexts: tmnxPortFCStatsIndex.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIndex.setDescription('The forwarding class associated with these stats\n         on this network port.')
tmnxPortFCStatsIngFwdInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdInProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdInProfPkts.setDescription('The number of in-profile packets (rate below CIR)\n         forwarded by the ingress Qchip.')
tmnxPortFCStatsIngFwdOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdOutProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdOutProfPkts.setDescription('The number of out-of-profile packets (rate above CIR)\n         forwarded by the ingress Qchip.')
tmnxPortFCStatsIngFwdInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdInProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdInProfOcts.setDescription('The number of in-profile octets (rate below CIR)\n         forwarded by the ingress Qchip.')
tmnxPortFCStatsIngFwdOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdOutProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngFwdOutProfOcts.setDescription('The number of out-of-profile octets (rate above CIR)\n         forwarded by the ingress Qchip.')
tmnxPortFCStatsIngDroInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroInProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroInProfPkts.setDescription('The number of in-profile packets (rate below CIR)\n         dropped by the ingress Qchip due to: MBS exceeded,\n         buffer pool limit exceeded, etc.')
tmnxPortFCStatsIngDroOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroOutProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroOutProfPkts.setDescription('The number of out-of-profile packets (rate above CIR)\n         dropped by the ingress Qchip due to: MBS exceeded, \n         buffer pool limit exceeded, etc.')
tmnxPortFCStatsIngDroInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroInProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroInProfOcts.setDescription('The number of in-profile octets (rate below CIR)\n         dropped by the ingress Qchip due to: MBS exceeded,\n         buffer pool limit exceeded, etc.')
tmnxPortFCStatsIngDroOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroOutProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsIngDroOutProfOcts.setDescription('The number of out-of-profile octets (rate above CIR)\n         dropped by the ingress Qchip due to: MBS exceeded,\n         buffer pool limit exceeded, etc.')
tmnxPortFCStatsEgrFwdInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdInProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdInProfPkts.setDescription('The number of in-profile packets (rate below CIR)\n         forwarded by the egress Qchip.')
tmnxPortFCStatsEgrFwdOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdOutProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdOutProfPkts.setDescription('The number of out-of-profile packets (rate above CIR)\n         forwarded by the egress Qchip.')
tmnxPortFCStatsEgrFwdInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdInProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdInProfOcts.setDescription('The number of in-profile octets (rate below CIR)\n         forwarded by the egress Qchip.')
tmnxPortFCStatsEgrFwdOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdOutProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrFwdOutProfOcts.setDescription('The number of out-of-profile octets (rate above CIR)\n         forwarded by the egress Qchip.')
tmnxPortFCStatsEgrDroInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroInProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroInProfPkts.setDescription('The number of in-profile packets (rate below CIR)\n         dropped by the egress Qchip due to: MBS exceeded,\n         buffer pool limit exceeded, etc.')
tmnxPortFCStatsEgrDroOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroOutProfPkts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroOutProfPkts.setDescription('The number of out-of-profile packets (rate above CIR)\n         dropped by the egress Qchip due to: MBS exceeded, \n         buffer pool limit exceeded, etc.')
tmnxPortFCStatsEgrDroInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroInProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroInProfOcts.setDescription('The number of in-profile octets (rate below CIR)\n         dropped by the egress Qchip due to: MBS exceeded,\n         buffer pool limit exceeded, etc.')
tmnxPortFCStatsEgrDroOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 9, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroOutProfOcts.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortFCStatsEgrDroOutProfOcts.setDescription('The number of out-of-profile octets (rate above CIR)\n         dropped by the egress Qchip due to: MBS exceeded,\n         buffer pool limit exceeded, etc.')
tmnxDS3Table = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 10), )
if mibBuilder.loadTexts: tmnxDS3Table.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3Table.setDescription('The tmnxDS3Table has an entry for a DS3 physical port.')
tmnxDS3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 10, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxDS3Entry.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3Entry.setDescription("Each row entry represents a physical DS3 port on a \n         IOM card in a chassis in the system.  Entries cannot be created \n         and deleted via SNMP SET operations.  Entries in this table will \n         be created automatically when the tmnxMDAAssignedType object is \n         set to the DS3 MDA type The tmnxDS3Entry contains attributes that are \n         unique to the 'ds3e3' TmnxPortType. The tmnxPortPortID contains\n         the slot, mda and port numbers encoded into it.\n\n         For each tmnxDS3Entry, there will be a corresponding entry \n         in the tmnxPortTable and the ifTable.")
tmnxDS3Buildout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("short", 1), ("long", 2))).clone('short')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3Buildout.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3Buildout.setDescription('tmnxDS3Buildout configures the T3 line buildout. A T3 port has two \n         settings for the T3 line buildout: a short setting, which is less \n         than 225 feet, and a long setting, which is greater than 225 feet. \n         This object applies to copper-cable-based T3 ports only.')
tmnxDS3LastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 10, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3LastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3LastChangeTime.setDescription('The tmnxDS3LastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxDS3Entry row for this port.')
tmnxDS3Type = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds3", 1), ("e3", 2))).clone('ds3')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3Type.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3Type.setDescription("tmnxDS3Type configures the type of the physical port to 'ds3' or 'e3'.")
tmnxDS3ChannelTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11), )
if mibBuilder.loadTexts: tmnxDS3ChannelTable.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelTable.setDescription('The tmnxDS3ChannelTable has an entry for a DS3 channel.')
tmnxDS3ChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxDS3ChannelEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelEntry.setDescription('Each row entry represents a DS3 channel. Entries can be created \n         and deleted via SNMP SET operations.  The tmnxDS3ChannelEntry \n         contains attributes that are applicable to a DS3 channel which\n         can belong to the DS3 physical port or belong to a container \n         on a sonet path. The tmnxPortPortID contains the slot, mda and \n         port numbers encoded into it.\n\n         For each tmnxDS3ChannelEntry, there will be a corresponding entry \n         in the tmnxPortTable and the ifTable.')
tmnxDS3ChannelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelRowStatus.setDescription('tmnxDS3ChannelRowStatus controls the creation and deletion of\n         row entries in the tmnxDS3ChannelTable.\n         For row creation, the manager has to first calculate the \n         tmnxPortPortID based on the TiMOS encoding scheme.')
tmnxDS3ChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds3", 1), ("e3", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelType.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelType.setDescription('The value of tmnxDS3ChannelType indicates whether the channel is\n         in DS3 or E3 mode.')
tmnxDS3ChannelFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cbit", 1), ("m23", 2), ("g751", 3), ("g832", 4))).clone('cbit')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelFraming.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelFraming.setDescription("The value of tmnxDS3ChannelFraming indicates the type of framing \n         associated with the DS3 channel.\n         If tmnxDS3ChannelType is set to 'ds3', the default framing is 'cbit'.\n         If tmnxDS3ChannelType is set to 'e3', the default framing is 'g751'.")
tmnxDS3ChannelClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 4), TmnxDSXClockSource().clone('loopTimed')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelClockSource.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelClockSource.setDescription("tmnxDS3ChannelClockSource configures the clock for transmitted data \n         from either the internal clock ('nodeTimed'), or from a clock\n         recovered from the line's receive data stream ('loopTimed').")
tmnxDS3ChannelChannelized = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("ds1", 2), ("e1", 3), ("j1", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelChannelized.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelChannelized.setDescription("tmnxDS3ChannelChannelized is used to create sub-channels of type\n         'ds1' or 'e1' or 'j1' on the interface. Setting the value to 'none'\n         removes the sub-channels on the interface.")
tmnxDS3ChannelSubrateCSUMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notUsed", 0), ("digital-link", 1))).clone('notUsed')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelSubrateCSUMode.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelSubrateCSUMode.setDescription("tmnxDS3ChannelSubrateCSUMode configures the channel service unit (CSU)\n         compatibility mode to interoperate with existing DS3 subrate \n         standards. \n         This configuration applies only for a non-channelized DS3.\n         \n         Changing the value of tmnxDS3ChannelSubrateCSUMode to notUsed resets\n         the value of tmnxDS3ChannelScramble to 'false'. \n         \n         Changing the value of tmnxDS3ChannelSubrateCSUMode \n         resets the value of tmnxDS3ChannelSubrate to default for the mode if\n         tmnxDS3ChannelSubrate is not provided.")
tmnxDS3ChannelSubrate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelSubrate.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelSubrate.setDescription('tmnxDS3ChannelSubrate configures the subrate step. \n\n         tmnxDS3ChannelSubrate multiplied by the granularity for a \n         particular mode as defined by tmnxDS3ChannelSubrateCSUMode gives \n         the absoulte subrate in kbps.\n\n         -----------------------------------------------------------------------\n          Subrate CSU Mode|Granularity|Default |Range     |Subrate speed range\n         ----------------------------------------------------------`-------------\n          notUsed         | N/A       | 0      | 0        |N/A\n          digital-link    | 301 kbps  | 1      | 1 to 147 |301 kbps to 44.2 mbps\n         -----------------------------------------------------------------------')
tmnxDS3ChannelIdleCycleFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 8), TmnxDSXIdleCycleFlags().clone('flags')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelIdleCycleFlags.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelIdleCycleFlags.setDescription("tmnxDS3ChannelIdleCycleFlags configures the value that the \n         DS3 port transmits during idle cycle.\n \n         The default value applies to HDLC channels only. For ATM\n         channels the object does not really apply so a default value\n         of 'none' is used and cannot be changed.")
tmnxDS3ChannelLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 9), TmnxDS3Loopback().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelLoopback.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelLoopback.setDescription("tmnxDS3ChannelLoopback is used to put the channel into a loopback mode.\n         The value of tmnxPortAdminStatus should be set to 'outOfService' \n         in order for the loopback to be enabled.\n         A 'line' loopback loops frames received on this port back to the \n         remote system.\n         A 'internal' loopback loops the frames from the local system back at\n         the framer.\n         When the value is set to 'remote', a signal is sent to the remote \n         system to provide a line loopback.")
tmnxDS3ChannelBitErrorInsertionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 7), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelBitErrorInsertionRate.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelBitErrorInsertionRate.setDescription('tmnxDS3ChannelBitErrorInsertionRate is used to insert bit errors for a \n         BERT test. The number of error corresponds to 10^(-rate). A rate of 7\n         will cause an error rate of 10^(-7), or 1 error in every 10\n         million bits transmitted.\n         If the value is set to 0, it disables the insertion of bit errors \n         into the BERT.\n         Change in this value while the test is running is accepted but\n         does not take effect until the test gets restarted.')
tmnxDS3ChannelBERTPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 11), TmnxDSXBertPattern().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelBERTPattern.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelBERTPattern.setDescription("tmnxDS3ChannelBERTPattern indicates the pattern used for the \n         Bit Error Rate Test (BERT). The value of tmnxDS3ChannelBERTDuration\n         indicates the duration of the test.\n         Setting the value of this object to 'none' terminates the test.")
tmnxDS3ChannelBERTDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelBERTDuration.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelBERTDuration.setDescription('tmnxDS3ChannelBERTDuration is used to set the duration of the \n         BERT test.')
tmnxDS3ChannelMDLEicString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLEicString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLEicString.setDescription('tmnxDS3ChannelMDLEicString configures the Equipment ID Code(EIC) of the \n         Message Data Link (MDL).')
tmnxDS3ChannelMDLLicString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLLicString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLLicString.setDescription('tmnxDS3ChannelMDLLicString configures the Location ID Code(LIC) of the \n         Message Data Link (MDL).')
tmnxDS3ChannelMDLFicString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLFicString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLFicString.setDescription('tmnxDS3ChannelMDLFicString configures the Frame ID Code(FIC) of the \n         Message Data Link (MDL).')
tmnxDS3ChannelMDLUnitString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLUnitString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLUnitString.setDescription('tmnxDS3ChannelMDLUnitString configures the Unit ID Code(UIC) of the \n         Message Data Link (MDL).')
tmnxDS3ChannelMDLPfiString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 38))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLPfiString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLPfiString.setDescription('tmnxDS3ChannelMDLPfiString configures the Facility ID Code sent in\n         the Message Data Link (MDL) Path message.')
tmnxDS3ChannelMDLPortString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 38))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLPortString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLPortString.setDescription('tmnxDS3ChannelMDLPortString configures the port number string sent in\n         the Message Data Link (MDL) idle signal message.')
tmnxDS3ChannelMDLGenString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 38))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLGenString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLGenString.setDescription('tmnxDS3ChannelMDLGenString configures the generator number string \n         sent in the Message Data Link (MDL) test signal message.')
tmnxDS3ChannelMDLMessageType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 20), Bits().clone(namedValues=NamedValues(("none", 0), ("ds3Path", 1), ("idleSignal", 2), ("testSignal", 3))).clone(namedValues=NamedValues(("none", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLMessageType.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLMessageType.setDescription("tmnxDS3ChannelMDLMessageType configures the type of MDL message that\n         is transmitted over the DS3 interface. If the value of this object is\n         set to 'none', MDL messages are not transmitted.\n         ds3Path(0)   - Enables transmission of the MDL path message.\n                        An MDL path message, as defined by ANSI T1.107, is\n                        distinguished from idle and test signal messages in \n                        that it contains a facility identification code as its \n                        final data element.\n        idleSignal(1) - Enables transmission of the MDL idle signal message.\n                        An MDL idle signal message, as defined by ANSI T1.107,\n                        is distinguished from path and test signal messages in\n                        that it contains a port number as its final data \n                        element.\n        testSignal(2) - Enables transmission of the MDL test signal message.\n                        An MDL test signal message, as defined by ANSI T1.107, \n                        is distinguished from path and idle signal messages in \n                        that it contains a generator number as its final data \n                        element.")
tmnxDS3ChannelFEACLoopRespond = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 21), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelFEACLoopRespond.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelFEACLoopRespond.setDescription("When tmnxDS3ChannelFEACLoopRespond has a value of 'true', the channel \n        is enabled to respond to remote loop signals.  When it has \n        a value of 'false' the port will not respond.")
tmnxDS3ChannelCRC = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16", 1), ("crc32", 2))).clone('crc16')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelCRC.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelCRC.setDescription("The value of tmnxDS3ChannelCRC variable indicates the precision of\n         the cyclic redundancy check.  A value of 'crc16' is a 16-bit\n         CRC calculation.  A value of 'crc32' is a 32-bit CRC\n         calculation.  32-bit CRC increases the error detection ability,\n         but it also adds some performance overhead.\n\n         For ATM channels, crc32 is the default and the only value supported\n         and applies to AAL5 CRC calculation on that channel.")
tmnxDS3ChannelMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 23), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 9208), ))).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMTU.setDescription('The size of the largest packet which can be sent/received\n         on the port, specified in octets.  For ports that\n         are used for transmitting network datagrams, this is the\n         size of the largest network datagram that can be sent on the\n         sonet path.\n            \n         Setting tmnxDS3ChannelMTU to a value of zero (0), causes the agent \n         to recalculate the default MTU size which can vary based on the \n         current setting of tmnxPortMode and tmnxPortEncapType variables.  \n         Some typical default values are:\n                1522 with mode access and encap-type bcp-null\n                1526 with mode access and encap-type bcp-dot1q\n                1502 with mode access and encap-type ipcp\n                4474 with mode access and encap-type frame-relay\n                1524 with mode access and encap-type atm\n                2092 with mode access and encap-type cem\n        ')
tmnxDS3ChannelOperMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 24), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelOperMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelOperMTU.setDescription('The negotiated size of the largest packet which can be sent on \n         the channel, specified in octets.  For channels that are used \n         for transmitting network datagrams, this is the size of the largest\n         network datagram that can be sent.')
tmnxDS3ChannelReportAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 25), TmnxDSXReportAlarm().clone(namedValues=NamedValues(("ais", 1), ("los", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelReportAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelReportAlarm.setDescription('The value of tmnxDS3ChannelReportAlarm determines when and if to\n         generate notifications for this channel:\n         ais - Reports alarm indication signal errors. \n               ais alarms are issued by default.\n         los - Reports loss of signal errors.\n               los alarms are issued by default.\n         oof - Reports out-of-frame errors. \n               oof alarms are not issued by default.\n         rai - Reports resource availability indicator events. \n               rai alarms are not issued by default.\n         looped - Reports if the far end has forced the near end to loopback.\n               looped alarms are not issued by default.\n         berSd - Reports DS3/E3 signal degradation bit errors.\n                 berSd alarms are not issued by default.\n         berSf - Reports DS3/E3 signal failure bit errors.\n                 berSf alarms are not issued by default')
tmnxDS3ChannelReportAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 26), TmnxDSXReportAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelReportAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelReportAlarmStatus.setDescription('The value of tmnxDS3ChannelReportAlarmStatus indicates the current \n         alarms on this port.')
tmnxDS3ChannelLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 27), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelLastChangeTime.setDescription('The tmnxDS3ChannelLastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxDS3ChannelEntry row for this port.')
tmnxDS3ChannelInFEACLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 28), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelInFEACLoop.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelInFEACLoop.setDescription('tmnxDS3ChannelInFEACLoop indicates whether the remote end has put \n         this channel in FEAC(Far End Alarm Control) loopback.')
tmnxDS3ChannelMDLMonPortString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 38))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLMonPortString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLMonPortString.setDescription('tmnxDS3ChannelMDLMonPortString indicates the port number string \n         received in the Message Data Link (MDL) idle signal message.')
tmnxDS3ChannelMDLMonGenString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 38))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelMDLMonGenString.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelMDLMonGenString.setDescription('tmnxDS3ChannelMDLMonGenString indicates the generator number string \n         received in the Message Data Link (MDL) test signal message.')
tmnxDS3ChannelBERTOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 31), TmnxDSXBertOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelBERTOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelBERTOperStatus.setDescription('tmnxDS3ChannelBERTOperStatus indicates the status of the BERT test\n         as specified by TmnxDSXBertOperStatus.')
tmnxDS3ChannelBERTSynched = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 32), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelBERTSynched.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelBERTSynched.setDescription("tmnxDS3ChannelBERTSynched is the number of seconds for which the \n         BERT hardware was synchronized. This will be less than or equal to \n         the duration of the last BERT test. It is valid only after \n         tmnxDS3ChannelBERTOperStatus transitioned from 'active' to 'idle'\n         the last time BERT was activated.")
tmnxDS3ChannelBERTErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelBERTErrors.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelBERTErrors.setDescription("tmnxDS3ChannelBERTErrors is the number of bit errors detected during \n         the last BERT test. It is valid only after tmnxDS3ChannelBERTOperStatus\n         transitioned from 'active' to 'idle' the last time BERT \n         was activated.")
tmnxDS3ChannelBERTTotalBits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 34), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelBERTTotalBits.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelBERTTotalBits.setDescription("tmnxDS3ChannelBERTTotalBits is the total number of bits received \n         during the last BERT test. Bits are only counted when the BERT \n         hardware is synchronized. It is valid only after \n         tmnxDS3ChannelBERTOperStatus transitioned from 'active' to 'idle'\n         the last time BERT was activated.")
tmnxDS3ChannelScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 35), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelScramble.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelScramble.setDescription("When tmnxDS3ChannelScramble indicates whether scrambling\n         is enabled on this channel.  Both ends of the connection\n         must use the same scrambling algorithm.  The default value\n         is 'true' if the tmnxPortEncapType is atmEncap for this\n         channel and indicates ATM payload scrambling; otherwise \n         (tmnxPortEncapType is not atmEncap) the default is 'false'\n         and can only be changed to true if the value of \n         tmnxDS3ChannelSubrateCSUMode is digital-link (1)")
tmnxDS3ChannelAcctPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelAcctPolicyId.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelAcctPolicyId.setDescription('The value of tmnxDS3ChannelAcctPolicyId specifies an existing accounting \n         policy to use for the ds3 channel. Accounting policies can only be \n         associated with network ports or channels.\n\n         A non-zero value indicates the tmnxLogApPolicyId index identifying the\n         policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is\n         associated with this channel.  A zero value indicates that there is no\n         accounting policy associated with this channel')
tmnxDS3ChannelCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 37), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS3ChannelCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelCollectStats.setDescription('The value of tmnxDS3ChannelCollectStats specifies whether or not the \n         collection of accounting and statistical data for the network ds3 \n         channel is collected.\n\n         When the value is set to false, the statistics are still accumulated \n         by the IOM cards, however, the CPM will not obtain the results and\n         write them to the billing file.\n\n         When applying accounting policies the data by default will be collected \n         in the appropriate records and written to the designated billing file.')
tmnxDS3ChannelClockSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 38), TmnxDSXClockSyncState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelClockSyncState.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelClockSyncState.setDescription("The value of tmnxDS3ChannelClockSyncState indicates the current clock\n         synchronization state if tmnxDS3ChannelClockSource is 'adaptive' or\n         'differential'.")
tmnxDS3ChannelClockMasterPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 11, 1, 39), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS3ChannelClockMasterPortId.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3ChannelClockMasterPortId.setDescription("The value of tmnxDS3ChannelClockMasterPortId indicates the current\n         clock synchronization master port id if tmnxDS3ChannelClockSource\n         is 'adaptive' or 'differential'.")
tmnxDS1Table = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12), )
if mibBuilder.loadTexts: tmnxDS1Table.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1Table.setDescription('The tmnxDS1Table has an entry for each DS1 channel.')
tmnxDS1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxDS1Entry.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1Entry.setDescription("Each row entry represents a DS1 channel on a IOM card \n         in a chassis in the system.  DS1 channel entries for DS3\n         ports cannot be created and deleted via SNMP SET operations.\n         Entries in this table will be created automatically when\n         tmnxDS3ChannelChannelized is set to 'true'. DS1 channel entries\n         for DS1 ports can be created and deleted via SNMP SET operations.\n         For each tmnxDS1Entry, there will be a corresponding entry \n         in the tmnxPortTable and the ifTable.")
tmnxDS1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1RowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1RowStatus.setDescription('tmnxDS1RowStatus controls the creation and deletion of\n         row entries in the tmnxDS1Table.\n         For row creation, the manager has to first calculate the \n         tmnxPortPortID based on the TiMOS encoding scheme.')
tmnxDS1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ds1", 1), ("e1", 2), ("j1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1Type.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1Type.setDescription('The value of tmnxDS1Type indicates whether the DS1 channel is\n         in DS1, E1 or J1 mode.')
tmnxDS1Framing = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("esf", 1), ("sf", 2), ("g704-no-crc", 3), ("g704", 4), ("e1-unframed", 5), ("ds1-unframed", 6))).clone('esf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1Framing.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1Framing.setDescription("The value of tmnxDS1Framing indicates the type of framing associated\n         with the channel:\n         esf            ESF (extended super frame) mode for T1 interfaces.\n         sf             SF (super frame) mode for T1 interfaces.\n         g704           G.704 framing format for E1 interfaces.\n         g704-no-crc4   G.704 framing with no CRC4 for E1 interfaces.\n         e1-unframed    E1 Unframed (G.703) mode for E1 interfaces.\n         ds1-unframed   Unframed mode for T1 interfaces.\n\n         If tmnxDS1Type is set to 'ds1', the default framing is 'esf'.\n         If tmnxDS1Type is set to 'e1', the default framing is 'g704'. \n         \n         Changing the value of tmnxDS1Framing resets the values of\n         tmnxDS1BerSdThreshold and tmnxDS1BerSfThreshold to defaults\n         and turns off reporting of berSd and berSf alarms \n         in tmnxDS1ReportAlarm.")
tmnxDS1IdleCycleFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 4), TmnxDSXIdleCycleFlags().clone('flags')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1IdleCycleFlags.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxDS1IdleCycleFlags.setDescription('tmnxDS1IdleCycleFlags configures the value that the DS1 \n         channel transmits during idle cycle.')
tmnxDS1Loopback = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 5), TmnxDS1Loopback().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1Loopback.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1Loopback.setDescription("tmnxDS1Loopback is used to put the channel into a loopback mode. The \n         value of tmnxPortAdminStatus should be set to 'outOfService' in order\n         for the loopback to be enabled.\n         A 'line' loopback loops frames received on this port back to the \n         remote system.\n         A 'internal' loopback loops frames from the local system back at\n         the framer.        \n         A 'fdlAnsi' requests loopback of type FDL ANSI T1.403. This is valid\n         with tmnxDS1Framing set to 'esf' framing.\n         A 'fdlBellcore' requests loopback of type FDL Bellcore TR-TSY-000312.\n         This is valid with tmnxDS1Framing set to 'esf'.\n         A 'inbandAnsi' requests loopback of type inband ANSI T1.403. This is \n         valid with tmnxDS1Framing set to 'sf'.")
tmnxDS1InvertData = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1InvertData.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1InvertData.setDescription("Setting tmnxDS1InvertData to 'true' causes all data bits to \n         be inverted, to guarantee ones density. It is typically used with\n         AMI line encoding.")
tmnxDS1BitErrorInsertionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 7), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1BitErrorInsertionRate.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BitErrorInsertionRate.setDescription('tmnxDS1BitErrorInsertionRate is used to insert bit errors for a \n         BERT test. The number of error corresponds to 10^(-rate). A rate of 7\n         will cause an error rate of 10^(-7), or 1 error in every 10\n         million bits transmitted.\n         If the value is set to 0, disables the insertion of bit errors into \n         the BERT.\n         Change in this value while the test is running is accepted but\n         does not take effect until the test gets restarted.')
tmnxDS1BERTPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 8), TmnxDSXBertPattern().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1BERTPattern.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BERTPattern.setDescription("tmnxDS1BERTPattern object indicates the pattern used for the \n         Bit Error Rate Test (BERT). The value of tmnxDS1BERTDuration\n         indicates the duration of the test.\n         Setting the value to 'none' terminates the test.")
tmnxDS1BERTDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1BERTDuration.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BERTDuration.setDescription('tmnxDS1BERTDuration is used to set the duration of the BERT test.')
tmnxDS1ReportAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 10), TmnxDSXReportAlarm().clone(namedValues=NamedValues(("ais", 1), ("los", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1ReportAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1ReportAlarm.setDescription('The value of tmnxDS1ReportAlarm determines when and if to\n         generate notifications for this channel:\n         ais - Reports alarm indication signal errors. \n               ais alarms are issued by default.\n         los - Reports loss of signal errors.\n               los alarms are issued by default.\n         oof - Reports out-of-frame errors.\n               oof alarms are not issued by default.\n         rai - Reports resource availability indicator events. \n               rai alarms are not issued by default.\n         looped - Reports if the far end has forced the near end to loopback.\n               looped alarms are not issued by default.\n         berSd - Reports DS1/E1/J1 signal degradation bit errors.\n                 berSd alarms are not issued by default.\n         berSf - Reports DS1/E1/J1 signal failure bit errors.\n                 berSf alarms are not issued by default')
tmnxDS1ReportAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 11), TmnxDSXReportAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1ReportAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1ReportAlarmStatus.setDescription('The value of tmnxDS1ReportAlarmStatus indicates the current alarms\n         on this channel.')
tmnxDS1LastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1LastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1LastChangeTime.setDescription('The tmnxDS1LastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxDS1Entry row for this channel.')
tmnxDS1ClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 13), TmnxDSXClockSource().clone('loopTimed')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1ClockSource.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1ClockSource.setDescription("tmnxDS1ClockSource configures the clock for transmitted data from\n         either the internal clock ('nodeTimed'), or from a clock recovered\n         from the line's receive data stream ('loopTimed'), or recovered\n         adaptively from the rate at which the data that is received and not\n         from the physical layer ('adaptive'), or recovered from the\n         differential timestamp in the RTP header ('differential').")
tmnxDS1BERTOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 14), TmnxDSXBertOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1BERTOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BERTOperStatus.setDescription('tmnxDS1BERTOperStatus indicates the status of the BERT test as \n         specified by TmnxDSXBertOperStatus.')
tmnxDS1BERTSynched = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 15), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1BERTSynched.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BERTSynched.setDescription("tmnxDS1BERTSynched is the number of seconds for which the \n         BERT hardware was synchronized. This will be less than or equal to \n         the duration of the last BERT test. It is valid only after \n         tmnxDS1BERTOperStatus transitioned from 'active' to 'idle'\n         the last time BERT was activated.")
tmnxDS1BERTErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1BERTErrors.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BERTErrors.setDescription("tmnxDS1BERTErrors is the number of bit errors detected during \n         the last BERT test. It is valid only after tmnxDS1BERTOperStatus\n         transitioned from 'active' to 'idle' the last time BERT \n         was activated.")
tmnxDS1BERTTotalBits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1BERTTotalBits.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BERTTotalBits.setDescription("tmnxDS1BERTTotalBits is the total number of bits received \n         during the last BERT test. Bits are only counted when the BERT \n         hardware is synchronized. It is valid only after \n         tmnxDS1BERTOperStatus transitioned from 'active' to 'idle'\n         the last time BERT was activated.")
tmnxDS1RemoteLoopRespond = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1RemoteLoopRespond.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1RemoteLoopRespond.setDescription("When tmnxDS1RemoteLoopRespond has a value of 'true', the channel \n        is enabled to respond to remote loop signals.  When it has \n        a value of 'false' the port will not respond.")
tmnxDS1InRemoteLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1InRemoteLoop.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1InRemoteLoop.setDescription('tmnxDS1InRemoteLoop indicates whether the remote end has put \n         this channel in remote loopback.')
tmnxDS1InsertSingleBitError = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 20), TmnxActionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1InsertSingleBitError.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1InsertSingleBitError.setDescription('tmnxDS1InsertSingleBitError is used to insert a single bit error for a\n         BERT test.')
tmnxDS1SignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("cas", 2))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1SignalMode.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1SignalMode.setDescription("The value of tmnxDS1SignalMode indicates the type of signalling\n         associated with the channel:\n         none  - Indicates no signalling on this channel.\n         cas   - Indicates Channel Associated Signalling (CAS) on this channel.\n         The default signalling is 'none'. ")
tmnxDS1ClockSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 22), TmnxDSXClockSyncState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1ClockSyncState.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1ClockSyncState.setDescription("The value of tmnxDS1ClockSyncState indicates the current clock\n         synchronization state if tmnxDS1ClockSource is 'adaptive' or\n         'differential'.")
tmnxDS1ClockMasterPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 23), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1ClockMasterPortId.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1ClockMasterPortId.setDescription("The value of tmnxDS1ClockMasterPortId indicates the current clock\n         synchronization master port id if tmnxDS1ClockSource is 'adaptive'\n         or 'differential'.")
tmnxDS1BerSdThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 24), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(50, 50), ValueRangeConstraint(100, 100), )).clone(5)).setUnits('error bits in million bits received').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1BerSdThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BerSdThreshold.setDescription('The value of tmnxDS1BerSdThreshold specifies a bit error rate (BER)\n         threshold used to determine when to send a tmnxEqPortDS1Alarm \n         notification for a BER SD failure and a tmnxEqPortDS1AlarmClear\n         notification for a BER SD failure clear. Bit error computed must \n         reach/exceed threshold value over a pre-defined period of time\n         for the tmnxEqPortSonetAlarm notification to be sent.\n         \n         The value of tmnxDS1Framing defines how the bit error is\n         computed and what values of tmnxDS1BerSdThreshold are allowed.\n         The following table defines this dependency:\n\n         tmnxDS1Framing   Bit error calculation and value supported\n         --------------   -----------------------------------------\n           esf  (1)       each CRC error is counted as one bit error\n           g704 (4)       values supported are 1,5,10,50,100\n            \n           other values   bit error alarms not supported, value\n                          of tmnxDS1BerSdThreshold set to default and \n                          cannot be changed\n         \n         tmnxDS1BerSdThreshold value must not exceed the value of\n         tmnxDS1BerSfThreshold.')
tmnxDS1BerSfThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 12, 1, 25), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(50, 50), ValueRangeConstraint(100, 100), )).clone(50)).setUnits('error bits in million bits received').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1BerSfThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1BerSfThreshold.setDescription('The value of tmnxDS1BerSfThreshold specifies a bit error rate (BER)\n         threshold used to determine when to send a tmnxEqPortDS1Alarm \n         notification for a BER SF failure and a tmnxEqPortDS1AlarmClear\n         notification for a BER SF failure clear. Bit error computed must \n         reach/exceed threshold value over a pre-defined period of time\n         for the tmnxEqPortSonetAlarm notification to be sent.\n         \n         The value of tmnxDS1Framing defines how the bit errors are\n         computed and what values of tmnxDS1BerSfThreshold are allowed.\n         The following table defines this dependency:\n\n         tmnxDS1Framing   Bit error calculation and value supported\n         --------------   -----------------------------------------\n           esf  (1)       each CRC error is counted as one bit error\n           g704 (4)       values supported are 1,5,10,50,100\n            \n           other values   bit error alarms not supported, value\n                          of tmnxDS1BerSfThreshold set to default and \n                          cannot be changed\n        \n         tmnxDS1BerSfThreshold value must not be smaller than \n         tmnxDS1BerSdThreshold value')
tmnxDS0ChanGroupTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13), )
if mibBuilder.loadTexts: tmnxDS0ChanGroupTable.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupTable.setDescription('The tmnxDS0ChanGroupTable has an entry for DS0 channels \n         grouped together and belonging to a particular DS1 channel.')
tmnxDS0ChanGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxDS0ChanGroupEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupEntry.setDescription('Each row entry represents one or more DS0 channels on a \n         DS1 interface.  tmnxDS0ChanGroupTimeSlots object is used to add or\n         remove DS0 channels from the group.\n         \n         Entries can be created and deleted via SNMP SET operations \n         using the tmnxDS0ChanGroupRowStatus object. \n\n         For each tmnxDS0ChanGroupEntry, there will be a corresponding entry \n         in the tmnxPortTable and the ifTable.')
tmnxDS0ChanGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupRowStatus.setDescription('tmnxDS0ChanGroupRowStatus controls the creation and deletion of\n         row entries in the tmnxDS0ChanGroupTable. The tmnxPortPortID \n         for a channel group includes a group ID in the lower bits.\n         The manager has to first calculate the tmnxPortPortID based on the\n         TiMOS encoding scheme.')
tmnxDS0ChanGroupTimeSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 2), TmnxDs0ChannelList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupTimeSlots.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupTimeSlots.setDescription("tmnxDS0ChanGroupTimeSlots is a bitmap which is used to \n         add/remove DS0 timeslots from a channel group. \n         The description for TmnxDs0ChannelList contains details of the\n         bitmap organization.\n\n         When a channel group is created on unframed DS1/E1, all timeslots\n         as applicable to a given speed are auto-allocated and cannot be \n         changed.\n\n         When a channel group is created on a framed DS1/E1 or\n         existing channel group's encapsulation is changed from ATM,\n         the default of no timeslots is auto-assigned to the group.\n\n         When a channel group  on a framed DS1/E1 is configured for \n         ATM encapsulation, the ATM defaults of 0x00FFFFFF (DS1) \n         and 0XFFFEFFFE (E1) are auto-assigned and cannot be changed.")
tmnxDS0ChanGroupSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("speed-56", 1), ("speed-64", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupSpeed.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupSpeed.setDescription('tmnxDS0ChanGroupSpeed configures the required link speed \n         for all the time slots included in this channel group.')
tmnxDS0ChanGroupCRC = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16", 1), ("crc32", 2))).clone('crc16')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupCRC.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupCRC.setDescription("The value of tmnxDS0ChanGroupCRC variable indicates the precision of\n         the cyclic redundancy check.  A value of 'crc16' is a 16-bit\n         CRC calculation.  A value of 'crc32' is a 32-bit CRC\n         calculation.  32-bit CRC increases the error detection ability,\n         but it also adds some performance overhead.\n\n         For channel groups with encapsulation set to ATM, the default and\n         only supported value is crc32 and applies to AAL5 CRC calculations\n         on that channel group.")
tmnxDS0ChanGroupMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 9208), ))).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupMTU.setDescription('The size of the largest packet which can be sent/received\n         on the channel group, specified in octets.  For groups that\n         are used for transmitting network datagrams, this is the\n         size of the largest network datagram that can be sent.\n            \n         Setting tmnxDS0ChanGroupMTU to a value of zero (0), causes the agent \n         to recalculate the default MTU size which can vary based on the \n         current setting of tmnxPortMode and tmnxPortEncapType variables.  \n         Some typical default values are:\n                1522 with mode access and encap-type bcp-null\n                1526 with mode access and encap-type bcp-dot1q\n                1502 with mode access and encap-type ipcp\n                4474 with mode access and encap-type frame-relay\n                1524 with mode access and encap-type atm\n                2092 with mode access and encap-type cem\n        ')
tmnxDS0ChanGroupOperMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 6), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS0ChanGroupOperMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupOperMTU.setDescription('The negotiated size of the largest packet which can be sent on \n         the channel group, specified in octets.  For channel groups that \n         are used for transmitting network datagrams, this is the size of \n         the largest network datagram that can be sent.')
tmnxDS0ChanGroupLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS0ChanGroupLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupLastChangeTime.setDescription('The tmnxDS0ChanGroupLastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxDS0ChanGroupEntry row for this channel group.')
tmnxDS0ChanGroupIdleCycleFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 8), TmnxDSXIdleCycleFlags().clone('flags')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupIdleCycleFlags.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupIdleCycleFlags.setDescription("tmnxDS0ChanGroupIdleCycleFlags configures the value that the\n         channel group transmits during idle cycle.\n \n         The default value applies to HDLC channels only. For ATM and CEM\n         channels the object does not really apply so a default value of\n         'none' is used and cannot be changed.")
tmnxDS0ChanGroupScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 9), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupScramble.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupScramble.setDescription("tmnxDS0ChanGroupScramble indicates whether payload scrambling\n         is enabled on this ATM channel.  Both ends of the connection\n         must use the same scrambling algorithm.  The default value\n         is 'true' if the tmnxPortEncapType is atmEncap for this\n         channel, otherwise the default is 'false' and not allowed to \n         change.")
tmnxDS0ChanGroupAcctPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupAcctPolicyId.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupAcctPolicyId.setDescription('The value of tmnxDS0ChanGroupAcctPolicyId specifies an existing accounting \n         policy to use for the ds0 channel-group. Accounting policies can only \n         be associated with network ports or channels.\n\n         A non-zero value indicates the tmnxLogApPolicyId index identifying the\n         policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is\n         associated with this channel-group.  A zero value indicates that there is \n         no accounting policy associated with this channel')
tmnxDS0ChanGroupCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 11), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupCollectStats.setDescription('The value of tmnxDS0ChanGroupCollectStats specifies whether or not the \n         collection of accounting and statistical data for the network ds0 \n         channel-group is collected.\n\n         When the value is set to false, the statistics are still accumulated \n         by the IOM cards, however, the CPM will not obtain the results and\n         write them to the billing file.\n\n         When applying accounting policies the data by default will be collected \n         in the appropriate records and written to the designated billing file.')
tmnxDS0ChanGroupPayloadFillType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 12), TmnxDSXIdleFillType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupPayloadFillType.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupPayloadFillType.setDescription("The value of tmnxDS0ChanGroupPayloadFillType specifies the type of\n         idle payload fill to be sent when the CEM channel group experiences\n         an underrun.\n\n         If the type is set to 'userDefinedPattern' then the value of\n         tmnxDS0ChanGroupPayloadPattern is used to define the payload pattern.\n\n         The default value depends on the encap type of the channel group:\n         For CEM encap           - 'allOnes'\n         For all other encaps    - 'notApplicable'\n         \n         For a ds1-unframed and e1-unframed CEM encap DS0 channel group the\n         only supported value is 'allOnes'.\n\n         For non-CEM encap channel groups the value cannot be changed.")
tmnxDS0ChanGroupPayloadPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupPayloadPattern.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupPayloadPattern.setDescription("The value of tmnxDS0ChanGroupPayloadPattern specifies the idle payload\n         fill pattern when the CEM channel group experiences an underrun and\n         tmnxDS0ChanGroupPayloadFillType is set to 'userDefinedPattern'.\n\n         The default value depends on the encap type of the channel group:\n         For CEM encap channel group             - 255 (Valid range 0..255)\n         For non-CEM encap channel group         -   0 (Valid range 0..0).")
tmnxDS0ChanGroupSignalFillType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 14), TmnxDSXIdleFillType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupSignalFillType.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupSignalFillType.setDescription("The value of tmnxDS0ChanGroupSignalFillType specifies the type of\n         idle signal fill to be sent when the CAS CEM channel group experiences\n         an underrun.\n\n         If the type is set to 'userDefinedPattern' then the value of\n         tmnxDS0ChanGroupSignalPattern is used to define the signal pattern.\n         \n         The default value depends on the encap of the DS0 channel group and\n         the signal-mode of the DS1/E1:\n         For CEM encap on DS1/E1 with CAS signal mode    - 'allOnes'\n         For all other encaps or non-CAS CEM DS1/E1      - 'notApplicable'\n\n         For CEM channel groups on DS1/E1 with no CAS signalling and non-CEM\n         encap channel groups the value cannot be changed.")
tmnxDS0ChanGroupSignalPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 13, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS0ChanGroupSignalPattern.setStatus('current')
if mibBuilder.loadTexts: tmnxDS0ChanGroupSignalPattern.setDescription("The value of tmnxDS0ChanGroupSignalPattern specifies the idle signal\n         fill pattern when the CAS CEM channel group experiences an underrun\n         and tmnxDS0ChanGroupSignalFillType is set to 'userDefinedPattern'.\n\n         CAS ESF DS1 and CAS E1 support 4 signalling bits per timeslot (ABCD)\n         CAS SF DS1 supports 2 signalling bits per timeslot (AB)\n         \n         The default value depends on the type of channel group:\n         For CAS DS1 ESF or CAS E1 channel group -  15 (Valid range 0..15)\n         For CAS DS1 SF channel group            -   3 (Valid range 0..3)\n         For non-CAS or non-CEM channel group    -   0 (Valid range 0..0)")
tmnxBundleTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14), )
if mibBuilder.loadTexts: tmnxBundleTable.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleTable.setDescription('The tmnxBundleTable has an entry for a bundle created on the system.')
tmnxBundleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleBundleID"))
if mibBuilder.loadTexts: tmnxBundleEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleEntry.setDescription('Each row entry represents a multilink bundle on a MDA.\n         Entries can be created and deleted via SNMP SET operations \n         using the tmnxBundleRowStatus object. The tmnxBundleBundleID will \n         contain the bundle number encoded in it. The bundle number is \n         unique for a MDA.\n         For each tmnxBundleEntry, there will be a corresponding entry \n         in the tmnxPortTable and the ifTable.')
tmnxBundleBundleID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 1), TmnxBundleID())
if mibBuilder.loadTexts: tmnxBundleBundleID.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleBundleID.setDescription('tmnxBundleBundleID identifies this multilink bundle. The value of\n         this object is calculated using the TiMOS encoding scheme described\n         in TmnxBundleID.\n         tmnxBundleBundleID is used as an index into the ifTable and the \n         tmnxPortTable to access an entry corresponding to this entry.')
tmnxBundleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleRowStatus.setDescription('tmnxBundleRowStatus controls the creation and deletion of\n         row entries in the tmnxBundleTable. \n\n         The manager has to first calculate the tmnxBundleBundleID \n         based on the TiMOS encoding.')
tmnxBundleType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mlppp", 1), ("mlfr", 2), ("imagrp", 3))).clone('mlppp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleType.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleType.setDescription('tmnxBundleType specifies the type of this multilink bundle.\n         It provides a reference as to the type of bundle this row\n         refers to but does not map to the direct value of \n         bndle type defined in TmnxBundleID.')
tmnxBundleMinimumLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMinimumLinks.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMinimumLinks.setDescription('tmnxBundleMinimumLinks is the minimum number of links that must be\n         active for a bundle to be active. If the number of links drop below\n         the given minimum then the multilink bundle will transition to an\n         operation down state.')
tmnxBundleNumLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleNumLinks.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleNumLinks.setDescription('tmnxBundleNumLinks indicates the total number of links configured \n         for this bundle.')
tmnxBundleNumActiveLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleNumActiveLinks.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleNumActiveLinks.setDescription('tmnxBundleNumActiveLinks indicates the current number of active links \n         belonging to this bundle.')
tmnxBundleMRRU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1500, 9206), )).clone(1524)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMRRU.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMRRU.setDescription('tmnxBundleMRRU is used to configure the \n         Max Received Reconstructed Unit (MRRU). This is the maximum frame that\n         can be reconstructed from multilink fragments.\n         This object is only applicable to tmnxBundleType values of mlppp or\n         mlfr. All non applicable types have a value of zero.')
tmnxBundleOperMRRU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 8), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleOperMRRU.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleOperMRRU.setDescription('tmnxBundleOperMRRU indicates the operational value of \n         Max Received Reconstructed Unit (MRRU).\n         This object is only applicable to tmnxBundleType values of mlppp or\n         mlfr. All non applicable types have a value of zero.')
tmnxBundlePeerMRRU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 9), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundlePeerMRRU.setStatus('current')
if mibBuilder.loadTexts: tmnxBundlePeerMRRU.setDescription('tmnxBundlePeerMRRU indicates the MRRU value sent by the peer\n         during negotiation.\n         This object is only applicable to tmnxBundleType values of mlppp or\n         mlfr. All non applicable types have a value of zero.')
tmnxBundleOperMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 10), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleOperMTU.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleOperMTU.setDescription('tmnxBundleOperMTU indicates the operational MTU of the bundle.')
tmnxBundleRedDiffDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 25), ValueRangeConstraint(0, 50), ))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleRedDiffDelay.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleRedDiffDelay.setDescription("tmnxBundleRedDiffDelay configures the maximum acceptable differential\n         delay for individual circuits within this multilink bundle. If\n         the delay exceeds this threshold, a tmnxEqPortBndlRedDiffExceeded\n         trap is issued.\n         \n         For a tmnxBundleType value of 'imagrp' a range of 0 to 50 is supported,\n         0 to 25 otherwise.")
tmnxBundleRedDiffDelayAction = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("down", 1))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleRedDiffDelayAction.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleRedDiffDelayAction.setDescription("tmnxBundleRedDiffDelayAction specifies the action to be taken\n         when the differential delay exceeds the threshold configured in\n         tmnxBundleRedDiffDelay.\n         For a tmnxBundleType value of 'imagrp', only the down action is \n         supported.")
tmnxBundleYellowDiffDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 25))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleYellowDiffDelay.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleYellowDiffDelay.setDescription("tmnxBundleYellowDiffDelay configures the yellow warning \n         threshold for the differential delay for the circuits \n         within a given multilink bundle. If the delay exceeds this \n         threshold, a tmnxEqPortBndlYellowDiffExceeded trap is issued.\n         This object is only applicable to tmnxBundleType values of \n         'mlppp' or 'mlfr'. All non applicable types have a value \n         of zero.")
tmnxBundleShortSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleShortSequence.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleShortSequence.setDescription('tmnxBundleShortSequence command specifies that the MLPPP bundle \n         should use short (12 bit) sequence numbers. Instead of the \n         standard long (24 bits) sequence number.\n         This object is only applicable to tmnxBundleType values of mlppp.')
tmnxBundleLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 15), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleLastChangeTime.setDescription('The tmnxBundleLastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxBundleEntry row for this channel group.')
tmnxBundleFragmentThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(128, 512), )).clone(128)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleFragmentThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleFragmentThreshold.setDescription('The value of tmnxBundleFragmentThreshold specifies the maximum length \n         of a fragment transmitted across the multilink bundle. Values supported\n         within each bundle type are H/W dependent. The value of 0 specifies\n         no fragmentation.\n         \n         Currently, the following values are supported depending upon the \n         tmnxBundleType value:\n         \n             tmnxBundleType         tmnxBundleFragmentThreshold values supported\n              mlppp                   0; 128 to 512 inclusive\n              imagrp                  128')
tmnxBundleUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 17), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleUpTime.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleUpTime.setDescription("tmnxBundleUpTime indicates the time since the bundle is operationally \n         'inService'.")
tmnxBundleInputDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleInputDiscards.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleInputDiscards.setDescription('tmnxBundleInputDiscards indicates the number of LCP packets that\n         were discarded. This object is only supported for a \n         tmnxBundleType value of mlppp.')
tmnxBundlePrimaryMemberPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 19), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundlePrimaryMemberPortID.setStatus('current')
if mibBuilder.loadTexts: tmnxBundlePrimaryMemberPortID.setDescription('tmnxBundlePrimaryMemberPortID indicates the TmnxPortID of the primary\n         member of this bundle. The value of this object will be zero if\n         there are no members configured in this bundle.')
tmnxBundleLFI = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 20), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleLFI.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleLFI.setDescription("tmnxBundleLFI specifies if Link Fragmentation and \n         Interleaving is enabled on the multilink bundle. A value of 'false'\n         indicates that Link Fragmentation and Interleaving is disabled on the \n         multilink bundle while a value of 'true' indicates that Link \n         Fragmentation and Interleaving is enabled on the multilink bundle.\n\n         This object is only supported for tmnxBundleType value of mlppp.\n         \n         The value of tmnxBundleLFI may be modified only when no members are \n         part of the bundle.\n         \n         This object cannot be set to true when tmnxBundleMlpppClassCount object\n         value is set to enable Multiclass MLPPP on the bundle.")
tmnxBundleProtectedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("working", 1), ("protection", 2))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleProtectedType.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleProtectedType.setDescription("tmnxBundleProtectedType identifies how this bundle is part \n        of a tmnxBundleParentBundle. A value of 'none' identifies no protection,\n        'working' identifies it to be a working bundle of a tmnxBundleParentBundle and\n        'protection' identifies it to be a protection bundle of a tmnxBundleParentBundle.\n        tmnxBundleProtectedType can only be set at row creation.")
tmnxBundleParentBundle = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 14, 1, 22), TmnxBundleID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleParentBundle.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleParentBundle.setDescription('tmnxBundleParentBundle specifies the parent to which this bundle belongs.\n        A row for the given non zero walue of tmnxBundleParentBundle must exist for \n        this row to be successfully created. If a bundle has no parent, its value\n        is zero. tmnxBundleParentBundle can only be set at row creation.')
tmnxBundleMemberTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 15), )
if mibBuilder.loadTexts: tmnxBundleMemberTable.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberTable.setDescription('The tmnxBundleMemberTable has an entry for a member port \n         associated with a multilink bundle.')
tmnxBundleMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 15, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleBundleID"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxBundleMemberEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberEntry.setDescription('Each row represents a port associated with a bundle. Entries\n         can be added or removed from this table using SNMP SET operation.')
tmnxBundleMemberRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 15, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMemberRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberRowStatus.setDescription('tmnxBundleMemberRowStatus controls the creation and deletion of\n         row entries in the tmnxBundleMemberTable.\n         tmnxPortPortID identifies the port to be associated with the bundle.\n         A bundle entry with tmnxBundleBundleID has to exist in the \n         tmnxBundleTable before creating an entry in this table.')
tmnxBundleMemberActive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 15, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberActive.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberActive.setDescription("tmnxBundleMemberActive is set to 'false' for one of reasons in \n         tmnxBundleMemberDownReason.")
tmnxBundleMemberDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 0), ("outOfService", 1), ("redDiffDelayExceeded", 2), ("mismatchEndPtDiscriminator", 3), ("peerNotBundleMember", 4), ("underNegotiation", 5), ("peerInvalidMlHdrFmt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberDownReason.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberDownReason.setDescription("tmnxBundleMemberDownReason contains the reason code for marking\n         the member link of the bundle to down (i.e. tmnxBundleMemberActive\n         will be set to false):\n             none - The link is active and the value of tmnxBundleMemberActive\n                    is 'true'.\n             outOfService - The link operational status is down.\n             redDiffDelayExceeded - The differential delay of the link\n                    exceeded the configured value of red differential delay\n                    and tmnxBundleRedDiffDelayAction was configured as 'down'.\n             mismatchEndPtDiscriminator - Detected inconsistent peer endpoint \n                    discriminator for the bundle.\n             peerNotBundleMember - When the peer is either not added to the\n                    bundle or is removed from the bundle.\n             underNegotiation - When the local end is trying to negotiate with\n                    the peer.\n             peerInvalidMlHdrFmt - The peer does not support the required ML-PPP\n                    header format. The remote peer must support the same short/long\n                    sequence code, and at least as many classes as configured for the\n                    local bundle.\n        ")
tmnxBundleMemberUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 15, 1, 4), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberUpTime.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberUpTime.setDescription('tmnxBundleMemberUpTime indicates the time since the bundle member is\n         active as indicated by tmnxBundleMemberActive.')
tmnxPortToChannelTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 16), )
if mibBuilder.loadTexts: tmnxPortToChannelTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortToChannelTable.setDescription('The tmnxPortToChannelTable is a mapping table. Given a chassis index,\n         physical port index and channel string, it maps it to the index\n         of the channel. This channel index can then be used as an index\n         into the ifTable or the tmnxPortTable.')
tmnxPortToChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 16, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxChannelIdxString"))
if mibBuilder.loadTexts: tmnxPortToChannelEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortToChannelEntry.setDescription('Each row represents a mapping of the physical port index and the\n         channel index string to the index of the channel.')
tmnxChannelIdxString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 16, 1, 1), DisplayString())
if mibBuilder.loadTexts: tmnxChannelIdxString.setStatus('current')
if mibBuilder.loadTexts: tmnxChannelIdxString.setDescription('tmnxChannelIdxString is an index into the table. It contains \n         a string identifying a channel on the physical port.')
tmnxChannelPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 16, 1, 2), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChannelPortID.setStatus('current')
if mibBuilder.loadTexts: tmnxChannelPortID.setDescription('tmnxChannelPortID contains the port ID of the channel. This value\n         is used to identify the entry for this channel in the ifTable or \n         the tmnxPortTable.')
tmnxPortIngrMdaQosStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17), )
if mibBuilder.loadTexts: tmnxPortIngrMdaQosStatTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQosStatTable.setDescription('The table tmnxPortIngrMdaQosStatTable contains a row for each ethernet\n         port located on an oversubscribed MDA.')
tmnxPortIngrMdaQosStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxPortIngrMdaQosStatEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQosStatEntry.setDescription('Each row entry indicates the MDA QoS discard statistics for an\n         ethernet port located on an oversubscribed MDA.\n         tmnxPortEtherIngressRate object in the tmnxPortEtherTable indicates\n         the ingress rate configured for the port.')
tmnxPortIngrMdaQos00StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos00StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos00StatDropPkts.setDescription('tmnxPortIngrMdaQos00StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos00StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos00StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos00StatDropOcts.setDescription('tmnxPortIngrMdaQos00StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos01StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos01StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos01StatDropPkts.setDescription('tmnxPortIngrMdaQos01StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos01StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos01StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos01StatDropOcts.setDescription('tmnxPortIngrMdaQos01StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos02StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos02StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos02StatDropPkts.setDescription('tmnxPortIngrMdaQos02StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos02StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos02StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos02StatDropOcts.setDescription('tmnxPortIngrMdaQos02StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos03StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos03StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos03StatDropPkts.setDescription('tmnxPortIngrMdaQos03StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos03StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos03StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos03StatDropOcts.setDescription('tmnxPortIngrMdaQos03StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos04StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos04StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos04StatDropPkts.setDescription('tmnxPortIngrMdaQos04StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos04StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos04StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos04StatDropOcts.setDescription('tmnxPortIngrMdaQos04StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos05StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos05StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos05StatDropPkts.setDescription('tmnxPortIngrMdaQos05StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos05StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos05StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos05StatDropOcts.setDescription('tmnxPortIngrMdaQos05StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos06StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos06StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos06StatDropPkts.setDescription('tmnxPortIngrMdaQos06StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos06StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos06StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos06StatDropOcts.setDescription('tmnxPortIngrMdaQos06StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos07StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos07StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos07StatDropPkts.setDescription('tmnxPortIngrMdaQos07StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos07StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos07StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos07StatDropOcts.setDescription('tmnxPortIngrMdaQos07StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos08StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos08StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos08StatDropPkts.setDescription('tmnxPortIngrMdaQos08StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos08StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos08StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos08StatDropOcts.setDescription('tmnxPortIngrMdaQos08StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos09StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos09StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos09StatDropPkts.setDescription('tmnxPortIngrMdaQos09StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos09StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos09StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos09StatDropOcts.setDescription('tmnxPortIngrMdaQos09StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos10StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos10StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos10StatDropPkts.setDescription('tmnxPortIngrMdaQos10StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos10StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos10StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos10StatDropOcts.setDescription('tmnxPortIngrMdaQos10StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos11StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos11StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos11StatDropPkts.setDescription('tmnxPortIngrMdaQos11StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos11StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos11StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos11StatDropOcts.setDescription('tmnxPortIngrMdaQos11StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos12StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos12StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos12StatDropPkts.setDescription('tmnxPortIngrMdaQos12StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos12StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos12StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos12StatDropOcts.setDescription('tmnxPortIngrMdaQos12StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos13StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos13StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos13StatDropPkts.setDescription('tmnxPortIngrMdaQos13StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos13StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos13StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos13StatDropOcts.setDescription('tmnxPortIngrMdaQos13StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos14StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos14StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos14StatDropPkts.setDescription('tmnxPortIngrMdaQos14StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos14StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos14StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos14StatDropOcts.setDescription('tmnxPortIngrMdaQos14StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos15StatDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos15StatDropPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos15StatDropPkts.setDescription('tmnxPortIngrMdaQos15StatDropPkts indicates the number of\n         packets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxPortIngrMdaQos15StatDropOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 17, 1, 32), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortIngrMdaQos15StatDropOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQos15StatDropOcts.setDescription('tmnxPortIngrMdaQos15StatDropOcts indicates the number of\n         octets dropped on the oversubscribed MDA for given Qos\n         classifier result because of an overload condition on the MDA.')
tmnxSonetGroupTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 18), )
if mibBuilder.loadTexts: tmnxSonetGroupTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetGroupTable.setDescription("The tmnxSonetGroupTable has an entry for each \n         Tributary Unit Group(TUG3) on a path. On a port which supports\n         unchannelized STS-3's, rows in this table are created when a\n         channelized STS-3 has its tmnxSonetPathChildType set to sdhTug3.\n         On a port which does not support unchannelized STS-3's, the rows\n         in this table are implicitly created when a STS-3 is created\n         in the tmnxSonetPathTable.  Entries in this table are implicitly\n         deleted when the parent entry of this group is deleted from the\n         tmnxSonetPathTable or if the tmnxSonetPathChildType of the parent\n         is set to something other than sdhTug3.")
tmnxSonetGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 18, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxSonetGroupEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetGroupEntry.setDescription('Each row entry represents a Tributary Unit Group(TUG3) on a path.')
tmnxSonetGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 18, 1, 1), TmnxMDAChanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetGroupType.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetGroupType.setDescription("tmnxSonetGroupType indicates the sonet group type of this entry.\n         For STS-3/STM-1 channelization, the value of this object will \n         be 'sdhTug3'.")
tmnxSonetGroupParentPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 18, 1, 2), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetGroupParentPortID.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetGroupParentPortID.setDescription('tmnxSonetGroupParentPortID indicates the TmnxPortID of the parent of\n         this group.')
tmnxSonetGroupChildType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 18, 1, 3), TmnxMDAChanType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxSonetGroupChildType.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetGroupChildType.setDescription("tmnxSonetGroupChildType is used to configure the type of the children\n         of this group. Based on the value of this object, entries of\n         a certain channel type can be created in the tmnxSonetPathTable.\n         For example, if the value of this object is set to 'sonetVt15', \n         then 28 entries of type 'sonetVt15' can be created in \n         the tmnxSonetPathTable.")
tmnxSonetGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 18, 1, 4), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSonetGroupName.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetGroupName.setDescription('tmnxSonetGroupName is the textual name for this sonet group.')
tmnxCiscoHDLCTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 20), )
if mibBuilder.loadTexts: tmnxCiscoHDLCTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCTable.setDescription('The tmnxCiscoHDLCTable has an entry for each port in the system \n         that is configured for Cisco HDLC. It contains the parameters related \n         to Cisco HDLC protocol on this port.')
tmnxCiscoHDLCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 20, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxCiscoHDLCEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCEntry.setDescription('The tmnxCiscoHDLCEntry specifies parameters for a particular \n         interfaces running Cisco HDLC encapsulation. Entries cannot be created \n         and deleted via SNMP SET operations.')
tmnxCiscoHDLCKeepAliveInt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 300)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCiscoHDLCKeepAliveInt.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCKeepAliveInt.setDescription('tmnxCiscoHDLCKeepAliveInt specifies the interval in seconds\n         used for sending periodic keepalive packets. The default value is set\n         to 10 seconds. A value of 0 specifies that the keepalive function is\n         turned off.\n\n         It is expected that the nodes at the two endpoints of \n         the Cisco HDLC link are provisioned with the same values.')
tmnxCiscoHDLCUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 20, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCiscoHDLCUpCount.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCUpCount.setDescription('tmnxCiscoHDLCUpCount specifies the number of continual\n         keepalive packets that has to be received to declare the link up.\n\n         It is expected that the nodes at the two endpoints of \n         the Cisco HDLC link are provisioned with the same values.')
tmnxCiscoHDLCDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 16)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCiscoHDLCDownCount.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCDownCount.setDescription("tmnxCiscoHDLCDownCount specifies the number of \n         'tmnxCiscoHDLCKeepAliveInt' intervals that must\n         pass without receiving a keepalive packet before the \n         link is declared down.\n    \n         It is expected that the nodes at the two endpoints of \n         the Cisco HDLC link are provisioned with the same values.")
tmnxCiscoHDLCOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 20, 1, 4), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCiscoHDLCOperState.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCOperState.setDescription('The value of tmnxCiscoHDLCOperState indicates the operational\n         status of the Cisco HDLC protocol for this port.')
tmnxCiscoHDLCStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3), )
if mibBuilder.loadTexts: tmnxCiscoHDLCStatsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCStatsTable.setDescription('The tmnxCiscoHDLCStatsTable has an entry for each port in the\n         system that is configured for Cisco HDLC encapsulation. It contains \n         Cisco HDLC protocol statistics for the particular port.')
tmnxCiscoHDLCStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3, 1), )
tmnxCiscoHDLCEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCStatsEntry"))
tmnxCiscoHDLCStatsEntry.setIndexNames(*tmnxCiscoHDLCEntry.getIndexNames())
if mibBuilder.loadTexts: tmnxCiscoHDLCStatsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCStatsEntry.setDescription('An entry in the tmnxCiscoHDLCStatsTable.')
tmnxCiscoHDLCDiscardStatInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCiscoHDLCDiscardStatInPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCDiscardStatInPkts.setDescription('tmnxCiscoHDLCDiscardStatInPkts indicates the number of \n         inbound Cisco HDLC packets discarded.')
tmnxCiscoHDLCDiscardStatOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCiscoHDLCDiscardStatOutPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCDiscardStatOutPkts.setDescription('tmnxCiscoHDLCDiscardStatOutPkts indicates the number of \n         outbound Cisco HDLC packets discarded.')
tmnxCiscoHDLCStatInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCiscoHDLCStatInPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCStatInPkts.setDescription('tmnxCiscoHDLCStatInPkts indicates the number of inbound Cisco \n         HDLC packets.')
tmnxCiscoHDLCStatOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCiscoHDLCStatOutPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCStatOutPkts.setDescription('tmnxCiscoHDLCStatOutPkts indicates the number of outbound Cisco \n         HDLC packets.')
tmnxCiscoHDLCStatInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCiscoHDLCStatInOctets.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCStatInOctets.setDescription('tmnxCiscoHDLCStatInOctets indicates the number of inbound Cisco\n         HDLC octets.')
tmnxCiscoHDLCStatOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 3, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCiscoHDLCStatOutOctets.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCStatOutOctets.setDescription('tmnxCiscoHDLCStatOutOctets indicates the number of outbound \n         Cisco HDLC octets.')
tmnxFRDlcmiTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1), )
if mibBuilder.loadTexts: tmnxFRDlcmiTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiTable.setDescription('The tmnxFRDlcmiTable has an entry for each port in the\n         system that is configured for Frame Relay. It contains \n         the parameters for the Data Link Connection Management\n         Interface (DLCMI) for the frame relay service on this port.')
tmnxFRDlcmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxFRDlcmiEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiEntry.setDescription('The Parameters for a particular Data Link Connection\n         Management Interface. Entries cannot be created and \n         deleted via SNMP SET operations.')
tmnxFRDlcmiMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2), ("bidir", 3))).clone('dte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFRDlcmiMode.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiMode.setDescription('tmnxFRDlcmiMode is used to set the mode of the interface.\n             It can be set as Data terminal equipment (dte),  \n             Data circuit-terminating equipment (dce) or both as Data \n             terminal equipment and Data circuit-terminating \n             equipment (bidir). ')
tmnxFRDlcmiN392Dce = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFRDlcmiN392Dce.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiN392Dce.setDescription('tmnxFRDlcmiN392Dce is used to configure the LMI error \n             threshold for DCE interface.')
tmnxFRDlcmiN393Dce = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFRDlcmiN393Dce.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiN393Dce.setDescription('tmnxFRDlcmiN393Dce is used to configure the LMI monitored \n             event count for DCE interface.')
tmnxFRDlcmiT392Dce = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(15)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFRDlcmiT392Dce.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiT392Dce.setDescription('tmnxFRDlcmiT392Dce is used to configure the polling verification \n             timer for the Frame Relay DCE interface.')
tmnxFRDlcmiTxStatusEnqMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 5), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiTxStatusEnqMsgs.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiTxStatusEnqMsgs.setDescription('tmnxFRDlcmiTxStatusEnqMsgs indicates the number of LMI Status\n             Enquiry messages transmitted on this Frame Relay interface.')
tmnxFRDlcmiRxStatusEnqMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 6), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiRxStatusEnqMsgs.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiRxStatusEnqMsgs.setDescription('tmnxFRDlcmiRxStatusEnqMsgs indicates the number of LMI Status\n             Enquiry messages received on this Frame Relay interface.')
tmnxFRDlcmiStatusEnqMsgTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 7), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiStatusEnqMsgTimeouts.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiStatusEnqMsgTimeouts.setDescription('tmnxFRDlcmiStatusEnqMsgTimeouts indicates the number of times \n             the LMI agent did not receive a Status Enquiry message within\n             the allotted time.')
tmnxFRDlcmiTxStatusMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 8), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiTxStatusMsgs.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiTxStatusMsgs.setDescription('tmnxFRDlcmiTxStatusMsgs indicates the number of LMI Status\n             messages transmitted on this Frame Relay interface.')
tmnxFRDlcmiRxStatusMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 9), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiRxStatusMsgs.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiRxStatusMsgs.setDescription('tmnxFRDlcmiRxStatusMsgs indicates the number of LMI Status\n             messages received on this Frame Relay interface.')
tmnxFRDlcmiStatusMsgTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 10), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiStatusMsgTimeouts.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiStatusMsgTimeouts.setDescription('tmnxFRDlcmiStatusMsgTimeouts indicates the number of times \n             the LMI agent did not receive a Status message within the\n             allotted time.')
tmnxFRDlcmiDiscardedMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 11), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiDiscardedMsgs.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiDiscardedMsgs.setDescription("tmnxFRDlcmiDiscardedMsgs indicates the number of times \n             the LMI agent discarded a received message because it\n             wasn't expecting it, the type of message was incorrect,\n             or the contents of the message were invalid.")
tmnxFRDlcmiInvRxSeqNumMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 9, 1, 1, 12), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFRDlcmiInvRxSeqNumMsgs.setStatus('current')
if mibBuilder.loadTexts: tmnxFRDlcmiInvRxSeqNumMsgs.setDescription('tmnxFRDlcmiInvRxSeqNumMsgs indicates the number of times \n             the LMI agent received a message with an invalid receive\n             sequence number: i.e. a sequence number that does not\n             match the last transmitted sequence number of the agent.')
tmnxQosPoolAppTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2), )
if mibBuilder.loadTexts: tmnxQosPoolAppTable.setStatus('current')
if mibBuilder.loadTexts: tmnxQosPoolAppTable.setDescription('This table maintains associations of the buffer pools with the\n        individual objects.')
tmnxQosPoolAppEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectType"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectId"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectAppType"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectAppPool"))
if mibBuilder.loadTexts: tmnxQosPoolAppEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxQosPoolAppEntry.setDescription('This entry maintains the specifics about the association of a \n        buffer pool and an object.')
tmnxObjectType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mda", 1), ("port", 2), ("channel", 3), ("bundle", 4))))
if mibBuilder.loadTexts: tmnxObjectType.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectType.setDescription('The object tmnxObjectType defines the type of object to which the \n        pool is being setup for.')
tmnxObjectId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 2), TmnxPortID())
if mibBuilder.loadTexts: tmnxObjectId.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectId.setDescription("tmnxObjectId is used to identify the specific object. If \n        tmnxObjectType is 'mda', then the tmnxObjectId is encoded as a\n        physical port with the port being '0'. For all other types the \n        encoding is done as per the description of TmnxPortID.")
tmnxObjectAppType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("accessIngress", 1), ("accessEgress", 2), ("networkIngress", 3), ("networkEgress", 4))))
if mibBuilder.loadTexts: tmnxObjectAppType.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectAppType.setDescription('The object tmnxObjectAppType specifies the nature of usage the pool \n        would be used for. The pools could be used for access or network\n        traffic at either ingress or egress.')
tmnxObjectAppPool = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 4), TNamedItem())
if mibBuilder.loadTexts: tmnxObjectAppPool.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectAppPool.setDescription('tmnxObjectAppPool specifies the name of the pool to be used/created.')
tmnxObjectAppPoolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxObjectAppPoolRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectAppPoolRowStatus.setDescription('The object tmnxObjectAppPoolRowStatus is used to create or remove a \n        pool application to the object.')
tmnxObjectAppResvCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxObjectAppResvCbs.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectAppResvCbs.setDescription("The percentage of pool size reserved for CBS. The value '-1'\n        implies that the reserved CBS should be computed as the sum of \n        the CBS requested by the entities using this pool if the application\n        point is 'network'. For 'access' application points the value '-1'\n        means a default of 30%.")
tmnxObjectAppSlopePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 7), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxObjectAppSlopePolicy.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectAppSlopePolicy.setDescription('tmnxObjectAppSlopePolicy specifies the slope policy being used for \n        this pool. The Slope policies define the nature of the RED Slopes for \n        the high and the low priority traffic.')
tmnxObjectAppPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxObjectAppPoolSize.setStatus('current')
if mibBuilder.loadTexts: tmnxObjectAppPoolSize.setDescription("Size in percentage of buffer space. The value '-1' implies that \n        the pool size should be computed as per fair weighing between\n        all other pools.")
tmnxATMIntfTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 11, 1), )
if mibBuilder.loadTexts: tmnxATMIntfTable.setStatus('current')
if mibBuilder.loadTexts: tmnxATMIntfTable.setDescription('The tmnxATMIntfTable has an entry for each port/channel in the\n         system that is configured for ATM. It contains ATM cell layer \n         configuration parameters.')
tmnxATMIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 11, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxATMIntfEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxATMIntfEntry.setDescription('The Parameters for a particular ATM Cell \n         Management Interface. Entries cannot be created or \n         deleted via SNMP SET operations.\n         Entries will exist in this table when ATM encapsulation\n         is configured on the port/channel.')
tmnxATMIntfCellFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2))).clone('uni')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxATMIntfCellFormat.setStatus('current')
if mibBuilder.loadTexts: tmnxATMIntfCellFormat.setDescription('tmnxATMIntfCellFormat is used to set the cell format \n         (UNI or NNI) that is to be used on the ATM interface.')
tmnxATMIntfMinVpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxATMIntfMinVpValue.setStatus('current')
if mibBuilder.loadTexts: tmnxATMIntfMinVpValue.setDescription('tmnxATMIntfMinVpValue is used to set the minimum \n             allowable VPI value that can be used on the  \n             ATM interface for a VPC.')
tmnxATMIntfMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("plcp", 2))).clone('direct')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxATMIntfMapping.setStatus('current')
if mibBuilder.loadTexts: tmnxATMIntfMapping.setDescription("The value of tmnxATMIntfMapping specifies the cell\n             mapping that is to be used on this ATM interface.  When\n             tmnxPortChanType does not have a value of 'pdhDs3 (14)',\n             'inconsistentValue' error will be returned to SNMP SET\n             requests.  When tmnxPortChanType has a value of 'pdhDs3 (14)', \n             tmnxATMIntfMapping can be set to 'plcp (2)'.")
tmnxPortNetIngressStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1), )
if mibBuilder.loadTexts: tmnxPortNetIngressStatsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressStatsTable.setDescription('Defines the Alcatel 7x50 SR series network port ingress \n         statistics table for providing, via SNMP, the capability of\n         retrieving the traffic statistics for the physical queues\n         being used for the ports to forward the network ingress\n         traffic.')
tmnxPortNetIngressStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressQueueIndex"))
if mibBuilder.loadTexts: tmnxPortNetIngressStatsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressStatsEntry.setDescription('Defines an entry in tmnxPortNetIngressStatsTable. Entries are \n         created and deleted by the system depending on the queue policy \n         being used at the specific port.')
tmnxPortNetIngressQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 1), TQueueId().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: tmnxPortNetIngressQueueIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressQueueIndex.setDescription('tmnxPortNetIngressQueueIndex serves as the tertiary index. When used\n         in conjunction with tmnxChassisIndex and tmnxPortPortID, it uniquely \n         identifies a network ingress queue for the specified port in the\n         managed system.')
tmnxPortNetIngressFwdInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressFwdInProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressFwdInProfPkts.setDescription('tmnxPortNetIngressFwdInProfPkts indicates the number of conforming\n         network ingress packets forwarded on this port using this queue.')
tmnxPortNetIngressFwdOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressFwdOutProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressFwdOutProfPkts.setDescription('tmnxPortNetIngressFwdOutProfPkts indicates the number of exceeding\n         network ingress packets forwarded on this port using this queue.')
tmnxPortNetIngressFwdInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressFwdInProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressFwdInProfOcts.setDescription('tmnxPortNetIngressFwdInProfOcts indicates the number of conforming\n         network ingress octets forwarded on this port using this queue.')
tmnxPortNetIngressFwdOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressFwdOutProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressFwdOutProfOcts.setDescription('tmnxPortNetIngressFwdOutProfOcts indicates the number of exceeding\n         network ingress octets forwarded on this port using this queue.')
tmnxPortNetIngressDroInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressDroInProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressDroInProfPkts.setDescription('tmnxPortNetIngressDroInProfPkts indicates the number of conforming\n         network ingress packets dropped on this port using this queue.')
tmnxPortNetIngressDroOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressDroOutProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressDroOutProfPkts.setDescription('tmnxPortNetIngressDroOutProfPkts indicates the number of exceeding\n         network ingress packets dropped on this port using this queue.')
tmnxPortNetIngressDroInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressDroInProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressDroInProfOcts.setDescription('tmnxPortNetIngressDroInProfOcts indicates the number of conforming\n         network ingress octets dropped on this port using this queue.')
tmnxPortNetIngressDroOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetIngressDroOutProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetIngressDroOutProfOcts.setDescription('tmnxPortNetIngressDroOutProfOcts indicates the number of exceeding\n         network ingress octets dropped on this port using this queue.')
tmnxPortNetEgressStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2), )
if mibBuilder.loadTexts: tmnxPortNetEgressStatsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressStatsTable.setDescription('Defines the Alcatel 7x50 SR series network port egress \n         statistics table for providing, via SNMP, the capability of\n         retrieving the traffic statistics for the physical queues\n         being used for the ports to forward the network egress\n         traffic.')
tmnxPortNetEgressStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressQueueIndex"))
if mibBuilder.loadTexts: tmnxPortNetEgressStatsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressStatsEntry.setDescription('Defines an entry in tmnxPortNetEgressStatsTable. Entries are \n         created and deleted by the system depending on the queue policy \n         being used at the specific port.')
tmnxPortNetEgressQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 1), TQueueId().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: tmnxPortNetEgressQueueIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressQueueIndex.setDescription('tmnxPortNetEgressQueueIndex serves as the tertiary index. When used\n         in conjunction with tmnxChassisIndex and tmnxPortPortID, it uniquely \n         identifies a network egress queue for the specified port in the\n         managed system.')
tmnxPortNetEgressFwdInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressFwdInProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressFwdInProfPkts.setDescription('tmnxPortNetEgressFwdInProfPkts indicates the number of conforming\n         network egress packets forwarded on this port using this queue.')
tmnxPortNetEgressFwdOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressFwdOutProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressFwdOutProfPkts.setDescription('tmnxPortNetEgressFwdOutProfPkts indicates the number of exceeding\n         network egress packets forwarded on this port using this queue.')
tmnxPortNetEgressFwdInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressFwdInProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressFwdInProfOcts.setDescription('tmnxPortNetEgressFwdInProfOcts indicates the number of conforming\n         network egress octets forwarded on this port using this queue.')
tmnxPortNetEgressFwdOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressFwdOutProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressFwdOutProfOcts.setDescription('tmnxPortNetEgressFwdOutProfOcts indicates the number of exceeding\n         network egress octets forwarded on this port using this queue.')
tmnxPortNetEgressDroInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressDroInProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressDroInProfPkts.setDescription('tmnxPortNetEgressDroInProfPkts indicates the number of conforming\n         network egress packets dropped on this port using this queue.')
tmnxPortNetEgressDroOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressDroOutProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressDroOutProfPkts.setDescription('tmnxPortNetEgressDroOutProfPkts indicates the number of exceeding\n         network egress packets dropped on this port using this queue.')
tmnxPortNetEgressDroInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressDroInProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressDroInProfOcts.setDescription('tmnxPortNetEgressDroInProfOcts indicates the number of conforming\n         network egress octets dropped on this port using this queue.')
tmnxPortNetEgressDroOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortNetEgressDroOutProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNetEgressDroOutProfOcts.setDescription('tmnxPortNetEgressDroOutProfOcts indicates the number of exceeding\n         network egress octets dropped on this port using this queue.')
tmnxMcMlpppStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4), )
if mibBuilder.loadTexts: tmnxMcMlpppStatsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsTable.setDescription('Defines the Alcatel 7x50 SR series Multiclass MLPPP\n         statistics table for providing the capability of\n         retrieving the traffic statistics for the physical queues\n         being used for a class of a multiclass MLPPP bundle to \n         forward the traffic.')
tmnxMcMlpppStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleBundleID"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppClassIndex"))
if mibBuilder.loadTexts: tmnxMcMlpppStatsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsEntry.setDescription('Defines an entry in tmnxMcMlpppStatsTable. Entries are \n         created and deleted by the system depending on the number of\n         classes being used by a given MLPPP bundle.')
tmnxMcMlpppClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1, 1), TmnxMcMlpppClassIndex())
if mibBuilder.loadTexts: tmnxMcMlpppClassIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppClassIndex.setDescription('tmnxMcMlpppClassIndex serves as the tertiary index. When used\n         in conjunction with tmnxChassisIndex and tmnxBundleBundleID, it \n         uniquely identifies a class of a multiclass MLPPP bundle in the\n         managed system.')
tmnxMcMlpppStatsIngressOct = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcMlpppStatsIngressOct.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsIngressOct.setDescription('The value of tmnxMcMlpppStatsIngressOct indicates the total \n         number of octets in all packets received on the bundle\n         for the given class on ingress before reassembly.')
tmnxMcMlpppStatsIngressPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcMlpppStatsIngressPkt.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsIngressPkt.setDescription('The value of tmnxMcMlpppStatsIngressPkt indicates the total \n         number of packets forwarded on the bundle for the given\n         class on ingress towards higher layer protocols.')
tmnxMcMlpppStatsIngressErrPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcMlpppStatsIngressErrPkt.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsIngressErrPkt.setDescription('The value of tmnxMcMlpppStatsIngressErrPkt indicates the total \n         number of packets discarded due to reassembly errors \n         on the bundle for the given class on ingress.')
tmnxMcMlpppStatsEgressOct = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcMlpppStatsEgressOct.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsEgressOct.setDescription('The value of tmnxMcMlpppStatsEgressOct indicates the total \n         number of octets in all packets received on the bundle\n         for the given class on egress before segmentation.')
tmnxMcMlpppStatsEgressPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcMlpppStatsEgressPkt.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsEgressPkt.setDescription('The value of tmnxMcMlpppStatsEgressPkt indicates the total \n         number of packets forwarded on the bundle for the given\n         class on egress towards the line.')
tmnxMcMlpppStatsEgressErrPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 12, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcMlpppStatsEgressErrPkt.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppStatsEgressErrPkt.setDescription('The value of tmnxMcMlpppStatsEgressErrPkt indicates the total \n         number of packets discarded due to segmentation errors\n         on the bundle for the given class on egress.')
tmnxBundleImaGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21), )
if mibBuilder.loadTexts: tmnxBundleImaGrpTable.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTable.setDescription('The tmnxBundleImaGrpTable contains IMA Group data')
tmnxBundleImaGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleBundleID"))
if mibBuilder.loadTexts: tmnxBundleImaGrpEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpEntry.setDescription('Each row entry contains data on an IMA Group.')
tmnxBundleImaGrpLnkActTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30000)).clone(10000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpLnkActTimer.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpLnkActTimer.setDescription('tmnxBundleImaGrpLnkActTimer specifies the Link Activation Timer\n         used to clear an existing LIF, LODS and FRI-IMA alarm. The time\n         specified determines how long is needed for member links to \n         stabilize before being activated.')
tmnxBundleImaGrpLnkDeactTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30000)).clone(2000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpLnkDeactTimer.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpLnkDeactTimer.setDescription('tmnxBundleImaGrpLnkDeactTimer specifies the Link Deactivation Timer\n         used to raise an LIF, LODS and FRI-IMA alarm. The time\n         specified determines how long before a member link is declared in\n         error and is deactivated.')
tmnxBundleImaGrpSymmetryMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("symmetric", 1))).clone('symmetric')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpSymmetryMode.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpSymmetryMode.setDescription('tmnxBundleImaGrpSymmetryMode specifies the type of cell rate\n         transfer over the virtual link.')
tmnxBundleImaGrpTxId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpTxId.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTxId.setDescription('tmnxBundleImaGrpTxId specifies the IMA Id generated at group\n         creation time used by the near-end.')
tmnxBundleImaGrpRxId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpRxId.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpRxId.setDescription('tmnxBundleImaGrpRxId specifies the IMA ID generated at group\n         creation time used by the far-end.')
tmnxBundleImaGrpTxRefLnk = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 6), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpTxRefLnk.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTxRefLnk.setDescription('tmnxBundleImaGrpTxRefLnk specifies the IMA bundle member\n         that was selected to be the transmit timing reference link.\n         If no member has been selected as the reference link a value\n         of zero is returned. ')
tmnxBundleImaGrpRxRefLnk = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 7), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpRxRefLnk.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpRxRefLnk.setDescription('tmnxBundleImaGrpRxRefLnk specifies the IMA bundle member\n         that was detected to be the receive timing reference link.\n         If no member has been detected as the reference link a value\n         of zero is returned. ')
tmnxBundleImaGrpSmNeState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 8), TmnxImaGrpState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpSmNeState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpSmNeState.setDescription('tmnxBundleImaGrpSmNeState specifies the current state \n         of the IMA Group for the near-end.')
tmnxBundleImaGrpSmFeState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 9), TmnxImaGrpState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpSmFeState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpSmFeState.setDescription('tmnxBundleImaGrpSmFeState specifies the current state \n         of the IMA Group for the far-end.')
tmnxBundleImaGrpSmFailState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 10), TmnxImaGrpFailState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpSmFailState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpSmFailState.setDescription('tmnxBundleImaGrpSmFailState specifies the current state \n         of the IMA Group.')
tmnxBundleImaGrpSmDownSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpSmDownSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpSmDownSecs.setDescription('tmnxBundleImaGrpSmDownSecs specifies the number of seconds\n         that the IMA Group State Machine is not Operational.')
tmnxBundleImaGrpSmOperSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpSmOperSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpSmOperSecs.setDescription('tmnxBundleImaGrpSmOperSecs specifies the number of seconds\n         that the IMA Group State Machine has been in the Operational\n         State.')
tmnxBundleImaGrpAvailTxCR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpAvailTxCR.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpAvailTxCR.setDescription('tmnxBundleImaGrpAvailTxCR specifies the available transmit \n         bandwidth on this IMA group. It only considers members that\n         are in the Active State.')
tmnxBundleImaGrpAvailRxCR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpAvailRxCR.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpAvailRxCR.setDescription('tmnxBundleImaGrpAvailRxCR specifies the available bandwidth \n         on this IMA group in the receive direction. It only considers\n         members that are in the Active State.')
tmnxBundleImaGrpNeFails = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpNeFails.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpNeFails.setDescription('tmnxBundleImaGrpNeFails specifies the number of reported\n         IMA Group failures since boot time.')
tmnxBundleImaGrpFeFails = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpFeFails.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpFeFails.setDescription('tmnxBundleImaGrpFeFails specifies the number of reported\n         IMA Group far-end failures since boot time.')
tmnxBundleImaGrpTxIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpTxIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTxIcpCells.setDescription('tmnxBundleImaGrpTxIcpCells specifies number of transmitted\n         ICP cells for this IMA Group.')
tmnxBundleImaGrpRxIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpRxIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpRxIcpCells.setDescription('tmnxBundleImaGrpRxIcpCells specifies number of received\n         ICP cells for this IMA Group.')
tmnxBundleImaGrpErrorIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpErrorIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpErrorIcpCells.setDescription('tmnxBundleImaGrpErrorIcpCells specifies number of \n         ICP cells with HEC or CRC-10 errors.')
tmnxBundleImaGrpLostRxIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpLostRxIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpLostRxIcpCells.setDescription('tmnxBundleImaGrpLostRxIcpCells specifies the number of\n         missing ICP cells at the expected offset.')
tmnxBundleImaGrpTxOamLablVal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpTxOamLablVal.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTxOamLablVal.setDescription('tmnxBundleImaGrpTxOamLablVal specifies near-end value\n         to be transmitted.')
tmnxBundleImaGrpRxOamLablVal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpRxOamLablVal.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpRxOamLablVal.setDescription('tmnxBundleImaGrpRxOamLablVal specifies far-end value\n         received.')
tmnxBundleImaGrpAlphaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 23), Integer32().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpAlphaValue.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpAlphaValue.setDescription('tmnxBundleImaGrpAlphaValue specifies the number of\n         consecutive ICP cells that need to be detected\n         before moving from the IMA Sync State to the IMA Hunt \n         State.')
tmnxBundleImaGrpBetaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 24), Integer32().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpBetaValue.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpBetaValue.setDescription('tmnxBundleImaGrpBetaValue specifies the number of\n         consecutive errored ICP cells that need to be detected\n         before moving from the IMA Sync State to the IMA Hunt \n         State')
tmnxBundleImaGrpGammaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 25), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpGammaValue.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpGammaValue.setDescription('tmnxBundleImaGrpGammaValue specifies the number of\n         consecutive valid ICP cells that need to be detected\n         before moving from the IMA pre-Sync State to the \n         IMA Hunt State.')
tmnxBundleImaGrpNeClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 26), TmnxImaGrpClockModes().clone('ctc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpNeClockMode.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpNeClockMode.setDescription('tmnxBundleImaGrpNeClockMode specifies near-end transmit\n         clock mode.')
tmnxBundleImaGrpFeClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 27), TmnxImaGrpClockModes().clone('ctc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpFeClockMode.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpFeClockMode.setDescription('tmnxBundleImaGrpFeClockMode specifies far-end transmit\n         clock mode.')
tmnxBundleImaGrpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 28), TmnxImaGrpVersion().clone('oneDotOne')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpVersion.setDescription('tmnxBundleImaGrpVersion specifies the IMA Version for\n         this group.')
tmnxBundleImaGrpMaxConfBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpMaxConfBw.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpMaxConfBw.setDescription('tmnxBundleImaGrpMaxConfBw specifies the number of links\n         that is used to determine the maximum configurable \n         bandwidth that is allowed to be used for this IMA group.')
tmnxBundleImaGrpTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 30), TmnxImaTestState().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpTestState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTestState.setDescription("tmnxBundleImaGrpTestState specifies the current state of\n         the test pattern procedure. A value of 'disabled' specifies  \n         that the group is currently not running. A value of \n         'operating' enables the test pattern procedure. The test\n         pattern procedure continues until it is 'disabled'.")
tmnxBundleImaGrpTestMember = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 31), TmnxPortID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpTestMember.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTestMember.setDescription("tmnxBundleImaGrpTestMember specifies a member link to \n         be used for the test pattern procedure. A value of zero\n         indicates that no member link has been selected. \n         \n         When tmnxBundleImaGrpTestState does not have the value\n         'disabled', an attempt to set this object will be  \n         rejected with an inconsistentValue error.")
tmnxBundleImaGrpTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleImaGrpTestPattern.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpTestPattern.setDescription("tmnxBundleImaGrpTestPattern specifies the Transmit Test \n         Pattern in an IMA group loopback operation. This value \n         may only be changed when tmnxBundleImaGrpTestState is \n         'disabled'.")
tmnxBundleImaGrpDiffDelayMaxObs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 33), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpDiffDelayMaxObs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpDiffDelayMaxObs.setDescription('tmnxBundleImaGrpDiffDelayMaxObs indicates the latest \n         maximum differential delay observed between links \n         having the least and most link propagation delay \n         among the received links configured in this IMA group.')
tmnxBundleImaGrpLeastDelayLink = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 21, 1, 34), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleImaGrpLeastDelayLink.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleImaGrpLeastDelayLink.setDescription('tmnxBundleImaGrpLeastDelayLink indicates a member link \n         which has the smallest link propagation delay. If this\n         delay has yet to be determined or no member link has \n         been configured, a value of zero is returned.')
tmnxBundleMemberImaTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22), )
if mibBuilder.loadTexts: tmnxBundleMemberImaTable.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaTable.setDescription('The tmnxBundleMemberImaTable has an entry for an\n         IMA link associated with an IMA Group.')
tmnxBundleMemberImaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleBundleID"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxBundleMemberImaEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaEntry.setDescription('Each row entry represents an IMA link associated with \n         an IMA Group.')
tmnxBundleMemberImaNeTxState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 1), TmnxImaLnkState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeTxState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeTxState.setDescription('tmnxBundleMemberImaNeTxState indicates the state of near-end\n         transmit IMA link.')
tmnxBundleMemberImaNeRxState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 2), TmnxImaLnkState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxState.setDescription('tmnxBundleMemberImaNeRxState indicates the state of near-end\n         receive IMA link.')
tmnxBundleMemberImaFeTxState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 3), TmnxImaLnkState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeTxState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeTxState.setDescription('tmnxBundleMemberImaFeTxState indicates the state of far-end\n         transmit IMA link.')
tmnxBundleMemberImaFeRxState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 4), TmnxImaLnkState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxState.setDescription('tmnxBundleMemberImaFeRxState indicates the state of far-end\n         receive IMA link.')
tmnxBundleMemberImaNeRxFailState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 5), TmnxImaLnkFailState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxFailState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxFailState.setDescription('tmnxBundleMemberImaNeRxFailState indicates the IMA link failure\n         reason for the near-end.')
tmnxBundleMemberImaFeRxFailState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 6), TmnxImaLnkFailState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxFailState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxFailState.setDescription('tmnxBundleMemberImaFeRxFailState indicates the IMA link failure\n         reason for the far-end.')
tmnxBundleMemberImaTxLid = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaTxLid.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaTxLid.setDescription('tmnxBundleMemberImaTxLid indicates the Link Identifier\n         assigned to the transmit IMA link.')
tmnxBundleMemberImaRxLid = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaRxLid.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaRxLid.setDescription('tmnxBundleMemberImaRxLid indicates the Link Identifier\n         used on the receive IMA link.')
tmnxBundleMemberImaViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaViolations.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaViolations.setDescription('tmnxBundleMemberImaViolations indicates the number of\n         ICP violations including errored, invalid or missing ICP \n         cells.')
tmnxBundleMemberImaNeSevErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeSevErrSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeSevErrSecs.setDescription('tmnxBundleMemberImaNeSevErrSecs indicates the number \n         of one second intervals in which thirty percent or \n         more of the near-end ICP cells are in violation, or\n         link defects have occurred.')
tmnxBundleMemberImaFeSevErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeSevErrSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeSevErrSecs.setDescription('tmnxBundleMemberImaFeSevErrSecs indicates the number\n         of one second intervals in which the far-end contains\n         IMA-RDI defects.')
tmnxBundleMemberImaNeUnavailSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeUnavailSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeUnavailSecs.setDescription('tmnxBundleMemberImaNeUnavailSecs indicates the number\n         of unavailable seconds at the near-end.')
tmnxBundleMemberImaFeUnavailSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeUnavailSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeUnavailSecs.setDescription('tmnxBundleMemberImaFeUnavailSecs indicates the number\n         of unavailable seconds at the near-end.')
tmnxBundleMemberImaNeTxUnuseSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeTxUnuseSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeTxUnuseSecs.setDescription('tmnxBundleMemberImaNeTxUnuseSecs indicates the number\n         of unavailable seconds at the near-end transmit link\n         state machine.')
tmnxBundleMemberImaNeRxUnuseSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxUnuseSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxUnuseSecs.setDescription('tmnxBundleMemberImaNeRxUnuseSecs indicates the number\n         of unavailable seconds at the near-end receive link\n         state machine.')
tmnxBundleMemberImaFeTxUnuseSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeTxUnuseSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeTxUnuseSecs.setDescription('tmnxBundleMemberImaFeTxUnuseSecs indicates the number\n         of unavailable seconds at the far-end transmit link\n         state machine.')
tmnxBundleMemberImaFeRxUnuseSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxUnuseSecs.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxUnuseSecs.setDescription('tmnxBundleMemberImaFeRxUnuseSecs indicates the number\n         of unavailable seconds at the far-end receive link\n         state machine.')
tmnxBundleMemberImaNeTxNumFails = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeTxNumFails.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeTxNumFails.setDescription('tmnxBundleMemberImaNeTxNumFails indicates the number\n         of times that a near-end transmit alarm is set on the\n         IMA link.')
tmnxBundleMemberImaNeRxNumFails = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxNumFails.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaNeRxNumFails.setDescription('tmnxBundleMemberImaNeRxNumFails indicates the number\n         of times that a near-end receive alarm is set on the\n         IMA link.')
tmnxBundleMemberImaFeTxNumFails = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeTxNumFails.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeTxNumFails.setDescription('tmnxBundleMemberImaFeTxNumFails indicates the number\n         of times that a far-end transmit alarm is set on the\n         IMA link.')
tmnxBundleMemberImaFeRxNumFails = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxNumFails.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaFeRxNumFails.setDescription('tmnxBundleMemberImaFeRxNumFails indicates the number\n         of times that a far-end receive alarm is set on the\n         IMA link.')
tmnxBundleMemberImaTxIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaTxIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaTxIcpCells.setDescription('tmnxBundleMemberImaTxIcpCells indicates the number\n         of ICP cells that have been transmitted on the IMA\n         link.')
tmnxBundleMemberImaRxIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaRxIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaRxIcpCells.setDescription('tmnxBundleMemberImaRxIcpCells indicates the number\n         of ICP cells that have been received on the IMA\n         link.')
tmnxBundleMemberImaErrorIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaErrorIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaErrorIcpCells.setDescription('tmnxBundleMemberImaErrorIcpCells indicates the number\n         of ICP cells with HEC or CRC-10 errors.')
tmnxBundleMemberImaLstRxIcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaLstRxIcpCells.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaLstRxIcpCells.setDescription('tmnxBundleMemberImaLstRxIcpCells indicates the number\n         of lost ICP cells at the expected offset.')
tmnxBundleMemberImaOifAnomalies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaOifAnomalies.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaOifAnomalies.setDescription('tmnxBundleMemberImaOifAnomalies indicates the number\n         of OIF anomalies at the near-end.')
tmnxBundleMemberImaRxTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 27), TmnxImaTestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaRxTestState.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaRxTestState.setDescription('tmnxBundleMemberImaRxTestState indicates the current\n         state of the test pattern on this link.')
tmnxBundleMemberImaRxTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaRxTestPattern.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaRxTestPattern.setDescription('tmnxBundleMemberImaRxTestPattern indicates the received\n        test pattern value on this link.')
tmnxBundleMemberImaRelDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 22, 1, 29), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBundleMemberImaRelDelay.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMemberImaRelDelay.setDescription('tmnxBundleMemberImaRelDelay indicates the latest measured\n        delay on this member link relative to the member link with\n        the least delay within the same IMA group')
tmnxPortScalarObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 19))
tmnxL4LoadBalancing = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 19, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxL4LoadBalancing.setStatus('current')
if mibBuilder.loadTexts: tmnxL4LoadBalancing.setDescription("The value of tmnxL4LoadBalancing specifies whether layer 4 information,\n         src and dst ports, should be used in the LAG and ECMP hashing \n         algorithm. This is the global system setting that all ports will\n         inherit. When set to 'true', src and dst ports are used in the hashing\n         algorithm. The per port setting of tmnxPortLoadBalanceAlgorithm can \n         override tmnxL4LoadBalancing.")
tmnxDS1PortTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23), )
if mibBuilder.loadTexts: tmnxDS1PortTable.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortTable.setDescription('The tmnxDS1PortTable has an entry for a DS1 physical port.')
tmnxDS1PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxDS1PortEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortEntry.setDescription("Each row entry represents a physical DS1 port on a \n         IOM card in a chassis in the system.  Entries cannot be created \n         and deleted via SNMP SET operations.  Entries in this table will \n         be created automatically when the tmnxMDAAssignedType object is \n         set to the DS1 MDA type The tmnxDS1PortEntry contains attributes\n         that are unique to the 'ds1e1' TmnxPortType. The tmnxPortPortID\n         contains the slot, mda and port numbers encoded into it.\n\n         For each tmnxDS1PortEntry, there will be a corresponding entry \n         in the tmnxPortTable and the ifTable.")
tmnxDS1PortBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("short", 1), ("long", 2))).clone('short')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1PortBuildout.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortBuildout.setDescription("tmnxDS1PortBuildout configures the cable buildout length.  A ds1 port\n         has two settings for the DS1 cable buildout: a 'short' setting, for\n         cable lengths of less than or equal to 655 feet, and a 'long' setting\n         for cable lengths of greater than 655 feet.\n         This object applies to copper-cable-based DS1 ports only.")
tmnxDS1PortLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1PortLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortLastChangeTime.setDescription('The tmnxDS1PortLastChangeTime variable contains the sysUpTime\n         value of the most recently modified writable variable in the\n         tmnxDS1PortEntry row for this port.')
tmnxDS1PortType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ds1", 1), ("e1", 2), ("j1", 3))).clone('ds1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1PortType.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortType.setDescription("tmnxDS1PortType configures the type of the physical port to 'ds1',\n         'e1' or 'j1'.")
tmnxDS1PortLineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lengthNotApplicable", 1), ("length0To133", 2), ("length134To266", 3), ("length267To399", 4), ("length400To533", 5), ("length534To655", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1PortLineLength.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortLineLength.setDescription("tmnxDS1PortLineLength configuration only applies to a ds1 port\n         configured with a 'short' buildout.  tmnxDS1PortLineLength configures\n         the length of the line (in feet).  For line lengths longer than 655\n         feet configure the ds1 port buildout as 'long'.\n         For 'long' buildout the following values are valid:\n             lengthNotApplicable - Not applicable\n         For 'short' buildout the following values are valid:\n             length0To133        - For line length from 0 to 133 feet\n             length134To266      - For line length from 134 to 266 feet\n             length267To399      - For line length from 267 to 399 feet\n             length400To533      - For line length from 400 to 533 feet\n             length534To655      - For line length from 534 to 655 feet\n         The default for 'long' buildout is 'lengthNotApplicable' while the\n         default for 'short' buildout is 'length0To133'.")
tmnxDS1PortLbo = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("lboNotApplicable", 1), ("lbo0dB", 2), ("lboNeg7p5dB", 3), ("lboNeg15p0dB", 4), ("lboNeg22p5dB", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxDS1PortLbo.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortLbo.setDescription("tmnxDS1PortLbo configuration only applies to a ds1 port\n         configured with a 'long' buildout.  tmnxDS1PortLbo configures the\n         number of decibels(dB) the transmission signal decreases over the line.\n         For 'short' buildout the following values are valid:\n             lboNotApplicable - Not applicable\n         For 'long' buildout the following values are valid:\n             lbo0dB           - For 0 dB\n             lboNeg7p5dB      - For -7.5 dB\n             lboNeg15p0dB     - For -15.0 dB\n             lboNeg22p5dB     - For -22.5 dB\n         The default for 'short' build out is 'lboNotApplicable' while the\n         default for 'long' buildout is 'lbo0dB'")
tmnxDS1PortDbGain = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 23, 1, 6), Integer32()).setUnits('db').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDS1PortDbGain.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1PortDbGain.setDescription("tmnxDS1PortDbGain only applies to a ds1 port configured with a\n         'long' buildout.  tmnxDS1PortDbGain shows the number of decibels\n         the received signal is increased to compensate for loss.")
tmnxPortSchedOverrideTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24), )
if mibBuilder.loadTexts: tmnxPortSchedOverrideTable.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideTable.setDescription('The tmnxPortSchedOverrideTable has an entry for each port \n         scheduler override configured on this system.')
tmnxPortSchedOverrideEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxPortSchedOverrideEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideEntry.setDescription('Each row represents a particular port-scheduler override. Entries\n         are created and deleted by the user.')
tmnxPortSchedOverrideRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideRowStatus.setDescription('The value of tmnxPortSchedOverrideRowStatus is used for the \n         creation and deletion of port-scheduler overrides. When\n         tmnxPortEgrPortSchedPlcy of the tmnxPortEntry indexed by the \n         same indices of this table is an empty string, creation\n         will fail.')
tmnxPortSchedOverrideSchedName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSchedOverrideSchedName.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideSchedName.setDescription('The value of tmnxPortSchedOverrideSchedName indicates the name\n         of the port scheduler policy that this row entry overrides.')
tmnxPortSchedOverrideLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLastChanged.setDescription('The value of tmnxPortSchedOverrideLastChanged indicates the value\n         of sysUpTime at the time of the most recent management change to \n         this row.')
tmnxPortSchedOverrideMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 4), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideMaxRate.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideMaxRate.setDescription('The value of tmnxPortSchedOverrideMaxRate specifies the explicit\n         maximum frame based bandwidth limit. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyMaxRate.')
tmnxPortSchedOverrideLvl1PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 5), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl1PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl1PIR.setDescription('The value of tmnxPortSchedOverrideLvl1PIR specifies the total \n         bandwidth limit, PIR, for priority level 1. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl1PIR.')
tmnxPortSchedOverrideLvl1CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 6), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl1CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl1CIR.setDescription('The value of tmnxPortSchedOverrideLvl1CIR specifies the within-cir\n         bandwidth limit for priority level 1. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl1CIR.')
tmnxPortSchedOverrideLvl2PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 7), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl2PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl2PIR.setDescription('The value of tmnxPortSchedOverrideLvl2PIR specifies the total \n         bandwidth limit, PIR, for priority level 2. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl2PIR.')
tmnxPortSchedOverrideLvl2CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 8), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl2CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl2CIR.setDescription('The value of tmnxPortSchedOverrideLvl2CIR specifies the within-cir\n         bandwidth limit for priority level 2. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl2CIR.')
tmnxPortSchedOverrideLvl3PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 9), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl3PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl3PIR.setDescription('The value of tmnxPortSchedOverrideLvl3PIR specifies the total \n         bandwidth limit, PIR, for priority level 3. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl3PIR.')
tmnxPortSchedOverrideLvl3CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 10), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl3CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl3CIR.setDescription('The value of tmnxPortSchedOverrideLvl3CIR specifies the within-cir\n         bandwidth limit for priority level 3. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl3CIR.')
tmnxPortSchedOverrideLvl4PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 11), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl4PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl4PIR.setDescription('The value of tmnxPortSchedOverrideLvl4PIR specifies the total \n         bandwidth limit, PIR, for priority level 4. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl4PIR.')
tmnxPortSchedOverrideLvl4CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 12), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl4CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl4CIR.setDescription('The value of tmnxPortSchedOverrideLvl4CIR specifies the within-cir\n         bandwidth limit for priority level 4. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl4CIR.')
tmnxPortSchedOverrideLvl5PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 13), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl5PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl5PIR.setDescription('The value of tmnxPortSchedOverrideLvl5PIR specifies the total \n         bandwidth limit, PIR, for priority level 5. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl5PIR.')
tmnxPortSchedOverrideLvl5CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 14), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl5CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl5CIR.setDescription('The value of tmnxPortSchedOverrideLvl5CIR specifies the within-cir\n         bandwidth limit for priority level 5. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl5CIR.')
tmnxPortSchedOverrideLvl6PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 15), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl6PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl6PIR.setDescription('The value of tmnxPortSchedOverrideLvl6PIR specifies the total \n         bandwidth limit, PIR, for priority level 6. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl6PIR.')
tmnxPortSchedOverrideLvl6CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 16), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl6CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl6CIR.setDescription('The value of tmnxPortSchedOverrideLvl6CIR specifies the within-cir\n         bandwidth limit for priority level 6. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl6CIR.')
tmnxPortSchedOverrideLvl7PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 17), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl7PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl7PIR.setDescription('The value of tmnxPortSchedOverrideLvl7PIR specifies the total \n         bandwidth limit, PIR, for priority level 7. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl7PIR.')
tmnxPortSchedOverrideLvl7CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 18), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl7CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl7CIR.setDescription('The value of tmnxPortSchedOverrideLvl7CIR specifies the within-cir\n         bandwidth limit for priority level 7. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl7CIR.')
tmnxPortSchedOverrideLvl8PIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 19), TPortSchedulerPIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl8PIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl8PIR.setDescription('The value of tmnxPortSchedOverrideLvl8PIR specifies the total \n         bandwidth limit, PIR, for priority level 8. This object \n         overrides ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl8PIR.')
tmnxPortSchedOverrideLvl8CIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 20), TPortSchedulerCIR().clone(-1)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl8CIR.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideLvl8CIR.setDescription('The value of tmnxPortSchedOverrideLvl8CIR specifies the within-cir\n         bandwidth limit for priority level 8. This object overrides\n         ALCATEL-IND1-TIMETRA-QOS-MIB::tPortSchedulerPlcyLvl8CIR.')
tmnxPortSchedOverrideFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 24, 1, 21), Bits().clone(namedValues=NamedValues(("maxRate", 0), ("lvl1PIR", 1), ("lvl1CIR", 2), ("lvl2PIR", 3), ("lvl2CIR", 4), ("lvl3PIR", 5), ("lvl3CIR", 6), ("lvl4PIR", 7), ("lvl4CIR", 8), ("lvl5PIR", 9), ("lvl5CIR", 10), ("lvl6PIR", 11), ("lvl6CIR", 12), ("lvl7PIR", 13), ("lvl7CIR", 14), ("lvl8PIR", 15), ("lvl8CIR", 16)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxPortSchedOverrideFlags.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedOverrideFlags.setDescription("The value of tmnxPortSchedOverrideFlags specifies the set of \n         attributes whose values have been overridden via management \n         on this port scheduler. Clearing a given flag will return the \n         corresponding overridden attribute to the value defined in \n         the port's port-scheduler policy.")
tmnxBPGrpAssocTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 25), )
if mibBuilder.loadTexts: tmnxBPGrpAssocTable.setStatus('current')
if mibBuilder.loadTexts: tmnxBPGrpAssocTable.setDescription('The tmnxBPGrpAssocTable has an entry for each Bundle Protection Group created \n         on the system.')
tmnxBPGrpAssocEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 25, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleBundleID"))
if mibBuilder.loadTexts: tmnxBPGrpAssocEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxBPGrpAssocEntry.setDescription('Each row displays the relationship between a Bundle Protection \n         group and its working and protection bundle.')
tmnxBPGrpAssocWorkingBundleID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 25, 1, 1), TmnxBundleID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBPGrpAssocWorkingBundleID.setStatus('current')
if mibBuilder.loadTexts: tmnxBPGrpAssocWorkingBundleID.setDescription('tmnxBPGrpAssocWorkingBundleID identifies the working bundle. A value\n         of zero is given if no working bundle is associated with the given\n         tmnxBundleBundleID.')
tmnxBPGrpAssocProtectBundleID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 25, 1, 2), TmnxBundleID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBPGrpAssocProtectBundleID.setStatus('current')
if mibBuilder.loadTexts: tmnxBPGrpAssocProtectBundleID.setDescription('tmnxBPGrpAssocProtectBundleID identifies the protection bundle. A value\n         of zero is given if no protection bundle is associated with the given \n         tmnxBundleBundleID.')
tmnxBPGrpAssocActiveBundleID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 25, 1, 3), TmnxBundleID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxBPGrpAssocActiveBundleID.setStatus('current')
if mibBuilder.loadTexts: tmnxBPGrpAssocActiveBundleID.setDescription('tmnxBPGrpAssocActiveBundleID identifies the bundle that is considered\n         the active bundle. This bundle contains the members that are part of the\n         active aps port. A value of zero is given if no bundle is considered active.')
tmnxBundleMlpppTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 26), )
if mibBuilder.loadTexts: tmnxBundleMlpppTable.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMlpppTable.setDescription('The tmnxBundleMlpppTable contains MLPPP specific data.')
tmnxBundleMlpppEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 26, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleBundleID"))
if mibBuilder.loadTexts: tmnxBundleMlpppEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMlpppEntry.setDescription('Each row entry contains data on an MLPPP Bundle.')
tmnxBundleMlpppEndpointID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 26, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMlpppEndpointID.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMlpppEndpointID.setDescription("tmnxBundleMlpppEndpointID indentifies the Endpoint Discriminator\n         identifier value within the specified tmnxBundleMlpppEndpointIDClass.\n         The object tmnxPortAdminStatus must be set to 'outOfService' to \n         change this value.")
tmnxBundleMlpppEndpointIDClass = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 26, 1, 2), TmnxMlpppEndpointIdClass()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMlpppEndpointIDClass.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMlpppEndpointIDClass.setDescription("tmnxBundleMlpppEndpointIDClass specifies the Link Control\n         Protocol Endpoint Descriminator Class field type of the \n         tmnxBundleMlpppEndpointID. The object tmnxPortAdminStatus \n         must be set to 'outOfService' to change this value.\n         \n                    Bundle                     DEFVAL\n            Physical MLPPP Bundle           ieee802dot1GlobalMacAddress (3)\n            MLPPP Bundle Protection Group   ipAddress (2)\n         ")
tmnxBundleMlpppClassCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 26, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMlpppClassCount.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMlpppClassCount.setDescription("The value of tmnxBundleMlpppClassCount specifies\n         whether Multiclass MLPPP is enabled on\n         a bundle with a tmnxBundleType of 'mlppp' and when enabled what is the\n         number of classes to be negotiated/supported over the MLPPP bundle. \n        \n         The value of 0 disables multiclass MLPPP including negotiation in\n         the PPP protocol.\n         All other values specify the number of classes to be supported\n         on a given multiclass bundle and enable Multiclass MLPPP negotiation \n         on that bundle.\n        \n         Non-zero values supported are platform/MDA specific.\n        \n         The value of tmnxBundleMlpppClassCount must be set to 0 and cannot be \n         changed when LFI is enabled on the bundle (see tmnxBundleLFI object \n         in tmnxBundleTable).\n        \n         The value of tmnxBundleMlpppClassCount may be modified only when \n         tmnxBundleNumLinks is zero.\n    \n         To set the value of tmnxBundleMlpppClassCount to a value greater\n         than 4, the long sequence format must be enabled on the bundle (see \n         tmnxBundleShortSequence object in tmnxBundleTable).\n         \n         Changing the value of tmnxBundleMlpppClassCount resets the values of\n         tmnxBundleMlpppIngQoSProfId and tmnxBundleMlpppEgrQoSProfId to their\n         defaults")
tmnxBundleMlpppIngQoSProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 26, 1, 4), TMlpppQoSProfileId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMlpppIngQoSProfId.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMlpppIngQoSProfId.setDescription('tmnxBundleMlpppIngQoSProfId specifies ingress QoS profile\n         to be used for the incoming traffic over this MLPPP\n         bundle.\n         \n         The value of tmnxBundleMlpppIngQoSProfId may be modified only \n         when the value of tmnxBundleNumLinks is 0.\n\n         The value of tmnxBundleMlpppIngQoSProfId of 0 indicates\n         a default QoS profile is used as applicable to a given H/W and\n         the configured value of tmnxBundleMlpppClassCount.')
tmnxBundleMlpppEgrQoSProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 26, 1, 5), TMlpppQoSProfileId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxBundleMlpppEgrQoSProfId.setStatus('current')
if mibBuilder.loadTexts: tmnxBundleMlpppEgrQoSProfId.setDescription('tmnxBundleMlpppEgrQoSProfId specifies egress QoS profile\n         to be used for the outgoing traffic over this MLPPP\n         bundle.\n         \n         The value of tmnxBundleMlpppEgrQoSProfId may be modified only \n         when tmnxBundleNumLinks is zero.\n\n         The value of tmnxBundleMlpppEgrQoSProfId of 0 indicates\n         a default profile is used as applicable to a given H/W and\n         the configured value of tmnxBundleMlpppClassCount.')
tmnxDigitalDiagMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31), )
if mibBuilder.loadTexts: tmnxDigitalDiagMonitorTable.setStatus('current')
if mibBuilder.loadTexts: tmnxDigitalDiagMonitorTable.setDescription('The tmnxDigitalDiagMonitorTable has an entry for each SFP/XFP in the\n         system that supports Digital Diagnostic Monitoring (DDM). The table is\n         indexed by TmnxPortID. Each row in this table is dynamically added\n         and removed internally by the system based on the presence or absence\n         of DDM capable SFP/XFP components.')
tmnxDigitalDiagMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPortID"))
if mibBuilder.loadTexts: tmnxDigitalDiagMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxDigitalDiagMonitorEntry.setDescription('Each row represents a particular SFP/XFP that supports Digital\n         Diagnostic Monitoring.\n         Entries are created and deleted internally by the system.')
tmnxDDMTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTemperature.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTemperature.setDescription('The value of tmnxDDMTemperature indicates the current temperature\n         of the SFP/XFP in degrees Celsius.')
tmnxDDMTempLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTempLowWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTempLowWarning.setDescription('The value of tmnxDDMTempLowWarning indicates the temperature\n         of the SFP/XFP in degrees Celsius that triggers a low-warning.')
tmnxDDMTempLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTempLowAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTempLowAlarm.setDescription('The value of tmnxDDMTempLowAlarm indicates the temperature\n         of the SFP/XFP in degrees Celsius that triggers a low-alarm.')
tmnxDDMTempHiWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTempHiWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTempHiWarning.setDescription('The value of tmnxDDMTempHiWarning indicates the temperature\n         of the SFP/XFP in degrees Celsius that triggers a hi-warning.')
tmnxDDMTempHiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTempHiAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTempHiAlarm.setDescription('The value of tmnxDDMTempHiAlarm indicates the temperature\n         of the SFP/XFP in degrees Celsius that triggers a hi-alarm.')
tmnxDDMSupplyVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMSupplyVoltage.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMSupplyVoltage.setDescription('The value of tmnxDDMSupplyVoltage indicates the current supply\n         voltage of the SFP/XFP in micro-Volts (uV).')
tmnxDDMSupplyVoltageLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageLowWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageLowWarning.setDescription('The value of tmnxDDMSupplyVoltageLowWarning indicates the supply\n         voltage of the SFP/XFP in micro-Volts (uV) that triggers a low-warning.')
tmnxDDMSupplyVoltageLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageLowAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageLowAlarm.setDescription('The value of tmnxDDMSupplyVoltageLowAlarm indicates the supply\n         voltage of the SFP/XFP in micro-Volts (uV) that triggers a low-alarm.')
tmnxDDMSupplyVoltageHiWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageHiWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageHiWarning.setDescription('The value of tmnxDDMSupplyVoltageHiWarning indicates the supply\n         voltage of the SFP/XFP in micro-Volts (uV) that triggers a hi-warning.')
tmnxDDMSupplyVoltageHiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageHiAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMSupplyVoltageHiAlarm.setDescription('The value of tmnxDDMSupplyVoltageHiAlarm indicates the supply\n         voltage of the SFP/XFP in micro-Volts (uV) that triggers a hi-alarm.')
tmnxDDMTxBiasCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrent.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrent.setDescription('The value of tmnxDDMTxBiasCurrent indicates the current Transmit\n         Bias Current of the SFP/XFP in micro-Amperes (uA).')
tmnxDDMTxBiasCurrentLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentLowWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentLowWarning.setDescription('The value of tmnxDDMTxBiasCurrentLowWarning indicates the Transmit\n         Bias Current of the SFP/XFP in micro-Amperes (uA) that triggers a\n         low-warning.')
tmnxDDMTxBiasCurrentLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentLowAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentLowAlarm.setDescription('The value of tmnxDDMTxBiasCurrentLowAlarm indicates the Transmit\n         Bias Current of the SFP/XFP in micro-Amperes (uA) that triggers a\n         low-alarm.')
tmnxDDMTxBiasCurrentHiWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentHiWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentHiWarning.setDescription('The value of tmnxDDMTxBiasCurrentHiWarning indicates the Transmit\n         Bias Current of the SFP/XFP in micro-Amperes (uA) that triggers a\n         hi-warning.')
tmnxDDMTxBiasCurrentHiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentHiAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxBiasCurrentHiAlarm.setDescription('The value of tmnxDDMTxBiasCurrentHiAlarm indicates the Transmit\n         Bias Current of the SFP/XFP in micro-Amperes (uA) that triggers a\n         hi-alarm.')
tmnxDDMTxOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxOutputPower.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxOutputPower.setDescription('The value of tmnxDDMTxOutputPower indicates the current Output\n         Power of the SFP/XFP in micro-Watts (uW).')
tmnxDDMTxOutputPowerLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerLowWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerLowWarning.setDescription('The value of tmnxDDMTxOutputPowerLowWarning indicates the Output Power\n         of the SFP/XFP in micro-Watts (uW) that triggers a low-warning.')
tmnxDDMTxOutputPowerLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerLowAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerLowAlarm.setDescription('The value of tmnxDDMTxOutputPowerLowAlarm indicates the Output Power\n         of the SFP/XFP in micro-Watts (uW) that triggers a low-alarm.')
tmnxDDMTxOutputPowerHiWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerHiWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerHiWarning.setDescription('The value of tmnxDDMTxOutputPowerHiWarning indicates the Output Power\n         of the SFP/XFP in micro-Watts (uW) that triggers a hi-alarm.')
tmnxDDMTxOutputPowerHiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerHiAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMTxOutputPowerHiAlarm.setDescription('The value of tmnxDDMTxOutputPowerHiAlarm indicates the Output Power\n         of the SFP/XFP in micro-Watts (uW) that triggers a hi-alarm.')
tmnxDDMRxOpticalPower = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMRxOpticalPower.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMRxOpticalPower.setDescription('The value of tmnxDDMRxOpticalPower indicates the current Received\n         Optical Power of the SFP/XFP in micro-Watts (uW).')
tmnxDDMRxOpticalPowerLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerLowWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerLowWarning.setDescription('The value of tmnxDDMRxOpticalPowerLowWarning indicates the Received\n         Optical Power of the SFP/XFP in micro-Watts (uW) that triggers a\n         low-warning.')
tmnxDDMRxOpticalPowerLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerLowAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerLowAlarm.setDescription('The value of tmnxDDMRxOpticalPowerLowAlarm indicates the Received\n         Optical Power of the SFP/XFP in micro-Watts (uW) that triggers a\n         low-alarm.')
tmnxDDMRxOpticalPowerHiWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerHiWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerHiWarning.setDescription('The value of tmnxDDMRxOpticalPowerHiWarning indicates the Received\n         Optical Power of the SFP/XFP in micro-Watts (uW) that triggers a\n         hi-warning.')
tmnxDDMRxOpticalPowerHiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerHiAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerHiAlarm.setDescription('The value of tmnxDDMRxOpticalPowerHiAlarm indicates the Received\n         Optical Power of the SFP/XFP in micro-Watts (uW) that triggers a\n         hi-alarm.')
tmnxDDMRxOpticalPowerType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("oma", 0), ("average", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerType.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMRxOpticalPowerType.setDescription('The value of tmnxDDMRxOpticalPowerType indicates whether the\n         tmnxDDMRxOpticalPower was taken as an average, or as an Optical\n         Modulation Amplitude (OMA).')
tmnxDDMAux1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux1.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux1.setDescription('The value of tmnxDDMAux1 indicates the Manufacturer specific\n         Auxiliary 1 information of the XFP.')
tmnxDDMAux1LowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux1LowWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux1LowWarning.setDescription('The value of tmnxDDMAux1LowWarning indicates the Manufacturer specific\n         Auxiliary 1 low-warning threshold for the XFP.')
tmnxDDMAux1LowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux1LowAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux1LowAlarm.setDescription('The value of tmnxDDMAux1LowAlarm indicates the Manufacturer specific\n         Auxiliary 1 low-alarm threshold for the XFP.')
tmnxDDMAux1HiWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux1HiWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux1HiWarning.setDescription('The value of tmnxDDMAux1HiWarning indicates the Manufacturer specific\n         Auxiliary 1 hi-warning threshold for the XFP.')
tmnxDDMAux1HiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux1HiAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux1HiAlarm.setDescription('The value of tmnxDDMAux1HiAlarm indicates the Manufacturer specific\n         Auxiliary 1 hi-alarm threshold for the XFP.')
tmnxDDMAux1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 0), ("adp-bias-voltage", 1), ("reserved-2", 2), ("tec-current", 3), ("laser-temp", 4), ("laser-wavelength", 5), ("voltage-50", 6), ("voltage-33", 7), ("voltage-18", 8), ("voltage-52", 9), ("current-50", 10), ("reserved-11", 11), ("reserved-12", 12), ("current-33", 13), ("current-18", 14), ("current-52", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux1Type.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux1Type.setDescription('The value of tmnxDDMAux1Type indicates the measurement type of\n         the Manufacturer specific Auxiliary 1 information of the XFP:\n            none             (0)  - not specified.\n            adp-bias-voltage (1)  - LSB is 10mV.\n            reserved-2       (2)  - reserved for future use.\n            tec-current      (3)  - LSB is 100uA.\n            laser-temp       (4)  - degrees Celsius(C).\n            laser-wavelength (5)  - LSB is 0.05 nm.\n            voltage-50       (6)  - 5.0 supply voltage, LSB=100uV.\n            voltage-33       (7)  - 3.3 supply voltage, LSB=100uV.\n            voltage-18       (8)  - 1.8 supply voltage, LSB=100uV,\n            voltage-52       (9)  - -5.2 supply voltage, LSB=100uV.\n            current-50      (10)  - 5.0V supply current, LSB=100uA.\n            reserved-11     (11)  - reserved for future use.\n            reserved-12     (12)  - reserved for future use.\n            current-33      (13)  - 3.3V supply current, LSB=100uA.\n            current-18      (14)  - 1.8V supply current, LSB=100uA.\n            current-52      (15)  - -5.2V supply current, LSB=100uA.')
tmnxDDMAux2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux2.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux2.setDescription('The value of tmnxDDMAux2 indicates the Manufacturer specific\n         Auxiliary 2 information of the SFP/XFP.')
tmnxDDMAux2LowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux2LowWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux2LowWarning.setDescription('The value of tmnxDDMAux2LowWarning indicates the Manufacturer specific\n         Auxiliary 2 low-warning threshold for the XFP.')
tmnxDDMAux2LowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux2LowAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux2LowAlarm.setDescription('The value of tmnxDDMAux2LowAlarm indicates the Manufacturer specific\n         Auxiliary 2 low-alarm threshold for the XFP.')
tmnxDDMAux2HiWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux2HiWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux2HiWarning.setDescription('The value of tmnxDDMAux2HiWarning indicates the Manufacturer specific\n         Auxiliary 2 hi-warning threshold for the XFP.')
tmnxDDMAux2HiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux2HiAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux2HiAlarm.setDescription('The value of tmnxDDMAux2HiAlarm indicates the Manufacturer specific\n         Auxiliary 2 hi-alarm threshold for the XFP.')
tmnxDDMAux2Type = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 0), ("adp-bias-voltage", 1), ("reserved-2", 2), ("tec-current", 3), ("laser-temp", 4), ("laser-wavelength", 5), ("voltage-50", 6), ("voltage-33", 7), ("voltage-18", 8), ("voltage-52", 9), ("current-50", 10), ("reserved-11", 11), ("reserved-12", 12), ("current-33", 13), ("current-18", 14), ("current-52", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMAux2Type.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMAux2Type.setDescription('The value of tmnxDDMAux2Type indicates the measurement type of\n         the Manufacturer specific Auxiliary 2 information of the XFP:\n            none             (0)  - not specified.\n            adp-bias-voltage (1)  - LSB is 10mV.\n            reserved-2       (2)  - reserved for future use.\n            tec-current      (3)  - LSB is 100uA.\n            laser-temp       (4)  - degrees Celsius(C).\n            laser-wavelength (5)  - LSB is 0.05 nm.\n            voltage-50       (6)  - 5.0 supply voltage, LSB=100uV.\n            voltage-33       (7)  - 3.3 supply voltage, LSB=100uV.\n            voltage-18       (8)  - 1.8 supply voltage, LSB=100uV,\n            voltage-52       (9)  - -5.2 supply voltage, LSB=100uV.\n            current-50      (10)  - 5.0V supply current, LSB=100uA.\n            reserved-11     (11)  - reserved for future use.\n            reserved-12     (12)  - reserved for future use.\n            current-33      (13)  - 3.3V supply current, LSB=100uA.\n            current-18      (14)  - 1.8V supply current, LSB=100uA.\n            current-52      (15)  - -5.2V supply current, LSB=100uA.')
tmnxDDMFailedThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 39), Bits().clone(namedValues=NamedValues(("unknown", 0), ("temperature-low-warning", 1), ("temperature-low-alarm", 2), ("temperature-high-warning", 3), ("temperature-high-alarm", 4), ("supplyVoltage-low-warning", 5), ("supplyVoltage-low-alarm", 6), ("supplyVoltage-high-warning", 7), ("supplyVoltage-high-alarm", 8), ("txBiasCurrent-low-warning", 9), ("txBiasCurrent-low-alarm", 10), ("txBiasCurrent-high-warning", 11), ("txBiasCurrent-high-alarm", 12), ("txOutputPower-low-warning", 13), ("txOutputPower-low-alarm", 14), ("txOutputPower-high-warning", 15), ("txOutputPower-high-alarm", 16), ("rxOpticalPower-low-warning", 17), ("rxOpticalPower-low-alarm", 18), ("rxOpticalPower-high-warning", 19), ("rxOpticalPower-high-alarm", 20), ("aux1-low-warning", 21), ("aux1-low-alarm", 22), ("aux1-high-warning", 23), ("aux1-high-alarm", 24), ("aux2-low-warning", 25), ("aux2-low-alarm", 26), ("aux2-high-warning", 27), ("aux2-high-alarm", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMFailedThresholds.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMFailedThresholds.setDescription('The value of tmnxDDMFailedThresholds indicates which objects\n        of the monitored SFP/XFP is in a failed or cleared threshold state.\n        A set bit indicates that the specified threshold has been exceeded.')
tmnxDDMExternallyCalibrated = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 40), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExternallyCalibrated.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExternallyCalibrated.setDescription('The value of tmnxDDMExternallyCalibrated indicates whether the\n         SFP was externally calibrated (true) or internally calibrated (false).')
tmnxDDMExtCalRxPower4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 41), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower4.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower4.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower4.setDescription("The value of tmnxDDMExtCalRxPower4 indicates the Rx_PWR(4)\n         value as specified in Table 3.16 in the SFF Committee Standard's\n         document SFF-8472 Rev 10.2.")
tmnxDDMExtCalRxPower3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 42), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower3.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower3.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower3.setDescription("The value of tmnxDDMExtCalRxPower3 indicates the Rx_PWR(3)\n         value as specified in Table 3.16 in the SFF Committee Standard's\n         document SFF-8462 Rev 10.2.")
tmnxDDMExtCalRxPower2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 43), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower2.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower2.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower2.setDescription("The value of tmnxDDMExtCalRxPower2 indicates the Rx_PWR(2)\n         value as specified in Table 3.16 in the SFF Committee Standard's\n         document SFF-8472 Rev 10.2.")
tmnxDDMExtCalRxPower1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 44), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower1.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower1.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower1.setDescription("The value of tmnxDDMExtCalRxPower1 indicates the Rx_PWR(1)\n         value as specified in Table 3.16 in the SFF Committee Standard's\n         document SFF-8472 Rev 10.2.")
tmnxDDMExtCalRxPower0 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 45), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower0.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower0.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalRxPower0.setDescription("The value of tmnxDDMExtCalRxPower0 indicates the Rx_PWR(0)\n         value as specified in Table 3.16 in the SFF Committee Standard's\n         document SFF-8472 Rev 10.2.")
tmnxDDMExtCalTxLaserBiasSlope = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 46), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalTxLaserBiasSlope.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalTxLaserBiasSlope.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalTxLaserBiasSlope.setDescription("The value of tmnxDDMExtCalTxLaserBiasSlope indicates the\n         Tx_l(Slope) value as specified in Table 3.16 in the SFF\n         Committee Standard's document SFF-8472 Rev 10.2.")
tmnxDDMExtCalTxLaserBiasOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32767, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalTxLaserBiasOffset.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalTxLaserBiasOffset.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalTxLaserBiasOffset.setDescription("The value of tmnxDDMExtCalTxLaserBiasOffset indicates the\n         Tx_l(Offset) value as specified in Table 3.16 in the SFF\n         Committee Standard's document SFF-8472 Rev 10.2.")
tmnxDDMExtCalTxPowerSlope = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 48), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalTxPowerSlope.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalTxPowerSlope.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalTxPowerSlope.setDescription("The value of tmnxDDMExtCalTxPowerSlope indicates the\n         Tx_PWR(Slope) value as specified in Table 3.16 in the\n         SFF Committee Standard's document SFF-8472 Rev 10.2.")
tmnxDDMExtCalTxPowerOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32767, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalTxPowerOffset.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalTxPowerOffset.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalTxPowerOffset.setDescription("The value of tmnxDDMExtCalTxPowerOffset indicates the\n         Tx_PWR(Offset) value as specified in Table 3.16 in the\n         SFF Committee Standard's document SFF-8472 Rev 10.2.")
tmnxDDMExtCalTemperatureSlope = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalTemperatureSlope.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalTemperatureSlope.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalTemperatureSlope.setDescription("The value of tmnxDDMExtCalTemperatureSlope indicates the\n         T(Slope) value as specified in Table 3.16 in the SFF\n         Committee Standard's document SFF-8472 Rev 10.2.")
tmnxDDMExtCalTemperatureOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32767, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalTemperatureOffset.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalTemperatureOffset.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalTemperatureOffset.setDescription("The value of tmnxDDMExtCalTemperatureOffset indicates the\n         T(Offset) value as specified in Table 3.16 in the SFF\n         Committee Standard's document SFF-8472 Rev 10.2.")
tmnxDDMExtCalVoltageSlope = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 52), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalVoltageSlope.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalVoltageSlope.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalVoltageSlope.setDescription("The value of tmnxDDMExtCalVoltageSlope indicates the V(Slope)\n        value as specified in Table 3.16 in the SFF Committee Standard's\n        document SFF-8472 Rev 10.2.")
tmnxDDMExtCalVoltageOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 4, 31, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32767, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDDMExtCalVoltageOffset.setReference('SFF-8472 Rev 10.2')
if mibBuilder.loadTexts: tmnxDDMExtCalVoltageOffset.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMExtCalVoltageOffset.setDescription("The value of tmnxDDMExtCalVoltageOffset indicates the V(Slope)\n        value as specified in Table 3.16 in the SFF Committee Standard's\n        document SFF-8472 Rev 10.2.")
tmnxPortNotifyPortId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 1), TmnxPortID()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifyPortId.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyPortId.setDescription('Used by tmnx port Notifications, the OID indicates the\n         port or sonet path associated with the alarm.')
tmnxPortNotifySonetAlarmReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("notUsed", 0), ("loc", 1), ("lais", 2), ("lrdi", 3), ("ss1f", 4), ("sb1err", 5), ("lb2erSd", 6), ("lb2erSf", 7), ("slof", 8), ("slos", 9), ("stxptr", 10), ("srxptr", 11), ("lrei", 12)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifySonetAlarmReason.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifySonetAlarmReason.setDescription('Used by tmnx sonet Port Notifications, the value of\n         tmnxPortNotifySonetAlarmReason indicates the reason a sonet port\n         alarm has been raised.')
tmnxPortNotifySonetPathAlarmReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notUsed", 0), ("pais", 1), ("plop", 2), ("prdi", 3), ("pb3err", 4), ("pplm", 5), ("prei", 6), ("puneq", 7), ("plcd", 8)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifySonetPathAlarmReason.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifySonetPathAlarmReason.setDescription('Used by tmnx sonet path Notifications, the value of\n         tmnxPortNotifySonetPathAlarmReason indicates the reason a sonet path\n         alarm has been raised.')
tmnxPortNotifyError = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("txClockError", 1), ("rxClockError", 2), ("txFifoError", 3), ("laserError", 4), ("miscError", 5)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifyError.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyError.setDescription('Used by tmnxEqPortError notification, the value of \n         tmnxPortNotifyError indicates the reason a port has\n         an error.')
tmnxPortNotifyDS3AlarmReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notUsed", 0), ("ais", 1), ("los", 2), ("oof", 3), ("rai", 4), ("looped", 5)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifyDS3AlarmReason.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyDS3AlarmReason.setDescription('Used by tmnx DS3 Port Notifications, the value of\n         tmnxPortNotifyDS3AlarmReason indicates the reason a DS3 interface\n         alarm has been raised.')
tmnxPortNotifyDS1AlarmReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notUsed", 0), ("ais", 1), ("los", 2), ("oof", 3), ("rai", 4), ("looped", 5), ("berSd", 6), ("berSf", 7)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifyDS1AlarmReason.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyDS1AlarmReason.setDescription('Used by tmnx DS1 Port Notifications, the value of\n         tmnxPortNotifyDS1AlarmReason indicates the reason a DS1 interface\n         alarm has been raised.')
tmnxPortNotifyBundleId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 7), TmnxBundleID()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifyBundleId.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyBundleId.setDescription('Used by tmnx bundle Notifications, the value indicates the\n         bundle associated with the alarm.')
tmnxPortNotifyEtherAlarmReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 8), TmnxPortEtherReportValue()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxPortNotifyEtherAlarmReason.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyEtherAlarmReason.setDescription('Used by tmnx ethernet Port Notifications, the value of\n         tmnxPortNotifyEtherAlarmReason indicates the reason a ethernet port\n         alarm has been raised.')
tmnxDDMFailedObject = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("unknown", 0), ("temperature-low-warning", 1), ("temperature-low-alarm", 2), ("temperature-high-warning", 3), ("temperature-high-alarm", 4), ("supplyVoltage-low-warning", 5), ("supplyVoltage-low-alarm", 6), ("supplyVoltage-high-warning", 7), ("supplyVoltage-high-alarm", 8), ("txBiasCurrent-low-warning", 9), ("txBiasCurrent-low-alarm", 10), ("txBiasCurrent-high-warning", 11), ("txBiasCurrent-high-alarm", 12), ("txOutputPower-low-warning", 13), ("txOutputPower-low-alarm", 14), ("txOutputPower-high-warning", 15), ("txOutputPower-high-alarm", 16), ("rxOpticalPower-low-warning", 17), ("rxOpticalPower-low-alarm", 18), ("rxOpticalPower-high-warning", 19), ("rxOpticalPower-high-alarm", 20), ("aux1-low-warning", 21), ("aux1-low-alarm", 22), ("aux1-high-warning", 23), ("aux1-high-alarm", 24), ("aux2-low-warning", 25), ("aux2-low-alarm", 26), ("aux2-high-warning", 27), ("aux2-high-alarm", 28)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxDDMFailedObject.setStatus('current')
if mibBuilder.loadTexts: tmnxDDMFailedObject.setDescription('Used by Digital Diagnostic Monitoring (DDM) Notifications, the\n         value of tmnxDDMFailedObject indicates which object of the\n         monitored SFP/XFP is in a failed or cleared threshold state.')
tmnxEqOobPortFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 1)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyChassisId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqOobPortFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqOobPortFailure.setDescription('Generated when the out-of-band Ethernet port has failed.  On the\n         Alcatel 7x50 SR system, the out-of-band port is the CPM management \n         interface.\n         \n         This notification was made obsolete in the 2.1 release.\n                    \n         The Out-of-band, OOB, port is what id refered to as the \n         management port or cpm port.  It has an entry in ifTable \n         and linkup, linkDown and tmnxEqPortError notifications \n         are sent for the management port just as for any other \n         port in the system.')
tmnxEqPortFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 2)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyChassisId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqPortFailure.setDescription("Generated when a port has failed.\n         \n         This notification was made obsolete in the 2.1 release.\n\n         tmnxEqPortError is used instead of tmnxEqPortFailure.\n                     \n         Standard IETF linkDown notification is sent when a \n         physical port failure is detected.  tmnxEqPortError is \n         sent with a ASCII reason message when port errors are \n         detected.\n\n         It was originally intended that tmnxEqPortError be used \n         to report errors that do not cause port state change to \n         'down'.\n\n         tmnxEqPortFailure was intended to report errors that \n         do cause the port state change to 'down'.\n\n         However, in the implementation tmnxEqPortError is used \n         for both fatal and non-fatal errors.")
tmnxEqPortSonetAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 4)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifySonetAlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortSonetAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSonetAlarm.setDescription('Generated when a SONET/SDH port alarm condition is detected.\n         It is generated only when the type of alarm being raised is enabled\n         in tmnxSonetReportAlarm.')
tmnxEqPortSonetAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 5)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifySonetAlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortSonetAlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSonetAlarmClear.setDescription('Generated when a SONET/SDH port alarm condition is cleared.\n         It is generated only when the type of alarm being cleared is enabled\n         in tmnxSonetReportAlarm.')
tmnxEqPortSonetPathAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 6)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifySonetPathAlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortSonetPathAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSonetPathAlarm.setDescription('Generated when a SONET/SDH path alarm condition is detected.\n         It is generated only when the type of alarm being raised is enabled\n         in tmnxSonetPathReportAlarm.')
tmnxEqPortSonetPathAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 7)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifySonetPathAlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortSonetPathAlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSonetPathAlarmClear.setDescription('Generated when a SONET/SDH path alarm condition is cleared.\n         It is generated only when the type of alarm being cleared is enabled\n         in tmnxSonetPathReportAlarm.')
tmnxEqPortSFPInserted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 8)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortSFPInserted.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSFPInserted.setDescription('Generated when a SFP is inserted in the port.')
tmnxEqPortSFPRemoved = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 9)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortSFPRemoved.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSFPRemoved.setDescription('Generated when a SFP is removed from the port.')
tmnxEqPortWrongSFP = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 10)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortWrongSFP.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqPortWrongSFP.setDescription('Generated when a wrong type of SFP optics module \n         is plugged into a 1 Gig MDA, SONET MDA, or 100FX MDA.\n\n         Because of the large variety of SFPs now supported and \n         their different encoding schemes for compliance bits, the\n         check for wrong SFP has been removed. As a result,                     \n         tmnxEqPortWrongSFP notification is no longer generated.\n \n         However, wrong SFP can be inferred from port statistics.')
tmnxEqPortSFPCorrupted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 11)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortSFPCorrupted.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqPortSFPCorrupted.setDescription('Generated when SFP information stored in the EPROM \n         on the SFP is corrupt. This notification was made\n         obsolete for revision 6.0 on Alcatel 7x50 SR series\n         systems; it was replaced by tmnxEqPortSFPStatusFailure.')
tmnxPortNotifyBerSdTca = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 12)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetBerSdThreshold"))
if mibBuilder.loadTexts: tmnxPortNotifyBerSdTca.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortNotifyBerSdTca.setDescription("Generated when a SONET/SDH port's signal degradation bit error\n         rate is greater than the configured error rate threshold.\n         \n         This notification was made obsolete in the 2.1 release.")
tmnxPortNotifyBerSfTca = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 13)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetBerSfThreshold"))
if mibBuilder.loadTexts: tmnxPortNotifyBerSfTca.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortNotifyBerSfTca.setDescription("Generated when a SONET/SDH port's signal failure bit error\n         rate is greater than the configured error rate threshold.\n         \n         This notification was made obsolete in the 2.1 release.")
tmnxEqPortError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 14)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyError"))
if mibBuilder.loadTexts: tmnxEqPortError.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortError.setDescription('Generated when an error listed in tmnxPortNotifyError \n         is detected on the port.')
tmnxEqPortDS3Alarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 15)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyDS3AlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortDS3Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortDS3Alarm.setDescription('Generated when a DS3 interface alarm condition is detected.\n         It is generated only when the type of alarm being raised is enabled\n         in tmnxDS3ChannelReportAlarm.')
tmnxEqPortDS3AlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 16)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyDS3AlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortDS3AlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortDS3AlarmClear.setDescription('Generated when a DS3 interface alarm condition is cleared.\n         It is generated only when the type of alarm being cleared is enabled\n         in tmnxDS3ChannelReportAlarm.')
tmnxEqPortDS1Alarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 17)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyDS1AlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortDS1Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortDS1Alarm.setDescription('Generated when a DS1 interface alarm condition is detected.\n         It is generated only when the type of alarm being raised is enabled\n         in tmnxDS1ReportAlarm.')
tmnxEqPortDS1AlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 18)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyDS1AlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortDS1AlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortDS1AlarmClear.setDescription('Generated when a DS1 interface alarm condition is cleared.\n         It is generated only when the type of alarm being cleared is enabled\n         in tmnxDS1ReportAlarm.')
tmnxEqPortBndlYellowDiffExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 19)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleYellowDiffDelay"))
if mibBuilder.loadTexts: tmnxEqPortBndlYellowDiffExceeded.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortBndlYellowDiffExceeded.setDescription('Generated when the differential delay of a port in the bundle \n         exceeds the configured value in tmnxBundleYellowDiffDelay.')
tmnxEqPortBndlRedDiffExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 20)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelay"))
if mibBuilder.loadTexts: tmnxEqPortBndlRedDiffExceeded.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortBndlRedDiffExceeded.setDescription('Generated when the differential delay of a port in the bundle \n         exceeds the configured value in tmnxBundleRedDiffDelay.')
tmnxEqPortBndlBadEndPtDiscr = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 21)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberDownReason"))
if mibBuilder.loadTexts: tmnxEqPortBndlBadEndPtDiscr.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortBndlBadEndPtDiscr.setDescription('Generated when the port detected mismatched peer endpoint \n         discriminator for the bundle.')
tmnxEqPortEtherAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 22)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyEtherAlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortEtherAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortEtherAlarm.setDescription('tmnxEqPortEtherAlarm is generated when a ethernet port alarm \n         condition is detected. It is generated only when the type of \n         alarm being raised is enabled in tmnxPortEtherReportAlarm.')
tmnxEqPortEtherAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 23)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyEtherAlarmReason"))
if mibBuilder.loadTexts: tmnxEqPortEtherAlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortEtherAlarmClear.setDescription('tmnxEqPortEtherAlarmClear is generated when a ethernet port alarm \n         condition is cleared. It is generated only when the type of alarm \n         being cleared is enabled in tmnxPortEtherReportAlarm.')
tmnxDS1E1LoopbackStarted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 24)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Loopback"))
if mibBuilder.loadTexts: tmnxDS1E1LoopbackStarted.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1E1LoopbackStarted.setDescription('The tmnxDS1E1LoopbackStarted notification is generated when a \n         loopback is provisioned on a DS1/E1 port.')
tmnxDS1E1LoopbackStopped = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 25)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Loopback"))
if mibBuilder.loadTexts: tmnxDS1E1LoopbackStopped.setStatus('current')
if mibBuilder.loadTexts: tmnxDS1E1LoopbackStopped.setDescription('The tmnxDS1E1LoopbackStopped notification is generated when a \n         loopback is removed on a DS1/E1 port. The value of \n         tmnxSonetLoopback specifies the type of loopback that was \n         configured and has now been removed.')
tmnxDS3E3LoopbackStarted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 26)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLoopback"))
if mibBuilder.loadTexts: tmnxDS3E3LoopbackStarted.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3E3LoopbackStarted.setDescription('The tmnxDS3E3LoopbackStarted notification is generated when a\n         loopback is provisioned on a DS3/E3 port.')
tmnxDS3E3LoopbackStopped = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 27)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLoopback"))
if mibBuilder.loadTexts: tmnxDS3E3LoopbackStopped.setStatus('current')
if mibBuilder.loadTexts: tmnxDS3E3LoopbackStopped.setDescription('The tmnxDS3E3LoopbackStopped notification is generated when a \n         loopback is removed on a DS3/E3 port. The value of \n         tmnxDS3ChannelLoopback specifies the type of loopback that was \n         configured and has now been removed.')
tmnxSonetSDHLoopbackStarted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 28)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetLoopback"))
if mibBuilder.loadTexts: tmnxSonetSDHLoopbackStarted.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetSDHLoopbackStarted.setDescription('The tmnxSonetSDHLoopbackStarted notification is generated when a\n         loopback is provisioned on a Sonet-SDH port.')
tmnxSonetSDHLoopbackStopped = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 29)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetLoopback"))
if mibBuilder.loadTexts: tmnxSonetSDHLoopbackStopped.setStatus('current')
if mibBuilder.loadTexts: tmnxSonetSDHLoopbackStopped.setDescription('The tmnxSonetSDHLoopbackStopped notification is generated when a\n         loopback test is removed on a Sonet-SDH port. The value of \n         tmnxDS1Loopback specifies the type of loopback that was \n         configured and has now been removed.')
tmnxEqPortEtherLoopDetected = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 30)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortEtherLoopDetected.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortEtherLoopDetected.setDescription("The tmnxEqPortEtherLoopDetected notification is genereated when\n         down-when-looped detects an Ethernet port is receiving PDUs that\n         it transmitted and tmnxPortEtherDownWhenLoopedEnabled is set to\n         'true'.")
tmnxEqPortEtherLoopCleared = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 31)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortEtherLoopCleared.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortEtherLoopCleared.setDescription("The tmnxEqPortEtherLoopCleared notification is generated when\n         down-when-looped detects an Ethernet port has stopped receiving\n         PDUs that it transmitted and tmnxPortEtherDownWhenLoopedEnabled\n         is set to 'true'.  Setting tmnxPortEtherDownWhenLoopedEnabled to\n         'false' will also cause this notification to be generated if \n         tmnxEqPortEtherLoopDetected had previously been raised.")
tmnxEqPortSpeedCfgNotCompatible = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 32)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherSpeed"))
if mibBuilder.loadTexts: tmnxEqPortSpeedCfgNotCompatible.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSpeedCfgNotCompatible.setDescription('Generated when a supported MDA is inserted into a slot of an\n         IOM, the MDA is compatible with the currently provisioned MDA, \n         but the currently configured speed on an MDA port is not \n         compatible with the inserted MDA.')
tmnxEqPortDuplexCfgNotCompatible = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 33)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDuplex"))
if mibBuilder.loadTexts: tmnxEqPortDuplexCfgNotCompatible.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortDuplexCfgNotCompatible.setDescription('Generated when a supported MDA is inserted into a slot of an\n         IOM, the MDA is compatible with the currently provisioned MDA,\n         but the currently configured duplex on an MDA port is not \n         compatible with the inserted MDA.')
tmnxEqPortIngressRateCfgNotCompatible = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 34)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxEqPortIngressRateCfgNotCompatible.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortIngressRateCfgNotCompatible.setDescription('Generated when a supported MDA is inserted into a slot of an\n         IOM, the MDA is compatible with the currently provisioned MDA,\n         but the currently configured ingress rate on an MDA port is not \n         compatible with the inserted MDA.')
tmnxEqDigitalDiagMonitorFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 35)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMFailedObject"))
if mibBuilder.loadTexts: tmnxEqDigitalDiagMonitorFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqDigitalDiagMonitorFailure.setDescription('Generated when an SFP/XFP that supports Digital Diagnostic\n         Monitoring (DDM) enters a failed state.')
tmnxEqPortSFPStatusFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 36)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPStatus"))
if mibBuilder.loadTexts: tmnxEqPortSFPStatusFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPortSFPStatusFailure.setDescription("Generated when the tmnxPortSFPStatus of an SFP/XFP results in \n         a value other than 'not-equipped (0)', or 'operational (1)'.\n         tmnxEqPortSFPStatusFailure obsoleted tmnxEqPortSFPCorrupted for\n         revision 6.0 on Alcatel 7x50 SR series systems.")
tmnxQosServiceDegraded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 2, 0, 3)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyChassisId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"))
if mibBuilder.loadTexts: tmnxQosServiceDegraded.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxQosServiceDegraded.setDescription('Generated when the port is unable to provided the specified\n         quality of service level.')
tmnxPortCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1))
tmnxPortGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2))
tmnxPortComp7750 = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 3))
tmnxPortComp7450 = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 4))
tmnxPortComp7710 = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 5))
tmnxPortComp7750V4v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 3, 2)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTDMGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV3v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortATMGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlBundleGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlImaBundleGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7750V4v0 = tmnxPortComp7750V4v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortComp7750V4v0.setDescription('The compliance statement for revision 4.0 of ALCATEL-IND1-TIMETRA-PORT-MIB on \n             the Alcatel 7750 SR series systems.\n             \n             tmnxMlImaBundleGroup was added as of R4.')
tmnxPortComp7750V5v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 3, 3)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTDMGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortATMGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlBundleGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlImaBundleGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedV5v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV5v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7750V5v0 = tmnxPortComp7750V5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortComp7750V5v0.setDescription('The compliance statement for revision 5.0 of ALCATEL-IND1-TIMETRA-PORT-MIB on \n             the Alcatel 7750 SR series systems.')
tmnxPortComp7750V6v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 3, 4)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTDMGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortATMGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlBundleGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlImaBundleGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedV5v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV6v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortCemGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppBundleGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlpppBundleGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxNamedPoolGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDigitalDiagMonitorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7750V6v0 = tmnxPortComp7750V6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortComp7750V6v0.setDescription('The compliance statement for revision 6.0 of ALCATEL-IND1-TIMETRA-PORT-MIB on \n             the Alcatel 7750 SR series systems.')
tmnxPortComp7450V4v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 4, 2)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV3v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7450V4v0 = tmnxPortComp7450V4v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortComp7450V4v0.setDescription('The compliance statement for revision 4.0 of ALCATEL-IND1-TIMETRA-PORT-MIB on \n             the Alcatel 7450 SR series systems.')
tmnxPortComp7450V5v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 4, 3)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV5v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7450V5v0 = tmnxPortComp7450V5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortComp7450V5v0.setDescription('The compliance statement for revision 5.0 of ALCATEL-IND1-TIMETRA-PORT-MIB on \n             the Alcatel 7450 SR series systems.')
tmnxPortComp7450V6v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 4, 4)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV6v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxNamedPoolGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDigitalDiagMonitorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7450V6v0 = tmnxPortComp7450V6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortComp7450V6v0.setDescription('The compliance statement for revision 5.0 of ALCATEL-IND1-TIMETRA-PORT-MIB on \n             the Alcatel 7450 SR series systems.')
tmnxPortComp7710V3v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 5, 1)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTDMV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupR2r1"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortATMV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlBundleV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnx7710PortTDMGroupV3v0"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7710V3v0 = tmnxPortComp7710V3v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortComp7710V3v0.setDescription('The compliance statement for revision 3.0 of ALCATEL-IND1-TIMETRA-PORT-MIB.')
tmnxPortComp7710V5v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 5, 2)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV5v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTDMGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortATMGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlBundleGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedV5v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnx7710PortTDMGroupV5v0"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7710V5v0 = tmnxPortComp7710V5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortComp7710V5v0.setDescription('The compliance statement for revision 5.0 of ALCATEL-IND1-TIMETRA-PORT-MIB.')
tmnxPortComp7710V6v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 1, 5, 3)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEthernetV6v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSonetV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTDMGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFRGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosAppObjsGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotificationGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQosStatR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortATMGroupV4v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortStatsR2r1Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxScalarPortV3v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlBundleGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedV5v0Group"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnx7710PortTDMGroupV5v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortCemGroupV6v0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppBundleGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMlpppBundleGroup"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDigitalDiagMonitorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortComp7710V6v0 = tmnxPortComp7710V6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortComp7710V6v0.setDescription('The compliance statement for revision 6.0 of ALCATEL-IND1-TIMETRA-PORT-MIB.')
tmnxPortFRGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 5)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiN392Dce"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiN393Dce"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiT392Dce"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiTxStatusEnqMsgs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiRxStatusEnqMsgs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiStatusEnqMsgTimeouts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiTxStatusMsgs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiRxStatusMsgs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiStatusMsgTimeouts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiDiscardedMsgs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxFRDlcmiInvRxSeqNumMsgs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortFRGroup = tmnxPortFRGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxPortFRGroup.setDescription('The group of objects supporting management of Frame Relay DLCMI\n         on Alcatel 7x50 SR series systems.')
tmnxQosAppObjsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 6)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectAppPoolRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectAppResvCbs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectAppSlopePolicy"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxObjectAppPoolSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxQosAppObjsGroup = tmnxQosAppObjsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxQosAppObjsGroup.setDescription('The group of objects supporting management of Qos associations of \n         the buffer pools to mdas, ports, channels and bundles on \n         Alcatel 7x50 SR series systems.')
tmnxPortTestGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 7)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestParameter"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestLastResult"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestStartTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestEndTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTestAction"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortTestGroup = tmnxPortTestGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTestGroup.setDescription('The group of objects supporting management of port testing\n         on Alcatel 7x50 SR series system.')
tmnxPortObsoleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 11)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1IdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngFwdInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngFwdOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngFwdInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngFwdOutProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngDroInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngDroOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngDroInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsIngDroOutProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrFwdInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrFwdOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrFwdInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrFwdOutProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrDroInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrDroOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrDroInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortFCStatsEgrDroOutProfOcts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortObsoleteGroup = tmnxPortObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxPortObsoleteGroup.setDescription('The group of objects in ALCATEL-IND1-TIMETRA-PORT-MIB which are obsoleted.')
tmnxPortIngrMdaQosStatR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 14)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos00StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos00StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos01StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos01StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos02StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos02StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos03StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos03StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos04StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos04StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos05StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos05StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos06StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos06StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos07StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos07StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos08StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos08StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos09StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos09StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos10StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos10StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos11StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos11StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos12StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos12StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos13StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos13StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos14StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos14StatDropOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos15StatDropPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngrMdaQos15StatDropOcts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortIngrMdaQosStatR2r1Group = tmnxPortIngrMdaQosStatR2r1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxPortIngrMdaQosStatR2r1Group.setDescription('The group of objects that describe the MDA QoS discard\n         statistics for an ethernet port located on an oversubscribed MDA\n         for revision 2.1 on Alcatel 7x50 SR series systems.')
tmnxPortStatsR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 16)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressFwdInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressFwdOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressFwdInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressFwdOutProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressDroInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressDroOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressDroInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetIngressDroOutProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressFwdInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressFwdOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressFwdInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressFwdOutProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressDroInProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressDroOutProfPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressDroInProfOcts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetEgressDroOutProfOcts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortStatsR2r1Group = tmnxPortStatsR2r1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxPortStatsR2r1Group.setDescription('The group of objects supporting port statistics\n         for revision 2.1 on Alcatel 7x50 SR series systems.')
tmnxPortNotificationGroupR2r1 = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 17)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPInserted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPRemoved"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPCorrupted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortError"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlYellowDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlRedDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlBadEndPtDiscr"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarmClear"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortNotificationGroupR2r1 = tmnxPortNotificationGroupR2r1.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortNotificationGroupR2r1.setDescription('The group of notifications supporting the management of physical\n         ports for revision 2.1 on Alcatel 7x50 SR series systems.')
tmnxPortNotifyObjsGroupR2r1 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 18)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifySonetAlarmReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifySonetPathAlarmReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyError"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyDS3AlarmReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyDS1AlarmReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyBundleId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyEtherAlarmReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortNotifyObjsGroupR2r1 = tmnxPortNotifyObjsGroupR2r1.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyObjsGroupR2r1.setDescription('The group of objects supporting physical port notifications \n          for revision 2.1 on Alcatel 7x50 SR series systems.')
tmnxPortNotifyObsoleteGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 20)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqOobPortFailure"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortFailure"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxQosServiceDegraded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyBerSdTca"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyBerSfTca"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortWrongSFP"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPCorrupted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortNotifyObsoleteGroup = tmnxPortNotifyObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyObsoleteGroup.setDescription('The group of notifications supporting the management of physical\n         ports made obsolete for revision 2.1 on Alcatel 7x50 SR series \n         systems. tmnxEqPortSFPCorrupted was made obsolete for revision 6.0\n         on Alcatel 7x50 SR series systems.')
tmnxPortSonetV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 21)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetFraming"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetBerSdThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetBerSfThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetLoopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetSectionTraceMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetJ0String"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetMonS1Byte"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetMonJ0String"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetMonK1Byte"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetMonK2Byte"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetSingleFiber"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetHoldTimeUp"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetHoldTimeDown"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathScramble"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathC2Byte"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathJ1String"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathOperMRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathCollectStats"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathMonC2Byte"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathMonJ1String"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetPathChildType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetGroupType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetGroupParentPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetGroupChildType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetGroupName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortSonetV3v0Group = tmnxPortSonetV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSonetV3v0Group.setDescription('The group of objects supporting management of SONET type ports\n         for revision 3.0 on Alcatel 7x50 SR series systems.')
tmnxPortTDMV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 22)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Buildout"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFraming"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelChannelized"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrateCSUMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelIdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLoopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLEicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLLicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLFicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLUnitString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPfiString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMessageType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFEACLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelInFEACLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Framing"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Loopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InvertData"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RemoteLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InRemoteLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupTimeSlots"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupIdleCycleFlags"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortTDMV3v0Group = tmnxPortTDMV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortTDMV3v0Group.setDescription('The group of objects supporting management of TDM type ports\n         for revision 3.0 on the Alcatel 7x50 SR series systems.')
tmnxPortATMV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 23)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxATMIntfCellFormat"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxATMIntfMinVpValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortATMV3v0Group = tmnxPortATMV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortATMV3v0Group.setDescription('The group of objects supporting management of ATM interfaces\n         for version 3.0 on Alcatel 7x50 SR series systems.')
tmnxScalarPortV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 24)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxL4LoadBalancing"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxScalarPortV3v0Group = tmnxScalarPortV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxScalarPortV3v0Group.setDescription('The group of objects supporting management for general port\n         settings for revision 3.0 on Alcatel 7x50 series systems.')
tmnxPortV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 25)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTableLastChange"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClass"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlias"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUserAssignedMac"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHwMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEncapType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLagId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeUp"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeDown"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUpProtocols"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectorType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverCode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverLaserWaveLen"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverDiagCapable"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverModelNumber"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPConnectorCode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorOUI"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorManufactureDate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPMedia"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorSerialNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorPartNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLinkStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAdminStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPrevState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlarmState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastAlarmEvent"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClearAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastStateChanged"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumChannels"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetworkEgrQueues"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIsLeaf"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortChanType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortParentPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLoadBalanceAlgorithm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxChannelPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOpticalCompliance"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxL4LoadBalancing"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortV3v0Group = tmnxPortV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortV3v0Group.setDescription('The group of objects supporting management of physical port \n         capabilities for revision 3.0 on Alcatel 7x50 SR series systems.')
tmnxCiscoHDLCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 26)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCKeepAliveInt"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCUpCount"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCDownCount"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCOperState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCDiscardStatInPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCDiscardStatOutPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCStatInPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCStatOutPkts"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCStatInOctets"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxCiscoHDLCStatOutOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCiscoHDLCGroup = tmnxCiscoHDLCGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxCiscoHDLCGroup.setDescription('The group of objects supporting Cisco HDLC encapsulation on Alcatel \n         7750 SR series systems.')
tmnxMlBundleV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 27)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMinimumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumActiveLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePeerMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelayAction"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleYellowDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleShortSequence"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleFragmentThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberActive"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberDownReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleInputDiscards"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePrimaryMemberPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLFI"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortBundleNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMlBundleV3v0Group = tmnxMlBundleV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMlBundleV3v0Group.setDescription('The group of objects supporting management MLBUNDLES\n         for revision 3.0 on the Alcatel 7x50 SR series systems.')
tmnxObsoleteGroupV3v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 28)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetAps"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsAdminStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsAuthKey"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsNeighborAddr"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsAdvertiseInterval"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsAdvertiseTimeLeft"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsHoldTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetApsHoldTimeLeft"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxObsoleteGroupV3v0 = tmnxObsoleteGroupV3v0.setStatus('current')
if mibBuilder.loadTexts: tmnxObsoleteGroupV3v0.setDescription('The group of objects obsoleted in the 7x50 SR series 3.0 release')
tmnxPortEthernetV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 29)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDuplex"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherAutoNegotiate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherOperDuplex"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherOperSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherCollectStats"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherMDIMDIX"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherXGigMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherEgressRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDot1qEtype"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherQinqEtype"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherIngressRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherHCOverPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherHCPkts1519toMax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortEthernetV3v0Group = tmnxPortEthernetV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortEthernetV3v0Group.setDescription('The group of objects supporting management of Ethernet ports\n         for revision 3.0 on Alcatel 7x50 SR series systems.')
tmnxPortTDMGroupV4v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 30)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Buildout"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFraming"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelChannelized"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrateCSUMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelIdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLoopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLEicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLLicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLFicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLUnitString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPfiString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMessageType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFEACLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelInFEACLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelScramble"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Framing"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Loopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InvertData"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RemoteLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InRemoteLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupTimeSlots"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupIdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupScramble"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortTDMGroupV4v0 = tmnxPortTDMGroupV4v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortTDMGroupV4v0.setDescription('The group of objects supporting management of TDM type ports\n         for version 4.0 on the Alcatel 7x50 SR series systems.')
tmnxPortATMGroupV4v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 31)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxATMIntfCellFormat"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxATMIntfMinVpValue"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxATMIntfMapping"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortATMGroupV4v0 = tmnxPortATMGroupV4v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortATMGroupV4v0.setDescription('The group of objects supporting management of ATM interfaces\n         for version 4.0 on Alcatel 7x50 SR series systems.')
tmnxMlBundleGroupV4v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 32)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMinimumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumActiveLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePeerMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelayAction"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleYellowDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleShortSequence"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleFragmentThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberActive"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberDownReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleInputDiscards"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePrimaryMemberPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLFI"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortBundleNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMlBundleGroupV4v0 = tmnxMlBundleGroupV4v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMlBundleGroupV4v0.setDescription('The group of objects supporting management MLBUNDLES\n         for revision 4.0 on the Alcatel 7x50 SR series systems.')
tmnxMlImaBundleGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 33)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpLnkActTimer"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpLnkDeactTimer"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpSymmetryMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpTxId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpRxId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpTxRefLnk"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpRxRefLnk"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpSmNeState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpSmFeState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpSmFailState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpSmDownSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpSmOperSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpAvailTxCR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpAvailRxCR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpNeFails"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpFeFails"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpTxIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpRxIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpErrorIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpLostRxIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpTxOamLablVal"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpRxOamLablVal"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpAlphaValue"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpBetaValue"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpGammaValue"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpNeClockMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpFeClockMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpVersion"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpMaxConfBw"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpTestState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpTestMember"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpTestPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpDiffDelayMaxObs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleImaGrpLeastDelayLink"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeTxState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeRxState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeTxState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeRxState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeRxFailState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeRxFailState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaTxLid"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaRxLid"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaViolations"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeSevErrSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeSevErrSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeUnavailSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeUnavailSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeTxUnuseSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeRxUnuseSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeTxUnuseSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeRxUnuseSecs"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeTxNumFails"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaNeRxNumFails"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeTxNumFails"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaFeRxNumFails"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaTxIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaRxIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaErrorIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaLstRxIcpCells"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaOifAnomalies"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaRxTestState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaRxTestPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberImaRelDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMlImaBundleGroup = tmnxMlImaBundleGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMlImaBundleGroup.setDescription('The group of objects supporting management of Ima Groups\n         and Members on the Alcatel 7x50 SR series systems.')
tmnx7710PortTDMGroupV3v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 34)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelCollectStats"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortBuildout"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortLineLength"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortLbo"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortDbGain"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InsertSingleBitError"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupCollectStats"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx7710PortTDMGroupV3v0 = tmnx7710PortTDMGroupV3v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnx7710PortTDMGroupV3v0.setDescription('The group of objects supporting management of TDM type ports\n         specific to the Alcatel 7710 SR series systems for revision 3.0.')
tmnxPortGroupV4v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 35)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTableLastChange"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClass"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlias"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUserAssignedMac"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHwMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEncapType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLagId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeUp"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeDown"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUpProtocols"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectorType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverCode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverLaserWaveLen"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverDiagCapable"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverModelNumber"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPConnectorCode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorOUI"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorManufactureDate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPMedia"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorSerialNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorPartNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLinkStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAdminStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPrevState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlarmState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastAlarmEvent"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClearAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastStateChanged"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumChannels"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetworkEgrQueues"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIsLeaf"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortChanType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortParentPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLoadBalanceAlgorithm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxChannelPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOpticalCompliance"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxL4LoadBalancing"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortGroupV4v0 = tmnxPortGroupV4v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortGroupV4v0.setDescription('The group of objects supporting management of physical port \n         capabilities for revision 4.0 on Alcatel 7x50 SR series systems.')
tmnxObsoleteGroupV5v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 36)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverCode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxObsoleteGroupV5v0 = tmnxObsoleteGroupV5v0.setStatus('current')
if mibBuilder.loadTexts: tmnxObsoleteGroupV5v0.setDescription('The group of objects obsoleted in the 7x50 SR series 5.0 release')
tmnxPortSchedV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 37)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEgrPortSchedPlcy"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideSchedName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLastChanged"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideMaxRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl1PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl1CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl2PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl2CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl3PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl3CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl4PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl4CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl5PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl5CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl6PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl6CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl7PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl7CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl8PIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideLvl8CIR"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSchedOverrideFlags"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortSchedV5v0Group = tmnxPortSchedV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxPortSchedV5v0Group.setDescription('The group of objects supporting management of physical port \n         virtual scheduler capabilities for revision 5.0 on Alcatel \n         7x50 SR series systems.')
tmnxPortEthernetV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 38)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDuplex"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherAutoNegotiate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherOperDuplex"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherOperSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherCollectStats"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherMDIMDIX"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherXGigMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherEgressRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDot1qEtype"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherQinqEtype"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherIngressRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherHCOverPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherHCPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherLacpTunnel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortEthernetV5v0Group = tmnxPortEthernetV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortEthernetV5v0Group.setDescription('The group of objects supporting management of Ethernet ports\n         for revision 5.0 on Alcatel 7x50 SR series systems.')
tmnxPortGroupV5v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 39)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTableLastChange"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClass"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlias"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUserAssignedMac"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHwMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEncapType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLagId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeUp"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeDown"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUpProtocols"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectorType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverCode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverLaserWaveLen"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverDiagCapable"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverModelNumber"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPConnectorCode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorOUI"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorManufactureDate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPMedia"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorSerialNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorPartNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLinkStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAdminStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPrevState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlarmState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastAlarmEvent"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClearAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastStateChanged"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumChannels"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetworkEgrQueues"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIsLeaf"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortChanType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortParentPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLoadBalanceAlgorithm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxChannelPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOpticalCompliance"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxL4LoadBalancing"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastClearedTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortGroupV5v0 = tmnxPortGroupV5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortGroupV5v0.setDescription('The group of objects supporting management of physical port \n         capabilities for revision 5.0 on Alcatel 7x50 SR series systems.')
tmnxMlBundleGroupV5v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 40)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMinimumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumActiveLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePeerMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelayAction"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleYellowDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleShortSequence"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleFragmentThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberActive"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberDownReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleInputDiscards"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePrimaryMemberPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLFI"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortBundleNumber"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleProtectedType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleParentBundle"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBPGrpAssocWorkingBundleID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBPGrpAssocProtectBundleID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBPGrpAssocActiveBundleID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMlBundleGroupV5v0 = tmnxMlBundleGroupV5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMlBundleGroupV5v0.setDescription('The group of objects supporting management MLBUNDLES\n         for revision 5.0 on the Alcatel 7x50 SR series systems.')
tmnxPortNotificationGroupV5v0 = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 41)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPInserted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPRemoved"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPCorrupted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortError"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlYellowDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlRedDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlBadEndPtDiscr"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1E1LoopbackStarted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1E1LoopbackStopped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3E3LoopbackStarted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3E3LoopbackStopped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetSDHLoopbackStarted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetSDHLoopbackStopped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSpeedCfgNotCompatible"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDuplexCfgNotCompatible"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortIngressRateCfgNotCompatible"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortNotificationGroupV5v0 = tmnxPortNotificationGroupV5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortNotificationGroupV5v0.setDescription('The group of notifications supporting the management of physical\n         ports for revision 5.0 on Alcatel 7x50 SR series systems.')
tmnxPortTDMGroupV5v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 42)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelCollectStats"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Buildout"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFraming"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelChannelized"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrateCSUMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelIdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLoopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLEicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLLicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLFicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLUnitString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPfiString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMessageType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFEACLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelInFEACLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelScramble"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Framing"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Loopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InvertData"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RemoteLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InRemoteLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupTimeSlots"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupIdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupScramble"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortTDMGroupV5v0 = tmnxPortTDMGroupV5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortTDMGroupV5v0.setDescription('The group of objects supporting management of TDM type ports\n         for version 5.0 on the Alcatel 7x50 SR series systems.')
tmnx7710PortTDMGroupV5v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 43)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortBuildout"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortLineLength"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortLbo"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1PortDbGain"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InsertSingleBitError"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupCollectStats"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx7710PortTDMGroupV5v0 = tmnx7710PortTDMGroupV5v0.setStatus('current')
if mibBuilder.loadTexts: tmnx7710PortTDMGroupV5v0.setDescription('The group of objects supporting management of TDM type ports\n         specific to the revision 5.0 on Alcatel 7710 SR series systems.')
tmnxPortCemGroupV6v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 44)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelClockSyncState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelClockMasterPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1SignalMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ClockSyncState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ClockMasterPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupPayloadFillType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupPayloadPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupSignalFillType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupSignalPattern"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortCemGroupV6v0 = tmnxPortCemGroupV6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortCemGroupV6v0.setDescription('The group of objects supporting management of CEM encapsulation TDM\n         type ports specific to the Alcatel 7750 and 7710 SR series systems\n         for revision 6.0.')
tmnxMcMlpppBundleGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 45)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMlpppClassCount"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMlpppIngQoSProfId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMlpppEgrQoSProfId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppStatsIngressOct"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppStatsIngressPkt"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppStatsIngressErrPkt"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppStatsEgressOct"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppStatsEgressPkt"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxMcMlpppStatsEgressErrPkt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMcMlpppBundleGroup = tmnxMcMlpppBundleGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMcMlpppBundleGroup.setDescription('The group of objects supporting management of MClass MLPPP BUNDLES\n         for revision 6.0 on the Alcatel 7x50 SR series systems.')
tmnxPortNotificationGroupV6v0 = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 46)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPInserted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPRemoved"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortError"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlYellowDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlRedDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlBadEndPtDiscr"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1E1LoopbackStarted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1E1LoopbackStopped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3E3LoopbackStarted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3E3LoopbackStopped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetSDHLoopbackStarted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxSonetSDHLoopbackStopped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherLoopDetected"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherLoopCleared"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSpeedCfgNotCompatible"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDuplexCfgNotCompatible"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortIngressRateCfgNotCompatible"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqDigitalDiagMonitorFailure"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPStatusFailure"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortNotificationGroupV6v0 = tmnxPortNotificationGroupV6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotificationGroupV6v0.setDescription('The group of notifications supporting the management of physical\n         ports for revision 6.0 on Alcatel 7x50 SR series systems.')
tmnxPortEthernetV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 47)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDuplex"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherAutoNegotiate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherOperDuplex"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherOperSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherCollectStats"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherMDIMDIX"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherXGigMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherEgressRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDot1qEtype"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherQinqEtype"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherIngressRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherHCOverPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherHCPkts1519toMax"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherLacpTunnel"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDownWhenLoopedEnabled"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDownWhenLoopedKeepAlive"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDownWhenLoopedRetry"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherDownWhenLoopedState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherPBBEtype"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEtherReasonDownFlags"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortEthernetV6v0Group = tmnxPortEthernetV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxPortEthernetV6v0Group.setDescription('The group of objects supporting management of Ethernet ports\n         for revision 6.0 on Alcatel 7x50 SR series systems.')
tmnxMlBundleGroupV6v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 48)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMinimumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleNumActiveLinks"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleRedDiffDelayAction"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleFragmentThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberActive"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberDownReason"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMemberUpTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleInputDiscards"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePrimaryMemberPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortBundleNumber"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleProtectedType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleParentBundle"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBPGrpAssocWorkingBundleID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBPGrpAssocProtectBundleID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBPGrpAssocActiveBundleID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMlBundleGroupV6v0 = tmnxMlBundleGroupV6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxMlBundleGroupV6v0.setDescription('The group of objects supporting management MLBUNDLES\n         for revision 6.0 on the Alcatel 7x50 SR series systems.')
tmnxMlpppBundleGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 49)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMlpppEndpointID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMlpppEndpointIDClass"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleYellowDiffDelay"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleShortSequence"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundlePeerMRRU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxBundleLFI"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMlpppBundleGroup = tmnxMlpppBundleGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMlpppBundleGroup.setDescription('The group of objects supporting management of MLPPP Bundles\n         on the Alcatel 7x50 SR series systems.')
tmnxPortNotificationGroupV3v0 = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 50)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSonetPathAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPInserted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPRemoved"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSFPCorrupted"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortError"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS3AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1Alarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDS1AlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlYellowDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlRedDiffExceeded"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortBndlBadEndPtDiscr"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortEtherAlarmClear"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortSpeedCfgNotCompatible"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortDuplexCfgNotCompatible"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxEqPortIngressRateCfgNotCompatible"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortNotificationGroupV3v0 = tmnxPortNotificationGroupV3v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPortNotificationGroupV3v0.setDescription('The group of notifications supporting the management of physical\n         ports for revision 3.0 on Alcatel 7x50 SR series systems.')
tmnxPortTDMGroupV6v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 52)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelCollectStats"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Buildout"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFraming"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelChannelized"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrateCSUMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelSubrate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelIdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLoopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLEicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLLicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLFicString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLUnitString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPfiString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMessageType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelFEACLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelInFEACLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonPortString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelMDLMonGenString"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelBERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS3ChannelScramble"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Framing"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1Loopback"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InvertData"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BitErrorInsertionRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTPattern"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTDuration"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ReportAlarmStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1LastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1ClockSource"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTSynched"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTErrors"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BERTTotalBits"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1RemoteLoopRespond"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1InRemoteLoop"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BerSdThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS1BerSfThreshold"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupTimeSlots"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupSpeed"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupCRC"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupOperMTU"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupIdleCycleFlags"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDS0ChanGroupScramble"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortTDMGroupV6v0 = tmnxPortTDMGroupV6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortTDMGroupV6v0.setDescription('The group of objects supporting management of TDM type ports\n         for version 6.0 on the Alcatel 7x50 SR series systems.')
tmnxDigitalDiagMonitorGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 53)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTemperature"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTempLowWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTempLowAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTempHiWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTempHiAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMSupplyVoltage"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMSupplyVoltageLowWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMSupplyVoltageLowAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMSupplyVoltageHiWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMSupplyVoltageHiAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxBiasCurrent"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxBiasCurrentLowWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxBiasCurrentLowAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxBiasCurrentHiWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxBiasCurrentHiAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxOutputPower"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxOutputPowerLowWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxOutputPowerLowAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxOutputPowerHiWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMTxOutputPowerHiAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMRxOpticalPower"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMRxOpticalPowerLowWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMRxOpticalPowerLowAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMRxOpticalPowerHiWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMRxOpticalPowerHiAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMRxOpticalPowerType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux1"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux1LowWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux1LowAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux1HiWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux1HiAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux1Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux2"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux2LowWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux2LowAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux2HiWarning"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux2HiAlarm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMAux2Type"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMFailedThresholds"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExternallyCalibrated"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalRxPower4"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalRxPower3"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalRxPower2"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalRxPower1"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalRxPower0"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalTxLaserBiasSlope"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalTxLaserBiasOffset"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalTxPowerSlope"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalTxPowerOffset"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalTemperatureSlope"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalTemperatureOffset"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalVoltageSlope"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMExtCalVoltageOffset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxDigitalDiagMonitorGroup = tmnxDigitalDiagMonitorGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxDigitalDiagMonitorGroup.setDescription('The group of objects supporting the management of \n         Digital Diagnostic Monitoring SFP/XFPs for revision 6.0 on \n         Alcatel 7x50 SR series systems.')
tmnxPortGroupV6v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 54)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTableLastChange"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastChangeTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClass"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlias"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUserAssignedMac"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHwMacAddress"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortMode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEncapType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLagId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeUp"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortHoldTimeDown"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortUpProtocols"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectorType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverLaserWaveLen"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverDiagCapable"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTransceiverModelNumber"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPConnectorCode"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorOUI"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorManufactureDate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPMedia"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorSerialNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPVendorPartNum"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEquipped"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLinkStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAdminStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOperStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortPrevState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortAlarmState"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastAlarmEvent"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortClearAlarms"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastStateChanged"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNumChannels"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNetworkEgrQueues"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIsLeaf"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortChanType"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortParentPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLoadBalanceAlgorithm"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeName"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeDescription"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortConnectTypeStatus"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxChannelPortID"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortOpticalCompliance"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxL4LoadBalancing"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortLastClearedTime"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortDDMEventSuppression"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortSFPStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortGroupV6v0 = tmnxPortGroupV6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortGroupV6v0.setDescription('The group of objects supporting management of physical port \n         capabilities for revision 6.0 on Alcatel 7x50 SR series systems.')
tmnxNamedPoolGroupV6v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 55)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngNamedPoolPlcy"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEgrNamedPoolPlcy"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortIngPoolPercentRate"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortEgrPoolPercentRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxNamedPoolGroupV6v0 = tmnxNamedPoolGroupV6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxNamedPoolGroupV6v0.setDescription('The group of objects supporting the Named Pool feature\n         for revision 6.0 on Alcatel 7x50 SR series systems.')
tmnxPortNotifyObjsGroupV6v0 = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 2, 2, 57)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxDDMFailedObject"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxPortNotifyObjsGroupV6v0 = tmnxPortNotifyObjsGroupV6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxPortNotifyObjsGroupV6v0.setDescription('The group of objects supporting physical port notifications\n         for revision 6.0 on Alcatel 7x50 SR series systems.')
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-PORT-MIB", tmnxPortTestMode=tmnxPortTestMode, tmnxDS1IdleCycleFlags=tmnxDS1IdleCycleFlags, tmnxDDMRxOpticalPower=tmnxDDMRxOpticalPower, tmnxDS3ChannelOperMTU=tmnxDS3ChannelOperMTU, tmnxSonetEntry=tmnxSonetEntry, tmnxFRDlcmiRxStatusEnqMsgs=tmnxFRDlcmiRxStatusEnqMsgs, tmnxDS0ChanGroupSpeed=tmnxDS0ChanGroupSpeed, tmnxPortNotificationGroupV5v0=tmnxPortNotificationGroupV5v0, tmnxPortNetEgressFwdInProfPkts=tmnxPortNetEgressFwdInProfPkts, tmnxDDMRxOpticalPowerLowWarning=tmnxDDMRxOpticalPowerLowWarning, tmnxPortIngrMdaQos07StatDropOcts=tmnxPortIngrMdaQos07StatDropOcts, tmnxPortFRGroup=tmnxPortFRGroup, tmnxPortNotificationGroupR2r1=tmnxPortNotificationGroupR2r1, tmnxBundleMemberImaRxTestState=tmnxBundleMemberImaRxTestState, tmnxBundleImaGrpLeastDelayLink=tmnxBundleImaGrpLeastDelayLink, tmnxPortComp7750V5v0=tmnxPortComp7750V5v0, tmnxDS3ChannelEntry=tmnxDS3ChannelEntry, tmnxPortIngrMdaQos08StatDropOcts=tmnxPortIngrMdaQos08StatDropOcts, tmnxPortObjs=tmnxPortObjs, tmnxBundleMemberImaNeSevErrSecs=tmnxBundleMemberImaNeSevErrSecs, tmnxBundleMlpppEntry=tmnxBundleMlpppEntry, tmnxPortHoldTimeUp=tmnxPortHoldTimeUp, tmnxBundleMlpppClassCount=tmnxBundleMlpppClassCount, tmnxDS3ChannelClockSyncState=tmnxDS3ChannelClockSyncState, tmnxPortIngrMdaQos01StatDropOcts=tmnxPortIngrMdaQos01StatDropOcts, tmnxDS3LastChangeTime=tmnxDS3LastChangeTime, TmnxImaLnkState=TmnxImaLnkState, tmnxDDMTempLowWarning=tmnxDDMTempLowWarning, tmnxEqPortBndlRedDiffExceeded=tmnxEqPortBndlRedDiffExceeded, tmnxSonetTable=tmnxSonetTable, tmnxDS3ChannelBERTPattern=tmnxDS3ChannelBERTPattern, tmnxPortIngrMdaQosStatTable=tmnxPortIngrMdaQosStatTable, tmnxMcMlpppBundleGroup=tmnxMcMlpppBundleGroup, tmnxBundleMemberImaOifAnomalies=tmnxBundleMemberImaOifAnomalies, tmnxSonetPathRowStatus=tmnxSonetPathRowStatus, tmnxDS3ChannelScramble=tmnxDS3ChannelScramble, tmnxDS0ChanGroupIdleCycleFlags=tmnxDS0ChanGroupIdleCycleFlags, tmnxPortNotifyEtherAlarmReason=tmnxPortNotifyEtherAlarmReason, tmnxFRDlcmiStatusEnqMsgTimeouts=tmnxFRDlcmiStatusEnqMsgTimeouts, tmnxBundleImaGrpSmFeState=tmnxBundleImaGrpSmFeState, tmnxBPGrpAssocProtectBundleID=tmnxBPGrpAssocProtectBundleID, tmnxPortTypeName=tmnxPortTypeName, tmnxPortNetIngressFwdInProfOcts=tmnxPortNetIngressFwdInProfOcts, tmnxDS1BerSdThreshold=tmnxDS1BerSdThreshold, tmnxBundleImaGrpNeClockMode=tmnxBundleImaGrpNeClockMode, tmnxDS3ChannelClockSource=tmnxDS3ChannelClockSource, tmnxPortPortID=tmnxPortPortID, tmnxEqOobPortFailure=tmnxEqOobPortFailure, tmnxPortSchedOverrideLvl3PIR=tmnxPortSchedOverrideLvl3PIR, tmnxPortSchedOverrideLvl8PIR=tmnxPortSchedOverrideLvl8PIR, tmnxBPGrpAssocTable=tmnxBPGrpAssocTable, tmnxPortSFPVendorPartNum=tmnxPortSFPVendorPartNum, tmnxDS1ReportAlarm=tmnxDS1ReportAlarm, tmnxDS1InRemoteLoop=tmnxDS1InRemoteLoop, tmnxL4LoadBalancing=tmnxL4LoadBalancing, TmnxDSXIdleCycleFlags=TmnxDSXIdleCycleFlags, tmnxPortTestEndTime=tmnxPortTestEndTime, tmnxNamedPoolGroupV6v0=tmnxNamedPoolGroupV6v0, tmnxDS3ChannelRowStatus=tmnxDS3ChannelRowStatus, tmnxPortEtherPBBEtype=tmnxPortEtherPBBEtype, tmnxPortNetIngressStatsEntry=tmnxPortNetIngressStatsEntry, tmnxDDMRxOpticalPowerType=tmnxDDMRxOpticalPowerType, tmnxPortOperStatus=tmnxPortOperStatus, tmnxDDMExtCalTemperatureOffset=tmnxDDMExtCalTemperatureOffset, tmnxPortEtherAutoNegotiate=tmnxPortEtherAutoNegotiate, tmnxCiscoHDLCStatInOctets=tmnxCiscoHDLCStatInOctets, tmnxDDMSupplyVoltageHiAlarm=tmnxDDMSupplyVoltageHiAlarm, tmnxBundleImaGrpVersion=tmnxBundleImaGrpVersion, tmnxPortFCStatsIndex=tmnxPortFCStatsIndex, tmnxPortMode=tmnxPortMode, tmnxSonetApsHoldTime=tmnxSonetApsHoldTime, tmnxPortObsoleteGroup=tmnxPortObsoleteGroup, tmnxDS1InvertData=tmnxDS1InvertData, tmnxSonetApsHoldTimeLeft=tmnxSonetApsHoldTimeLeft, tmnxDS1BERTDuration=tmnxDS1BERTDuration, tmnxPortSchedOverrideSchedName=tmnxPortSchedOverrideSchedName, tmnxDS0ChanGroupCRC=tmnxDS0ChanGroupCRC, tmnxPortSFPVendorSerialNum=tmnxPortSFPVendorSerialNum, tmnxBundleImaGrpDiffDelayMaxObs=tmnxBundleImaGrpDiffDelayMaxObs, tmnxBundleOperMTU=tmnxBundleOperMTU, tmnxDS0ChanGroupOperMTU=tmnxDS0ChanGroupOperMTU, TmnxImaGrpState=TmnxImaGrpState, tmnxPortDescription=tmnxPortDescription, tmnxBundleShortSequence=tmnxBundleShortSequence, tmnxSonetSingleFiber=tmnxSonetSingleFiber, tmnxBundleMemberImaNeTxNumFails=tmnxBundleMemberImaNeTxNumFails, TmnxDSXReportAlarm=TmnxDSXReportAlarm, tmnxPortNotifyBerSfTca=tmnxPortNotifyBerSfTca, tmnxPortATMGroupV4v0=tmnxPortATMGroupV4v0, tmnxPortGroupV4v0=tmnxPortGroupV4v0, tmnxPortEtherReportAlarm=tmnxPortEtherReportAlarm, tmnxSonetSDHLoopbackStarted=tmnxSonetSDHLoopbackStarted, tmnxPortNotifySonetPathAlarmReason=tmnxPortNotifySonetPathAlarmReason, tmnxBundleRedDiffDelayAction=tmnxBundleRedDiffDelayAction, tmnxBundleEntry=tmnxBundleEntry, tmnx7710PortTDMGroupV3v0=tmnx7710PortTDMGroupV3v0, tmnxPortState=tmnxPortState, tmnxBundleRowStatus=tmnxBundleRowStatus, tmnxPortComp7450=tmnxPortComp7450, tmnxPortEtherReportAlarmStatus=tmnxPortEtherReportAlarmStatus, tmnxBundleType=tmnxBundleType, tmnxPortNotifyBundleId=tmnxPortNotifyBundleId, tmnxBundleImaGrpFeFails=tmnxBundleImaGrpFeFails, tmnxDS3ChannelClockMasterPortId=tmnxDS3ChannelClockMasterPortId, tmnxDDMTxOutputPowerLowAlarm=tmnxDDMTxOutputPowerLowAlarm, tmnxDS1PortType=tmnxDS1PortType, tmnxFRDlcmiDiscardedMsgs=tmnxFRDlcmiDiscardedMsgs, tmnxEqPortSonetAlarm=tmnxEqPortSonetAlarm, tmnxQosAppObjs=tmnxQosAppObjs, tmnxFRDlcmiMode=tmnxFRDlcmiMode, tmnxBPGrpAssocEntry=tmnxBPGrpAssocEntry, tmnxPortEgrNamedPoolPlcy=tmnxPortEgrNamedPoolPlcy, tmnxBundleMemberImaTable=tmnxBundleMemberImaTable, tmnxPortTable=tmnxPortTable, tmnxDS3ChannelMDLGenString=tmnxDS3ChannelMDLGenString, tmnxPortHwMacAddress=tmnxPortHwMacAddress, tmnxDS3ChannelBERTSynched=tmnxDS3ChannelBERTSynched, tmnxPortIngrMdaQos04StatDropOcts=tmnxPortIngrMdaQos04StatDropOcts, tmnxDigitalDiagMonitorEntry=tmnxDigitalDiagMonitorEntry, tmnxDS0ChanGroupRowStatus=tmnxDS0ChanGroupRowStatus, tmnxPortComp7710=tmnxPortComp7710, tmnxSonetBerSdThreshold=tmnxSonetBerSdThreshold, tmnxPortTypeDescription=tmnxPortTypeDescription, tmnxBundleMemberImaFeUnavailSecs=tmnxBundleMemberImaFeUnavailSecs, tmnxPortIngrMdaQos09StatDropOcts=tmnxPortIngrMdaQos09StatDropOcts, tmnxPortTestDuration=tmnxPortTestDuration, tmnxDS0ChanGroupTable=tmnxDS0ChanGroupTable, tmnxDS3ChannelMDLPfiString=tmnxDS3ChannelMDLPfiString, tmnxSonetGroupTable=tmnxSonetGroupTable, tmnxFRDlcmiRxStatusMsgs=tmnxFRDlcmiRxStatusMsgs, tmnxPortTestAction=tmnxPortTestAction, tmnxDS3ChannelReportAlarmStatus=tmnxDS3ChannelReportAlarmStatus, tmnxPortSchedOverrideLvl2CIR=tmnxPortSchedOverrideLvl2CIR, TmnxPortState=TmnxPortState, tmnxPortEtherDot1qEtype=tmnxPortEtherDot1qEtype, tmnxBundleMemberImaTxIcpCells=tmnxBundleMemberImaTxIcpCells, tmnxBundleImaGrpSmOperSecs=tmnxBundleImaGrpSmOperSecs, tmnxDS3ChannelBERTTotalBits=tmnxDS3ChannelBERTTotalBits, tmnxPortSchedOverrideLvl4CIR=tmnxPortSchedOverrideLvl4CIR, tmnxPortTableLastChange=tmnxPortTableLastChange, tmnxSonetHoldTimeUp=tmnxSonetHoldTimeUp, tmnxSonetApsAdminStatus=tmnxSonetApsAdminStatus, tmnxPortEgrPortSchedPlcy=tmnxPortEgrPortSchedPlcy, tmnxPortEtherOperSpeed=tmnxPortEtherOperSpeed, tmnxObjectId=tmnxObjectId, tmnxBundleImaGrpAlphaValue=tmnxBundleImaGrpAlphaValue, tmnxBundleMlpppIngQoSProfId=tmnxBundleMlpppIngQoSProfId, tmnxBundleMemberImaNeUnavailSecs=tmnxBundleMemberImaNeUnavailSecs, tmnxDS1PortLastChangeTime=tmnxDS1PortLastChangeTime, tmnxPortNetIngressFwdOutProfOcts=tmnxPortNetIngressFwdOutProfOcts, tmnxCiscoHDLCStatsTable=tmnxCiscoHDLCStatsTable, tmnxPortEthernetV6v0Group=tmnxPortEthernetV6v0Group, tmnxPortNotifyObjsGroupV6v0=tmnxPortNotifyObjsGroupV6v0, tmnxPortEtherXGigMode=tmnxPortEtherXGigMode, tmnxEqPortError=tmnxEqPortError, tmnxDS3ChannelFEACLoopRespond=tmnxDS3ChannelFEACLoopRespond, tmnxSonetPathMTU=tmnxSonetPathMTU, tmnxDS1ClockSource=tmnxDS1ClockSource, tmnxPortIngrMdaQos05StatDropPkts=tmnxPortIngrMdaQos05StatDropPkts, tmnxEqDigitalDiagMonitorFailure=tmnxEqDigitalDiagMonitorFailure, tmnxPortFCStatsEgrFwdOutProfOcts=tmnxPortFCStatsEgrFwdOutProfOcts, tmnxPortConnectTypeEntry=tmnxPortConnectTypeEntry, tmnxPortMacAddress=tmnxPortMacAddress, tmnxObjectAppPoolSize=tmnxObjectAppPoolSize, tmnxSonetGroupType=tmnxSonetGroupType, tmnxDS3ChannelSubrate=tmnxDS3ChannelSubrate, tmnxEqPortIngressRateCfgNotCompatible=tmnxEqPortIngressRateCfgNotCompatible, tmnxFRDlcmiEntry=tmnxFRDlcmiEntry, tmnxPortSFPConnectorCode=tmnxPortSFPConnectorCode, tmnxDS3ChannelAcctPolicyId=tmnxDS3ChannelAcctPolicyId, TmnxPortClass=TmnxPortClass, TmnxPortOperStatus=TmnxPortOperStatus, tmnxPortAdminStatus=tmnxPortAdminStatus, tmnxSonetPathReportAlarmStatus=tmnxSonetPathReportAlarmStatus, tmnxPortSchedOverrideLvl6PIR=tmnxPortSchedOverrideLvl6PIR, tmnxPortEncapType=tmnxPortEncapType, tmnxCiscoHDLCStatOutPkts=tmnxCiscoHDLCStatOutPkts, tmnxPortToChannelTable=tmnxPortToChannelTable, tmnxPortIngrMdaQos02StatDropOcts=tmnxPortIngrMdaQos02StatDropOcts, tmnxPortIngrMdaQos12StatDropPkts=tmnxPortIngrMdaQos12StatDropPkts, tmnxPortNetIngressFwdInProfPkts=tmnxPortNetIngressFwdInProfPkts, tmnxBundleImaGrpTxOamLablVal=tmnxBundleImaGrpTxOamLablVal, tmnxPortIngrMdaQosStatEntry=tmnxPortIngrMdaQosStatEntry, tmnxCiscoHDLCStatOutOctets=tmnxCiscoHDLCStatOutOctets, tmnxPortIngrMdaQos10StatDropPkts=tmnxPortIngrMdaQos10StatDropPkts, tmnxPortNetEgressFwdInProfOcts=tmnxPortNetEgressFwdInProfOcts, tmnxObjectAppSlopePolicy=tmnxObjectAppSlopePolicy, tmnxPortComp7450V4v0=tmnxPortComp7450V4v0, tmnxDS1BERTOperStatus=tmnxDS1BERTOperStatus, tmnxBundleFragmentThreshold=tmnxBundleFragmentThreshold, tmnxMcMlpppStatsIngressOct=tmnxMcMlpppStatsIngressOct, tmnxEqPortSpeedCfgNotCompatible=tmnxEqPortSpeedCfgNotCompatible, TmnxDSXClockSyncState=TmnxDSXClockSyncState, tmnxPortIngrMdaQos06StatDropOcts=tmnxPortIngrMdaQos06StatDropOcts, tmnxDS1Loopback=tmnxDS1Loopback, tmnxDS1BerSfThreshold=tmnxDS1BerSfThreshold, tmnxEqPortWrongSFP=tmnxEqPortWrongSFP, tmnxDDMExtCalTxLaserBiasOffset=tmnxDDMExtCalTxLaserBiasOffset, tmnxPortSFPStatus=tmnxPortSFPStatus, tmnxBundleImaGrpTestMember=tmnxBundleImaGrpTestMember, tmnxATMObjs=tmnxATMObjs, tmnxDS1BitErrorInsertionRate=tmnxDS1BitErrorInsertionRate, tmnxPortNotifyError=tmnxPortNotifyError, tmnxPortNotificationGroupV6v0=tmnxPortNotificationGroupV6v0, tmnxPortNetworkEgrQueues=tmnxPortNetworkEgrQueues, tmnxCiscoHDLCUpCount=tmnxCiscoHDLCUpCount, tmnxBundleImaGrpSmFailState=tmnxBundleImaGrpSmFailState, tmnxPortIngrMdaQos14StatDropOcts=tmnxPortIngrMdaQos14StatDropOcts, tmnxDDMFailedThresholds=tmnxDDMFailedThresholds, tmnxPortEthernetV5v0Group=tmnxPortEthernetV5v0Group, tmnxPortTransceiverType=tmnxPortTransceiverType, tmnxPortTestState=tmnxPortTestState, tmnxSonetPathMonC2Byte=tmnxSonetPathMonC2Byte, tmnxBundleOperMRRU=tmnxBundleOperMRRU, tmnxFRDlcmiN393Dce=tmnxFRDlcmiN393Dce, tmnxDDMRxOpticalPowerHiAlarm=tmnxDDMRxOpticalPowerHiAlarm, tmnxPortNotificationObjects=tmnxPortNotificationObjects, tmnxBundleImaGrpBetaValue=tmnxBundleImaGrpBetaValue, tmnxBundleMemberImaNeRxUnuseSecs=tmnxBundleMemberImaNeRxUnuseSecs, tmnxDDMExtCalVoltageSlope=tmnxDDMExtCalVoltageSlope, tmnxPortComp7750=tmnxPortComp7750, tmnxDDMSupplyVoltageLowAlarm=tmnxDDMSupplyVoltageLowAlarm, tmnxBundleImaGrpTxId=tmnxBundleImaGrpTxId, tmnxPortSchedOverrideLvl4PIR=tmnxPortSchedOverrideLvl4PIR, tmnxPortAlarmState=tmnxPortAlarmState, tmnxDS1ClockMasterPortId=tmnxDS1ClockMasterPortId, tmnxBundleImaGrpSmNeState=tmnxBundleImaGrpSmNeState, tmnxMlpppBundleGroup=tmnxMlpppBundleGroup, tmnxDDMAux2HiWarning=tmnxDDMAux2HiWarning, tmnxPortFCStatsIngFwdOutProfPkts=tmnxPortFCStatsIngFwdOutProfPkts, tmnxPortEtherTable=tmnxPortEtherTable, tmnxDDMTxBiasCurrentHiWarning=tmnxDDMTxBiasCurrentHiWarning, TmnxImaLnkFailState=TmnxImaLnkFailState, tmnxPortTDMGroupV4v0=tmnxPortTDMGroupV4v0, tmnxDDMExternallyCalibrated=tmnxDDMExternallyCalibrated, tmnxPortIngrMdaQos09StatDropPkts=tmnxPortIngrMdaQos09StatDropPkts, tmnxBPGrpAssocActiveBundleID=tmnxBPGrpAssocActiveBundleID, TmnxDSXBertPattern=TmnxDSXBertPattern, TmnxImaTestState=TmnxImaTestState, tmnxBundleBundleID=tmnxBundleBundleID, tmnxBundleNumActiveLinks=tmnxBundleNumActiveLinks, tmnxBundleMemberImaFeRxNumFails=tmnxBundleMemberImaFeRxNumFails, tmnxDDMExtCalVoltageOffset=tmnxDDMExtCalVoltageOffset, tmnxFRObjs=tmnxFRObjs, tmnxDS1RemoteLoopRespond=tmnxDS1RemoteLoopRespond, tmnxPortIngrMdaQos04StatDropPkts=tmnxPortIngrMdaQos04StatDropPkts, tmnxBundleMemberImaEntry=tmnxBundleMemberImaEntry, tmnxDDMExtCalRxPower2=tmnxDDMExtCalRxPower2, tmnxPortIngPoolPercentRate=tmnxPortIngPoolPercentRate, tmnxSonetSpeed=tmnxSonetSpeed, tmnxPortSchedOverrideLastChanged=tmnxPortSchedOverrideLastChanged, tmnxBundleImaGrpRxId=tmnxBundleImaGrpRxId, tmnxDS3ChannelMDLMessageType=tmnxDS3ChannelMDLMessageType, tmnxPortSchedOverrideRowStatus=tmnxPortSchedOverrideRowStatus)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-PORT-MIB", tmnxPortEtherDownWhenLoopedKeepAlive=tmnxPortEtherDownWhenLoopedKeepAlive, tmnxMcMlpppStatsEgressOct=tmnxMcMlpppStatsEgressOct, tmnxBundleImaGrpAvailTxCR=tmnxBundleImaGrpAvailTxCR, tmnxDDMAux2Type=tmnxDDMAux2Type, tmnxPortTransceiverCode=tmnxPortTransceiverCode, tmnxPortIngrMdaQos15StatDropOcts=tmnxPortIngrMdaQos15StatDropOcts, tmnxCiscoHDLCStatInPkts=tmnxCiscoHDLCStatInPkts, tmnxObjectAppPool=tmnxObjectAppPool, tmnxPortNotifySonetAlarmReason=tmnxPortNotifySonetAlarmReason, tmnxPortComp7710V3v0=tmnxPortComp7710V3v0, tmnxPortIngrMdaQos03StatDropPkts=tmnxPortIngrMdaQos03StatDropPkts, tmnxPortNetEgressStatsTable=tmnxPortNetEgressStatsTable, tmnxEqPortDS1Alarm=tmnxEqPortDS1Alarm, tmnxEqPortSFPStatusFailure=tmnxEqPortSFPStatusFailure, tmnxPortComp7750V4v0=tmnxPortComp7750V4v0, tmnxPortConnectTypeStatus=tmnxPortConnectTypeStatus, tmnxBundleImaGrpSmDownSecs=tmnxBundleImaGrpSmDownSecs, tmnxDS1PortBuildout=tmnxDS1PortBuildout, tmnxPortSchedOverrideMaxRate=tmnxPortSchedOverrideMaxRate, tmnxDS3ChannelType=tmnxDS3ChannelType, tmnxDS1SignalMode=tmnxDS1SignalMode, TmnxImaGrpFailState=TmnxImaGrpFailState, tmnxSonetApsAuthKey=tmnxSonetApsAuthKey, tmnxPortNetIngressQueueIndex=tmnxPortNetIngressQueueIndex, tmnxPortClass=tmnxPortClass, tmnxPortHoldTimeDown=tmnxPortHoldTimeDown, tmnxPortIngrMdaQos13StatDropOcts=tmnxPortIngrMdaQos13StatDropOcts, tmnxPortNetIngressStatsTable=tmnxPortNetIngressStatsTable, tmnxPortSonetV3v0Group=tmnxPortSonetV3v0Group, tmnxSonetGroupChildType=tmnxSonetGroupChildType, tmnxDDMSupplyVoltageHiWarning=tmnxDDMSupplyVoltageHiWarning, tmnxDS3ChannelCollectStats=tmnxDS3ChannelCollectStats, tmnxBundleMemberRowStatus=tmnxBundleMemberRowStatus, tmnxBundleImaGrpAvailRxCR=tmnxBundleImaGrpAvailRxCR, tmnxFRDlcmiStatusMsgTimeouts=tmnxFRDlcmiStatusMsgTimeouts, tmnxDS3ChannelBERTErrors=tmnxDS3ChannelBERTErrors, tmnxEqPortDS3AlarmClear=tmnxEqPortDS3AlarmClear, tmnxPortNetEgressDroInProfOcts=tmnxPortNetEgressDroInProfOcts, TmnxDs0ChannelList=TmnxDs0ChannelList, tmnxPortLastStateChanged=tmnxPortLastStateChanged, tmnxBundleMemberImaRxLid=tmnxBundleMemberImaRxLid, tmnxDDMTxOutputPowerLowWarning=tmnxDDMTxOutputPowerLowWarning, tmnxSonetGroupEntry=tmnxSonetGroupEntry, tmnxPortUpProtocols=tmnxPortUpProtocols, tmnxMcMlpppStatsEgressPkt=tmnxMcMlpppStatsEgressPkt, tmnxPortLagId=tmnxPortLagId, tmnxDDMTxBiasCurrentLowWarning=tmnxDDMTxBiasCurrentLowWarning, tmnxPortSFPVendorOUI=tmnxPortSFPVendorOUI, tmnxSonetMonJ0String=tmnxSonetMonJ0String, tmnxSonetMonS1Byte=tmnxSonetMonS1Byte, tmnxBundleMlpppEndpointIDClass=tmnxBundleMlpppEndpointIDClass, tmnxPortIngrMdaQos11StatDropPkts=tmnxPortIngrMdaQos11StatDropPkts, PYSNMP_MODULE_ID=tmnxPortMIBModule, tmnxBundleUpTime=tmnxBundleUpTime, tmnxDS3E3LoopbackStopped=tmnxDS3E3LoopbackStopped, tmnxPortParentPortID=tmnxPortParentPortID, tmnxPortConnectTypeDescription=tmnxPortConnectTypeDescription, tmnxBundleMRRU=tmnxBundleMRRU, TmnxBundleID=TmnxBundleID, tmnxSonetPathEntry=tmnxSonetPathEntry, tmnxATMIntfMinVpValue=tmnxATMIntfMinVpValue, tmnxEqPortSFPRemoved=tmnxEqPortSFPRemoved, tmnxEqPortDuplexCfgNotCompatible=tmnxEqPortDuplexCfgNotCompatible, tmnxMlBundleGroupV6v0=tmnxMlBundleGroupV6v0, tmnxBundlePrimaryMemberPortID=tmnxBundlePrimaryMemberPortID, tmnxEqPortBndlYellowDiffExceeded=tmnxEqPortBndlYellowDiffExceeded, tmnxPortIngNamedPoolPlcy=tmnxPortIngNamedPoolPlcy, tmnxBundleMemberImaFeSevErrSecs=tmnxBundleMemberImaFeSevErrSecs, tmnxPortEtherOperDuplex=tmnxPortEtherOperDuplex, tmnxScalarPortV3v0Group=tmnxScalarPortV3v0Group, tmnxPortSchedOverrideLvl3CIR=tmnxPortSchedOverrideLvl3CIR, tmnxEqPortEtherLoopDetected=tmnxEqPortEtherLoopDetected, tmnxPortSchedOverrideLvl2PIR=tmnxPortSchedOverrideLvl2PIR, tmnxDS3ChannelFraming=tmnxDS3ChannelFraming, tmnxObjectAppResvCbs=tmnxObjectAppResvCbs, tmnxBundleTable=tmnxBundleTable, tmnxPortIngrMdaQos13StatDropPkts=tmnxPortIngrMdaQos13StatDropPkts, tmnxPortTypeTable=tmnxPortTypeTable, tmnxBundleMemberImaFeTxState=tmnxBundleMemberImaFeTxState, tmnxBundleInputDiscards=tmnxBundleInputDiscards, tmnxPortConformance=tmnxPortConformance, tmnxDS1InsertSingleBitError=tmnxDS1InsertSingleBitError, tmnxMcMlpppStatsEgressErrPkt=tmnxMcMlpppStatsEgressErrPkt, tmnxDDMTempLowAlarm=tmnxDDMTempLowAlarm, tmnxDDMRxOpticalPowerHiWarning=tmnxDDMRxOpticalPowerHiWarning, tmnxDS3ChannelSubrateCSUMode=tmnxDS3ChannelSubrateCSUMode, tmnxPortEtherLacpTunnel=tmnxPortEtherLacpTunnel, tmnxBundleImaGrpTestPattern=tmnxBundleImaGrpTestPattern, tmnxDDMExtCalRxPower0=tmnxDDMExtCalRxPower0, tmnxPortSFPEquipped=tmnxPortSFPEquipped, tmnxPortEtherCollectStats=tmnxPortEtherCollectStats, tmnxFRDlcmiTxStatusMsgs=tmnxFRDlcmiTxStatusMsgs, tmnxSonetPathCollectStats=tmnxSonetPathCollectStats, tmnxDDMExtCalTxLaserBiasSlope=tmnxDDMExtCalTxLaserBiasSlope, tmnxMlImaBundleGroup=tmnxMlImaBundleGroup, tmnxDS1ReportAlarmStatus=tmnxDS1ReportAlarmStatus, tmnxEqPortSFPCorrupted=tmnxEqPortSFPCorrupted, tmnxPortEtherEgressRate=tmnxPortEtherEgressRate, tmnxSonetJ0String=tmnxSonetJ0String, tmnxBundleMemberImaRxIcpCells=tmnxBundleMemberImaRxIcpCells, tmnxObjectAppType=tmnxObjectAppType, tmnxEqPortSonetPathAlarmClear=tmnxEqPortSonetPathAlarmClear, tmnxDS1PortDbGain=tmnxDS1PortDbGain, tmnxPortIngrMdaQos00StatDropPkts=tmnxPortIngrMdaQos00StatDropPkts, tmnxDDMRxOpticalPowerLowAlarm=tmnxDDMRxOpticalPowerLowAlarm, tmnxPortV3v0Group=tmnxPortV3v0Group, tmnxPortEtherReasonDownFlags=tmnxPortEtherReasonDownFlags, tmnxPortNotifyDS1AlarmReason=tmnxPortNotifyDS1AlarmReason, tmnxPortConnectTypeName=tmnxPortConnectTypeName, tmnxQosPoolAppTable=tmnxQosPoolAppTable, tmnxBundleMinimumLinks=tmnxBundleMinimumLinks, tmnxBundleLFI=tmnxBundleLFI, tmnxPortATMV3v0Group=tmnxPortATMV3v0Group, tmnxPortSchedOverrideLvl6CIR=tmnxPortSchedOverrideLvl6CIR, tmnxEqPortSonetAlarmClear=tmnxEqPortSonetAlarmClear, tmnxATMIntfTable=tmnxATMIntfTable, tmnxPortComp7750V6v0=tmnxPortComp7750V6v0, tmnxPortNotifyDS3AlarmReason=tmnxPortNotifyDS3AlarmReason, tmnxDS0ChanGroupEntry=tmnxDS0ChanGroupEntry, tmnxDS1PortTable=tmnxDS1PortTable, tmnxPortEtherQinqEtype=tmnxPortEtherQinqEtype, tmnxFRDlcmiTxStatusEnqMsgs=tmnxFRDlcmiTxStatusEnqMsgs, tmnxBundleImaGrpRxIcpCells=tmnxBundleImaGrpRxIcpCells, tmnxPortBundleNumber=tmnxPortBundleNumber, tmnxPortEtherDownWhenLoopedRetry=tmnxPortEtherDownWhenLoopedRetry, tmnxPortNetEgressDroOutProfPkts=tmnxPortNetEgressDroOutProfPkts, tmnxBundleMemberImaErrorIcpCells=tmnxBundleMemberImaErrorIcpCells, tmnxDDMAux2=tmnxDDMAux2, tmnxEqPortFailure=tmnxEqPortFailure, tmnxBundleImaGrpRxRefLnk=tmnxBundleImaGrpRxRefLnk, tmnxBundleMemberImaRxTestPattern=tmnxBundleMemberImaRxTestPattern, tmnxDS1Type=tmnxDS1Type, tmnxDS1ClockSyncState=tmnxDS1ClockSyncState, tmnxBundleImaGrpRxOamLablVal=tmnxBundleImaGrpRxOamLablVal, tmnxDS3ChannelMDLMonGenString=tmnxDS3ChannelMDLMonGenString, tmnxPortEtherDownWhenLoopedState=tmnxPortEtherDownWhenLoopedState, tmnxPortSchedOverrideLvl5CIR=tmnxPortSchedOverrideLvl5CIR, tmnxSonetSDHLoopbackStopped=tmnxSonetSDHLoopbackStopped, tmnxPortTypeEntry=tmnxPortTypeEntry, tmnxBundleRedDiffDelay=tmnxBundleRedDiffDelay, tmnxDS3ChannelMDLLicString=tmnxDS3ChannelMDLLicString, tmnxBundleMemberImaLstRxIcpCells=tmnxBundleMemberImaLstRxIcpCells, tmnxDS0ChanGroupPayloadFillType=tmnxDS0ChanGroupPayloadFillType, tmnxPortIngrMdaQos10StatDropOcts=tmnxPortIngrMdaQos10StatDropOcts, tmnxPortCompliances=tmnxPortCompliances, tmnxCiscoHDLCDiscardStatOutPkts=tmnxCiscoHDLCDiscardStatOutPkts, tmnxCiscoHDLCTable=tmnxCiscoHDLCTable, tmnxPortNetEgressDroOutProfOcts=tmnxPortNetEgressDroOutProfOcts, tmnxDigitalDiagMonitorTable=tmnxDigitalDiagMonitorTable, tmnxSonetSectionTraceMode=tmnxSonetSectionTraceMode, tmnxPortName=tmnxPortName, tmnxSonetApsAdvertiseInterval=tmnxSonetApsAdvertiseInterval, tmnxSonetAps=tmnxSonetAps, tmnxPortEtherMTU=tmnxPortEtherMTU, tmnxBundleMemberImaViolations=tmnxBundleMemberImaViolations, tmnxBundleImaGrpLnkDeactTimer=tmnxBundleImaGrpLnkDeactTimer, tmnxDDMTempHiAlarm=tmnxDDMTempHiAlarm, tmnxDDMAux1LowWarning=tmnxDDMAux1LowWarning, tmnxDS1Entry=tmnxDS1Entry, tmnxSonetLoopback=tmnxSonetLoopback, tmnxEqPortSFPInserted=tmnxEqPortSFPInserted, tmnxBundleImaGrpLnkActTimer=tmnxBundleImaGrpLnkActTimer, tmnxDS3ChannelMDLMonPortString=tmnxDS3ChannelMDLMonPortString, tmnxPortEtherPkts1519toMax=tmnxPortEtherPkts1519toMax, tmnxSonetFraming=tmnxSonetFraming, tmnxDS0ChanGroupScramble=tmnxDS0ChanGroupScramble, tmnxPortSchedV5v0Group=tmnxPortSchedV5v0Group, tmnxDS1BERTPattern=tmnxDS1BERTPattern, tmnxDS3ChannelBERTOperStatus=tmnxDS3ChannelBERTOperStatus, tmnxPortGroups=tmnxPortGroups, tmnxDS3ChannelReportAlarm=tmnxDS3ChannelReportAlarm, tmnxBundleImaGrpEntry=tmnxBundleImaGrpEntry, tmnxDS3Buildout=tmnxDS3Buildout, tmnxMlBundleGroupV4v0=tmnxMlBundleGroupV4v0, tmnxPortIngrMdaQos07StatDropPkts=tmnxPortIngrMdaQos07StatDropPkts, tmnxPortNetIngressDroInProfOcts=tmnxPortNetIngressDroInProfOcts, tmnxPortFCStatsEgrFwdInProfPkts=tmnxPortFCStatsEgrFwdInProfPkts, tmnxDS1BERTTotalBits=tmnxDS1BERTTotalBits, tmnxDS0ChanGroupAcctPolicyId=tmnxDS0ChanGroupAcctPolicyId, tmnxBundleMemberTable=tmnxBundleMemberTable, tmnxPortClearAlarms=tmnxPortClearAlarms, tmnxDS3ChannelMDLFicString=tmnxDS3ChannelMDLFicString, tmnxBundleMemberImaFeRxState=tmnxBundleMemberImaFeRxState, tmnxDDMExtCalTxPowerSlope=tmnxDDMExtCalTxPowerSlope, tmnxBundleMemberImaNeRxFailState=tmnxBundleMemberImaNeRxFailState, tmnxDS1BERTErrors=tmnxDS1BERTErrors, tmnxBundleMemberActive=tmnxBundleMemberActive, tmnxFRDlcmiT392Dce=tmnxFRDlcmiT392Dce, tmnxBundleImaGrpLostRxIcpCells=tmnxBundleImaGrpLostRxIcpCells, tmnxPortEquipped=tmnxPortEquipped, tmnxPortTransceiverDiagCapable=tmnxPortTransceiverDiagCapable, tmnxDS3Type=tmnxDS3Type, tmnxDS0ChanGroupPayloadPattern=tmnxDS0ChanGroupPayloadPattern, tmnxPortTestEntry=tmnxPortTestEntry, tmnxPortGroupV5v0=tmnxPortGroupV5v0, tmnxSonetPathMonJ1String=tmnxSonetPathMonJ1String, tmnxDS0ChanGroupLastChangeTime=tmnxDS0ChanGroupLastChangeTime, tmnxSonetApsNeighborAddr=tmnxSonetApsNeighborAddr, tmnxPortFCStatsIngFwdInProfOcts=tmnxPortFCStatsIngFwdInProfOcts, tmnxDS3ChannelBERTDuration=tmnxDS3ChannelBERTDuration, tmnxDDMAux1=tmnxDDMAux1, tmnxPortComp7450V6v0=tmnxPortComp7450V6v0, tmnxPortEtherEntry=tmnxPortEtherEntry, tmnxEqPortDS3Alarm=tmnxEqPortDS3Alarm, TmnxPortEtherReportStatus=TmnxPortEtherReportStatus, tmnxBundleProtectedType=tmnxBundleProtectedType, tmnxPortComp7450V5v0=tmnxPortComp7450V5v0, tmnxSonetHoldTimeDown=tmnxSonetHoldTimeDown, tmnxPortFCStatsEgrFwdInProfOcts=tmnxPortFCStatsEgrFwdInProfOcts, tmnxPortSchedOverrideLvl7CIR=tmnxPortSchedOverrideLvl7CIR, tmnxPortTDMGroupV6v0=tmnxPortTDMGroupV6v0, tmnxMcMlpppClassIndex=tmnxMcMlpppClassIndex, TmnxDSXLoopback=TmnxDSXLoopback, tmnxPortTypeStatus=tmnxPortTypeStatus, tmnxPortEtherDownWhenLoopedEnabled=tmnxPortEtherDownWhenLoopedEnabled, tmnxCiscoHDLCDiscardStatInPkts=tmnxCiscoHDLCDiscardStatInPkts, tmnxBundleMemberImaNeRxNumFails=tmnxBundleMemberImaNeRxNumFails, tmnxPortFCStatsEgrDroOutProfPkts=tmnxPortFCStatsEgrDroOutProfPkts, tmnxObsoleteGroupV3v0=tmnxObsoleteGroupV3v0, tmnxSonetPathLastChangeTime=tmnxSonetPathLastChangeTime, tmnxPortSchedOverrideLvl1PIR=tmnxPortSchedOverrideLvl1PIR, tmnxDDMAux2HiAlarm=tmnxDDMAux2HiAlarm, tmnxSonetPathTable=tmnxSonetPathTable, tmnxDS3ChannelIdleCycleFlags=tmnxDS3ChannelIdleCycleFlags, TmnxDSXBertOperStatus=TmnxDSXBertOperStatus, tmnxPortNotificationGroupV3v0=tmnxPortNotificationGroupV3v0, tmnxObjectAppPoolRowStatus=tmnxObjectAppPoolRowStatus, tmnxPortNumChannels=tmnxPortNumChannels, tmnxPortFCStatsEgrFwdOutProfPkts=tmnxPortFCStatsEgrFwdOutProfPkts, TmnxImaGrpClockModes=TmnxImaGrpClockModes, tmnxPortIngrMdaQos03StatDropOcts=tmnxPortIngrMdaQos03StatDropOcts, tmnxPortConnectTypeIndex=tmnxPortConnectTypeIndex, TmnxPortType=TmnxPortType, tmnxPortLoadBalanceAlgorithm=tmnxPortLoadBalanceAlgorithm, tmnxMcMlpppStatsIngressPkt=tmnxMcMlpppStatsIngressPkt, tmnxBundleMemberImaFeTxUnuseSecs=tmnxBundleMemberImaFeTxUnuseSecs, tmnxPortDDMEventSuppression=tmnxPortDDMEventSuppression, tmnxPortTDMV3v0Group=tmnxPortTDMV3v0Group, tmnxEqPortEtherAlarm=tmnxEqPortEtherAlarm, tmnxMcMlpppStatsTable=tmnxMcMlpppStatsTable, tmnxDDMAux2LowWarning=tmnxDDMAux2LowWarning, tmnxBundleYellowDiffDelay=tmnxBundleYellowDiffDelay, tmnxPortEtherHCPkts1519toMax=tmnxPortEtherHCPkts1519toMax, tmnxPortNotifyPortId=tmnxPortNotifyPortId, tmnxBundleMemberDownReason=tmnxBundleMemberDownReason, TmnxMlpppEndpointIdClass=TmnxMlpppEndpointIdClass, tmnxDDMTempHiWarning=tmnxDDMTempHiWarning, tmnxDDMTxOutputPowerHiAlarm=tmnxDDMTxOutputPowerHiAlarm, tmnxDDMExtCalRxPower1=tmnxDDMExtCalRxPower1, tmnxPortFCStatsEgrDroOutProfOcts=tmnxPortFCStatsEgrDroOutProfOcts, tmnxDigitalDiagMonitorGroup=tmnxDigitalDiagMonitorGroup, tmnxBundleMlpppEgrQoSProfId=tmnxBundleMlpppEgrQoSProfId, tmnxCiscoHDLCStatsEntry=tmnxCiscoHDLCStatsEntry, tmnxBundleImaGrpTxRefLnk=tmnxBundleImaGrpTxRefLnk)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-PORT-MIB", tmnxPortIngrMdaQos15StatDropPkts=tmnxPortIngrMdaQos15StatDropPkts, tmnxDS1BERTSynched=tmnxDS1BERTSynched, tmnxDS0ChanGroupSignalPattern=tmnxDS0ChanGroupSignalPattern, tmnxDS1LastChangeTime=tmnxDS1LastChangeTime, tmnxFRDlcmiTable=tmnxFRDlcmiTable, tmnxDDMAux1HiWarning=tmnxDDMAux1HiWarning, tmnxPortType=tmnxPortType, tmnxDS3ChannelMDLEicString=tmnxDS3ChannelMDLEicString, tmnxCiscoHDLCGroup=tmnxCiscoHDLCGroup, tmnxFRDlcmiInvRxSeqNumMsgs=tmnxFRDlcmiInvRxSeqNumMsgs, tmnxPortNotifyObjsGroupR2r1=tmnxPortNotifyObjsGroupR2r1, tmnxPortIsLeaf=tmnxPortIsLeaf, tmnxDDMAux2LowAlarm=tmnxDDMAux2LowAlarm, tmnxPortFCStatsEntry=tmnxPortFCStatsEntry, TmnxPortConnectorType=TmnxPortConnectorType, tmnxPortFCStatsEgrDroInProfOcts=tmnxPortFCStatsEgrDroInProfOcts, tmnxBundleMemberImaNeRxState=tmnxBundleMemberImaNeRxState, tmnxEqPortSonetPathAlarm=tmnxEqPortSonetPathAlarm, tmnxPortEntry=tmnxPortEntry, tmnxDDMSupplyVoltage=tmnxDDMSupplyVoltage, tmnxBundleNumLinks=tmnxBundleNumLinks, tmnxPortTestGroup=tmnxPortTestGroup, tmnxDS0ChanGroupCollectStats=tmnxDS0ChanGroupCollectStats, tmnxPortNetEgressFwdOutProfPkts=tmnxPortNetEgressFwdOutProfPkts, tmnxPortIngrMdaQos02StatDropPkts=tmnxPortIngrMdaQos02StatDropPkts, tmnxBundleLastChangeTime=tmnxBundleLastChangeTime, tmnxDDMAux1LowAlarm=tmnxDDMAux1LowAlarm, tmnxBPGrpAssocWorkingBundleID=tmnxBPGrpAssocWorkingBundleID, tmnxDS1RowStatus=tmnxDS1RowStatus, tmnxPortNetEgressDroInProfPkts=tmnxPortNetEgressDroInProfPkts, tmnxATMIntfEntry=tmnxATMIntfEntry, tmnxPortLastChangeTime=tmnxPortLastChangeTime, tmnxDS3ChannelMDLUnitString=tmnxDS3ChannelMDLUnitString, tmnxDS3ChannelMDLPortString=tmnxDS3ChannelMDLPortString, tmnxPortAlias=tmnxPortAlias, tmnxSonetPathOperMRU=tmnxSonetPathOperMRU, tmnxDS3ChannelCRC=tmnxDS3ChannelCRC, tmnxCiscoHDLCOperState=tmnxCiscoHDLCOperState, tmnxPortNetIngressDroInProfPkts=tmnxPortNetIngressDroInProfPkts, tmnxMcMlpppStatsEntry=tmnxMcMlpppStatsEntry, tmnxChannelIdxString=tmnxChannelIdxString, tmnxPortNotifyBerSdTca=tmnxPortNotifyBerSdTca, tmnxSonetMonK1Byte=tmnxSonetMonK1Byte, tmnxDDMAux1Type=tmnxDDMAux1Type, tmnxPortGroupV6v0=tmnxPortGroupV6v0, tmnxDDMTxBiasCurrentHiAlarm=tmnxDDMTxBiasCurrentHiAlarm, tmnxSonetPathJ1String=tmnxSonetPathJ1String, tmnxDS1PortLineLength=tmnxDS1PortLineLength, tmnxPortSchedOverrideTable=tmnxPortSchedOverrideTable, tmnxPortSchedOverrideEntry=tmnxPortSchedOverrideEntry, tmnxDDMExtCalTxPowerOffset=tmnxDDMExtCalTxPowerOffset, tmnxPortFCStatsIngDroOutProfOcts=tmnxPortFCStatsIngDroOutProfOcts, tmnxDDMTxOutputPower=tmnxDDMTxOutputPower, tmnxPortPrevState=tmnxPortPrevState, tmnxMcMlpppStatsIngressErrPkt=tmnxMcMlpppStatsIngressErrPkt, tmnxPortEthernetV3v0Group=tmnxPortEthernetV3v0Group, tmnxBundlePeerMRRU=tmnxBundlePeerMRRU, tmnxPortFCStatsIngFwdOutProfOcts=tmnxPortFCStatsIngFwdOutProfOcts, tmnxPortSchedOverrideLvl7PIR=tmnxPortSchedOverrideLvl7PIR, tmnxPortStatsObjs=tmnxPortStatsObjs, tmnxBundleMemberImaTxLid=tmnxBundleMemberImaTxLid, tmnxBundleImaGrpTxIcpCells=tmnxBundleImaGrpTxIcpCells, tmnxDDMSupplyVoltageLowWarning=tmnxDDMSupplyVoltageLowWarning, tmnxBundleParentBundle=tmnxBundleParentBundle, TmnxPortEtherReportValue=TmnxPortEtherReportValue, tmnxEqPortEtherLoopCleared=tmnxEqPortEtherLoopCleared, tmnxDS0ChanGroupTimeSlots=tmnxDS0ChanGroupTimeSlots, tmnxPortSchedOverrideLvl8CIR=tmnxPortSchedOverrideLvl8CIR, tmnxDDMExtCalRxPower3=tmnxDDMExtCalRxPower3, tmnxQosPoolAppEntry=tmnxQosPoolAppEntry, tmnxPortIngrMdaQos06StatDropPkts=tmnxPortIngrMdaQos06StatDropPkts, tmnxDS3ChannelInFEACLoop=tmnxDS3ChannelInFEACLoop, tmnxPortFCStatsIngDroOutProfPkts=tmnxPortFCStatsIngDroOutProfPkts, tmnxBundleImaGrpNeFails=tmnxBundleImaGrpNeFails, tmnxPortSchedOverrideLvl5PIR=tmnxPortSchedOverrideLvl5PIR, tmnxDS3ChannelBitErrorInsertionRate=tmnxDS3ChannelBitErrorInsertionRate, TmnxImaGrpVersion=TmnxImaGrpVersion, tmnxPortIngrMdaQos08StatDropPkts=tmnxPortIngrMdaQos08StatDropPkts, tmnxPortUserAssignedMac=tmnxPortUserAssignedMac, tmnxBundleImaGrpGammaValue=tmnxBundleImaGrpGammaValue, tmnxSonetBerSfThreshold=tmnxSonetBerSfThreshold, TmnxDSXIdleFillType=TmnxDSXIdleFillType, tmnxPortTDMGroupV5v0=tmnxPortTDMGroupV5v0, tmnxDS3ChannelChannelized=tmnxDS3ChannelChannelized, tmnxPortNetEgressFwdOutProfOcts=tmnxPortNetEgressFwdOutProfOcts, tmnxPortCemGroupV6v0=tmnxPortCemGroupV6v0, TmnxDS1Loopback=TmnxDS1Loopback, tmnxATMIntfMapping=tmnxATMIntfMapping, tmnxPortLastClearedTime=tmnxPortLastClearedTime, tmnxBundleMlpppEndpointID=tmnxBundleMlpppEndpointID, tmnxPortIngrMdaQos01StatDropPkts=tmnxPortIngrMdaQos01StatDropPkts, tmnxDS1Framing=tmnxDS1Framing, tmnxPortIngrMdaQosStatR2r1Group=tmnxPortIngrMdaQosStatR2r1Group, tmnxPortComp7710V6v0=tmnxPortComp7710V6v0, tmnxMlBundleV3v0Group=tmnxMlBundleV3v0Group, tmnxBundleImaGrpErrorIcpCells=tmnxBundleImaGrpErrorIcpCells, TmnxDSXClockSource=TmnxDSXClockSource, tmnxSonetApsOperStatus=tmnxSonetApsOperStatus, tmnxEqPortEtherAlarmClear=tmnxEqPortEtherAlarmClear, tmnxPortLastAlarmEvent=tmnxPortLastAlarmEvent, tmnxSonetPathChildType=tmnxSonetPathChildType, tmnxDDMTxBiasCurrentLowAlarm=tmnxDDMTxBiasCurrentLowAlarm, tmnxQosServiceDegraded=tmnxQosServiceDegraded, tmnxPortTestParameter=tmnxPortTestParameter, tmnxDDMTemperature=tmnxDDMTemperature, tmnxObjectType=tmnxObjectType, tmnxBundleMemberImaNeTxState=tmnxBundleMemberImaNeTxState, tmnxChannelPortID=tmnxChannelPortID, tmnxBundleImaGrpMaxConfBw=tmnxBundleImaGrpMaxConfBw, tmnxPortStatsR2r1Group=tmnxPortStatsR2r1Group, tmnxDS3ChannelLastChangeTime=tmnxDS3ChannelLastChangeTime, tmnxBundleMemberUpTime=tmnxBundleMemberUpTime, tmnxPortIngrMdaQos05StatDropOcts=tmnxPortIngrMdaQos05StatDropOcts, tmnxPortFCStatsIngFwdInProfPkts=tmnxPortFCStatsIngFwdInProfPkts, tmnxBundleMemberImaFeTxNumFails=tmnxBundleMemberImaFeTxNumFails, tmnxQosAppObjsGroup=tmnxQosAppObjsGroup, tmnxSonetPathAcctPolicyId=tmnxSonetPathAcctPolicyId, tmnxPortToChannelEntry=tmnxPortToChannelEntry, TmnxDS3Loopback=TmnxDS3Loopback, tmnxCiscoHDLCDownCount=tmnxCiscoHDLCDownCount, tmnxPortConnectorType=tmnxPortConnectorType, tmnxBundleMemberImaFeRxUnuseSecs=tmnxBundleMemberImaFeRxUnuseSecs, tmnxPortSchedOverrideFlags=tmnxPortSchedOverrideFlags, tmnxATMIntfCellFormat=tmnxATMIntfCellFormat, tmnxPortFCStatsTable=tmnxPortFCStatsTable, tmnxDDMExtCalTemperatureSlope=tmnxDDMExtCalTemperatureSlope, tmnxPortConnectTypeTable=tmnxPortConnectTypeTable, TmnxMcMlpppClassIndex=TmnxMcMlpppClassIndex, tmnxPortEtherIngressRate=tmnxPortEtherIngressRate, tmnxPortMIBModule=tmnxPortMIBModule, tmnxPortNotifyObsoleteGroup=tmnxPortNotifyObsoleteGroup, tmnxBundleImaGrpFeClockMode=tmnxBundleImaGrpFeClockMode, tmnxBundleMemberImaNeTxUnuseSecs=tmnxBundleMemberImaNeTxUnuseSecs, tmnxPortEtherSpeed=tmnxPortEtherSpeed, tmnxSonetGroupParentPortID=tmnxSonetGroupParentPortID, tmnxDS1E1LoopbackStopped=tmnxDS1E1LoopbackStopped, tmnxPortNetEgressQueueIndex=tmnxPortNetEgressQueueIndex, tmnxDS3Table=tmnxDS3Table, tmnxPortNetIngressFwdOutProfPkts=tmnxPortNetIngressFwdOutProfPkts, tmnxSonetPathType=tmnxSonetPathType, tmnxPortSFPVendorManufactureDate=tmnxPortSFPVendorManufactureDate, tmnxBundleImaGrpTable=tmnxBundleImaGrpTable, tmnxPortOpticalCompliance=tmnxPortOpticalCompliance, tmnxPortScalarObjs=tmnxPortScalarObjs, tmnxPortFCStatsIngDroInProfOcts=tmnxPortFCStatsIngDroInProfOcts, tmnxSonetMonK2Byte=tmnxSonetMonK2Byte, tmnxBundleMlpppTable=tmnxBundleMlpppTable, tmnxDS1Table=tmnxDS1Table, tmnx7710PortTDMGroupV5v0=tmnx7710PortTDMGroupV5v0, tmnxPortTransceiverModelNumber=tmnxPortTransceiverModelNumber, tmnxPortNotification=tmnxPortNotification, tmnxDS3ChannelLoopback=tmnxDS3ChannelLoopback, tmnxDS0ChanGroupMTU=tmnxDS0ChanGroupMTU, tmnxPortNumAlarms=tmnxPortNumAlarms, tmnxDDMExtCalRxPower4=tmnxDDMExtCalRxPower4, tmnxSonetApsAdvertiseTimeLeft=tmnxSonetApsAdvertiseTimeLeft, tmnxSonetGroupName=tmnxSonetGroupName, tmnxPortIngrMdaQos00StatDropOcts=tmnxPortIngrMdaQos00StatDropOcts, tmnxPortNetIngressDroOutProfPkts=tmnxPortNetIngressDroOutProfPkts, tmnxPortFCStatsEgrDroInProfPkts=tmnxPortFCStatsEgrDroInProfPkts, tmnxSonetPathC2Byte=tmnxSonetPathC2Byte, tmnxFRDlcmiN392Dce=tmnxFRDlcmiN392Dce, tmnxPortNetEgressStatsEntry=tmnxPortNetEgressStatsEntry, tmnxPortSchedOverrideLvl1CIR=tmnxPortSchedOverrideLvl1CIR, tmnxBundleImaGrpSymmetryMode=tmnxBundleImaGrpSymmetryMode, tmnxPortEtherMDIMDIX=tmnxPortEtherMDIMDIX, tmnxDS1E1LoopbackStarted=tmnxDS1E1LoopbackStarted, tmnxDDMTxOutputPowerHiWarning=tmnxDDMTxOutputPowerHiWarning, tmnxPortSFPMedia=tmnxPortSFPMedia, tmnxPortTransceiverLaserWaveLen=tmnxPortTransceiverLaserWaveLen, tmnxPortIngrMdaQos12StatDropOcts=tmnxPortIngrMdaQos12StatDropOcts, tmnxDS3ChannelTable=tmnxDS3ChannelTable, tmnxPortTypeIndex=tmnxPortTypeIndex, tmnxDS3ChannelMTU=tmnxDS3ChannelMTU, tmnxDS1PortLbo=tmnxDS1PortLbo, tmnxPortEtherDuplex=tmnxPortEtherDuplex, tmnxSonetReportAlarm=tmnxSonetReportAlarm, tmnxBundleImaGrpTestState=tmnxBundleImaGrpTestState, tmnxSonetClockSource=tmnxSonetClockSource, tmnxBundleMemberImaFeRxFailState=tmnxBundleMemberImaFeRxFailState, tmnxPortIngrMdaQos14StatDropPkts=tmnxPortIngrMdaQos14StatDropPkts, tmnxPortTestLastResult=tmnxPortTestLastResult, tmnxEqPortDS1AlarmClear=tmnxEqPortDS1AlarmClear, tmnxDS3Entry=tmnxDS3Entry, tmnxSonetReportAlarmStatus=tmnxSonetReportAlarmStatus, tmnxObsoleteGroupV5v0=tmnxObsoleteGroupV5v0, tmnxPortComp7710V5v0=tmnxPortComp7710V5v0, tmnxPortTestTable=tmnxPortTestTable, tmnxPortEgrPoolPercentRate=tmnxPortEgrPoolPercentRate, tmnxSonetPathOperMTU=tmnxSonetPathOperMTU, tmnxDS0ChanGroupSignalFillType=tmnxDS0ChanGroupSignalFillType, tmnxPortEtherAcctPolicyId=tmnxPortEtherAcctPolicyId, tmnxDDMTxBiasCurrent=tmnxDDMTxBiasCurrent, tmnxEqPortBndlBadEndPtDiscr=tmnxEqPortBndlBadEndPtDiscr, tmnxCiscoHDLCEntry=tmnxCiscoHDLCEntry, tmnxPortTestStartTime=tmnxPortTestStartTime, tmnxDS3E3LoopbackStarted=tmnxDS3E3LoopbackStarted, tmnxPortNotifyPrefix=tmnxPortNotifyPrefix, tmnxBundleMemberImaRelDelay=tmnxBundleMemberImaRelDelay, tmnxDDMFailedObject=tmnxDDMFailedObject, tmnxPortChanType=tmnxPortChanType, tmnxPortFCStatsIngDroInProfPkts=tmnxPortFCStatsIngDroInProfPkts, tmnxDS1PortEntry=tmnxDS1PortEntry, tmnxPortEtherHCOverPkts1519toMax=tmnxPortEtherHCOverPkts1519toMax, tmnxPortNetIngressDroOutProfOcts=tmnxPortNetIngressDroOutProfOcts, tmnxMlBundleGroupV5v0=tmnxMlBundleGroupV5v0, tmnxDDMAux1HiAlarm=tmnxDDMAux1HiAlarm, tmnxSonetPathScramble=tmnxSonetPathScramble, tmnxPortIngrMdaQos11StatDropOcts=tmnxPortIngrMdaQos11StatDropOcts, tmnxSonetPathCRC=tmnxSonetPathCRC, tmnxPortLinkStatus=tmnxPortLinkStatus, tmnxCiscoHDLCKeepAliveInt=tmnxCiscoHDLCKeepAliveInt, tmnxBundleMemberEntry=tmnxBundleMemberEntry, tmnxSonetPathReportAlarm=tmnxSonetPathReportAlarm)
