#
# PySNMP MIB module MPLS-LSR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/MPLS-LSR-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 05:10:50 2022
# On host fv-az42-839 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressIPv4, InetAddressIPv6, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4", "InetAddressIPv6", "InetAddressType")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
NotificationType, Counter32, iso, IpAddress, TimeTicks, ModuleIdentity, Unsigned32, Counter64, Bits, Gauge32, ObjectIdentity, experimental, MibIdentifier, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter32", "iso", "IpAddress", "TimeTicks", "ModuleIdentity", "Unsigned32", "Counter64", "Bits", "Gauge32", "ObjectIdentity", "experimental", "MibIdentifier", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
StorageType, TextualConvention, TruthValue, RowPointer, RowStatus, TimeStamp, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "TruthValue", "RowPointer", "RowStatus", "TimeStamp", "DisplayString")
mplsLsrMIB = ModuleIdentity((1, 3, 6, 1, 3, 96))
mplsLsrMIB.setRevisions(('1999-06-16 12:00', '2000-02-16 12:00', '2000-03-06 12:00', '2000-04-21 12:00', '2000-04-26 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsLsrMIB.setRevisionsDescriptions(('Initial draft version.', 'Second draft version.', 'Third draft version.', 'Fourth draft version.  Made corrections from WG Last \n        Call comments.', 'Fifth draft version. Made minor typographical corrections \n        noted from WG mailing list.',))
if mibBuilder.loadTexts: mplsLsrMIB.setLastUpdated('200004261200Z')
if mibBuilder.loadTexts: mplsLsrMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsLsrMIB.setContactInfo('        Cheenu Srinivasan\n        Postal: Tachion Networks, Inc.\n                Monmouth Park Corporate Center I\n                Building C, 185 Monmouth Parkway\n                West Long Branch, NJ 07764\n        Tel:    +1-732-542-7750 x1234\n        Email:  cheenu@tachion.com\n\n                Arun Viswanathan\n        Postal: Force10 Networks, Inc.\n                1440 McCarthy Blvd\n                Milpitas, CA 95035\n        Tel:    +1-408-571-3516\n        Email:  arun@force10networks.com\n\n                Thomas D. Nadeau\n        Postal: Cisco Systems, Inc.\n                250 Apollo Drive\n                Chelmsford, MA 01824\n        Tel:    +1-978-244-3051\n        Email:  tnadeau@cisco.com')
if mibBuilder.loadTexts: mplsLsrMIB.setDescription('This MIB contains managed object definitions for the\n        Multiprotocol Label Switching (MPLS) Router as\n        defined in: Rosen, E., Viswanathan, A., and R.\n        Callon, Multiprotocol Label Switching Architecture,\n        Internet Draft <draft-ietf-mpls-arch-06.txt>,\n        February 2000.')
class MplsLSPID(TextualConvention, OctetString):
    description = 'An identifier that is assigned to each LSP and is\n        used to uniquely identify it.  This is assigned at\n        the head end of the LSP and can be used by all LSRs\n        to identify this LSP.  This value is piggybacked by\n        the signaling protocol when this LSP is signaled\n        within the network.  This identifier can then be\n        used at each LSR to identify which labels are being\n        swapped to other labels for this LSP.  For IPv4\n        addresses this results in a 6-octet long cookie.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 31)

class MplsLabel(TextualConvention, Unsigned32):
    reference = '1. MPLS Label Stack Encoding, Rosen et al, draft-\n          ietf-mpls-label-encaps-07.txt, March 2000.\n        2. Use of Label Switching on Frame Relay Networks,\n          Conta et al, draft-ietf-mpls-fr-03.txt, Nov.\n          1998.\n        3. MPLS using LDP and ATM VC switching, Davie et al,\n          draft-ietf-mpls-atm-02.txt, April 1999.'
    description = 'This value represents an MPLS label.  Note that the\n        contents of a label field are interpreted in an\n        interface-type specific fashion.  For example, the\n        20-bit wide label carried in the MPLS shim header is\n        contained in bits 0-19 and bits 20-31 must be zero.\n        The frame relay label can be either 10 or 23 bits\n        wide depending on the size of the DLCI field and\n        bits 10-31, or 23-31 must be zero, respectively.\n        For an ATM interface, bits 0-15 must be interpreted\n        as the VCI, bits 16-23 as the VPI and bits 24-31\n        must be zero.  Note that the permissible label\n        values are also a function of the interface type.\n        For example, the value 3 has special semantics in\n        the control plane for an MPLS shim header label and\n        is not a valid label value in the data path.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class MplsBitRate(TextualConvention, Integer32):
    description = "An estimate of bandwidth in units of 1,000 bits per\n        second.  If this object reports a value of 'n' then\n        the rate of the object is somewhere in the range of\n        'n-500' to 'n+499'. For objects which do not vary in\n        bitrate, or for those where no accurate estimation\n        can be made, this object should contain the nominal\n        bitrate."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MplsBurstSize(TextualConvention, Integer32):
    description = 'The number of octets of MPLS data that the stream\n        may send back-to-back without concern for policing.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MplsBufferSize(TextualConvention, Integer32):
    description = 'Size of buffer in octets of MPLS data.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MplsObjectOwner(TextualConvention, Integer32):
    description = 'The entity which owns the object in question.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("other", 1), ("snmp", 2), ("ldp", 3), ("rsvp", 4), ("policyAgent", 5), ("unknown", 6))

mplsLsrObjects = MibIdentifier((1, 3, 6, 1, 3, 96, 1))
mplsLsrNotifications = MibIdentifier((1, 3, 6, 1, 3, 96, 2))
mplsLsrConformance = MibIdentifier((1, 3, 6, 1, 3, 96, 3))
mplsInterfaceConfTable = MibTable((1, 3, 6, 1, 3, 96, 1, 1), )
if mibBuilder.loadTexts: mplsInterfaceConfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceConfTable.setDescription('This table specifies per-interface MPLS capability\n        and associated information.')
mplsInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 1, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsInterfaceConfIndex"))
if mibBuilder.loadTexts: mplsInterfaceConfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceConfEntry.setDescription('An entry in this table is created by an LSR for\n        every interface capable of supporting MPLS. The\n        entry with index 0 represents the per-platform label\n        space and contains parameters that apply to all\n        interfaces that participate in the per-platform\n        label space. Other entries defined in this table\n        represent additional MPLS interfaces that may\n        participate in either the per-platform or per-\n        interface label spaces, or both. Additional\n        information about label space participation of an\n        interface is provided in the description clause of\n        mplsInterfaceLabelParticipationType.')
mplsInterfaceConfIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsInterfaceConfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n        McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsInterfaceConfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceConfIndex.setDescription('This is a unique index for an entry in the\n        MplsInterfaceConfTable.  A non-zero index for an\n        entry indicates the ifIndex for the corresponding\n        interface entry in of the MPLS-layer in the ifTable.\n        Note that the per-platform label space may apply to\n        several interfaces, and therefore the configuration\n        of the per-platform label space interface parameters\n        will apply to all of the interfaces that are\n        participating in the per-platform label space.')
mplsInterfaceLabelMinIn = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 2), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMinIn.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMinIn.setDescription('This is the minimum value of an MPLS label that this\n        LSR is willing to receive on this interface.')
mplsInterfaceLabelMaxIn = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 3), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMaxIn.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMaxIn.setDescription('This is the maximum value of an MPLS label that this\n        LSR is willing to receive on this interface.')
mplsInterfaceLabelMinOut = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 4), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMinOut.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMinOut.setDescription('This is the minimum value of an MPLS label that this\n        LSR is willing to send on this interface.')
mplsInterfaceLabelMaxOut = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 5), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMaxOut.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMaxOut.setDescription('This is the maximum value of an MPLS label that this\n        LSR is willing to send on this interface.')
mplsInterfaceTotalBandwidth = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 6), MplsBitRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceTotalBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceTotalBandwidth.setDescription('This value indicates the total amount of usable\n        bandwidth on this interface and is specified in\n        kilobits per second (Kbps).  This variable is\n        not applicable when applied to the interface with\n        index 0.')
mplsInterfaceAvailableBandwidth = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 7), MplsBitRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceAvailableBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceAvailableBandwidth.setDescription('This value indicates the total amount of available\n        bandwidth available on this interface and is\n        specified in kilobits per second (Kbps).  This\n        value is calculated as the difference between the\n        amount of bandwidth currently in use and that\n        specified in mplsInterfaceTotalBandwidth.  This\n        variable is not applicable when applied to the\n        interface with index 0.')
mplsInterfaceTotalBuffer = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 8), MplsBufferSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceTotalBuffer.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceTotalBuffer.setDescription('This value indicates the total amount of buffer\n        space allocated for this interface.  This variable\n        is not applicable when applied to the interface with\n        index 0.')
mplsInterfaceAvailableBuffer = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 9), MplsBufferSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceAvailableBuffer.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceAvailableBuffer.setDescription('This value reflects the total amount of buffer space\n        available on this interface.  This variable is not\n        applicable when applied to the interface with index\n        0.')
mplsInterfaceLabelParticipationType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 10), Bits().clone(namedValues=NamedValues(("perPlatform", 0), ("perInterface", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setReference('Multiprotocol Label Switching, Rosen et al, draft-ietf-mpls-\n       arch-06.txt, August 1999.')
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setDescription('Either the perPlatform(0) or perInterface(1) bit\n        MUST be set. If the value of the\n        mplsInterfaceConfIndex for this entry is zero, then\n        only the perPlatform(0) bit MUST be set and the\n        perInterface(1) bit is meaningless. If the\n        perInterface(1) bit is set then the value of\n        mplsInterfaceLabelMinIn, mplsInterfaceLabelMaxIn,\n        mplsInterfaceLabelMinOut, and\n        mplsInterfaceLabelMaxOut for this entry reflect the\n        label ranges for this interface.  If only the\n        perPlatform(0) bit is set, then the value of\n        mplsInterfaceLabelMinIn, mplsInterfaceLabelMaxIn,\n        mplsInterfaceLabelMinOut, and\n        mplsInterfaceLabelMaxOut for this entry must be\n        identical to the instance of these objects with\n        index 0.')
mplsInterfaceConfStorageType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 1, 1, 11), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInterfaceConfStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceConfStorageType.setDescription('The storage type for this entry.')
mplsInterfacePerfTable = MibTable((1, 3, 6, 1, 3, 96, 1, 2), )
if mibBuilder.loadTexts: mplsInterfacePerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfTable.setDescription('This table provides MPLS performance information on\n        a per-interface basis.')
mplsInterfacePerfEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 2, 1), )
mplsInterfaceConfEntry.registerAugmentions(("MPLS-LSR-MIB", "mplsInterfacePerfEntry"))
mplsInterfacePerfEntry.setIndexNames(*mplsInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: mplsInterfacePerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfEntry.setDescription('An entry in this table is created by the LSR for\n        every interface capable of supporting MPLS.  Its is\n        an extension to the mplsInterfaceConfEntry table.')
mplsInterfaceInLabelsUsed = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceInLabelsUsed.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceInLabelsUsed.setDescription('This value indicates the specific number of labels\n        that are in use at this point in time on this\n        interface in the incoming direction.')
mplsInterfaceInPackets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceInPackets.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceInPackets.setDescription('This variable reflects the number of labeled packets\n        that have been received on this interface.')
mplsInterfaceInDiscards = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceInDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceInDiscards.setDescription('The number of inbound labeled packets, which were\n        chosen to be discarded even though no errors had\n        been detected to prevent their being transmitted.\n        One possible reason for discarding such a labeled\n        packet could be to free up buffer space.')
mplsInterfaceFailedLabelLookup = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceFailedLabelLookup.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceFailedLabelLookup.setDescription('This value indicates the number of labeled packets\n        that have been received on this interface and were\n        discarded because there were no matching entries\n        found for them in mplsInSegmentTable.')
mplsInterfaceOutLabelsUsed = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceOutLabelsUsed.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceOutLabelsUsed.setDescription('Indicates the number of top-most labels in the\n        outgoing label stacks that are in use at this point\n        in time on this interface.')
mplsInterfaceOutPackets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceOutPackets.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceOutPackets.setDescription('This variable contains the number of labeled packets\n        that have been transmitted on this interface.')
mplsInterfaceOutDiscards = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceOutDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceOutDiscards.setDescription('The number of outbound labeled packets, which were\n        chosen to be discarded even though no errors had\n        been detected to prevent their being transmitted.\n        One possible reason for discarding such a labeled\n        packet could be to free up buffer space.')
mplsInterfaceOutFragments = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceOutFragments.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceOutFragments.setDescription('This variable indicates the number of outgoing MPLS\n        packets that required fragmentation before\n        transmission on this interface.')
mplsInSegmentTable = MibTable((1, 3, 6, 1, 3, 96, 1, 3), )
if mibBuilder.loadTexts: mplsInSegmentTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentTable.setDescription('This table contains a collection of incoming\n        segments to an LSR.')
mplsInSegmentEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 3, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsInSegmentIfIndex"), (0, "MPLS-LSR-MIB", "mplsInSegmentLabel"))
if mibBuilder.loadTexts: mplsInSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentEntry.setDescription('An entry in this table represents one incoming\n        segment.  An entry can be created by a network\n        administrator or an SNMP agent, or an MPLS signaling\n        protocol.  The creator of the entry is denoted by\n        mplsInSegmentOwner.  An entry in this table is\n        indexed by the ifIndex of the incoming interface and\n        the (top) label.')
mplsInSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsInSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentIfIndex.setDescription('This is a unique index for an entry in the\n        MplsInSegmentTable.  This value represents the\n        interface index for the incoming MPLS interface.  A\n        value of zero represents an incoming label from the\n        per-platform label space.  In this case, the\n        mplsInSegmentLabel is interpreted to be an MPLS-type\n        label.')
mplsInSegmentLabel = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 2), MplsLabel())
if mibBuilder.loadTexts: mplsInSegmentLabel.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLabel.setDescription('The incoming label for this segment.')
mplsInSegmentNPop = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentNPop.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentNPop.setDescription('The number of labels to pop from the incoming\n        packet.  Normally only the top label is popped from\n        the packet and used for all switching decisions for\n        that packet.  Note that technologies which do not\n        support label popping should set this value to its\n        default value of 1.')
mplsInSegmentAddrFamily = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 4), AddressFamilyNumbers().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentAddrFamily.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentAddrFamily.setDescription('The IANA address family [IANAFamily] of the incoming\n\n\n        packet.  A value of other(0) indicates that the\n        family type is either unknown or undefined.')
mplsInSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentXCIndex.setDescription('Index into mplsXCTable which identifies which cross-\n        connect entry this segment is part of.  A value of\n        zero indicates that this entry is not referred to by\n        any cross-connect entry.  When a cross-connect entry\n        is created which this in-segment is a part of, this\n        object is automatically updated to reflect the value\n        of mplsXCIndex of that cross-connect entry.')
mplsInSegmentOwner = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 6), MplsObjectOwner().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentOwner.setDescription('Denotes the entity that created and is responsible\n        for managing this segment.')
mplsInSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 7), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic\n     parameter specification for this in-segment.  This\n     value may point at an entry in the\n     mplsTrafficParamTable to indicate which\n     mplsTrafficParamEntry is to be assigned to this\n     segment.  This value may optionally point at an\n     externally defined traffic parameter specification\n     table.  A value of zero-dot-zero indicates best-effort\n     treatment.  By having the same value of this object,\n     two or more segments can indicate resource sharing.')
mplsInSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentRowStatus.setDescription('This variable is used to create, modify, and/or\n        delete a row in this table.')
mplsInSegmentStorageType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 9), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentStorageType.setDescription('This variable indicates the storage type for this\n        object.')
mplsInSegmentAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentAdminStatus.setDescription('This value is used to represent the managers\n        desired operational status of this segment.')
mplsInSegmentOperStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentOperStatus.setDescription('This value represents the actual operational status\n        of this segment.')
mplsInSegmentPerfTable = MibTable((1, 3, 6, 1, 3, 96, 1, 4), )
if mibBuilder.loadTexts: mplsInSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfTable.setDescription('This table contains statistical information for\n        incoming MPLS segments to an LSR.')
mplsInSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 4, 1), )
mplsInSegmentEntry.registerAugmentions(("MPLS-LSR-MIB", "mplsInSegmentPerfEntry"))
mplsInSegmentPerfEntry.setIndexNames(*mplsInSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: mplsInSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfEntry.setDescription('An entry in this table contains statistical\n        information about one incoming segment which was\n        configured in the mplsInSegmentTable. The counters\n        in this entry should behave in a manner similar to\n        that of the interface.')
mplsInSegmentOctets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentOctets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentOctets.setDescription('This value represents the total number of octets\n        received by this segment.')
mplsInSegmentPackets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPackets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPackets.setDescription('Total number of packets received by this segment.')
mplsInSegmentErrors = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentErrors.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentErrors.setDescription('The number of errored packets received on this\n        segment.')
mplsInSegmentDiscards = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentDiscards.setDescription('The number of labeled packets received on this in-\n        segment, which were chosen to be discarded even\n        though no errors had been detected to prevent their\n        being transmitted.  One possible reason for\n        discarding such a labeled packet could be to free up\n        buffer space.')
mplsInSegmentHCOctets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentHCOctets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentHCOctets.setDescription('The total number of octets received.  This is the 64\n        bit version of mplsInSegmentOctets.')
mplsInSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 4, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\n          which any one or more of this segment's Counter32 or\n          Counter64 suffered a discontinuity. If no such\n          discontinuities have occurred since the last re-\n          initialization of the local management subsystem, then\n          this object contains a zero value.")
mplsOutSegmentIndexNext = MibScalar((1, 3, 6, 1, 3, 96, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIndexNext.setDescription('This object contains the next appropriate value to\n        be used for mplsOutSegmentIndex when creating\n        entries in the mplsOutSegmentTable.  If the number\n        of unassigned entries is exhausted, this object will\n        take on the value of 0.  To obtain the\n        mplsOutSegmentIndex value for a new entry, the\n        manager must first issue a management protocol\n        retrieval operation to obtain the current value of\n        this object.  The agent should modify the value to\n        reflect the next unassigned index after each\n        retrieval operation.  After a manager retrieves a\n        value the agent will determine through its local\n        policy when this index value will be made available\n        for reuse.')
mplsOutSegmentTable = MibTable((1, 3, 6, 1, 3, 96, 1, 6), )
if mibBuilder.loadTexts: mplsOutSegmentTable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTable.setDescription('This table contains a representation of the outgoing\n        segments from an LSR.')
mplsOutSegmentEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 6, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsOutSegmentIndex"))
if mibBuilder.loadTexts: mplsOutSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentEntry.setDescription('An entry in this table represents one outgoing\n        segment.  An entry can be created by a network\n        administrator or an SNMP agent, or an MPLS signaling\n        protocol.  The object mplsOutSegmentOwner indicates\n        the creator of this entry.')
mplsOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: mplsOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIndex.setDescription('This value contains a unique index for this row.\n        While a value of 0 is not valid as an index for this\n        row it can be supplied as a valid value to index\n        mplsXCTable to access entries for which no out-\n        segment has been configured.')
mplsOutSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 2), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIfIndex.setDescription('This value contains the interface index of the\n        outgoing interface.')
mplsOutSegmentPushTopLabel = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 3), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentPushTopLabel.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPushTopLabel.setDescription("This value indicates whether or not a top label\n        should be pushed onto the outgoing packet's label\n        stack.  The value of this variable must be set to\n        true if the outgoing interface does not support pop-\n        and-go (for example an ATM interface) or if it is a\n        tunnel origination.  Note that it is considered an\n        error in the case that mplsOutSegmentPushTopLabel is\n        set to false, but the cross-connect entry which\n        refers to this out-segment has a non-zero\n        mplsLabelStackIndex.  The LSR MUST ensure that this\n\n\n        situation does not happen ")
mplsOutSegmentTopLabel = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 4), MplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentTopLabel.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTopLabel.setDescription("If mplsOutSegmentPushTopLabel is true then this\n        represents the label that should be pushed onto the\n        top of the outgoing packet's label stack.")
mplsOutSegmentNextHopIpAddrType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 5), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpAddrType.setDescription('Indicates whether the next hop address is IPv4 or\n        IPv6.  Note that a value of unknown (0) is valid\n        only when the outgoing interface is of type point-to-\n        point.')
mplsOutSegmentNextHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 6), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv4Addr.setDescription('IPv4 Address of the next hop.  Its value is\n        significant only when\n        mplsOutSegmentNextHopIpAddrType is ipV4 (1),\n        otherwise it should return a value of 0.')
mplsOutSegmentNextHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 7), InetAddressIPv6()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv6Addr.setDescription('IPv6 address of the next hop.  Its value is\n        significant only when\n        mplsOutSegmentNextHopIpAddrType is ipV6 (2),\n        otherwise it should return a value of 0.')
mplsOutSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentXCIndex.setDescription('Index into mplsXCTable which identifies which cross-\n        connect entry this segment is part of.  A value of\n        zero indicates that this entry is not referred to by\n        any cross-connect entry.  When a cross-connect entry\n        is created which this out-segment is a part of, this\n        object is automatically updated to reflect the value\n        of mplsXCIndex of that cross-connect entry.')
mplsOutSegmentOwner = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 9), MplsObjectOwner().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentOwner.setDescription('Denotes the entity which created and is responsible\n        for managing this segment.')
mplsOutSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 10), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic\n      parameter specification for this out-segment.  This\n      value may point at an entry in the\n      mplsTrafficParamTable to indicate which\n      mplsTrafficParamEntry is to be assigned to this\n      segment.  This value may optionally point at an\n      externally defined traffic parameter specification\n      table.  A value of zero-dot-zero indicates best-\n      effort treatment.  By having the same value of this\n      object, two or more segments can indicate resource\n      sharing.')
mplsOutSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsOutSegmentStorageType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 12), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentStorageType.setDescription('This variable indicates the storage type for this\n        object.')
mplsOutSegmentAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentAdminStatus.setDescription('The desired operational status of this segment.')
mplsOutSegmentOperStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentOperStatus.setDescription('The actual operational status of this segment.')
mplsOutSegmentPerfTable = MibTable((1, 3, 6, 1, 3, 96, 1, 7), )
if mibBuilder.loadTexts: mplsOutSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfTable.setDescription('This table contains statistical information about\n        outgoing segments from an LSR. The counters in this\n        entry should behave in a manner similar to that of\n\n\n        the interface.')
mplsOutSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 7, 1), )
mplsOutSegmentEntry.registerAugmentions(("MPLS-LSR-MIB", "mplsOutSegmentPerfEntry"))
mplsOutSegmentPerfEntry.setIndexNames(*mplsOutSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: mplsOutSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfEntry.setDescription('An entry in this table contains statistical\n        information about one outgoing segment configured in\n        mplsOutSegmentTable.')
mplsOutSegmentOctets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentOctets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentOctets.setDescription('This value contains the total number of octets sent\n        on this segment.')
mplsOutSegmentPackets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPackets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPackets.setDescription('This value contains the total number of packets sent\n        on this segment.')
mplsOutSegmentErrors = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentErrors.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentErrors.setDescription('Number of packets that could not be sent due to\n\n\n        errors on this segment.')
mplsOutSegmentDiscards = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentDiscards.setDescription('The number of labeled packets received on this out-\n        segment, which were chosen to be discarded even\n        though no errors had been detected to prevent their\n        being transmitted.  One possible reason for\n        discarding such a labeled packet could be to free up\n        buffer space.')
mplsOutSegmentHCOctets = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 7, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentHCOctets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentHCOctets.setDescription('Total number of octets sent.  This is the 64 bit\n        version of mplsOutSegmentOctets.')
mplsOutSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 7, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\n          which any one or more of this segment's Counter32 or\n          Counter64 suffered a discontinuity. If no such\n          discontinuities have occurred since the last re-\n          initialization of the local management subsystem, then\n          this object contains a zero value.")
mplsXCIndexNext = MibScalar((1, 3, 6, 1, 3, 96, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsXCIndexNext.setDescription('This object contains an appropriate value to be used\n        for mplsXCIndex when creating entries in the\n\n\n        mplsXCTable.  The value 0 indicates that no\n        unassigned entries are available.  To obtain the\n        value of mplsXCIndex for a new entry in the\n        mplsXCTable, the manager issues a management\n        protocol retrieval operation to obtain the current\n        value of mplsXCIndex.  After each retrieval\n        operation, the agent should modify the value to\n        reflect the next unassigned index.  After a manager\n        retrieves a value the agent will determine through\n        its local policy when this index value will be made\n        available for reuse.')
mplsXCTable = MibTable((1, 3, 6, 1, 3, 96, 1, 9), )
if mibBuilder.loadTexts: mplsXCTable.setStatus('current')
if mibBuilder.loadTexts: mplsXCTable.setDescription('This table specifies information for switching\n        between LSP segments.  It supports point-to-point,\n        point-to-multipoint and multipoint-to-point\n        connections.  mplsLabelStackTable specifies the\n        label stack information for a cross-connect LSR and\n        is referred to from mplsXCTable.')
mplsXCEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 9, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsXCIndex"), (0, "MPLS-LSR-MIB", "mplsInSegmentIfIndex"), (0, "MPLS-LSR-MIB", "mplsInSegmentLabel"), (0, "MPLS-LSR-MIB", "mplsOutSegmentIndex"))
if mibBuilder.loadTexts: mplsXCEntry.setStatus('current')
if mibBuilder.loadTexts: mplsXCEntry.setDescription('A row in this table represents one cross-connect\n        entry.  The following objects index it:\n\n        - cross-connect index mplsXCIndex that uniquely\n          identifies a group of cross-connect entries\n        - interface index of the in-segment,\n          mplsInSegmentIfIndex\n        - incoming label(s), mplsInSegmentLabel\n        - out-segment index, mplsOutSegmentIndex\n\n       Originating LSPs:\n        These are represented by using the special\n        combination of values mplsInSegmentIfIndex=0 and\n        mplsInSegmentLabel=0 as indexes.  In this case the\n        mplsOutSegmentIndex MUST be non-zero.\n\n       Terminating LSPs:\n       These are represented by using the special value\n        mplsOutSegmentIndex=0 as index.\n\n\n       Special labels:\n        Entries indexed by reserved MPLS label values 0\n        through 15 imply terminating LSPs and MUST have\n        mplsOutSegmentIfIndex = 0.  Note that situations\n        where LSPs are terminated with incoming label equal\n        to 0, should have mplsInSegmentIfIndex = 0 as well,\n        but can be distinguished from originating LSPs\n        because the mplsOutSegmentIfIndex = 0.  The\n        mplsOutSegmentIfIndex MUST only be set to 0 in\n        cases of terminating LSPs.\n\n        An entry can be created by a network administrator\n        or by an SNMP agent as instructed by an MPLS\n        signaling protocol.')
mplsXCIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCIndex.setDescription('Primary index for the row identifying a group of\n        cross-connect segments.')
mplsXCLspId = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 2), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCLspId.setStatus('current')
if mibBuilder.loadTexts: mplsXCLspId.setDescription('This value identifies the label switched path that\n        this cross-connect entry belongs to.')
mplsXCLabelStackIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCLabelStackIndex.setDescription('Primary index into mplsLabelStackTable identifying a\n        stack of labels to be pushed beneath the top label.\n        Note that the top label identified by the out-\n        segment ensures that all the components of a\n        multipoint-to-point connection have the same\n        outgoing label.  A value of 0 indicates that no\n        labels are to be stacked beneath the top label.')
mplsXCIsPersistent = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCIsPersistent.setStatus('current')
if mibBuilder.loadTexts: mplsXCIsPersistent.setDescription('Denotes whether or not this cross-connect entry and\n        associated in- and out-segments should be restored\n        automatically after failures.  This value MUST be\n        set to false in cases where this cross-connect entry\n        was created by a signaling protocol.')
mplsXCOwner = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 5), MplsObjectOwner()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCOwner.setStatus('current')
if mibBuilder.loadTexts: mplsXCOwner.setDescription('Denotes the entity that created and is responsible\n        for managing this cross-connect.')
mplsXCRowStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsXCStorageType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 7), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsXCStorageType.setDescription('Defines the storage type for this object.')
mplsXCAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCAdminStatus.setDescription('The desired operational status of this segment.')
mplsXCOperStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCOperStatus.setDescription('The actual operational status of this cross-\n        connect.')
mplsMaxLabelStackDepth = MibScalar((1, 3, 6, 1, 3, 96, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsMaxLabelStackDepth.setStatus('current')
if mibBuilder.loadTexts: mplsMaxLabelStackDepth.setDescription('The maximum stack depth supported by this LSR.')
mplsLabelStackIndexNext = MibScalar((1, 3, 6, 1, 3, 96, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLabelStackIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackIndexNext.setDescription('This object contains an appropriate value to be used\n        for mplsLabelStackIndex when creating entries in the\n        mplsLabelStackTable.  The value 0 indicates that no\n        unassigned entries are available.  To obtain an\n        mplsLabelStackIndex value for a new entry, the\n        manager issues a management protocol retrieval\n        operation to obtain the current value of this\n        object.  After each retrieval operation, the agent\n        should modify the value to reflect the next\n        unassigned index.  After a manager retrieves a value\n        the agent will determine through its local policy\n        when this index value will be made available for\n        reuse.')
mplsLabelStackTable = MibTable((1, 3, 6, 1, 3, 96, 1, 12), )
if mibBuilder.loadTexts: mplsLabelStackTable.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackTable.setDescription('This table specifies the label stack to be pushed\n        onto a packet, beneath the top label.  Entries into\n        this table are referred to from mplsXCTable.')
mplsLabelStackEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 12, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsLabelStackIndex"), (0, "MPLS-LSR-MIB", "mplsLabelStackLabelIndex"))
if mibBuilder.loadTexts: mplsLabelStackEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackEntry.setDescription('An entry in this table represents one label which is\n        to be pushed onto an outgoing packet, beneath the\n        top label.  An entry can be created by a network\n        administrator or by an SNMP agent as instructed by\n        an MPLS signaling protocol.')
mplsLabelStackIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackIndex.setDescription('Primary index for this row identifying a stack of\n        labels to be pushed on an outgoing packet, beneath\n        the top label.')
mplsLabelStackLabelIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLabelStackLabelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackLabelIndex.setDescription('Secondary index for this row identifying one label\n        of the stack.  Note that an entry with a smaller\n        mplsLabelStackLabelIndex would refer to a label\n        higher up the label stack and would be popped at a\n        downstream LSR before a label represented by a\n        higher mplsLabelStackLabelIndex at a downstream\n        LSR.')
mplsLabelStackLabel = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 12, 1, 3), MplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackLabel.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackLabel.setDescription('The label to pushed.')
mplsLabelStackRowStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 12, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsLabelStackStorageType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 12, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackStorageType.setDescription('Defines the storage type for this object.')
mplsTrafficParamIndexNext = MibScalar((1, 3, 6, 1, 3, 96, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTrafficParamIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamIndexNext.setDescription('This object contains an appropriate value which will\n        be used for mplsTrafficParamIndex when creating\n        entries in the mplsTrafficParamTable.  The value 0\n        indicates that no unassigned entries are available.\n        To obtain the mplsTrafficParamIndex value for a new\n        entry, the manager issues a management protocol\n        retrieval operation to obtain the current value of\n        this object.  After each retrieval operation, the\n        agent should modify the value to reflect the next\n        unassigned index.  After a manager retrieves a value\n        the agent will determine through its local policy\n        when this index value will be made available for\n        reuse.')
mplsTrafficParamTable = MibTable((1, 3, 6, 1, 3, 96, 1, 14), )
if mibBuilder.loadTexts: mplsTrafficParamTable.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamTable.setDescription('This table specifies the Traffic Parameter objects\n        for in and out-segments.')
mplsTrafficParamEntry = MibTableRow((1, 3, 6, 1, 3, 96, 1, 14, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsTrafficParamIndex"))
if mibBuilder.loadTexts: mplsTrafficParamEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamEntry.setDescription('An entry in this table represents the TrafficParam\n        objects for one or more in or out segments.  A\n        single entry can be pointed to by multiple segments\n        indicating resource sharing.')
mplsTrafficParamIndex = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTrafficParamIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamIndex.setDescription('Uniquely identifies this row of the table.  Note\n        that zero represents an invalid index.')
mplsTrafficParamMaxRate = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 14, 1, 2), MplsBitRate()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamMaxRate.setDescription('Maximum rate in kilobits/second.')
mplsTrafficParamMeanRate = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 14, 1, 3), MplsBitRate()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamMeanRate.setDescription('Mean rate in kilobits/second.')
mplsTrafficParamMaxBurstSize = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 14, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamMaxBurstSize.setDescription('Maximum burst size in bytes.')
mplsTrafficParamRowStatus = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 14, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsTrafficParamStorageType = MibTableColumn((1, 3, 6, 1, 3, 96, 1, 14, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamStorageType.setDescription('The storage type for this object.')
mplsInSegmentTrapEnable = MibScalar((1, 3, 6, 1, 3, 96, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsInSegmentTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentTrapEnable.setDescription('If this object is true, then it enables the\n        generation of mplsInSegmentUp and mplsInSegmentDown\n        traps, otherwise these traps are not emitted.')
mplsOutSegmentTrapEnable = MibScalar((1, 3, 6, 1, 3, 96, 1, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsOutSegmentTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTrapEnable.setDescription('If this object is true, then it enables the\n        generation of mplsOutSegmentUp and\n        mplsOutSegmentDown traps, otherwise these traps are\n        not emitted.')
mplsXCTrapEnable = MibScalar((1, 3, 6, 1, 3, 96, 1, 17), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsXCTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsXCTrapEnable.setDescription('If this object is true, then it enables the\n        generation of mplsXCUp and mplsXCDown traps,\n        otherwise these traps are not emitted.')
mplsInSegmentUp = NotificationType((1, 3, 6, 1, 3, 96, 2, 1)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentIfIndex"), ("MPLS-LSR-MIB", "mplsInSegmentLabel"), ("MPLS-LSR-MIB", "mplsInSegmentAdminStatus"), ("MPLS-LSR-MIB", "mplsInSegmentOperStatus"))
if mibBuilder.loadTexts: mplsInSegmentUp.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentUp.setDescription('This notification is generated when a\n        mplsInSegmentOperStatus object for one of the\n        configured in-segments is about to leave the down\n        state and transition into some other state (but not\n        into the notPresent state).  This other state is\n        indicated by the included value of\n        mplsInSegmentOperStatus.')
mplsInSegmentDown = NotificationType((1, 3, 6, 1, 3, 96, 2, 2)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentIfIndex"), ("MPLS-LSR-MIB", "mplsInSegmentLabel"), ("MPLS-LSR-MIB", "mplsInSegmentAdminStatus"), ("MPLS-LSR-MIB", "mplsInSegmentOperStatus"))
if mibBuilder.loadTexts: mplsInSegmentDown.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentDown.setDescription('This notification is generated when a\n        mplsInSegmentOperStatus object for one of the\n        configured in-segments is about to enter the down\n        state from some other state (but not from the\n        notPresent state).  This other state is indicated by\n        the included value of mplsInSegmentOperStatus.')
mplsOutSegmentUp = NotificationType((1, 3, 6, 1, 3, 96, 2, 3)).setObjects(("MPLS-LSR-MIB", "mplsOutSegmentIndex"), ("MPLS-LSR-MIB", "mplsInSegmentAdminStatus"), ("MPLS-LSR-MIB", "mplsInSegmentOperStatus"))
if mibBuilder.loadTexts: mplsOutSegmentUp.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentUp.setDescription('This notification is generated when a\n        mplsOutSegmentOperStatus object for one of the\n        configured out-segments is about to leave the down\n        state and transition into some other state (but not\n        into the notPresent state).  This other state is\n        indicated by the included value of\n        mplsOutSegmentOperStatus.')
mplsOutSegmentDown = NotificationType((1, 3, 6, 1, 3, 96, 2, 4)).setObjects(("MPLS-LSR-MIB", "mplsOutSegmentIndex"), ("MPLS-LSR-MIB", "mplsInSegmentAdminStatus"), ("MPLS-LSR-MIB", "mplsInSegmentOperStatus"))
if mibBuilder.loadTexts: mplsOutSegmentDown.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentDown.setDescription('This notification is generated when a\n        mplsOutSegmentOperStatus object for one of the\n        configured out-segments is about to enter the down\n\n\n        state from some other state (but not from the\n        notPresent state).  This other state is indicated by\n        the included value of mplsOutSegmentOperStatus.')
mplsXCUp = NotificationType((1, 3, 6, 1, 3, 96, 2, 5)).setObjects(("MPLS-LSR-MIB", "mplsXCIndex"), ("MPLS-LSR-MIB", "mplsInSegmentIfIndex"), ("MPLS-LSR-MIB", "mplsInSegmentLabel"), ("MPLS-LSR-MIB", "mplsOutSegmentIndex"), ("MPLS-LSR-MIB", "mplsXCAdminStatus"), ("MPLS-LSR-MIB", "mplsXCOperStatus"))
if mibBuilder.loadTexts: mplsXCUp.setStatus('current')
if mibBuilder.loadTexts: mplsXCUp.setDescription('This notification is generated when a\n        mplsXCOperStatus object for one of the configured\n        cross-connect entries is about to leave the down\n        state and transition into some other state (but not\n        into the notPresent state).  This other state is\n        indicated by the included value of\n        mplsXCOperStatus.')
mplsXCDown = NotificationType((1, 3, 6, 1, 3, 96, 2, 6)).setObjects(("MPLS-LSR-MIB", "mplsXCIndex"), ("MPLS-LSR-MIB", "mplsInSegmentIfIndex"), ("MPLS-LSR-MIB", "mplsInSegmentLabel"), ("MPLS-LSR-MIB", "mplsOutSegmentIndex"), ("MPLS-LSR-MIB", "mplsXCAdminStatus"), ("MPLS-LSR-MIB", "mplsXCOperStatus"))
if mibBuilder.loadTexts: mplsXCDown.setStatus('current')
if mibBuilder.loadTexts: mplsXCDown.setDescription('This notification is generated when a\n        mplsXCOperStatus object for one of the configured\n        cross-connect entries is about to enter the down\n        state from some other state (but not from the\n        notPresent state).  This other state is indicated by\n        the included value of mplsXCOperStatus.')
mplsLsrGroups = MibIdentifier((1, 3, 6, 1, 3, 96, 3, 1))
mplsLsrCompliances = MibIdentifier((1, 3, 6, 1, 3, 96, 3, 2))
mplsLsrModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 96, 3, 2, 1)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentGroup"), ("MPLS-LSR-MIB", "mplsOutSegmentGroup"), ("MPLS-LSR-MIB", "mplsXCGroup"), ("MPLS-LSR-MIB", "mplsInterfaceGroup"), ("MPLS-LSR-MIB", "mplsPerfGroup"), ("MPLS-LSR-MIB", "mplsSegmentDiscontinuityGroup"), ("MPLS-LSR-MIB", "mplsHCInSegmentPerfGroup"), ("MPLS-LSR-MIB", "mplsHCOutSegmentPerfGroup"), ("MPLS-LSR-MIB", "mplsTrafficParamGroup"), ("MPLS-LSR-MIB", "mplsXCIsPersistentGroup"), ("MPLS-LSR-MIB", "mplsXCIsNotPersistentGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLsrModuleCompliance = mplsLsrModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLsrModuleCompliance.setDescription('Compliance statement for agents that support the\n        MPLS LSR MIB.')
mplsInterfaceGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 1)).setObjects(("MPLS-LSR-MIB", "mplsInterfaceLabelMinIn"), ("MPLS-LSR-MIB", "mplsInterfaceLabelMaxIn"), ("MPLS-LSR-MIB", "mplsInterfaceLabelMinOut"), ("MPLS-LSR-MIB", "mplsInterfaceLabelMaxOut"), ("MPLS-LSR-MIB", "mplsInterfaceTotalBandwidth"), ("MPLS-LSR-MIB", "mplsInterfaceAvailableBandwidth"), ("MPLS-LSR-MIB", "mplsInterfaceTotalBuffer"), ("MPLS-LSR-MIB", "mplsInterfaceAvailableBuffer"), ("MPLS-LSR-MIB", "mplsInterfaceLabelParticipationType"), ("MPLS-LSR-MIB", "mplsInterfaceConfStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsInterfaceGroup = mplsInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceGroup.setDescription('Collection of objects needed for MPLS interface\n           configuration and performance information.')
mplsInSegmentGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 2)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentNPop"), ("MPLS-LSR-MIB", "mplsInSegmentAddrFamily"), ("MPLS-LSR-MIB", "mplsInSegmentXCIndex"), ("MPLS-LSR-MIB", "mplsInSegmentOctets"), ("MPLS-LSR-MIB", "mplsInSegmentDiscards"), ("MPLS-LSR-MIB", "mplsInSegmentOwner"), ("MPLS-LSR-MIB", "mplsInSegmentAdminStatus"), ("MPLS-LSR-MIB", "mplsInSegmentOperStatus"), ("MPLS-LSR-MIB", "mplsInSegmentRowStatus"), ("MPLS-LSR-MIB", "mplsInSegmentTrapEnable"), ("MPLS-LSR-MIB", "mplsInSegmentStorageType"), ("MPLS-LSR-MIB", "mplsInSegmentTrafficParamPtr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsInSegmentGroup = mplsInSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentGroup.setDescription('Collection of objects needed to implement an in-\n           segment.')
mplsOutSegmentGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 3)).setObjects(("MPLS-LSR-MIB", "mplsOutSegmentIndexNext"), ("MPLS-LSR-MIB", "mplsOutSegmentIfIndex"), ("MPLS-LSR-MIB", "mplsOutSegmentPushTopLabel"), ("MPLS-LSR-MIB", "mplsOutSegmentTopLabel"), ("MPLS-LSR-MIB", "mplsOutSegmentNextHopIpAddrType"), ("MPLS-LSR-MIB", "mplsOutSegmentNextHopIpv4Addr"), ("MPLS-LSR-MIB", "mplsOutSegmentNextHopIpv6Addr"), ("MPLS-LSR-MIB", "mplsOutSegmentXCIndex"), ("MPLS-LSR-MIB", "mplsOutSegmentOwner"), ("MPLS-LSR-MIB", "mplsOutSegmentOctets"), ("MPLS-LSR-MIB", "mplsOutSegmentDiscards"), ("MPLS-LSR-MIB", "mplsOutSegmentErrors"), ("MPLS-LSR-MIB", "mplsOutSegmentAdminStatus"), ("MPLS-LSR-MIB", "mplsOutSegmentOperStatus"), ("MPLS-LSR-MIB", "mplsOutSegmentRowStatus"), ("MPLS-LSR-MIB", "mplsOutSegmentTrapEnable"), ("MPLS-LSR-MIB", "mplsOutSegmentStorageType"), ("MPLS-LSR-MIB", "mplsOutSegmentTrafficParamPtr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsOutSegmentGroup = mplsOutSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentGroup.setDescription('Collection of objects needed to implement an out-\n           segment.')
mplsXCGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 4)).setObjects(("MPLS-LSR-MIB", "mplsXCIndexNext"), ("MPLS-LSR-MIB", "mplsXCLspId"), ("MPLS-LSR-MIB", "mplsXCLabelStackIndex"), ("MPLS-LSR-MIB", "mplsXCOwner"), ("MPLS-LSR-MIB", "mplsXCAdminStatus"), ("MPLS-LSR-MIB", "mplsXCOperStatus"), ("MPLS-LSR-MIB", "mplsXCRowStatus"), ("MPLS-LSR-MIB", "mplsXCTrapEnable"), ("MPLS-LSR-MIB", "mplsXCStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCGroup = mplsXCGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCGroup.setDescription('Collection of objects needed to implement a\n           cross-connect entry.')
mplsPerfGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 5)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentOctets"), ("MPLS-LSR-MIB", "mplsInSegmentPackets"), ("MPLS-LSR-MIB", "mplsInSegmentErrors"), ("MPLS-LSR-MIB", "mplsInSegmentDiscards"), ("MPLS-LSR-MIB", "mplsOutSegmentOctets"), ("MPLS-LSR-MIB", "mplsOutSegmentPackets"), ("MPLS-LSR-MIB", "mplsOutSegmentDiscards"), ("MPLS-LSR-MIB", "mplsInterfaceInLabelsUsed"), ("MPLS-LSR-MIB", "mplsInterfaceInPackets"), ("MPLS-LSR-MIB", "mplsInterfaceInDiscards"), ("MPLS-LSR-MIB", "mplsInterfaceFailedLabelLookup"), ("MPLS-LSR-MIB", "mplsInterfaceOutPackets"), ("MPLS-LSR-MIB", "mplsInterfaceOutDiscards"), ("MPLS-LSR-MIB", "mplsInterfaceOutFragments"), ("MPLS-LSR-MIB", "mplsInterfaceOutLabelsUsed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsPerfGroup = mplsPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsPerfGroup.setDescription('Collection of objects providing performance\n           information\n        about an LSR.')
mplsHCInSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 6)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsHCInSegmentPerfGroup = mplsHCInSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsHCInSegmentPerfGroup.setDescription('Object(s) providing performance information\n           specific to out-segments for which the object\n           mplsInterfaceInOctets wraps around too quickly.')
mplsHCOutSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 7)).setObjects(("MPLS-LSR-MIB", "mplsOutSegmentHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsHCOutSegmentPerfGroup = mplsHCOutSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsHCOutSegmentPerfGroup.setDescription('Object(s) providing performance information\n           specific to out-segments for which the object\n           mplsInterfaceOutOctets wraps around too\n           quickly.')
mplsTrafficParamGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 8)).setObjects(("MPLS-LSR-MIB", "mplsTrafficParamIndexNext"), ("MPLS-LSR-MIB", "mplsTrafficParamMaxRate"), ("MPLS-LSR-MIB", "mplsTrafficParamMeanRate"), ("MPLS-LSR-MIB", "mplsTrafficParamMaxBurstSize"), ("MPLS-LSR-MIB", "mplsTrafficParamRowStatus"), ("MPLS-LSR-MIB", "mplsTrafficParamStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTrafficParamGroup = mplsTrafficParamGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamGroup.setDescription('Object(s) required for supporting QoS resource\n           reservation.')
mplsXCIsPersistentGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 9)).setObjects(("MPLS-LSR-MIB", "mplsXCIsPersistent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCIsPersistentGroup = mplsXCIsPersistentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCIsPersistentGroup.setDescription('Objects needed to support persistent cross-\n           connects.')
mplsXCIsNotPersistentGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 10)).setObjects(("MPLS-LSR-MIB", "mplsXCIsPersistent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCIsNotPersistentGroup = mplsXCIsNotPersistentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCIsNotPersistentGroup.setDescription('Objects needed to support non-persistent cross-\n           connects.')
mplsLabelStackGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 11)).setObjects(("MPLS-LSR-MIB", "mplsLabelStackLabel"), ("MPLS-LSR-MIB", "mplsLabelStackRowStatus"), ("MPLS-LSR-MIB", "mplsLabelStackStorageType"), ("MPLS-LSR-MIB", "mplsMaxLabelStackDepth"), ("MPLS-LSR-MIB", "mplsLabelStackIndexNext"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLabelStackGroup = mplsLabelStackGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackGroup.setDescription('Objects needed to support label stacking.')
mplsSegmentDiscontinuityGroup = ObjectGroup((1, 3, 6, 1, 3, 96, 3, 1, 12)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentPerfDiscontinuityTime"), ("MPLS-LSR-MIB", "mplsOutSegmentPerfDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsSegmentDiscontinuityGroup = mplsSegmentDiscontinuityGroup.setStatus('current')
if mibBuilder.loadTexts: mplsSegmentDiscontinuityGroup.setDescription(' A collection of objects providing information\n        specific to segment discontinuities..')
mplsLsrNotificationGroup = NotificationGroup((1, 3, 6, 1, 3, 96, 3, 1, 13)).setObjects(("MPLS-LSR-MIB", "mplsInSegmentUp"), ("MPLS-LSR-MIB", "mplsInSegmentDown"), ("MPLS-LSR-MIB", "mplsOutSegmentUp"), ("MPLS-LSR-MIB", "mplsOutSegmentDown"), ("MPLS-LSR-MIB", "mplsXCUp"), ("MPLS-LSR-MIB", "mplsXCDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLsrNotificationGroup = mplsLsrNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLsrNotificationGroup.setDescription('Set of notifications implemented in this module.\n           None is mandatory.')
mibBuilder.exportSymbols("MPLS-LSR-MIB", mplsLabelStackIndexNext=mplsLabelStackIndexNext, MplsObjectOwner=MplsObjectOwner, mplsMaxLabelStackDepth=mplsMaxLabelStackDepth, mplsOutSegmentEntry=mplsOutSegmentEntry, mplsTrafficParamIndex=mplsTrafficParamIndex, mplsSegmentDiscontinuityGroup=mplsSegmentDiscontinuityGroup, mplsOutSegmentTrafficParamPtr=mplsOutSegmentTrafficParamPtr, mplsInSegmentIfIndex=mplsInSegmentIfIndex, mplsTrafficParamMeanRate=mplsTrafficParamMeanRate, mplsInterfaceFailedLabelLookup=mplsInterfaceFailedLabelLookup, mplsInSegmentPackets=mplsInSegmentPackets, mplsHCInSegmentPerfGroup=mplsHCInSegmentPerfGroup, mplsXCIndexNext=mplsXCIndexNext, mplsOutSegmentNextHopIpAddrType=mplsOutSegmentNextHopIpAddrType, mplsTrafficParamGroup=mplsTrafficParamGroup, mplsOutSegmentPerfTable=mplsOutSegmentPerfTable, mplsInterfaceInDiscards=mplsInterfaceInDiscards, mplsInterfaceLabelMinIn=mplsInterfaceLabelMinIn, mplsInSegmentRowStatus=mplsInSegmentRowStatus, mplsXCOperStatus=mplsXCOperStatus, mplsInterfaceConfTable=mplsInterfaceConfTable, mplsLsrConformance=mplsLsrConformance, mplsOutSegmentIfIndex=mplsOutSegmentIfIndex, mplsInterfaceTotalBuffer=mplsInterfaceTotalBuffer, mplsLabelStackLabel=mplsLabelStackLabel, mplsTrafficParamEntry=mplsTrafficParamEntry, mplsOutSegmentOctets=mplsOutSegmentOctets, mplsInSegmentPerfDiscontinuityTime=mplsInSegmentPerfDiscontinuityTime, mplsXCDown=mplsXCDown, mplsInterfacePerfTable=mplsInterfacePerfTable, mplsInSegmentStorageType=mplsInSegmentStorageType, mplsOutSegmentPerfEntry=mplsOutSegmentPerfEntry, mplsXCUp=mplsXCUp, mplsOutSegmentPackets=mplsOutSegmentPackets, mplsInterfaceTotalBandwidth=mplsInterfaceTotalBandwidth, mplsOutSegmentNextHopIpv6Addr=mplsOutSegmentNextHopIpv6Addr, mplsXCStorageType=mplsXCStorageType, mplsLabelStackStorageType=mplsLabelStackStorageType, MplsBurstSize=MplsBurstSize, mplsInterfaceLabelParticipationType=mplsInterfaceLabelParticipationType, mplsXCGroup=mplsXCGroup, mplsXCTrapEnable=mplsXCTrapEnable, mplsInSegmentTrafficParamPtr=mplsInSegmentTrafficParamPtr, mplsLabelStackTable=mplsLabelStackTable, mplsInterfaceConfIndex=mplsInterfaceConfIndex, mplsOutSegmentIndex=mplsOutSegmentIndex, mplsInterfaceLabelMaxOut=mplsInterfaceLabelMaxOut, mplsInSegmentOwner=mplsInSegmentOwner, mplsPerfGroup=mplsPerfGroup, mplsOutSegmentTable=mplsOutSegmentTable, MplsLSPID=MplsLSPID, mplsOutSegmentHCOctets=mplsOutSegmentHCOctets, mplsInSegmentErrors=mplsInSegmentErrors, mplsOutSegmentNextHopIpv4Addr=mplsOutSegmentNextHopIpv4Addr, mplsTrafficParamIndexNext=mplsTrafficParamIndexNext, mplsInterfaceAvailableBuffer=mplsInterfaceAvailableBuffer, mplsInSegmentHCOctets=mplsInSegmentHCOctets, mplsLabelStackRowStatus=mplsLabelStackRowStatus, mplsTrafficParamRowStatus=mplsTrafficParamRowStatus, mplsInSegmentAddrFamily=mplsInSegmentAddrFamily, mplsOutSegmentErrors=mplsOutSegmentErrors, mplsOutSegmentDown=mplsOutSegmentDown, MplsBitRate=MplsBitRate, mplsInSegmentTable=mplsInSegmentTable, mplsInSegmentTrapEnable=mplsInSegmentTrapEnable, mplsXCOwner=mplsXCOwner, mplsInterfaceOutPackets=mplsInterfaceOutPackets, mplsInterfaceAvailableBandwidth=mplsInterfaceAvailableBandwidth, mplsTrafficParamMaxRate=mplsTrafficParamMaxRate, mplsInSegmentAdminStatus=mplsInSegmentAdminStatus, mplsLsrObjects=mplsLsrObjects, mplsOutSegmentUp=mplsOutSegmentUp, mplsInterfaceInPackets=mplsInterfaceInPackets, mplsXCLabelStackIndex=mplsXCLabelStackIndex, mplsInterfaceOutLabelsUsed=mplsInterfaceOutLabelsUsed, mplsOutSegmentGroup=mplsOutSegmentGroup, mplsXCAdminStatus=mplsXCAdminStatus, mplsXCEntry=mplsXCEntry, mplsXCLspId=mplsXCLspId, mplsInSegmentXCIndex=mplsInSegmentXCIndex, mplsInSegmentGroup=mplsInSegmentGroup, mplsLsrMIB=mplsLsrMIB, mplsOutSegmentPerfDiscontinuityTime=mplsOutSegmentPerfDiscontinuityTime, mplsTrafficParamMaxBurstSize=mplsTrafficParamMaxBurstSize, MplsBufferSize=MplsBufferSize, mplsOutSegmentOperStatus=mplsOutSegmentOperStatus, mplsLsrNotificationGroup=mplsLsrNotificationGroup, mplsInSegmentUp=mplsInSegmentUp, mplsInSegmentNPop=mplsInSegmentNPop, mplsInterfaceOutDiscards=mplsInterfaceOutDiscards, mplsXCTable=mplsXCTable, mplsOutSegmentTrapEnable=mplsOutSegmentTrapEnable, mplsXCRowStatus=mplsXCRowStatus, mplsOutSegmentOwner=mplsOutSegmentOwner, mplsOutSegmentXCIndex=mplsOutSegmentXCIndex, mplsInSegmentDown=mplsInSegmentDown, mplsXCIsPersistentGroup=mplsXCIsPersistentGroup, mplsXCIsNotPersistentGroup=mplsXCIsNotPersistentGroup, MplsLabel=MplsLabel, mplsInterfaceInLabelsUsed=mplsInterfaceInLabelsUsed, mplsInSegmentPerfTable=mplsInSegmentPerfTable, mplsInSegmentEntry=mplsInSegmentEntry, mplsTrafficParamStorageType=mplsTrafficParamStorageType, mplsOutSegmentTopLabel=mplsOutSegmentTopLabel, mplsOutSegmentDiscards=mplsOutSegmentDiscards, mplsOutSegmentPushTopLabel=mplsOutSegmentPushTopLabel, mplsInSegmentOctets=mplsInSegmentOctets, mplsLabelStackIndex=mplsLabelStackIndex, mplsLsrCompliances=mplsLsrCompliances, mplsInterfaceConfEntry=mplsInterfaceConfEntry, mplsInterfaceGroup=mplsInterfaceGroup, mplsLabelStackLabelIndex=mplsLabelStackLabelIndex, mplsInSegmentDiscards=mplsInSegmentDiscards, mplsOutSegmentAdminStatus=mplsOutSegmentAdminStatus, mplsXCIndex=mplsXCIndex, mplsLsrNotifications=mplsLsrNotifications, mplsInterfaceLabelMinOut=mplsInterfaceLabelMinOut, mplsTrafficParamTable=mplsTrafficParamTable, mplsXCIsPersistent=mplsXCIsPersistent, mplsInterfacePerfEntry=mplsInterfacePerfEntry, PYSNMP_MODULE_ID=mplsLsrMIB, mplsInterfaceOutFragments=mplsInterfaceOutFragments, mplsLabelStackGroup=mplsLabelStackGroup, mplsInSegmentOperStatus=mplsInSegmentOperStatus, mplsInSegmentPerfEntry=mplsInSegmentPerfEntry, mplsInterfaceConfStorageType=mplsInterfaceConfStorageType, mplsInterfaceLabelMaxIn=mplsInterfaceLabelMaxIn, mplsInSegmentLabel=mplsInSegmentLabel, mplsOutSegmentIndexNext=mplsOutSegmentIndexNext, mplsOutSegmentRowStatus=mplsOutSegmentRowStatus, mplsHCOutSegmentPerfGroup=mplsHCOutSegmentPerfGroup, mplsLsrGroups=mplsLsrGroups, mplsLsrModuleCompliance=mplsLsrModuleCompliance, mplsOutSegmentStorageType=mplsOutSegmentStorageType, mplsLabelStackEntry=mplsLabelStackEntry)
