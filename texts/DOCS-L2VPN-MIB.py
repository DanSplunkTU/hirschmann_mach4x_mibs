#
# PySNMP MIB module DOCS-L2VPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/DOCS-L2VPN-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 17:49:37 2022
# On host fv-az77-149 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
dot1dBasePort, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePort")
clabProjDocsis, = mibBuilder.importSymbols("CLAB-DEF-MIB", "clabProjDocsis")
docsIfCmtsCmStatusIndex, = mibBuilder.importSymbols("DOCS-IF-MIB", "docsIfCmtsCmStatusIndex")
docsQosPktClassId, docsQosServiceFlowId = mibBuilder.importSymbols("DOCS-QOS-MIB", "docsQosPktClassId", "docsQosServiceFlowId")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
dot1qFdbId, dot1qTpFdbAddress, dot1qTpGroupAddress, dot1qVlanIndex = mibBuilder.importSymbols("Q-BRIDGE-MIB", "dot1qFdbId", "dot1qTpFdbAddress", "dot1qTpGroupAddress", "dot1qVlanIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibIdentifier, Counter32, Counter64, ModuleIdentity, iso, ObjectIdentity, IpAddress, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, NotificationType, Bits, Gauge32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter32", "Counter64", "ModuleIdentity", "iso", "ObjectIdentity", "IpAddress", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "NotificationType", "Bits", "Gauge32", "Unsigned32")
DisplayString, TextualConvention, TruthValue, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue", "MacAddress")
docsL2vpnMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8))
docsL2vpnMIB.setRevisions(('2006-03-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: docsL2vpnMIB.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: docsL2vpnMIB.setLastUpdated('200603280000Z')
if mibBuilder.loadTexts: docsL2vpnMIB.setOrganization('CableLabs')
if mibBuilder.loadTexts: docsL2vpnMIB.setContactInfo('Postal: Cable Television Laboratories, Inc.  \n        858 Coal Creek Circle  \n        Louisville, Colorado 80027-9750  \n        U.S.A.  \n        Phone:  +1 303-661-9100  \n        Fax:   +1 303-661-9199  \n        E-mail: mibs@cablelabs.com')
if mibBuilder.loadTexts: docsL2vpnMIB.setDescription('This is the management MIB for devices complying to the  \n        DOCSIS L2VPN Feature.')
class DocsL2vpnIdentifier(TextualConvention, OctetString):
    description = 'An externally administered octet string identifying an  \n            L2VPN. An implementation MUST support a length of at least \n            16 octets. The octet string is used as an index. As such,  \n            the CMTS enforces that objects of type DocsL2vpnIdentifier \n            are unique per CMTS. An MSO is encouraged to define  \n            DocsL2vpnIdentifier values as globally unique.'
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 16)

class DocsL2vpnIndex(TextualConvention, Unsigned32):
    description = 'An integer value locally generated by the agent for each  \n            known DocsL2vpnIdentifier administrative identifier. It is \n            intended to be used as a short index for tables in this MIB \n            module in lieu of an object of the type  \n            DocsL2vpnIdentifier.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class DocsNsiEncapSubtype(TextualConvention, Integer32):
    description = 'An enumerated integer that defines the default  \n            encapsulation on NSI ports of an L2VPN-forwarded packet. \n            A CMTS implementation MUST support ieee802.1q(2). \n            A CMTS MAY omit support for all NSI  encapsulations  \n            other than ieee802.1q(2).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("ieee8021q", 2), ("ieee8021ad", 3), ("mpls", 4), ("l2tpv3", 5))

class DocsNsiEncapValue(TextualConvention, OctetString):
    description = 'The encapsulation value for L2VPN forwarded packets on NSI \n            ports. The value of an object of this type depends on the  \n            value of an associated object of type DocsEncapSubtype: \n \n            other(1): vendor specific, \n            ieee8021q(2): 802.1Q tag with VLAN ID in lower 12 bits, \n            ieee8021ad(3): pair of 16-bit values with service provider \n            in lower 12 bits of the first 16-bit value and customer  \n            VLAN ID in the lower 12 bits of the second 16-bit value, \n            mpls(4): must be zero length string, \n            l2tpv3(5): must be zero length string.'
    status = 'current'

class DocsL2vpnIfList(TextualConvention, Bits):
    description = "A object of this type indicates a set of CM  \n            MAC bridge interfaces, encoded as a BITS syntax with a ?1? \n            Bit for each interface included in the set. \n \n            Bit position eCM(0) represents a conceptual interface to  \n            the internal 'self' host MAC of the eCM itself. All other  \n            bit positions K correspond to CM MAC bridge port interface \n            index with ifIndex value K.  \n \n            A BITS object is encoded as an OCTET STRING, which may have \n            length zero. Bit position 0 is encoded in the most \n            significant bit of the first octet, proceeding to  \n            bit position 7 in the least significant bit. Bit position 8 \n            is encoded in the most significant bit of the second octet, \n            and so on. \n \n            In a CM, ifIndex value 1 corresponds to the primary CPE  \n            interface. In CableHome devices, this interface is assigned \n            to the embedded Portal Services (ePS) host interface, which \n            provides a portal to the primary physical CPE interface.  \n            In many contexts of a DocsL2VpnIfList, a '1' in bit  \n            position 1 corresponds to 'any' or 'all' CPE interfaces  \n            when the CM contains more than one CPE interface.  \n \n            ifIndex value 2 corresponds to the docsCableMacLayer  \n            RF MAC interface.  \n \n            ifIndex values 3 and 4 correspond to the  \n            docsCableDownstream and docsCableUpstream interfaces,  \n            respectively, which are not separate MAC bridge port  \n            interfaces. Bit positions 3 and 4 are unused in this type; \n            they must be saved and reported as configured, but  \n            otherwise ignored.  \n \n            ifIndex values 5 through 15 are reserved for individual \n            CPE interfaces for devices that implement more than one \n            CPE interface. In such devices, DocsL2vpnIfList bit  \n            position 1 corresponds to the set of all CPE interfaces. \n            A CM with more than one CPE interface MAY assign a \n            DocsL2vpnIfList bit position within the range of 5..15 to \n            refer to the single primary CPE interface.  \n \n            ifIndex value 16 is assigned to any embedded Multimedia  \n            Terminal Adapter (eMTA) as defined by PacketCable. \n \n            ifIndex value 17 is assigned to the IP management host  \n            interface of an embedded Set Top Box (eSTB). ifIndex value  \n            18 is reserved for the DOCSIS Set-top Gateway (DSG) traffic \n            delivered to an eSTB.  \n \n            ifIndex values 19 through 31 are \n            reserved for future defined embedded Service Application."
    status = 'current'
    namedValues = NamedValues(("eCm", 0), ("cmci", 1), ("docsCableMacLayer", 2), ("docsCableDownstream", 3), ("docsCableUpstream", 4), ("eMta", 16), ("eStbIp", 17), ("eStbDsg", 18))

docsL2vpnMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 0))
docsL2vpnMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1))
docsL2vpnIdToIndexTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 1), )
if mibBuilder.loadTexts: docsL2vpnIdToIndexTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnIdToIndexTable.setDescription("Table indexed by the octet string DocsL2vpnIdentifier that \n            provides the local agent's internally assigned docsL2vpnIdx \n            value for that DocsL2vpnIdentifier value. The mapping of  \n            DocsL2vpnIdentifier to docsL2vpnIdx is 1-1. The agent  \n            must instantiate a row in both docsL2vpnIndexToIdTable and \n            docsL2vpnIdToIndexTable for each known L2VPN Identifier.")
docsL2vpnIdToIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 1, 1), ).setIndexNames((0, "DOCS-L2VPN-MIB", "docsL2vpnId"))
if mibBuilder.loadTexts: docsL2vpnIdToIndexEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnIdToIndexEntry.setDescription("Maps a DocsL2vpnIdentifier octet string into the local  \n            agent's locally assigned docsL2vpnIdx value.")
docsL2vpnId = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 1, 1, 1), DocsL2vpnIdentifier())
if mibBuilder.loadTexts: docsL2vpnId.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnId.setDescription('An externally configured octet string that identifies an \n            L2VPN.')
docsL2vpnIdToIndexIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 1, 1, 2), DocsL2vpnIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnIdToIndexIdx.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnIdToIndexIdx.setDescription('An internally assigned index value for a known L2VPN.')
docsL2vpnIndexToIdTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 2), )
if mibBuilder.loadTexts: docsL2vpnIndexToIdTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnIndexToIdTable.setDescription("Table indexed by agent's local docsL2vpnIdx that provides \n            the global L2VPN Identifier. The mapping of docsL2vpnIdx to \n            DocsL2vpnIdentifier is 1-1. The agent must instantiate a  \n            row in both docsL2vpnIndexToIdTable and  \n            docsL2vpnIdToIndexTable for each known L2VPN.")
docsL2vpnIndexToIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 2, 1), ).setIndexNames((0, "DOCS-L2VPN-MIB", "docsL2vpnIdx"))
if mibBuilder.loadTexts: docsL2vpnIndexToIdEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnIndexToIdEntry.setDescription('Provides the L2VPN Identifier for each locally-assigned  \n            L2vpn Index.')
docsL2vpnIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 2, 1, 1), DocsL2vpnIndex())
if mibBuilder.loadTexts: docsL2vpnIdx.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnIdx.setDescription('An internally assigned index value for a known L2VPN.')
docsL2vpnIndexToIdId = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 2, 1, 2), DocsL2vpnIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnIndexToIdId.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnIndexToIdId.setDescription('An administered octet string that externally identifies an \n            L2VPN.')
docsL2vpnCmTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 3), )
if mibBuilder.loadTexts: docsL2vpnCmTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmTable.setDescription('This table describes L2VPN per-CM information that \n            is in common with all L2VPNs for the CM, regardless \n            of forwarding mode.')
docsL2vpnCmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 3, 1), ).setIndexNames((0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"))
if mibBuilder.loadTexts: docsL2vpnCmEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmEntry.setDescription('An entry is indexed by Cable Modem Index that \n            describes L2VPN information for a single CM that is in \n            common with all L2VPNs implemented by the CM, \n            regardless of the L2VPN forwarding mode. \n \n            An entry in this table is created for every CM that  \n            registers with a forwarding L2VPN encoding.')
docsL2vpnCmCompliantCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 3, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmCompliantCapability.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmCompliantCapability.setDescription("This object reports whether an L2VPN forwarding CM is \n            compliant with the DOCSIS L2VPN specification, as reported \n            in the L2VPN Capability encoding in the CM's registration \n            request message. \n \n            If the capability encoding was omitted, this object must \n            report the value false(2).")
docsL2vpnCmDutFilteringCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 3, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmDutFilteringCapability.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmDutFilteringCapability.setDescription("This object reports whether an L2VPN forwarding CM is \n            capable of Downstream Unencrypted Traffic (DUT) Filtering, \n            as reported in the CM's registration request message. \n \n            If the capability encoding was omitted, this object must \n            report the value false(2).")
docsL2vpnCmDutCMIM = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 3, 1, 3), DocsL2vpnIfList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmDutCMIM.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmDutCMIM.setDescription("This object reports the value configured in a per-CM  \n            L2VPN Encoding for Downstream Unencrypted Traffic (DUT) \n            Cable Modem Interface Mask (CMIM).  \n \n            The DUT CMIM is a bit string with a '1' for each bit  \n            position K for an internal or external CM interface with  \n            ifIndex K to which the CM permits DUT to be forwarded. A CM \n            capable of DUT filtering MUST discard DUT to interfaces \n            with a '0' in the DUT CMIM.  \n \n            If a CM's top-level registration request L2VPN Encoding \n            contained no DUT CMIM subtype, this object is reported \n            with its default value of a '1' in bit position 0  \n            (corresponding to the eCM's own 'self' host) and a '1' in  \n            each bit position K for which an eSAFE interface exists at \n            ifIndex K. In other words, the default DUT CMIM includes  \n            the eCM and all eSAFE interfaces. \n \n            This value is reported independently of whether the CM is \n            actually capable of performing DUT filtering.")
docsL2vpnCmDhcpSnooping = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 3, 1, 4), DocsL2vpnIfList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmDhcpSnooping.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmDhcpSnooping.setDescription('This object reports the value of the Enable DHCP Snooping \n            subtype of a top-level L2VPN Encoding.  \n \n            It has the syntax of a CM Interface List bitmask and \n            represents a set of CM MAC bridge interfaces  \n            corresponding to eSAFE hosts for which the CMTS is enabled  \n            to snoop DHCP traffic in order to learn the eSAFE host MAC \n            address on that interface.   \n \n            Only bits corresponding to eSAFE host MAC addresses may be \n            validly set in this object, including cpe(1) for ePS \n            and the eSAFE interfaces in bits positions 16 through 31.')
docsL2vpnVpnCmTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 4), )
if mibBuilder.loadTexts: docsL2vpnVpnCmTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmTable.setDescription('This table describes the operation of L2VPN forwarding \n            on each CM.')
docsL2vpnVpnCmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 4, 1), ).setIndexNames((0, "DOCS-L2VPN-MIB", "docsL2vpnIdx"), (0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"))
if mibBuilder.loadTexts: docsL2vpnVpnCmEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmEntry.setDescription('An entry is indexed by VPN ID and Cable Modem Index that \n            describes the operation of L2VPN forwarding for a single \n            L2VPN on a single CM.')
docsL2vpnVpnCmCMIM = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 4, 1, 1), DocsL2vpnIfList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmCMIM.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmCMIM.setDescription('A Cable Modem Interface Mask represents a set of  \n            MAC bridge interfaces within the CM. This object \n            represents the CMIM within a forwarding per-SF L2VPN  \n            encoding, which specifies a set of CM MAC bridge  \n            interfaces to which L2VPN forwarding is restricted. \n \n            If the CMIM Subtype is omitted from a forwarding \n            per-SF encoding, its default value includes only \n            cpePrimary(1) and cableMac(2), which can be encoded \n            with a single octet with the value 0x60.')
docsL2vpnVpnCmIndividualSAId = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmIndividualSAId.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmIndividualSAId.setDescription('The BPI+ Security Association ID in which traffic intended \n            for point-to-point forwarding through an individual CM is  \n            forwarded.  \n \n            If the CMTS does not allocate an individual SAID for \n            multipoint forwarding (as is recommended),it MUST  \n            report this object as zero.')
docsL2vpnVpnCmVendorSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmVendorSpecific.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmVendorSpecific.setDescription('This object encodes the concatenation of all Vendor  \n            Specific Subtype encodings that appeared in any  \n            registration per-CM L2VPN Encoding associated with this  \n            entry.')
docsL2vpnVpnCmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5), )
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsTable.setDescription('This table contains statistics for forwarding of  \n            packets to and from a CM on each VPN.')
docsL2vpnVpnCmStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5, 1), ).setIndexNames((0, "DOCS-L2VPN-MIB", "docsL2vpnIdx"), (0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"))
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsEntry.setDescription('An entry is indexed by VPN ID and Cable Modem Index.')
docsL2vpnVpnCmStatsUpstreamPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsUpstreamPkts.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsUpstreamPkts.setDescription("The number of L2vpn-forwarded packets received \n            from this instance's Cable Modem on \n            this instance's L2VPN.")
docsL2vpnVpnCmStatsUpstreamBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsUpstreamBytes.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsUpstreamBytes.setDescription("The number of L2vpn-forwarded bytes received \n            from this instance's Cable Modem on \n            this instance's L2VPN.")
docsL2vpnVpnCmStatsUpstreamDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsUpstreamDiscards.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsUpstreamDiscards.setDescription("The number of L2-forwarded packets  \n            discarded from this instance's  \n            Cable Modem on this instance's VPN.")
docsL2vpnVpnCmStatsDownstreamPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsDownstreamPkts.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsDownstreamPkts.setDescription("The number of L2-forwarded packets \n            transmitted to this instance's \n            Cable Modem on this instance's VPN.")
docsL2vpnVpnCmStatsDownstreamBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsDownstreamBytes.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsDownstreamBytes.setDescription("The number of L2-forwarded bytes \n            transmitted to this instance's \n            Cable Modem on this instance's VPN.")
docsL2vpnVpnCmStatsDownstreamDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsDownstreamDiscards.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmStatsDownstreamDiscards.setDescription("The number of L2-forwarded packets that were discarded  \n            before they could be transmitted to this instance's  \n            Cable Modem on this instance's VPN.")
docsL2vpnPortStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 6), )
if mibBuilder.loadTexts: docsL2vpnPortStatusTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPortStatusTable.setDescription('This table displays summary information for the \n            run-time state of each VPN that is currently operating  \n            on each bridge port.')
docsL2vpnPortStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 6, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"), (0, "DOCS-L2VPN-MIB", "docsL2vpnIdx"))
if mibBuilder.loadTexts: docsL2vpnPortStatusEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPortStatusEntry.setDescription("Information specific to the operation of L2VPN forwarding \n            on a particular CMTS 'bridge port'. A CMTS 'bridge port'  \n            may be defined by the CMTS vendor, but is advantageously a \n            single DOCSIS MAC Domain.")
docsL2vpnPortStatusGroupSAId = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnPortStatusGroupSAId.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPortStatusGroupSAId.setDescription("The Group SAID associated with this VPN on a  \n            particular CMTS MAC domain. This SAID is used to encrypt \n            all downstream flooded bridge traffic sent to CMs on  \n            this VPN and CMTS MAC domain bridge port.  \n \n            A value of '0' means there is no associated Group SAID for \n            this VPN and bridge port, e.g., if the L2VPN uses \n            point-to-point individual SAIDs only for forwarding. \n \n            A bridge port that is not a CMTS MAC \n            domain will report a value of '0'.")
docsL2vpnSfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 7), )
if mibBuilder.loadTexts: docsL2vpnSfStatusTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnSfStatusTable.setDescription('This table displays SF-specific L2VPN forwarding status  \n           for each upstream service flow configured with a per-SF  \n            L2VPN Encoding. \n \n            Objects which were signaled in a per-SF L2VPN Encoding but \n            apply for the entire CM are shown in the  \n            docsL2vpnVpnCmTable.')
docsL2vpnSfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DOCS-QOS-MIB", "docsQosServiceFlowId"))
if mibBuilder.loadTexts: docsL2vpnSfStatusEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnSfStatusEntry.setDescription('SF-specific L2VPN forwarding status information for each \n            upstream service flow configured with a per-SF L2VPN  \n            Encoding. The ifIndex is of type docsCableMacLayer(127).')
docsL2vpnSfStatusL2vpnId = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 7, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnSfStatusL2vpnId.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnSfStatusL2vpnId.setDescription('This object represents the value of the L2VPN Identifier \n            subtype of a per-SF L2VPN Encoding.')
docsL2vpnSfStatusIngressUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 7, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnSfStatusIngressUserPriority.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnSfStatusIngressUserPriority.setDescription("This object provides the configured Ingress User Priority \n            subtype of a per-SF L2VPN Encoding for this CM. If the  \n            subtype was omitted, this object's value is zero.")
docsL2vpnSfStatusVendorSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnSfStatusVendorSpecific.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnSfStatusVendorSpecific.setDescription('This object provides the set of configured Vendor Specific \n            subtypes within a per-SF L2VPN Encoding for a CM. If no  \n            Vendor Specific subtype was specified, this object is a  \n            zero length octet string. If one or more Vendor Specific  \n            subtype parameters was specified, this object represents  \n            the concatenation of all such subtypes.')
docsL2vpnPktClassTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 8), )
if mibBuilder.loadTexts: docsL2vpnPktClassTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPktClassTable.setDescription('This table provides the L2VPN-specific objects for \n            packet classifiers that apply to only L2VPN traffic.  \n            The indices of this table are a subset of the \n            indices of classifiers in docsQosPktClassTable.')
docsL2vpnPktClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DOCS-QOS-MIB", "docsQosServiceFlowId"), (0, "DOCS-QOS-MIB", "docsQosPktClassId"))
if mibBuilder.loadTexts: docsL2vpnPktClassEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPktClassEntry.setDescription('An entry in this table extends a single row \n            of docsQosPktClassTable for a rule that applies only to \n            downstream L2VPN forwarded packets. \n            The index ifIndex is an ifType of docsCableMaclayer(127).')
docsL2vpnPktClassL2vpnId = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 8, 1, 1), DocsL2vpnIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnPktClassL2vpnId.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPktClassL2vpnId.setDescription('The locally assigned L2VPN index corresponding to the VPN \n            Identifier subtype of a Downstream Classifier L2VPN  \n            Encoding.')
docsL2vpnPktClassUserPriRangeLow = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnPktClassUserPriRangeLow.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPktClassUserPriRangeLow.setDescription('The lower priority of the user Priority Range subtype \n            of a Downstream Classifier L2VPN Encoding. If the subtype \n            was omitted, this object has value 0.')
docsL2vpnPktClassUserPriRangeHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnPktClassUserPriRangeHigh.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPktClassUserPriRangeHigh.setDescription('The higher priority of the user Priority Range subtype \n            of a Downstream Classifier L2VPN Encoding. If the subtype \n            was omitted, this object has value 7.')
docsL2vpnPktClassCMIM = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 8, 1, 4), DocsL2vpnIfList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnPktClassCMIM.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPktClassCMIM.setDescription('The Cable Modem Interface Mask (CMIM) signaled in a  \n            Packet Classifier Encoding.  In a Downstream Packet  \n            Classifier Encoding, a specified CMIM value restricts the  \n            classifier to match packets with a Destination MAC address \n            corresponding to the interfaces indicated in the CMIM mask. \n            The eCM self and any eSAFE interface bits correspond to \n            the individual eCM and eSAFE host MAC addresses. \n \n            In an Upstream Packet Classifier encoding, a specified CMIM \n            value restricts the classifier to match packets with an  \n            ingress bridge port interface matching the bits in the  \n            CMIM value. \n \n            If the CMIM subtype was omitted, this object should be  \n            reported as a zero length octet string.')
docsL2vpnPktClassVendorSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 8, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnPktClassVendorSpecific.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPktClassVendorSpecific.setDescription('This object provides the set of configured  \n            Vendor Specific subtypes within a Packet Classifier  \n            Encoding for a CM. If no Vendor Specific subtype was  \n            specified, this object is a zero length octet string.  \n            If one or more Vendor Specific subtype parameters was  \n            specified, this object represents the concatenation of all \n            such subtypes.')
docsL2vpnCmNsiTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 9), )
if mibBuilder.loadTexts: docsL2vpnCmNsiTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmNsiTable.setDescription('This table describes the NSI configuration for a single \n            CM when operating in point-to-point forwarding mode for an \n            L2VPN.')
docsL2vpnCmNsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 9, 1), ).setIndexNames((0, "DOCS-L2VPN-MIB", "docsL2vpnIdx"), (0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"))
if mibBuilder.loadTexts: docsL2vpnCmNsiEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmNsiEntry.setDescription('An entry indexed by VPN ID and Cable Modem Index that \n            describes the point-to-point forwarding between a single \n            NSI encapsulation and a single CM. This table is  \n            implemented only for a CM forwarding an L2VPN on a  \n            point-to-point basis. It is associated with a single  \n            per-CM L2VPN encoding.')
docsL2vpnCmNsiEncapSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 9, 1, 1), DocsNsiEncapSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmNsiEncapSubtype.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmNsiEncapSubtype.setDescription('The General Encapsulation Information (GEI) subtype of the \n            Network System Interface (NSI) encapsulation configured \n            for the CM.')
docsL2vpnCmNsiEncapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 9, 1, 2), DocsNsiEncapValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmNsiEncapValue.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmNsiEncapValue.setDescription('The encapsulation value for L2VPN forwarded packets on NSI \n            ports.')
docsL2vpnCmNsiAGI = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 9, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmNsiAGI.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmNsiAGI.setDescription("This object is the configuration of any Attachment Group  \n            Identifier subtype in the per-SF L2VPN Encoding  \n            represented by this row. If the subtype was omitted, this  \n            object's value is a zero length string.")
docsL2vpnCmNsiSAII = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 9, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmNsiSAII.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmNsiSAII.setDescription("This object is the configuration of any Source  \n            Attachment Individual ID subtype in the L2VPN Encoding  \n            represented by this row. If the subtype was omitted, this \n            object's value is a zero length string.")
docsL2vpnCmNsiTAII = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 9, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmNsiTAII.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmNsiTAII.setDescription("This object is the configuration of any Target \n            Attachment Individual ID subtype in the L2VPN Encoding \n            represented by this row. If the subtype was omitted, this \n            object's value is a zero length string.")
docsL2vpnCmVpnCpeTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 10), )
if mibBuilder.loadTexts: docsL2vpnCmVpnCpeTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmVpnCpeTable.setDescription('This table is a list of CPEs, indexed by the VPNs on a  \n            Cable Modem.')
docsL2vpnCmVpnCpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 10, 1), ).setIndexNames((0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"), (0, "DOCS-L2VPN-MIB", "docsL2vpnIdx"), (0, "DOCS-L2VPN-MIB", "docsL2vpnCmVpnCpeMacAddress"))
if mibBuilder.loadTexts: docsL2vpnCmVpnCpeEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmVpnCpeEntry.setDescription('This table is a list of CPEs, indexed by the VPNs on a  \n            Cable Modem.')
docsL2vpnCmVpnCpeMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 10, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnCmVpnCpeMacAddress.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCmVpnCpeMacAddress.setDescription("The Customer Premise Equipment (CPE) Mac Address \n            that is attached to this instances Cable Modem \n            and bridging on this instance's VPN Id.")
docsL2vpnVpnCmCpeTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 11), )
if mibBuilder.loadTexts: docsL2vpnVpnCmCpeTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmCpeTable.setDescription('This table contains a list of bridging CPEs, indexed by \n            L2VPN Index and the corresponding CMs on that VPN.')
docsL2vpnVpnCmCpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 11, 1), ).setIndexNames((0, "DOCS-L2VPN-MIB", "docsL2vpnIdx"), (0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"), (0, "DOCS-L2VPN-MIB", "docsL2vpnVpnCmCpeMacAddress"))
if mibBuilder.loadTexts: docsL2vpnVpnCmCpeEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmCpeEntry.setDescription('This table contains a list of bridging CPEs, indexed by \n            VPN and the corresponding CMs on that VPN.')
docsL2vpnVpnCmCpeMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 11, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnVpnCmCpeMacAddress.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnVpnCmCpeMacAddress.setDescription("The Customer Premise Equipment (CPE) Mac Address \n            that is attached to this instances Cable Modem \n            and bridging on this instance's L2vpn Index.")
docsL2vpnDot1qTpFdbExtTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 12), )
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtTable.setDescription('This table contains packet counters for  \n            Unicast MAC Addresses within a VPN.')
docsL2vpnDot1qTpFdbExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 12, 1), ).setIndexNames((0, "Q-BRIDGE-MIB", "dot1qFdbId"), (0, "Q-BRIDGE-MIB", "dot1qTpFdbAddress"))
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtEntry.setDescription('This table extends the dot1qTpFdbTable only for RF network \n            bridge port entries.  It is implemented by an agent only \n            if the agent implements dot1qTpFdbTable for RF network \n            bridge ports.')
docsL2vpnDot1qTpFdbExtTransmitPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtTransmitPkts.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtTransmitPkts.setDescription("The number of packets where the Destination  \n            MAC Address matched this instance  \n            dot1qTpFdbAddress and packet was bridged on \n            a VPN, where the VPN ID matched this  \n            instance's dot1qFdbId.")
docsL2vpnDot1qTpFdbExtReceivePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtReceivePkts.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpFdbExtReceivePkts.setDescription("The number of packets where the Source MAC  \n            Address matched this instance dot1qTpFdbAddress \n            and the packet was bridged on a VPN, \n            where the docsL2vpnIdx matched this instance's  \n            dot1qFdbId.")
docsL2vpnDot1qTpGroupExtTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 13), )
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtTable.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtTable.setDescription('This table contains packet counters for  \n            Multicast MAC Addresses within a VPN.')
docsL2vpnDot1qTpGroupExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 13, 1), ).setIndexNames((0, "Q-BRIDGE-MIB", "dot1qVlanIndex"), (0, "Q-BRIDGE-MIB", "dot1qTpGroupAddress"))
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtEntry.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtEntry.setDescription('This table extends the dot1qTpGroupTable only for RF  \n            Network bridge port entries.  It is implemented by an agent \n            Only if the agent implements dot1qTpGroupTable for RF  \n            network bridge ports.')
docsL2vpnDot1qTpGroupExtTransmitPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtTransmitPkts.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtTransmitPkts.setDescription("The number of packets where the Destination  \n            MAC Address matched this instance  \n            dot1qTpGroupAddress and packet was bridged on \n            a VPN, where the docsL2vpnIdx matched this  \n            instance's dot1qVlanIndex.")
docsL2vpnDot1qTpGroupExtReceivePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 1, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtReceivePkts.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnDot1qTpGroupExtReceivePkts.setDescription("The number of packets where the Source MAC  \n            Address matched this instance dot1qTpGroupAddress \n            and the packet was bridged on a VPN, \n            where the docsL2vpnIdx matched this instance's  \n            dot1qVlanIndex.")
docsL2vpnConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 2))
docsL2vpnCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 2, 1))
docsL2vpnGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 2, 2))
docsL2vpnCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 2, 1, 1)).setObjects(("DOCS-L2VPN-MIB", "docsL2vpnBaseGroup"), ("DOCS-L2VPN-MIB", "docsL2vpnPointToPointGroup"), ("DOCS-L2VPN-MIB", "docsL2vpnMultipointGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsL2vpnCompliance = docsL2vpnCompliance.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnCompliance.setDescription('The compliance statement for the Cable Modem Termination  \n            Systems that implement the DOCSIS L2VPN Feature.')
docsL2vpnBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 2, 2, 1)).setObjects(("DOCS-L2VPN-MIB", "docsL2vpnIdToIndexIdx"), ("DOCS-L2VPN-MIB", "docsL2vpnIndexToIdId"), ("DOCS-L2VPN-MIB", "docsL2vpnCmCompliantCapability"), ("DOCS-L2VPN-MIB", "docsL2vpnCmDutFilteringCapability"), ("DOCS-L2VPN-MIB", "docsL2vpnCmDutCMIM"), ("DOCS-L2VPN-MIB", "docsL2vpnCmDhcpSnooping"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmCMIM"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmVendorSpecific"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmIndividualSAId"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmStatsUpstreamPkts"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmStatsUpstreamBytes"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmStatsUpstreamDiscards"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmStatsDownstreamPkts"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmStatsDownstreamBytes"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmStatsDownstreamDiscards"), ("DOCS-L2VPN-MIB", "docsL2vpnPortStatusGroupSAId"), ("DOCS-L2VPN-MIB", "docsL2vpnSfStatusL2vpnId"), ("DOCS-L2VPN-MIB", "docsL2vpnSfStatusIngressUserPriority"), ("DOCS-L2VPN-MIB", "docsL2vpnSfStatusVendorSpecific"), ("DOCS-L2VPN-MIB", "docsL2vpnPktClassL2vpnId"), ("DOCS-L2VPN-MIB", "docsL2vpnPktClassUserPriRangeLow"), ("DOCS-L2VPN-MIB", "docsL2vpnPktClassUserPriRangeHigh"), ("DOCS-L2VPN-MIB", "docsL2vpnPktClassCMIM"), ("DOCS-L2VPN-MIB", "docsL2vpnPktClassVendorSpecific"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsL2vpnBaseGroup = docsL2vpnBaseGroup.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnBaseGroup.setDescription('A collection of objects in common for both  \n            Point-to-Point and Multipoint L2VPN forwarding \n            Modes.')
docsL2vpnPointToPointGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 2, 2, 2)).setObjects(("DOCS-L2VPN-MIB", "docsL2vpnCmNsiEncapSubtype"), ("DOCS-L2VPN-MIB", "docsL2vpnCmNsiEncapValue"), ("DOCS-L2VPN-MIB", "docsL2vpnCmNsiAGI"), ("DOCS-L2VPN-MIB", "docsL2vpnCmNsiSAII"), ("DOCS-L2VPN-MIB", "docsL2vpnCmNsiTAII"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsL2vpnPointToPointGroup = docsL2vpnPointToPointGroup.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnPointToPointGroup.setDescription('A collection of objects in common for only the \n            Point-to-Point forwarding mode.')
docsL2vpnMultipointGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 8, 2, 2, 3)).setObjects(("DOCS-L2VPN-MIB", "docsL2vpnCmVpnCpeMacAddress"), ("DOCS-L2VPN-MIB", "docsL2vpnVpnCmCpeMacAddress"), ("DOCS-L2VPN-MIB", "docsL2vpnDot1qTpFdbExtTransmitPkts"), ("DOCS-L2VPN-MIB", "docsL2vpnDot1qTpFdbExtReceivePkts"), ("DOCS-L2VPN-MIB", "docsL2vpnDot1qTpGroupExtTransmitPkts"), ("DOCS-L2VPN-MIB", "docsL2vpnDot1qTpGroupExtReceivePkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsL2vpnMultipointGroup = docsL2vpnMultipointGroup.setStatus('current')
if mibBuilder.loadTexts: docsL2vpnMultipointGroup.setDescription('A collection of objects required only for Multipoint \n            forwarding mode.')
mibBuilder.exportSymbols("DOCS-L2VPN-MIB", docsL2vpnCmNsiTAII=docsL2vpnCmNsiTAII, docsL2vpnVpnCmCMIM=docsL2vpnVpnCmCMIM, docsL2vpnSfStatusVendorSpecific=docsL2vpnSfStatusVendorSpecific, docsL2vpnPortStatusEntry=docsL2vpnPortStatusEntry, docsL2vpnSfStatusIngressUserPriority=docsL2vpnSfStatusIngressUserPriority, docsL2vpnDot1qTpFdbExtTable=docsL2vpnDot1qTpFdbExtTable, docsL2vpnVpnCmCpeMacAddress=docsL2vpnVpnCmCpeMacAddress, docsL2vpnCmTable=docsL2vpnCmTable, docsL2vpnDot1qTpGroupExtTransmitPkts=docsL2vpnDot1qTpGroupExtTransmitPkts, docsL2vpnDot1qTpGroupExtReceivePkts=docsL2vpnDot1qTpGroupExtReceivePkts, docsL2vpnIndexToIdId=docsL2vpnIndexToIdId, docsL2vpnSfStatusL2vpnId=docsL2vpnSfStatusL2vpnId, docsL2vpnCompliances=docsL2vpnCompliances, docsL2vpnDot1qTpGroupExtTable=docsL2vpnDot1qTpGroupExtTable, docsL2vpnPktClassUserPriRangeHigh=docsL2vpnPktClassUserPriRangeHigh, docsL2vpnMIBObjects=docsL2vpnMIBObjects, docsL2vpnVpnCmStatsUpstreamBytes=docsL2vpnVpnCmStatsUpstreamBytes, docsL2vpnCmCompliantCapability=docsL2vpnCmCompliantCapability, DocsNsiEncapValue=DocsNsiEncapValue, docsL2vpnVpnCmStatsUpstreamPkts=docsL2vpnVpnCmStatsUpstreamPkts, docsL2vpnId=docsL2vpnId, docsL2vpnCmVpnCpeEntry=docsL2vpnCmVpnCpeEntry, docsL2vpnCmDutCMIM=docsL2vpnCmDutCMIM, docsL2vpnIdx=docsL2vpnIdx, docsL2vpnPktClassCMIM=docsL2vpnPktClassCMIM, docsL2vpnVpnCmIndividualSAId=docsL2vpnVpnCmIndividualSAId, docsL2vpnDot1qTpGroupExtEntry=docsL2vpnDot1qTpGroupExtEntry, docsL2vpnCmNsiSAII=docsL2vpnCmNsiSAII, docsL2vpnCmDhcpSnooping=docsL2vpnCmDhcpSnooping, docsL2vpnGroups=docsL2vpnGroups, docsL2vpnIndexToIdEntry=docsL2vpnIndexToIdEntry, docsL2vpnPktClassTable=docsL2vpnPktClassTable, docsL2vpnCmVpnCpeTable=docsL2vpnCmVpnCpeTable, docsL2vpnVpnCmCpeTable=docsL2vpnVpnCmCpeTable, DocsL2vpnIfList=DocsL2vpnIfList, docsL2vpnCmNsiEntry=docsL2vpnCmNsiEntry, docsL2vpnIdToIndexIdx=docsL2vpnIdToIndexIdx, docsL2vpnVpnCmCpeEntry=docsL2vpnVpnCmCpeEntry, docsL2vpnVpnCmStatsUpstreamDiscards=docsL2vpnVpnCmStatsUpstreamDiscards, docsL2vpnCmEntry=docsL2vpnCmEntry, docsL2vpnDot1qTpFdbExtEntry=docsL2vpnDot1qTpFdbExtEntry, docsL2vpnVpnCmStatsEntry=docsL2vpnVpnCmStatsEntry, docsL2vpnMIB=docsL2vpnMIB, docsL2vpnVpnCmVendorSpecific=docsL2vpnVpnCmVendorSpecific, docsL2vpnCmDutFilteringCapability=docsL2vpnCmDutFilteringCapability, docsL2vpnCmNsiEncapValue=docsL2vpnCmNsiEncapValue, docsL2vpnPktClassUserPriRangeLow=docsL2vpnPktClassUserPriRangeLow, docsL2vpnIndexToIdTable=docsL2vpnIndexToIdTable, docsL2vpnSfStatusEntry=docsL2vpnSfStatusEntry, docsL2vpnVpnCmStatsTable=docsL2vpnVpnCmStatsTable, docsL2vpnDot1qTpFdbExtReceivePkts=docsL2vpnDot1qTpFdbExtReceivePkts, docsL2vpnPktClassVendorSpecific=docsL2vpnPktClassVendorSpecific, docsL2vpnConformance=docsL2vpnConformance, docsL2vpnIdToIndexEntry=docsL2vpnIdToIndexEntry, docsL2vpnCmNsiAGI=docsL2vpnCmNsiAGI, docsL2vpnVpnCmEntry=docsL2vpnVpnCmEntry, docsL2vpnPktClassL2vpnId=docsL2vpnPktClassL2vpnId, DocsNsiEncapSubtype=DocsNsiEncapSubtype, docsL2vpnPortStatusTable=docsL2vpnPortStatusTable, docsL2vpnCmVpnCpeMacAddress=docsL2vpnCmVpnCpeMacAddress, docsL2vpnSfStatusTable=docsL2vpnSfStatusTable, docsL2vpnDot1qTpFdbExtTransmitPkts=docsL2vpnDot1qTpFdbExtTransmitPkts, docsL2vpnIdToIndexTable=docsL2vpnIdToIndexTable, docsL2vpnPktClassEntry=docsL2vpnPktClassEntry, docsL2vpnVpnCmStatsDownstreamBytes=docsL2vpnVpnCmStatsDownstreamBytes, docsL2vpnBaseGroup=docsL2vpnBaseGroup, docsL2vpnPointToPointGroup=docsL2vpnPointToPointGroup, docsL2vpnPortStatusGroupSAId=docsL2vpnPortStatusGroupSAId, docsL2vpnCompliance=docsL2vpnCompliance, docsL2vpnVpnCmStatsDownstreamPkts=docsL2vpnVpnCmStatsDownstreamPkts, docsL2vpnCmNsiTable=docsL2vpnCmNsiTable, docsL2vpnVpnCmStatsDownstreamDiscards=docsL2vpnVpnCmStatsDownstreamDiscards, docsL2vpnMultipointGroup=docsL2vpnMultipointGroup, docsL2vpnVpnCmTable=docsL2vpnVpnCmTable, DocsL2vpnIndex=DocsL2vpnIndex, PYSNMP_MODULE_ID=docsL2vpnMIB, DocsL2vpnIdentifier=DocsL2vpnIdentifier, docsL2vpnCmNsiEncapSubtype=docsL2vpnCmNsiEncapSubtype, docsL2vpnMIBNotifications=docsL2vpnMIBNotifications)
