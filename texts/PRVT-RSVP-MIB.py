#
# PySNMP MIB module PRVT-RSVP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-RSVP-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 16:27:00 2022
# On host fv-az135-792 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressIPv6, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6")
mpls, = mibBuilder.importSymbols("PRVT-CR-LDP-MIB", "mpls")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
iso, IpAddress, Counter64, ObjectIdentity, ModuleIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Bits, NotificationType, Counter32, Gauge32, MibIdentifier, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "IpAddress", "Counter64", "ObjectIdentity", "ModuleIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Bits", "NotificationType", "Counter32", "Gauge32", "MibIdentifier", "TimeTicks")
TextualConvention, RowStatus, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "TruthValue", "DisplayString")
prvtRsvp = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7))
prvtRsvp.setRevisions(('2008-04-14 00:00', '2006-06-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtRsvp.setRevisionsDescriptions(('Added range constraints to\n         prvtRsvpProductLocalRepairDelay, prvtRsvpProductRefreshInterval,\n         prvtRsvpProductNotifyRRInterval, prvtRsvpProductNotifyRRLimit,\n         prvtRsvpProductInitPathRRInterval, prvtRsvpProductInitPathRRLimit.', 'Initial version.',))
if mibBuilder.loadTexts: prvtRsvp.setLastUpdated('200804140000Z')
if mibBuilder.loadTexts: prvtRsvp.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtRsvp.setContactInfo(' BATM/Telco Systems Support team\n\t\t\t\t\tEmail: \n\t\t\t\tFor North America: techsupport@telco.com\n\t\t\t\tFor North Europe: support@batm.de, info@batm.de\n\t\t\t\tFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtRsvp.setDescription('The MIB module for management of the PRVT-RSVP\n                    product.')
prvtRsvpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1))
class PrvtRsvpAdminStatus(TextualConvention, Integer32):
    description = 'The desired administrative state of an RSVP\n                   entity.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("up", 1), ("down", 2))

class PrvtRsvpOperStatus(TextualConvention, Integer32):
    description = 'The current operational state of an RSVP entity.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("up", 1), ("down", 2), ("goingUp", 3), ("goingDown", 4), ("actFailed", 5))

class PrvtRsvpIndex(TextualConvention, Unsigned32):
    description = 'The index value identifying an RSVP entity.'
    status = 'current'

class PrvtRsvpDiagReqIndex(TextualConvention, Unsigned32):
    description = 'The index value identifying an RSVP session that is being\n           diagnosed.'
    status = 'current'

class PrvtRsvpDiagNodeIndexType(TextualConvention, Unsigned32):
    description = 'The index value identifying a node within an RSVP session that is\n           being diagnosed.'
    status = 'current'

class PrvtRsvpDiagNodeTypeVal(TextualConvention, Integer32):
    description = 'The type of a node in a session that is being diagnosed.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("missing", 1), ("ingress", 2), ("transit", 3), ("egress", 4))

prvtRsvpProductTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1), )
if mibBuilder.loadTexts: prvtRsvpProductTable.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductTable.setDescription('The table of RSVP entities.')
prvtRsvpProductEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1), ).setIndexNames((0, "PRVT-RSVP-MIB", "prvtRsvpProductIndex"))
if mibBuilder.loadTexts: prvtRsvpProductEntry.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductEntry.setDescription('Each entry represents an RSVP entity.')
prvtRsvpProductIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 1), PrvtRsvpIndex())
if mibBuilder.loadTexts: prvtRsvpProductIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductIndex.setDescription('The index of this prvtRsvpProductEntry.  This is the\n           HAF entity index passed on the entity create parameters.')
prvtRsvpProductASNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductASNumber.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductASNumber.setDescription('The number identifying the autonomous system (AS) to which\n        this node belongs.')
prvtRsvpProductSenderTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductSenderTTL.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductSenderTTL.setDescription('The TTL set on messages originating at this node.  A value\n        of 0 indicates this number is determined by other means.')
prvtRsvpProductMinTimerPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 4), Integer32().clone(200)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductMinTimerPeriod.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductMinTimerPeriod.setDescription('The minimum granularity to allow an internal timer to be\n        set in the PRVT-RSVP product code.')
prvtRsvpProductAPIIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 5), InterfaceIndexOrZero().clone(2147483647)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductAPIIfIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductAPIIfIndex.setDescription('Management assigned interface identifier for the (internal) LRAPI\n        interface between RSVP and TE-MIB components.  This must be unique in\n        the interface index namespace of the node - it MUST not match any real\n        interface index.\n        It is recommended that this is set to zero or 0x7FFFFFFF.')
prvtRsvpProductAPIAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 16)).clone(hexValue="E0000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductAPIAddress.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductAPIAddress.setDescription('Management assigned IP address used to identify the (internal) LRAPI\n        interface between RSVP and TE-MIB components.\n        The configured API address MUST not be a real address in the network.\n        It is recommended that this is set to a non-zero reserved address\n        value, such as 224.0.0.0.\n        If multi-stack support is set to PHOP, this address must be unique for\n        each RSVP stack in the node.\n        The same address(es) can be used on all nodes in the network.')
prvtRsvpProductAPIRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 7), Integer32().clone(30000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductAPIRefreshInterval.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductAPIRefreshInterval.setDescription('This field is now deprecated.')
prvtRsvpProductLocalRepairDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1000, 2147483647), )).clone(1000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductLocalRepairDelay.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLocalRepairDelay.setDescription('This object is used to set the delay between detection of a\n        path error and instigation of local repair procedures.  This\n        allows local routing updates to converge.\n        A value of -1 indicates that local\n        repair procedures should not take place, but that the error\n        should be propagated upstream.\n        Where FRR capabilities are supported at this node\n        local_repair_delay must be set to -1.')
prvtRsvpProductRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 2147483647)).clone(30000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRefreshInterval.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRefreshInterval.setDescription('This RSVP value, R,  which is used to set the average\n        interval between refresh path and resv messages.\n        Note : If values for the if_refresh_interval and if_refresh_multiple\n        are configured such that the following inequality is not obeyed :\n        6 * refresh_interval * (refresh_multiple + 0.5) < 0x7FFFFFFF.\n        Then the time-to-die for the path value will be set to its maximum\n        value and it is probable that the lsp will time out before a refresh\n        arrives.')
prvtRsvpProductRefreshMultiple = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRefreshMultiple.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRefreshMultiple.setDescription('The RSVP value, K, which is the number of unresponded Path\n        or Resv refresh attempts which must be made, spaced by\n        the refresh interval before the state is deemed to have\n        timed out.\n        Note : See note in prvtRsvpProductRefreshInterval above.')
prvtRsvpProductRfrshSlewDenom = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRfrshSlewDenom.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRfrshSlewDenom.setDescription('The denominator of the fraction, SlewMax, which is the\n        maximum allowable increase in the refresh interval, R, to\n        prevent state timeout while changing R.  R is increased by\n        this fraction until it reaches the new desired value.')
prvtRsvpProductRfrshSlewNumerator = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRfrshSlewNumerator.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRfrshSlewNumerator.setDescription('The numerator of the fraction, SlewMax, which is the maximum\n        allowable increase in the refresh interval, R, to prevent\n        state timeout while changing R.  R is increased by this\n        fraction until it reaches the new desired value.')
prvtRsvpProductBlockadeMultiple = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214783647)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductBlockadeMultiple.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductBlockadeMultiple.setDescription('The RSVP value, Kb, which is the number of refresh timeout\n        periods after which blockade state is deleted.')
prvtRsvpProductSocketBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 14), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductSocketBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductSocketBufPoolSize.setDescription('The number of pre-reserved buffers available for sending\n        sockets data.  This is used to pace the sockets data flows.')
prvtRsvpProductSwitchBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 15), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductSwitchBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductSwitchBufPoolSize.setDescription('The number of pre-reserved buffers available for programming\n        the switch.  This is used to ensure programming operations do\n        not fail in buffer shortage conditions.')
prvtRsvpProductTeMibBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 16), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductTeMibBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductTeMibBufPoolSize.setDescription('The number of pre-reserved buffers available for signalling\n        TE-MIB.  This is used to ensure signals are not lost in buffer\n        shortage conditions.')
prvtRsvpProductRoutingBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 17), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRoutingBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRoutingBufPoolSize.setDescription('The number of pre-reserved buffers available for route\n        queries.  This is used to ensure re-routing of many LSPs does\n        not fail in buffer shortage conditions.')
prvtRsvpProductLSPSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductLSPSetupPriority.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLSPSetupPriority.setDescription('The setup priority to apply to LSPs which are not\n        signalling this parameter.  0 represents the highest\n        priority, 7 the lowest.  The value of this object must be\n        numerically more or equal (so lower or equal priority)\n        than the value of the holding priority object.')
prvtRsvpProductLSPHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductLSPHoldingPriority.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLSPHoldingPriority.setDescription('The holding priority to apply to LSPs which are not\n       signalling this parameter.  0 represents the highest\n       priority, 7 the lowest.  The value of this object must be\n       numerically less or equal (so higher or equal priority)\n       than the value of the holding priority object.')
prvtRsvpProductAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 20), PrvtRsvpAdminStatus().clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductAdminStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductAdminStatus.setDescription('The desired administrative state of the RSVP entity.')
prvtRsvpProductOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 21), PrvtRsvpOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpProductOperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductOperStatus.setDescription('The current operational state of this instance of PRVT-RSVP.')
prvtRsvpProductRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 22), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRowStatus.setDescription("Used to create and delete a PRVT-RSVP Product Table entry.\n        When this object is set to 'active', only the\n        prvtRsvpProductAdminStatus object in the row may be modified.")
prvtRsvpProductLsrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 23), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductLsrIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLsrIndex.setDescription('The index of the PRVT-LMGR product instance which this\n        PRVT-RSVP is to join to as its LDB interface provider.  If\n        this value is not specified, or the value of this object\n        is 0, PRVT-RSVP will use the prvtRsvpProductIndex value as the\n        Lsr index when joining on the LDB interface.')
prvtRsvpProductTeMibIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 24), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductTeMibIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductTeMibIndex.setDescription('The index of the TE-MIB product instance which this\n        PRVT-RSVP is to join to as its LRA interface provider. If\n        this value is not specified, or the value of this object\n        is 0, PRVT-RSVP will use the prvtRsvpProductIndex value as the\n        TeMib Index when joining on the LRA interface.')
prvtRsvpProductMultiStackSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductMultiStackSupport.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductMultiStackSupport.setDescription('A flag to indicate if multiple RSVP stacks are present\n         in the same system as the current one and, if so, how\n         they are supported.  If set to PHOP, Path messages are\n         forwarded to PRVT-RSVP with the Previous Hop value set as\n         the hop prior to the incoming interface, not as the next\n         hop interface as normal.  If set to LIH, the hardware\n         location of the current RSVP stack is used as the LIH in\n         the HOP object.')
prvtRsvpProductUseHopByHop = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductUseHopByHop.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductUseHopByHop.setDescription('A flag to indicate that PRVT-RSVP should use the hop by hop\n         addressing scheme for PATH and PATH-TEAR messages it\n         sends.  If set then the IP addresses used in the IP header\n         of PATH messages forwarded by PRVT-RSVP set source as the\n         local outgoing interface IP address, and destination as\n         the next hop router IP address.')
prvtRsvpProductUseNotify = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 27), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductUseNotify.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductUseNotify.setDescription('A flag to indicate that PRVT-RSVP should attempt to insert\n         a Notify Request object in all Path requests that is sends\n         as ingress and all Resv requests that it sends as egress.\n         The precise behavior is modified by a user exit called by\n         the RSVP code.\n\n         This field is not used unless the mplsTunnelUpNotRecip or\n         mplsTunnelDownNotRecip fields in TE-MIB are set to 0.0.0.0.')
prvtRsvpProductNotifyRRDecay = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductNotifyRRDecay.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductNotifyRRDecay.setDescription('The percentage increase in the rapid retransmission\n         interval for each consecutive unacknowledged RSVP Notify\n         message.  A value of 0 indicates a constant retransmission\n         rate.')
prvtRsvpProductNotifyRRInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 2147483647)).clone(2000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductNotifyRRInterval.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductNotifyRRInterval.setDescription('The interval in milliseconds before a Notify message is\n         first resent if no acknowledgement is received.')
prvtRsvpProductNotifyRRLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductNotifyRRLimit.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductNotifyRRLimit.setDescription('The maximum number of times a Notify message is resent if\n         no acknowledgement is received.')
prvtRsvpProductAllowIPEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 31), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductAllowIPEncap.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductAllowIPEncap.setDescription('A flag to indicate that PRVT-RSVP should support the use of\n         IP encapsulation of RSVP packets, which are required for\n         out-of-band signaling.  If set, then PRVT-RSVP will accept\n         incoming RSVP packets that are IP encapsulated, and will\n         IP encapsulate outgoing packets whenever the IP routing\n         stub indicates that it is required for a particular route.')
prvtRsvpProductProtocolExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 32), Bits().clone(namedValues=NamedValues(("bypassFastReroute", 0), ("detourFastReroute", 1), ("noResAffOnInIf", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductProtocolExtensions.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductProtocolExtensions.setDescription('Specifies which extensions to the standard RSVP-TE protocol\n         are enabled.  For fully standards-compliant behavior, set\n         this parameter to zero (no bits set).  To enable specific\n         non-standard protocol extensions, set this parameter to the\n         bitwise OR of whichever of the following behaviors you wish\n         to enable.\n\n         - bypassFastReroute: Enable support for facility fast reroute\n         protection of LSPs (bypass LSP protection).  This flag is\n         deprecated in favour of the\n         prvtRsvpProductFrrFacAdminStatus field which can be\n         modified while RSVP is admin up, however either field can be\n         used.  When this flag is set RSVP automatically sets the\n         prvtRsvpProductFrrFacAdminStatus.\n\n         - detourFastReroute: Enable support for one-to-one fast\n         reroute protection of LSPs (detour LSP protection).\n\n         -  noResAffOnInIf: Disable resource affinity checking on\n         incoming interfaces for LSPs.  If this flag is set, RSVP\n         will accept Path messages which use invalid resource\n         affinities for the incoming interface used by the LSP.')
prvtRsvpProductPSRFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 33), Bits().clone(namedValues=NamedValues(("pathErrPSRSet", 0), ("pathErrPSRNotSet", 1), ("ldbCommonRcvd", 2), ("ldbPreempted", 3), ("routingError", 4), ("invalidPathMsg", 5), ("sessionExpired", 6), ("unableToRepairRoute", 7), ("unableToRepairIf", 8), ("reachedRetryLimit", 9), ("unableToRefresh", 10), ("resvErrTurnaround", 11), ("incomingIfDown", 12), ("outgoingIfDown", 13)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductPSRFlags.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductPSRFlags.setDescription('This field is used by PRVT-RSVP to determine whether it\n         should set the Path State Removed flag on a PathErr (and\n         therefore remove corresponding state and generate a\n         PathTear).  Each bit of this flags field corresponds to a\n         situation where PRVT-RSVP may generate a PathErr.  Setting a\n         particular bit will result in PRVT-RSVP removing state,\n         setting the Path State Removed flag and generating a\n         PathTear in that corresponding situation.  The possible\n         bit values are\n\n         - pathErrPSRSet: PRVT-RSVP has received a PathErr message\n         with the Path State Removed flag set.\n\n         - pathErrPSRNotSet: PRVT-RSVP has received a PathErr message\n         with the Path State Removed flag unset.\n\n         - ldbCommonRcvd: PRVT-RSVP has received a negative response\n         to an ATG_LDB_RESERVE_LSP_XC or ATG_LDB_CONNECT_LSP_XC\n         message.\n\n         - ldbPreempted: PRVT-RSVP has received a Preemption message\n         from Label Manager.\n\n         - routingError: PRVT-RSVP has received a Negative response\n         to an ATG_IPR_QUERY_ROUTE message.\n\n         - invalidPathMsg: PRVT-RSVP has received an invalid Path\n         message.\n\n         - sessionExpired:  A session in PRVT-RSVP has expired.\n\n         - unableToRepairRoute:  A route has been removed and\n         PRVT-RSVP is unable to start local repair.\n\n         - unableToRepairIf:  An interface has been removed and\n         PRVT-RSVP is unable start local repair.\n\n         - reachedRetryLimit: An initial Path Message has reached\n         its retry limit.\n\n         - unableToRefresh: PRVT-RSVP has been unable to refresh an\n         LSP.\n\n         - resvErrTurnaround: PRVT-RSVP has received a ResvErr at the\n         Egress node containing a REROUTING object and this is to\n         be turned round into a PathErr.\n\n         - incomingIfDown: The incoming MPLS data interface for\n         an LSP has been deactivated.\n\n         - outgoingIfDown: The outgoing MPLS data interface for\n         an LSP has been deactivated.')
prvtRsvpProductInitPathRRDecay = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductInitPathRRDecay.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductInitPathRRDecay.setDescription('The percentage increase in the rapid\n         retransmission interval for each consecutive\n         unacknowledged RSVP Initial Path message.  A value of 0\n         indicates a constant retransmission rate.\n\n         A Path message is treated as an initial Path if it is the\n         Path message which creates the LSP or a Path refresh\n         message which requires re-routing.')
prvtRsvpProductInitPathRRInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 2147483647)).clone(2000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductInitPathRRInterval.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductInitPathRRInterval.setDescription('The rapid retransmission interval in milliseconds before\n         an Initial Path message is first resent if no\n         acknowledgement is received.\n\n         A Path message is treated as an initial Path if it is the\n         Path message which creates the LSP or a Path refresh\n         message which requires re-routing.')
prvtRsvpProductInitPathRRLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductInitPathRRLimit.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductInitPathRRLimit.setDescription('The maximum number of times an Initial Path message is\n         resent if no acknowledgement is received.\n\n         A Path message is treated as an initial Path if it is the\n         Path message which creates the LSP or a Path refresh\n         message which requires re-routing.')
prvtRsvpProductEnableUni = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 37), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductEnableUni.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductEnableUni.setDescription('A flag to indicate whether the local node supports UNI\n           signaling messages.')
prvtRsvpProductRestartCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 38), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRestartCapable.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRestartCapable.setDescription('A flag to indicate whether the local node should advertise\n           itself as restart capable.  This should be set to true\n           if fault-tolerance is enabled in PRVT-MPLS or if the node\n           supports recovery procedures.')
prvtRsvpProductRestartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 39), Unsigned32().clone(10000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRestartTime.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRestartTime.setDescription('The time in milliseconds that the local node takes to\n         restart RSVP-TE and the communication channel used for\n         RSVP communication.  This is advertised to neighbors in\n         the Restart_Cap object in Hello messages.\n\n         The value chosen should be large enough for RSVP to be\n         terminated and restarted.  If fault-tolerance is enabled\n         in PRVT-MPLS, then sufficient time should be allowed for\n         RSVP to fail over, which should include the time taken for\n         the audit phase to complete.\n\n         A value of 0xFFFFFFFF may be configured to imply an infinite\n         restart time.\n\n         Only used if prvtRsvpProductRestartCapable is set to true.\n\n         Note that the maximum real time value that can be set is\n         0x7FFFFFFF.  If a value is requested greater than\n         0x7FFFFFFF and less than 0xFFFFFFFF the request will be\n         rejected.')
prvtRsvpProductRecoveryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 40), Unsigned32().clone(10000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductRecoveryTime.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductRecoveryTime.setDescription('The period of time in milliseconds that the local node\n         would like neighbors to take to resyncronize RSVP and\n         MPLS forwarding information after the re-establishment of\n         Hello connectivity.  This is advertised to neighbors in\n         the Restart_Cap object in Hello messages.\n\n         A value of zero indicates that the node does not support\n         resynchronization following failure of the local node.\n\n         A value of 0xFFFFFFFF indicates an infinite recovery time.\n\n         Note that if fault-tolerance is not enabled in PRVT-MPLS and\n         the node is acting as an ingress for tunnels, then any\n         ingress tunnels that need to be recovered should be\n         configured during this recovery period.  These tunnels\n         should be configured in TE-MIB with the admin_status set\n         to UP, otherwise they will be lost from the switch\n         controller.\n\n         Only used if prvtRsvpProductRestartCapable is set to true.\n\n         Note that the maximum real time value that can be set is\n         0x7FFFFFFF.  If a value is requested greater than\n         0x7FFFFFFF and less than 0xFFFFFFFF the request will be\n         rejected.')
prvtRsvpProductMinPeerRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 41), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductMinPeerRestart.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductMinPeerRestart.setDescription('The mininum period of time in milliseconds that RSVP\n         should wait for a restart capable neighbor to regain\n         Hello connectivity before invoking procedures related to\n         communication loss.\n\n         RSVP will wait for the maximum of this time and the\n         restart_time advertised in the RESTART_CAP object in Hello\n         messages from the neighbor.')
prvtRsvpProductGracefulDelTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 42), Integer32().clone(30000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductGracefulDelTimeout.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductGracefulDelTimeout.setDescription('The time in milliseconds that PRVT-MPLS will wait for\n         graceful deletion to complete before the forced deletion\n         procedure is used instead.')
prvtRsvpProductEgressDelBehavior = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delWithPathErr", 1), ("delWithResvD", 2))).clone('delWithPathErr')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductEgressDelBehavior.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductEgressDelBehavior.setDescription('Specifies the action that an egress node should take in\n         the graceful deletion procedure on receipt of a Path\n         message containing an Admin Status object with the D\n         and R bits set.  The possible values are:-\n\n         - delWithPathErr:  Send a PathErr message with the\n         Path_State_removed flag set.\n\n         - delWithResvD:  Send a Resv message containing an Admin\n         Status object with the D bit set.')
prvtRsvpProductEnabUniConnSplicing = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 44), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductEnabUniConnSplicing.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductEnabUniConnSplicing.setDescription('A flag to indicate whether UNI-N nodes should allow the\n         splicing of UNI connections with proprietary ON\n         connections.')
prvtRsvpProductFastRerouteCaps = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 45), Bits().clone(namedValues=NamedValues(("fastReroutePLR", 0), ("fastRerouteMP", 1), ("fastRerouteDetourRestart", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductFastRerouteCaps.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductFastRerouteCaps.setDescription('Specifies what fast reroute capabilities are enabled\n         on this node.  This field is only valid if the fast\n         reroute extension is enabled in the\n         prvtRsvpProductProtocolExtensions field above.\n\n         -  PLR: Node provides fast reroute point of local repair\n         capability.\n\n         -  MP: Node provides fast reroute merge point capability.\n\n         -  DetourRestart: Node implements some protocol extensions\n         to recover detour fast reroute LSPs after a node restart\n         or an adjacent node restart.  This flag is only valid if\n         detourFastReroute flag is set in the\n         prvtRsvpProductProtocolExtensions field above.\n\n         Note that a node can still perform some FRR processing\n         even if the PLR and MP flags are clear (at a detour transit\n         for instance).')
prvtRsvpProductFastRroutBkpRtryInt = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 46), Integer32().clone(30000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductFastRroutBkpRtryInt.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductFastRroutBkpRtryInt.setDescription('When this node is a PLR, this field specifies the period\n         that the node should wait before retrying the setup of a\n         backup LSP which failed last time because no route was\n         available.  In the case that a backup LSP is set up but an\n         error is received from upstream, setup will be attempted\n         again immediately.\n         This field is only valid if this node is defined as PLR\n         capable in the _prvtRsvpProductFastRerouteCapabilities_\n         field above.')
prvtRsvpProductErrorActionFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 47), Bits().clone(namedValues=NamedValues(("eafTearStateOnLSIErr", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductErrorActionFlags.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductErrorActionFlags.setDescription('This field is used by PRVT-RSVP to determine whether it\n         should take any special action following certain types of\n         local errors.  Each bit of this flags field corresponds to\n         an error and a corresponding action.\n\n         When one of these errors occurs, the relevant bit flag is\n         checked - if set, the specified action is taken; if not\n         set, the normal action is taken according the RSVP\n         protocol.  The possible bit values are the following.\n\n         - eafTearStateOnLSIErr:  When PRVT-RSVP receives a negative\n           response to an ATG_LDB_CONNECT_LSP_XC message on a UNI\n           node, the Path state is torn down.')
prvtRsvpProductEnableNni = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("disabling", 3))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductEnableNni.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductEnableNni.setDescription('A flag to indicate whether the local node supports NNI\n         signaling messages.')
prvtRsvpProductBehaviorFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 49), Bits().clone(namedValues=NamedValues(("enableTTLMatch", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductBehaviorFlags.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductBehaviorFlags.setDescription('Specifies some detailed aspects of the behavior of\n         PRVT-RSVP.  This field may be changed while _admin_status_\n         is up.\n\n         - enableTTLMatch: Whether to discard received RSVP\n         packets sent with the Router Alert option if the IP and\n         RSVP TTL values do not match.  In certain circumstances\n         TTL comparison can identify RSVP service breaks, and allow\n         the discarding of packets that would otherwise disrupt\n         installed LSPs.\n\n         This option has no effect for Out Of Band operation.\n\n         This option should be left disabled for LSP hierarchy\n         operation (LSPs set up over existing LSPs) and for\n         Facility Fast Reroute (which sets up backup LSPs over\n         existing bypass LSPs).')
prvtRsvpProductLabelSetStyle = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("excludeLabelHeader", 1), ("includeLabelHeader", 2))).clone('excludeLabelHeader')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductLabelSetStyle.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLabelSetStyle.setDescription('Specifies the style of LABEL_SET object that should be\n         used.  RFCs 3741 and 3743 are unclear whether the\n         LABEL_SET object should include LABEL headers.  The\n         correct interpretation is that the header should not be\n         present, but there are implementations that include the\n         LABEL header, so this option is included for compatibility\n         with these implementations.\n\n         - excludeLabelHeader:  The LABEL_SET object contains\n           concatenated LABEL values without the object headers.\n\n         - includeLabelHeader:  The LABEL_SET object contains\n           concatenated LABEL objects with the object headers.')
prvtRsvpProductLabelSetOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("excludeLabelHeader", 1), ("includeLabelHeader", 2), ("goingToExclude", 3), ("goingToInclude", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpProductLabelSetOperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLabelSetOperStatus.setDescription('The current operational state of Label Set style.\n         - excludeLabelHeader:  The LABEL_SET object contains\n           concatenated LABEL values without the object headers.\n\n         - includeLabelHeader:  The LABEL_SET object contains\n           concatenated LABEL objects with the object headers.\n\n         - goingToExclude:  The Label Set Style is being changed\n           from includeLabelHeader to excludeLabelHeader.\n\n         - goingToInclude:  The Label Set Style is being changed\n           from excludeLabelHeader to includeLabelHeader.')
prvtRsvpProductLabelSetTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 52), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductLabelSetTrapEnable.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLabelSetTrapEnable.setDescription('This object is used to enable traps for the Label\n         Set style  oper_status object.')
prvtRsvpProductLabelSetChngAct = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 53), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductLabelSetChngAct.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductLabelSetChngAct.setDescription('Specifies the action to take when the value of\n         prvtRsvpProductLabelSetStyle is changed.\n\n         - leaveLSPs:  All nodes should suppress refreshes and\n         switch to the new format while refreshes are suppressed.\n\n         - tearLSPs:   Any LSPs using label sets will be deleted\n         before switching all nodes to the new format, and any new\n         LSPs using label sets will be dropped/rejected until the\n         switch is complete.')
prvtRsvpProductExtPrtAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 54), PrvtRsvpAdminStatus().clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductExtPrtAdminStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductExtPrtAdminStatus.setDescription('The desired operational state of support for the extended\n        PROTECTION object defined in\n        draft-lang-ccamp-gmpls-recovery-e2e-signaling.')
prvtRsvpProductUniIncSonetProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 55), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductUniIncSonetProfile.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductUniIncSonetProfile.setDescription('Specifies whether Sonet Profile is included on messages\n         to or from a UNI-C node.')
prvtRsvpProductFrrFacAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 56), PrvtRsvpAdminStatus().clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductFrrFacAdminStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductFrrFacAdminStatus.setDescription('Specifies whether backup LSPs can be put in place for LSPs\n         requesting FRR using the facility method.\n\n         Setting this to UP means that LSPs that request FRR using\n         the facility method can have protection at this node.\n         Existing LSPs that request FRR facility protection will have\n         protection put in place when the next Path refresh is\n         received.\n\n         Setting this to DOWN means that LSPs that request FRR using\n         the facility method will not be protected at this node.\n         Existing LSPs that have FRR facility protection will lose\n         that protection, and if the LSP had been rerouted to use the\n         backup LSP then the protected LSP will be lost.\n\n         This field replaces the bypassFastReroute flag on the protocol\n         extensions field in this MIB (although the bypassFastReroute flag\n         is still supported for backwards compatibility). It can be\n         modified while RSVP is oper_status UP or DOWN.  When this field\n         is changed the bypassFastReroute flag is automatically modified\n         to mirror the change.')
prvtRsvpProductFrrFacOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 57), PrvtRsvpOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpProductFrrFacOperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductFrrFacOperStatus.setDescription('The current operational status for FRR Facility support.\n         When this is UP backup LSPs will be put in place, when this\n         is down backup LSPs will not be put in place and there will\n         be no LSPs that have backup LSPs.')
prvtRsvpProductIpv6AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 58), PrvtRsvpAdminStatus().clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prvtRsvpProductIpv6AdminStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductIpv6AdminStatus.setDescription('Specifies whether the local node supports IPv6 LSPs.\n\n         Setting this to UP means that this node supports IPv6 LSPs\n         being set up to, from and through this node.\n\n         Setting this to DOWN means that IPv6 LSPs are NOT supported by\n         this node.  Existing IPv6 LSPs for which this node is the\n         ingress, egress or transit are torn down.\n\n         This field can be modified while RSVP is oper_status UP or\n         DOWN.\n\n         The value of this field MUST match the value of the\n         dcMplsTeMibRsvpIpv6AdminStatus field in the\n         prvtMplsTeMibEntityTable.')
prvtRsvpProductIpv6OperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 59), PrvtRsvpOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpProductIpv6OperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductIpv6OperStatus.setDescription('The current operational status for IPv6 support.  When\n         this is UP IPv6 LSPs can be set up to from or through this\n         node.  When this is down there will be no active IPv6 LSPs.')
prvtRsvpProductAPIIpv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 1, 1, 60), InetAddressIPv6()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtRsvpProductAPIIpv6Address.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductAPIIpv6Address.setDescription('Management assigned IPv6 address used to identify the\n         (internal) LRAPI interface between RSVP and TE-MIB\n         components.\n\n         The configured API IPv6 address MUST not be a real address\n         in the network.  It is recommended that this is set to a\n         non-zero reserved address value.  This MUST be an address\n         with global scope.\n\n         If multi-stack support is set to PHOP, this address must\n         be unique for each RSVP stack in the node.\n\n         The same address(es) can be used on all nodes in the\n         network.')
prvtRsvpDiagnosticTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2), )
if mibBuilder.loadTexts: prvtRsvpDiagnosticTable.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagnosticTable.setDescription('The table of sessions that are being diagnosed.')
prvtRsvpDiagnosticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1), ).setIndexNames((0, "PRVT-RSVP-MIB", "prvtRsvpDiagProductIndex"), (0, "PRVT-RSVP-MIB", "prvtRsvpDiagRequestIndex"))
if mibBuilder.loadTexts: prvtRsvpDiagnosticEntry.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagnosticEntry.setDescription('Each entry represents a session that is being diagnosed.')
prvtRsvpDiagProductIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 1), PrvtRsvpIndex())
if mibBuilder.loadTexts: prvtRsvpDiagProductIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagProductIndex.setDescription('The index of the PRVT-RSVP product that is handling this query.')
prvtRsvpDiagRequestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 2), PrvtRsvpDiagReqIndex())
if mibBuilder.loadTexts: prvtRsvpDiagRequestIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagRequestIndex.setDescription('The index of this prvtRsvpDiagnosticEntry.  This corresponds to a\n           particular session being diagnosed and is an arbitrary value,\n           defined on row creation.')
prvtRsvpDiagReqsInProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagReqsInProgress.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagReqsInProgress.setDescription('The number of outstanding diagnostic requests relating to this\n           session.')
prvtRsvpDiagSessionEndPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagSessionEndPoint.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagSessionEndPoint.setDescription('The IP address of the tunnel end point, from the LSP_TUNNEL_IPv4\n           session object.')
prvtRsvpDiagSessionTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagSessionTunnelId.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagSessionTunnelId.setDescription('The tunnel ID, from the LSP_TUNNEL_IPv4 session object.')
prvtRsvpDiagSessionExtTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagSessionExtTunnelId.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagSessionExtTunnelId.setDescription('The extended tunnel ID, from the LSP_TUNNEL_IPv4 session object.')
prvtRsvpDiagLastHop = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagLastHop.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagLastHop.setDescription('The IP address of the last hop to be queried. This is the address\n           to which the DREQ message is first sent.')
prvtRsvpDiagSender = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagSender.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagSender.setDescription('The IP address of the sender for the specified session.')
prvtRsvpDiagMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagMaxHops.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagMaxHops.setDescription('The maximum number of hops to diagnose.')
prvtRsvpDiagHopByHopReply = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 2, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagHopByHopReply.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagHopByHopReply.setDescription('A flag to indicate that DREPs should be returned hop-by-\n          hop using the reverse of the path taken by the DREQ.')
prvtRsvpDiagNodeTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3), )
if mibBuilder.loadTexts: prvtRsvpDiagNodeTable.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeTable.setDescription('The table of nodes within a session that is being diagnosed.\n\n           External management can extract information\n           from this table, but cannot modify information in it.')
prvtRsvpDiagNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1), ).setIndexNames((0, "PRVT-RSVP-MIB", "prvtRsvpDiagNodeProductIndex"), (0, "PRVT-RSVP-MIB", "prvtRsvpDiagNodeRequestIndex"), (0, "PRVT-RSVP-MIB", "prvtRsvpDiagNodeIndex"))
if mibBuilder.loadTexts: prvtRsvpDiagNodeEntry.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeEntry.setDescription('Each entry represents a node within a session that is being diagnosed.')
prvtRsvpDiagNodeProductIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 1), PrvtRsvpIndex())
if mibBuilder.loadTexts: prvtRsvpDiagNodeProductIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeProductIndex.setDescription('The index of the PRVT-RSVP product that is handling this query.')
prvtRsvpDiagNodeRequestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 2), PrvtRsvpDiagReqIndex())
if mibBuilder.loadTexts: prvtRsvpDiagNodeRequestIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeRequestIndex.setDescription('The index of the corresponding request in prvtRsvpDiagnosticTable.')
prvtRsvpDiagNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 3), PrvtRsvpDiagNodeIndexType())
if mibBuilder.loadTexts: prvtRsvpDiagNodeIndex.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeIndex.setDescription('The index of this prvtRsvpDiagNodeEntry. This is equivalent to the\n           hop number, with 1 being the ingress.')
prvtRsvpDiagNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 4), PrvtRsvpDiagNodeTypeVal()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeType.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeType.setDescription('The type of the node: ingress, transit, egress or missing. Missing\n           indicates that no diagnostic response has been received for this\n           node, and this entry may in fact represent more than one node.')
prvtRsvpDiagNodeDreqArrivalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeDreqArrivalTime.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeDreqArrivalTime.setDescription('The arrival time of the DREQ at the node, specified as a 32-bit\n           NTP timestamp.')
prvtRsvpDiagNodeIncomingIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeIncomingIfAddr.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeIncomingIfAddr.setDescription('The IP address of the interface on which message from the sender\n           are expected to arrive at this node, or 0 if unknown.')
prvtRsvpDiagNodeOutgoingIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeOutgoingIfAddr.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeOutgoingIfAddr.setDescription('The IP address of the interface through which the DREQ arrived\n           and to which messages flow from the given sender for the\n           specified session address, or 0 if unknown.')
prvtRsvpDiagNodePrevHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodePrevHopAddr.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodePrevHopAddr.setDescription('The IP address from which this node receives RSVP PATH messages\n           for this source, or 0 if unknown. This is also the address to\n           which the DREQ was forwarded.')
prvtRsvpDiagNodeDTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeDTTL.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeDTTL.setDescription('The number of IP hops traversed by the DREQ between the downstream\n           RSVP node and this node.')
prvtRsvpDiagNodeMFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeMFlag.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeMFlag.setDescription('A flag that indicates whether the reservation described by the\n           response objects is merged with reservations from other downstream\n           interfaces before being forwarded upstream.')
prvtRsvpDiagNodeRErr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeRErr.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeRErr.setDescription('The error conditions at this node.\n           Bit 3 indicates ROUTE object too big;\n           Bit 2 indicates packet too big;\n           Bit 1 indicates no PATH state.\n           Bit 1 is the least significant bit.')
prvtRsvpDiagNodeKValue = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeKValue.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeKValue.setDescription('The refresh timer multiple.')
prvtRsvpDiagNodeTimerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagNodeTimerValue.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeTimerValue.setDescription('The local refresh timer value in seconds.')
prvtRsvpDiagRsvpHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagRsvpHopAddr.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagRsvpHopAddr.setDescription("The hop address from the session's RSVP_HOP object.")
prvtRsvpDiagRsvpHopLIH = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagRsvpHopLIH.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagRsvpHopLIH.setDescription("The LIH from the session's RSVP_HOP object.")
prvtRsvpDiagSenderTpltAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagSenderTpltAddress.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagSenderTpltAddress.setDescription("The address from the session's SENDER_TEMPLATE object.")
prvtRsvpDiagSenderTpltLSPId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagSenderTpltLSPId.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagSenderTpltLSPId.setDescription("The LSP ID from the session's SENDER_TEMPLATE object.")
prvtRsvpDiagFlowSpecCLBktRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLBktRate.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLBktRate.setDescription("Int-serv controlled load token bucket rate in bytes per second,\n           from the session's FLOWSPEC object.\n           This value is rounded to the nearest integer.")
prvtRsvpDiagFlowSpecCLBktDep = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLBktDep.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLBktDep.setDescription("Int-serv controlled load token bucket depth in bytes,\n           from the session's FLOWSPEC object.\n           This value is rounded to the nearest integer.")
prvtRsvpDiagFlowSpecCLPkDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLPkDataRate.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLPkDataRate.setDescription("Int-serv controlled load peak data rate in bytes per second,\n           from the session's FLOWSPEC object.\n           This value is rounded to the nearest integer.")
prvtRsvpDiagFlowSpecCLMinPolUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLMinPolUnit.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLMinPolUnit.setDescription("Int-serv controlled load minimum policed unit\n           from the session's FLOWSPEC object.")
prvtRsvpDiagFlowSpecCLMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLMaxPktSize.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCLMaxPktSize.setDescription("Int-serv controlled load maximum packet size\n           from the session's FLOWSPEC object.")
prvtRsvpDiagFlowSpecGQBktRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQBktRate.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQBktRate.setDescription("Int-serv guaranteed QoS token bucket rate in bytes per second,\n           from the session's FLOWSPEC object.\n           This value is rounded to the nearest integer.")
prvtRsvpDiagFlowSpecGQBktDep = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQBktDep.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQBktDep.setDescription("Int-serv guaranteed QoS token bucket depth in bytes,\n           from the session's FLOWSPEC object.\n           This value is rounded to the nearest integer.")
prvtRsvpDiagFlowSpecGQPkDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQPkDataRate.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQPkDataRate.setDescription("Int-serv guaranteed QoS peak data rate in bytes per second,\n           from the session's FLOWSPEC object.\n           This value is rounded to the nearest integer.")
prvtRsvpDiagFlowSpecGQMinPolUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQMinPolUnit.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQMinPolUnit.setDescription("Int-serv guaranteed QoS minimum policed unit\n           from the session's FLOWSPEC object.")
prvtRsvpDiagFlowSpecGQMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQMaxPktSize.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQMaxPktSize.setDescription("Int-serv guaranteed QoS maximum packet size\n           from the session's FLOWSPEC object.")
prvtRsvpDiagFlowSpecGQRate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQRate.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQRate.setDescription("Int-serv guaranteed QoS rate in bytes per second,\n           from the session's FLOWSPEC object.\n           This value is rounded to the nearest integer.")
prvtRsvpDiagFlowSpecGQSlack = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQSlack.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecGQSlack.setDescription("Int-serv guaranteed QoS slack in microseconds,\n           from the session's FLOWSPEC object.")
prvtRsvpDiagFlowSpecCoSCoS = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCoSCoS.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCoSCoS.setDescription("CoS class of service from the session's FLOWSPEC object.")
prvtRsvpDiagFlowSpecCoSMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCoSMTU.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFlowSpecCoSMTU.setDescription("CoS maximum packet size from the session's FLOWSPEC object.")
prvtRsvpDiagFilterSpecAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 32), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFilterSpecAddress.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFilterSpecAddress.setDescription("The address from the session's FILTER_SPEC object.")
prvtRsvpDiagFilterSpecLSPId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagFilterSpecLSPId.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagFilterSpecLSPId.setDescription("The LSP ID from the session's FILTER_SPEC object.")
prvtRsvpDiagConfirmRcvAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 34), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagConfirmRcvAddr.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagConfirmRcvAddr.setDescription("The address from the session's CONFIRM object.")
prvtRsvpDiagStyle = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 1, 3, 1, 35), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtRsvpDiagStyle.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagStyle.setDescription("The style word from the session's STYLE object.")
prvtRsvpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 2))
prvtRsvpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 2, 1))
prvtRsvpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 2, 2))
prvtRsvpCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 2, 1, 1)).setObjects(("PRVT-RSVP-MIB", "prvtRsvpProductGroup"), ("PRVT-RSVP-MIB", "prvtRsvpDiagGroup"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtRsvpCompliance = prvtRsvpCompliance.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpCompliance.setDescription('The compliance statement for the PRVT-RSVP product MIB.')
prvtRsvpProductGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 2, 2, 2)).setObjects(("PRVT-RSVP-MIB", "prvtRsvpProductASNumber"), ("PRVT-RSVP-MIB", "prvtRsvpProductSenderTTL"), ("PRVT-RSVP-MIB", "prvtRsvpProductMinTimerPeriod"), ("PRVT-RSVP-MIB", "prvtRsvpProductAPIIfIndex"), ("PRVT-RSVP-MIB", "prvtRsvpProductAPIAddress"), ("PRVT-RSVP-MIB", "prvtRsvpProductAPIRefreshInterval"), ("PRVT-RSVP-MIB", "prvtRsvpProductLocalRepairDelay"), ("PRVT-RSVP-MIB", "prvtRsvpProductRefreshInterval"), ("PRVT-RSVP-MIB", "prvtRsvpProductRefreshMultiple"), ("PRVT-RSVP-MIB", "prvtRsvpProductRfrshSlewDenom"), ("PRVT-RSVP-MIB", "prvtRsvpProductRfrshSlewNumerator"), ("PRVT-RSVP-MIB", "prvtRsvpProductBlockadeMultiple"), ("PRVT-RSVP-MIB", "prvtRsvpProductSocketBufPoolSize"), ("PRVT-RSVP-MIB", "prvtRsvpProductSwitchBufPoolSize"), ("PRVT-RSVP-MIB", "prvtRsvpProductTeMibBufPoolSize"), ("PRVT-RSVP-MIB", "prvtRsvpProductRoutingBufPoolSize"), ("PRVT-RSVP-MIB", "prvtRsvpProductLSPSetupPriority"), ("PRVT-RSVP-MIB", "prvtRsvpProductLSPHoldingPriority"), ("PRVT-RSVP-MIB", "prvtRsvpProductAdminStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductOperStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductRowStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductLsrIndex"), ("PRVT-RSVP-MIB", "prvtRsvpProductTeMibIndex"), ("PRVT-RSVP-MIB", "prvtRsvpProductMultiStackSupport"), ("PRVT-RSVP-MIB", "prvtRsvpProductUseHopByHop"), ("PRVT-RSVP-MIB", "prvtRsvpProductUseNotify"), ("PRVT-RSVP-MIB", "prvtRsvpProductNotifyRRDecay"), ("PRVT-RSVP-MIB", "prvtRsvpProductNotifyRRInterval"), ("PRVT-RSVP-MIB", "prvtRsvpProductNotifyRRLimit"), ("PRVT-RSVP-MIB", "prvtRsvpProductAllowIPEncap"), ("PRVT-RSVP-MIB", "prvtRsvpProductProtocolExtensions"), ("PRVT-RSVP-MIB", "prvtRsvpProductPSRFlags"), ("PRVT-RSVP-MIB", "prvtRsvpProductInitPathRRDecay"), ("PRVT-RSVP-MIB", "prvtRsvpProductInitPathRRInterval"), ("PRVT-RSVP-MIB", "prvtRsvpProductInitPathRRLimit"), ("PRVT-RSVP-MIB", "prvtRsvpProductEnableUni"), ("PRVT-RSVP-MIB", "prvtRsvpProductRestartCapable"), ("PRVT-RSVP-MIB", "prvtRsvpProductRestartTime"), ("PRVT-RSVP-MIB", "prvtRsvpProductRecoveryTime"), ("PRVT-RSVP-MIB", "prvtRsvpProductMinPeerRestart"), ("PRVT-RSVP-MIB", "prvtRsvpProductGracefulDelTimeout"), ("PRVT-RSVP-MIB", "prvtRsvpProductEgressDelBehavior"), ("PRVT-RSVP-MIB", "prvtRsvpProductEnabUniConnSplicing"), ("PRVT-RSVP-MIB", "prvtRsvpProductFastRerouteCaps"), ("PRVT-RSVP-MIB", "prvtRsvpProductFastRroutBkpRtryInt"), ("PRVT-RSVP-MIB", "prvtRsvpProductErrorActionFlags"), ("PRVT-RSVP-MIB", "prvtRsvpProductEnableNni"), ("PRVT-RSVP-MIB", "prvtRsvpProductBehaviorFlags"), ("PRVT-RSVP-MIB", "prvtRsvpProductLabelSetStyle"), ("PRVT-RSVP-MIB", "prvtRsvpProductLabelSetOperStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductLabelSetTrapEnable"), ("PRVT-RSVP-MIB", "prvtRsvpProductLabelSetChngAct"), ("PRVT-RSVP-MIB", "prvtRsvpProductExtPrtAdminStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductUniIncSonetProfile"), ("PRVT-RSVP-MIB", "prvtRsvpProductFrrFacAdminStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductFrrFacOperStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductIpv6AdminStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductIpv6OperStatus"), ("PRVT-RSVP-MIB", "prvtRsvpProductAPIIpv6Address"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtRsvpProductGroup = prvtRsvpProductGroup.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpProductGroup.setDescription('Product Table Objects.')
prvtRsvpDiagGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 2, 2, 3)).setObjects(("PRVT-RSVP-MIB", "prvtRsvpDiagReqsInProgress"), ("PRVT-RSVP-MIB", "prvtRsvpDiagSessionEndPoint"), ("PRVT-RSVP-MIB", "prvtRsvpDiagSessionTunnelId"), ("PRVT-RSVP-MIB", "prvtRsvpDiagSessionExtTunnelId"), ("PRVT-RSVP-MIB", "prvtRsvpDiagLastHop"), ("PRVT-RSVP-MIB", "prvtRsvpDiagSender"), ("PRVT-RSVP-MIB", "prvtRsvpDiagMaxHops"), ("PRVT-RSVP-MIB", "prvtRsvpDiagHopByHopReply"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtRsvpDiagGroup = prvtRsvpDiagGroup.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagGroup.setDescription('Diagnostic Table Objects.')
prvtRsvpDiagNodeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 7, 2, 2, 4)).setObjects(("PRVT-RSVP-MIB", "prvtRsvpDiagNodeType"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeDreqArrivalTime"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeIncomingIfAddr"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeOutgoingIfAddr"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodePrevHopAddr"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeDTTL"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeMFlag"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeRErr"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeKValue"), ("PRVT-RSVP-MIB", "prvtRsvpDiagNodeTimerValue"), ("PRVT-RSVP-MIB", "prvtRsvpDiagRsvpHopAddr"), ("PRVT-RSVP-MIB", "prvtRsvpDiagRsvpHopLIH"), ("PRVT-RSVP-MIB", "prvtRsvpDiagSenderTpltLSPId"), ("PRVT-RSVP-MIB", "prvtRsvpDiagSenderTpltAddress"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecCLBktRate"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecCLBktDep"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecCLPkDataRate"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecCLMinPolUnit"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecCLMaxPktSize"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecGQBktRate"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecGQBktDep"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecGQPkDataRate"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecGQMinPolUnit"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecGQMaxPktSize"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecGQRate"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecGQSlack"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecCoSCoS"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFlowSpecCoSMTU"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFilterSpecAddress"), ("PRVT-RSVP-MIB", "prvtRsvpDiagFilterSpecLSPId"), ("PRVT-RSVP-MIB", "prvtRsvpDiagConfirmRcvAddr"), ("PRVT-RSVP-MIB", "prvtRsvpDiagStyle"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtRsvpDiagNodeGroup = prvtRsvpDiagNodeGroup.setStatus('current')
if mibBuilder.loadTexts: prvtRsvpDiagNodeGroup.setDescription('Diag Node Table Objects.')
mibBuilder.exportSymbols("PRVT-RSVP-MIB", prvtRsvpDiagFlowSpecCoSMTU=prvtRsvpDiagFlowSpecCoSMTU, prvtRsvpProductRowStatus=prvtRsvpProductRowStatus, prvtRsvpCompliances=prvtRsvpCompliances, prvtRsvpGroups=prvtRsvpGroups, prvtRsvpDiagNodeMFlag=prvtRsvpDiagNodeMFlag, prvtRsvpProductMinPeerRestart=prvtRsvpProductMinPeerRestart, prvtRsvpProductUniIncSonetProfile=prvtRsvpProductUniIncSonetProfile, prvtRsvpDiagStyle=prvtRsvpDiagStyle, prvtRsvpDiagReqsInProgress=prvtRsvpDiagReqsInProgress, prvtRsvpDiagFlowSpecGQBktDep=prvtRsvpDiagFlowSpecGQBktDep, prvtRsvpProductGroup=prvtRsvpProductGroup, prvtRsvpDiagFlowSpecCoSCoS=prvtRsvpDiagFlowSpecCoSCoS, prvtRsvpDiagFlowSpecGQBktRate=prvtRsvpDiagFlowSpecGQBktRate, prvtRsvpDiagMaxHops=prvtRsvpDiagMaxHops, prvtRsvpProductLabelSetStyle=prvtRsvpProductLabelSetStyle, prvtRsvpDiagNodeRErr=prvtRsvpDiagNodeRErr, prvtRsvpProductUseNotify=prvtRsvpProductUseNotify, prvtRsvpDiagLastHop=prvtRsvpDiagLastHop, prvtRsvpProductSwitchBufPoolSize=prvtRsvpProductSwitchBufPoolSize, prvtRsvpDiagSenderTpltLSPId=prvtRsvpDiagSenderTpltLSPId, prvtRsvpDiagNodeDreqArrivalTime=prvtRsvpDiagNodeDreqArrivalTime, prvtRsvpProductAPIIfIndex=prvtRsvpProductAPIIfIndex, prvtRsvpProductRoutingBufPoolSize=prvtRsvpProductRoutingBufPoolSize, prvtRsvpProductExtPrtAdminStatus=prvtRsvpProductExtPrtAdminStatus, prvtRsvpProductFastRerouteCaps=prvtRsvpProductFastRerouteCaps, PrvtRsvpDiagReqIndex=PrvtRsvpDiagReqIndex, prvtRsvpProductAdminStatus=prvtRsvpProductAdminStatus, prvtRsvpProductSenderTTL=prvtRsvpProductSenderTTL, prvtRsvpDiagRequestIndex=prvtRsvpDiagRequestIndex, prvtRsvpProductRestartTime=prvtRsvpProductRestartTime, prvtRsvpDiagFlowSpecGQPkDataRate=prvtRsvpDiagFlowSpecGQPkDataRate, prvtRsvpProductRfrshSlewNumerator=prvtRsvpProductRfrshSlewNumerator, prvtRsvpDiagSenderTpltAddress=prvtRsvpDiagSenderTpltAddress, prvtRsvpDiagFilterSpecLSPId=prvtRsvpDiagFilterSpecLSPId, prvtRsvpDiagnosticTable=prvtRsvpDiagnosticTable, PrvtRsvpDiagNodeTypeVal=PrvtRsvpDiagNodeTypeVal, prvtRsvpDiagSessionExtTunnelId=prvtRsvpDiagSessionExtTunnelId, prvtRsvpProductLSPHoldingPriority=prvtRsvpProductLSPHoldingPriority, prvtRsvpDiagNodeGroup=prvtRsvpDiagNodeGroup, prvtRsvpDiagFlowSpecGQMinPolUnit=prvtRsvpDiagFlowSpecGQMinPolUnit, PrvtRsvpIndex=PrvtRsvpIndex, prvtRsvpProductLsrIndex=prvtRsvpProductLsrIndex, prvtRsvpProductNotifyRRInterval=prvtRsvpProductNotifyRRInterval, prvtRsvpProductBlockadeMultiple=prvtRsvpProductBlockadeMultiple, prvtRsvpProductLocalRepairDelay=prvtRsvpProductLocalRepairDelay, prvtRsvpProductIpv6AdminStatus=prvtRsvpProductIpv6AdminStatus, prvtRsvpDiagRsvpHopLIH=prvtRsvpDiagRsvpHopLIH, prvtRsvpDiagProductIndex=prvtRsvpDiagProductIndex, prvtRsvpProductEnableUni=prvtRsvpProductEnableUni, prvtRsvpDiagnosticEntry=prvtRsvpDiagnosticEntry, prvtRsvpCompliance=prvtRsvpCompliance, prvtRsvpDiagGroup=prvtRsvpDiagGroup, prvtRsvpDiagNodeOutgoingIfAddr=prvtRsvpDiagNodeOutgoingIfAddr, prvtRsvpProductAPIIpv6Address=prvtRsvpProductAPIIpv6Address, prvtRsvpProductBehaviorFlags=prvtRsvpProductBehaviorFlags, prvtRsvpProductIpv6OperStatus=prvtRsvpProductIpv6OperStatus, prvtRsvpDiagNodeType=prvtRsvpDiagNodeType, prvtRsvpDiagNodeKValue=prvtRsvpDiagNodeKValue, prvtRsvpDiagNodeIncomingIfAddr=prvtRsvpDiagNodeIncomingIfAddr, prvtRsvpProductAllowIPEncap=prvtRsvpProductAllowIPEncap, prvtRsvpProductRefreshMultiple=prvtRsvpProductRefreshMultiple, prvtRsvpProductRfrshSlewDenom=prvtRsvpProductRfrshSlewDenom, prvtRsvpProductASNumber=prvtRsvpProductASNumber, prvtRsvpProductIndex=prvtRsvpProductIndex, prvtRsvpProductErrorActionFlags=prvtRsvpProductErrorActionFlags, prvtRsvpProductEnableNni=prvtRsvpProductEnableNni, prvtRsvpDiagNodeIndex=prvtRsvpDiagNodeIndex, prvtRsvpDiagFlowSpecGQSlack=prvtRsvpDiagFlowSpecGQSlack, prvtRsvpDiagFlowSpecGQRate=prvtRsvpDiagFlowSpecGQRate, prvtRsvpDiagNodeRequestIndex=prvtRsvpDiagNodeRequestIndex, prvtRsvpProductLabelSetOperStatus=prvtRsvpProductLabelSetOperStatus, prvtRsvp=prvtRsvp, prvtRsvpDiagFilterSpecAddress=prvtRsvpDiagFilterSpecAddress, prvtRsvpProductMultiStackSupport=prvtRsvpProductMultiStackSupport, prvtRsvpObjects=prvtRsvpObjects, prvtRsvpProductAPIAddress=prvtRsvpProductAPIAddress, prvtRsvpProductSocketBufPoolSize=prvtRsvpProductSocketBufPoolSize, PrvtRsvpAdminStatus=PrvtRsvpAdminStatus, prvtRsvpProductFrrFacOperStatus=prvtRsvpProductFrrFacOperStatus, prvtRsvpProductUseHopByHop=prvtRsvpProductUseHopByHop, prvtRsvpDiagNodeTimerValue=prvtRsvpDiagNodeTimerValue, prvtRsvpProductRecoveryTime=prvtRsvpProductRecoveryTime, prvtRsvpProductNotifyRRLimit=prvtRsvpProductNotifyRRLimit, prvtRsvpProductOperStatus=prvtRsvpProductOperStatus, prvtRsvpDiagConfirmRcvAddr=prvtRsvpDiagConfirmRcvAddr, prvtRsvpDiagFlowSpecCLBktDep=prvtRsvpDiagFlowSpecCLBktDep, prvtRsvpDiagSender=prvtRsvpDiagSender, prvtRsvpDiagNodeTable=prvtRsvpDiagNodeTable, PYSNMP_MODULE_ID=prvtRsvp, prvtRsvpProductInitPathRRLimit=prvtRsvpProductInitPathRRLimit, prvtRsvpDiagNodeProductIndex=prvtRsvpDiagNodeProductIndex, prvtRsvpProductRestartCapable=prvtRsvpProductRestartCapable, prvtRsvpDiagFlowSpecCLPkDataRate=prvtRsvpDiagFlowSpecCLPkDataRate, prvtRsvpProductTable=prvtRsvpProductTable, prvtRsvpDiagSessionTunnelId=prvtRsvpDiagSessionTunnelId, prvtRsvpDiagNodePrevHopAddr=prvtRsvpDiagNodePrevHopAddr, prvtRsvpProductNotifyRRDecay=prvtRsvpProductNotifyRRDecay, prvtRsvpConformance=prvtRsvpConformance, prvtRsvpProductLabelSetChngAct=prvtRsvpProductLabelSetChngAct, prvtRsvpDiagHopByHopReply=prvtRsvpDiagHopByHopReply, prvtRsvpProductInitPathRRInterval=prvtRsvpProductInitPathRRInterval, prvtRsvpDiagFlowSpecCLMaxPktSize=prvtRsvpDiagFlowSpecCLMaxPktSize, prvtRsvpProductTeMibIndex=prvtRsvpProductTeMibIndex, prvtRsvpProductInitPathRRDecay=prvtRsvpProductInitPathRRDecay, prvtRsvpDiagSessionEndPoint=prvtRsvpDiagSessionEndPoint, prvtRsvpProductAPIRefreshInterval=prvtRsvpProductAPIRefreshInterval, prvtRsvpDiagFlowSpecCLMinPolUnit=prvtRsvpDiagFlowSpecCLMinPolUnit, prvtRsvpProductMinTimerPeriod=prvtRsvpProductMinTimerPeriod, prvtRsvpProductLabelSetTrapEnable=prvtRsvpProductLabelSetTrapEnable, prvtRsvpDiagFlowSpecCLBktRate=prvtRsvpDiagFlowSpecCLBktRate, prvtRsvpDiagRsvpHopAddr=prvtRsvpDiagRsvpHopAddr, PrvtRsvpOperStatus=PrvtRsvpOperStatus, prvtRsvpProductFastRroutBkpRtryInt=prvtRsvpProductFastRroutBkpRtryInt, prvtRsvpProductLSPSetupPriority=prvtRsvpProductLSPSetupPriority, prvtRsvpDiagNodeDTTL=prvtRsvpDiagNodeDTTL, prvtRsvpProductProtocolExtensions=prvtRsvpProductProtocolExtensions, prvtRsvpProductEnabUniConnSplicing=prvtRsvpProductEnabUniConnSplicing, prvtRsvpProductTeMibBufPoolSize=prvtRsvpProductTeMibBufPoolSize, prvtRsvpDiagNodeEntry=prvtRsvpDiagNodeEntry, PrvtRsvpDiagNodeIndexType=PrvtRsvpDiagNodeIndexType, prvtRsvpProductEgressDelBehavior=prvtRsvpProductEgressDelBehavior, prvtRsvpProductRefreshInterval=prvtRsvpProductRefreshInterval, prvtRsvpDiagFlowSpecGQMaxPktSize=prvtRsvpDiagFlowSpecGQMaxPktSize, prvtRsvpProductFrrFacAdminStatus=prvtRsvpProductFrrFacAdminStatus, prvtRsvpProductEntry=prvtRsvpProductEntry, prvtRsvpProductPSRFlags=prvtRsvpProductPSRFlags, prvtRsvpProductGracefulDelTimeout=prvtRsvpProductGracefulDelTimeout)
