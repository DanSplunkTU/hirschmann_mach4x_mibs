#
# PySNMP MIB module ALCATEL-IND1-TIMETRA-VRTR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nokia/aos7/ALCATEL-IND1-TIMETRA-VRTR-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 17:15:06 2022
# On host fv-az135-792 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
TmnxSlotNum, = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "TmnxSlotNum")
TFilterID, TIPFilterID = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-FILTER-MIB", "TFilterID", "TIPFilterID")
timetraSRMIBModules, tmnxSRConfs, tmnxSRObjs, tmnxSRNotifyPrefix = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-GLOBAL-MIB", "timetraSRMIBModules", "tmnxSRConfs", "tmnxSRObjs", "tmnxSRNotifyPrefix")
tmnxPortNotifyPortId, tmnxPortType = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId", "tmnxPortType")
TNetworkPolicyID, = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-QOS-MIB", "TNetworkPolicyID")
sapPortId, sapEncapValue = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-SAP-MIB", "sapPortId", "sapEncapValue")
svcDhcpClientLease, svcDhcpLseStateNewChAddr, svcDhcpLseStateNewCiAddr = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-SERV-MIB", "svcDhcpClientLease", "svcDhcpLseStateNewChAddr", "svcDhcpLseStateNewCiAddr")
TmnxDHCP6MsgType, TmnxEncapVal, TmnxPortID, TItemDescription, TmnxBgpAutonomousSystem, TItemLongDescription, TDSCPValue, Dot1PPriority, TmnxTunnelID, TmnxVRtrIDOrZero, TmnxTunnelType, TmnxStatus, TNamedItemOrEmpty, TPolicyStatementNameOrEmpty, TmnxCustId, TCpmProtPolicyID, TFCType, TDSCPValueOrNone, IpAddressPrefixLength, TmnxVPNRouteDistinguisher, TmnxOperState, TmnxAdminState, TmnxVRtrID, TNamedItem, TmnxServId = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-TC-MIB", "TmnxDHCP6MsgType", "TmnxEncapVal", "TmnxPortID", "TItemDescription", "TmnxBgpAutonomousSystem", "TItemLongDescription", "TDSCPValue", "Dot1PPriority", "TmnxTunnelID", "TmnxVRtrIDOrZero", "TmnxTunnelType", "TmnxStatus", "TNamedItemOrEmpty", "TPolicyStatementNameOrEmpty", "TmnxCustId", "TCpmProtPolicyID", "TFCType", "TDSCPValueOrNone", "IpAddressPrefixLength", "TmnxVPNRouteDistinguisher", "TmnxOperState", "TmnxAdminState", "TmnxVRtrID", "TNamedItem", "TmnxServId")
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressIPv6z, InetAddressType, InetAddressIPv6, InetAddress, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6z", "InetAddressType", "InetAddressIPv6", "InetAddress", "InetAddressPrefixLength")
ipCidrRouteEntry, = mibBuilder.importSymbols("IP-FORWARD-MIB", "ipCidrRouteEntry")
ipNetToMediaEntry, = mibBuilder.importSymbols("IP-MIB", "ipNetToMediaEntry")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
iso, ModuleIdentity, Counter64, MibIdentifier, TimeTicks, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Integer32, Gauge32, Counter32, NotificationType, Unsigned32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "ModuleIdentity", "Counter64", "MibIdentifier", "TimeTicks", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Integer32", "Gauge32", "Counter32", "NotificationType", "Unsigned32", "Bits")
RowStatus, MacAddress, TruthValue, TextualConvention, DisplayString, TimeStamp, TestAndIncr = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "MacAddress", "TruthValue", "TextualConvention", "DisplayString", "TimeStamp", "TestAndIncr")
timetraVRtrMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 3))
timetraVRtrMIBModule.setRevisions(('1908-01-01 00:00', '1907-01-01 00:00', '1906-02-28 00:00', '1905-08-31 00:00', '1905-01-24 00:00', '1904-01-15 00:00', '1903-08-15 00:00', '1903-01-20 00:00', '1900-08-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: timetraVRtrMIBModule.setRevisionsDescriptions(('Rev 6.0                01 Jan 2008 00:00\n                         6.0 release of the TIMETRA-VRTR-MIB.', 'Rev 5.0                01 Jan 2007 00:00\n                         5.0 release of the TIMETRA-VRTR-MIB.', 'Rev 4.0                28 Feb 2006 00:00\n                         4.0 release of the TIMETRA-VRTR-MIB.', 'Rev 3.0                31 Aug 2005 00:00\n                         3.0 release of the TIMETRA-VRTR-MIB.', 'Rev 2.1                24 Jan 2005 00:00\n                         2.1 release of the TIMETRA-VRTR-MIB.', 'Rev 2.0                15 Jan 2004 00:00\n                         2.0 release of the TIMETRA-VRTR-MIB.', 'Rev 1.2                15 Aug 2003 00:00\n                         1.2 release of the TIMETRA-VRTR-MIB.', 'Rev 1.0                20 Jan 2003 00:00\n                         1.0 Release of the TIMETRA-VRTR-MIB.', 'Rev 0.1                14 Aug 2000 00:00\n                         Initial version of the TIMETRA-VRTR-MIB.',))
if mibBuilder.loadTexts: timetraVRtrMIBModule.setLastUpdated('0801010000Z')
if mibBuilder.loadTexts: timetraVRtrMIBModule.setOrganization('Alcatel')
if mibBuilder.loadTexts: timetraVRtrMIBModule.setContactInfo('Alcatel 7x50 Support\n             Web: http://www.alcatel.com/comps/pages/carrier_support.jhtml')
if mibBuilder.loadTexts: timetraVRtrMIBModule.setDescription("This document  is the SNMP MIB  module to manage and provision\n             the  Alcatel  7x50 device transport and virtual routers, their\n             interfaces, and other related features.\n\n             Copyright 2003-2008 Alcatel-Lucent. All rights reserved.\n             Reproduction of  this document is authorized  on the condition\n             that the foregoing copyright notice is included.\n\n             This   SNMP  MIB  module  (Specification)  embodies  Alcatel's\n             proprietary  intellectual  property. Alcatel retains all title\n             and ownership in the Specification, including any revisions.\n\n             Alcatel  grants all interested parties a non-exclusive license\n             to use and distribute an unmodified copy of this Specification\n             in connection with management of Alcatel products, and without\n             fee,  provided this copyright notice and license appear on all\n             copies.\n\n             This  Specification  is supplied `as is', and Alcatel makes no\n             warranty, either express or implied, as to the use, operation,\n             condition, or performance of the Specification.")
tmnxVRtrObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3))
tmnxVRtrConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3))
tmnxVRtrNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3))
tmnxVRtrNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0))
class TmnxVPNId(TextualConvention, OctetString):
    reference = "RFC 2685, Fox & Gleeson, 'Virtual Private Networks Identifier',\n         September 1999."
    description = 'The purpose of a VPN-ID is to identify a VPN.\n         The global VPN Identifier format is:\n            3-octet VPN Authority, organizationally unique ID followed by a\n            4-octet VPN index identifying the VPN according to OUI.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 7)

class TmnxInetAddrState(TextualConvention, Integer32):
    description = 'The TmnxInetAddrState is the state of an ipv6 address.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("unknown", 0), ("tentative", 1), ("duplicated", 2), ("inaccessible", 3), ("deprecated", 4), ("preferred", 5))

class TDSCPAppId(TextualConvention, Integer32):
    description = 'DSCP Application identifiers for protocols that generate control traffic\n         on the the Alcatel 7x50 SR router.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27))
    namedValues = NamedValues(("bgp", 1), ("cflowd", 2), ("dhcp", 3), ("dns", 4), ("ftp", 5), ("icmp", 6), ("igmp", 7), ("ldp", 8), ("mld", 9), ("msdp", 10), ("ndis", 11), ("ntp", 12), ("ospf", 13), ("pim", 14), ("radius", 15), ("rip", 16), ("rsvp", 17), ("snmp", 18), ("snmp-notification", 19), ("srrp", 20), ("ssh", 21), ("syslog", 22), ("tacplus", 23), ("telnet", 24), ("tftp", 25), ("traceroute", 26), ("vrrp", 27))

class TDot1pAppId(TextualConvention, Integer32):
    description = 'IEEE 802.1p priority (Dot1p) Application identifiers for Layer-2\n         protocols that generate control traffic on the the Alcatel\n         7x50 SR router.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("arp", 1), ("isis", 2), ("pppoe", 3))

tmnxVRtrGlobalObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 15))
vRtrNextVRtrID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 15, 1), TestAndIncr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrNextVRtrID.setStatus('current')
if mibBuilder.loadTexts: vRtrNextVRtrID.setDescription("The vRtrNextVRtrID object is used to assign values to vRtrID\n         to be used to create a new row in the vRtrConfTable as described\n         in 'Textual Conventions for SNMPv2'.  The network manager reads\n         the object, and then writes the value back in the SET request\n         that creates a new instance of vRtrConfEntry.  If the SET fails\n         with the code 'inconsistentValue', then the process must be\n         repeated.  If the the SET succeeds, then the object is\n         incremented and the new instance is created according to the\n         manager's directions.")
vRtrConfiguredVRtrs = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 15, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrConfiguredVRtrs.setStatus('current')
if mibBuilder.loadTexts: vRtrConfiguredVRtrs.setDescription('The value of vRtrConfiguredVRtrs indicates the current number of\n         virtual routers configured in the system and represented as rows\n         in the vRtrConfTable.')
vRtrActiveVRtrs = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 15, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrActiveVRtrs.setStatus('current')
if mibBuilder.loadTexts: vRtrActiveVRtrs.setDescription("The value of vRtrActiveVRtrs indicates the current number of virtual\n         routers in the system with vRtrAdminStatus equal 'inService'.")
vRtrRouteThresholdSoakTime = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 15, 4), Unsigned32().clone(600)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrRouteThresholdSoakTime.setStatus('current')
if mibBuilder.loadTexts: vRtrRouteThresholdSoakTime.setDescription('Following the generation of a tmnxVRtrHighRouteTCA notification, the\n         value of vRtrRouteThresholdSoakTime indicates the soak interval in\n         seconds before another tmnxVRtrHighRouteTCA notification will be\n         re-issued.  Imposing this soak period prevents continuous generation of\n         notifications by the agent in the event that routes are continually\n         added to a VRF after it has reached its maximum capacity.  When this\n         object has a value of 0, it indicates that the agent should issue a\n         single notification at the time that the value of\n         vRtrHighRouteThreshold is exceeded and another notification should not\n         be sent until the number of routes has fallen below the value\n         configured in vRtrMidRouteThreshold.')
vRtrMaxARPEntries = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 15, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMaxARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrMaxARPEntries.setDescription('vRtrMaxARPEntries indicates the maximum number of active\n         and inactive ARP entries supported across all virtual routers\n         in the system.')
vRtrIPv6RouteThresholdSoakTime = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 15, 6), Unsigned32().clone(600)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrIPv6RouteThresholdSoakTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIPv6RouteThresholdSoakTime.setDescription('The value of object vRtrIPv6RouteThresholdSoakTime specifies\n         the soak interval in seconds before another\n         tmnxVRtrIPv6HighRouteTCA notification will be re-issued,\n         after the generation of a tmnxVRtrIPv6HighRouteTCA notification.\n         \n         Imposing this soak period prevents continuous generation of\n         notifications by the agent, in the event that routes are continually\n         added to a VRF after it has reached its maximum capacity.\n         \n         When this object has a value of 0, it indicates that the agent should\n         issue a single notification at the time that the value of\n         vRtrIPv6HighRouteThreshold is exceeded and another notification should\n         not be sent until the number of routes has fallen below the value\n         configured in vRtrIPv6MidRouteThreshold.')
vRtrConfTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1), )
if mibBuilder.loadTexts: vRtrConfTable.setStatus('current')
if mibBuilder.loadTexts: vRtrConfTable.setDescription('The vRtrConfTable has an entry for each virtual router configured\n         in the system.')
vRtrConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"))
if mibBuilder.loadTexts: vRtrConfEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrConfEntry.setDescription('Each row entry represents a virtual router in the system. Entries can\n         be created and deleted via SNMP SET operations.  Creation requires a\n         SET request containing vRtrRowStatus, vRtrName and vRtrType.\n         Note that rows in this table are usually created by the agent itself\n         as a side affect of some other configuration; for example, when a\n         service vprn is created by setting the appropriate objects in the\n         ALCATEL-IND1-TIMETRA-SERV-MIB.\n\n         There will always be at least two row entries in this table, one of\n         these entries represents the base or transport router and the other\n         represents the management router.  These entries are created when the\n         system is initialized and can never be deleted.')
vRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 1), TmnxVRtrID()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrID.setStatus('current')
if mibBuilder.loadTexts: vRtrID.setDescription('The  unique value which identifies this virtual router in the Tmnx\n         system.  The  vRtrID  value  for  each  virtual router must remain\n         constant  at least   from  one  re-initialization  of  the  system\n         management  processor  (CPM)  to the next. There will always be at\n         least  one  router  entry defined by the agent with vRtrID=1 which\n         represents the transport router.')
vRtrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrRowStatus.setDescription("The row status. The creation or deletion of a virtual router entry\n         causes creation or deletion of corresponding entries in other Tmnx\n         MIB tables with the same vRtrID value. Note that it is not allowed\n         to 'destroy' the row entry for vRtrID = 1.\n\n         In  order  for  row  creation  to succeed, values for vRtrName and\n         vRtrType   must   be   included  in  the  same  SNMP  SET  PDU  as\n         vRtrRowStatus.")
vRtrAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 3), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrAdminState.setDescription("The desired administrative state for this virtual router.\n         Note that it is not allowed to set vRtrAdminState to 'outOfService\n         for the row entry with vRtrID = 1.")
vRtrName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 4), TNamedItemOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrName.setStatus('current')
if mibBuilder.loadTexts: vRtrName.setDescription("The administritive name for this virtual router. The router\n         name must be unique among all virtual routers in the system.\n         When a row is created in the vRtrConfTable for a service vprn,\n         the agent assigns the name 'VR-<service-id>'.  Note that for\n         row creation to succeed, a value must be specified for vRtrName.")
vRtrMaxNumRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMaxNumRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrMaxNumRoutes.setDescription('The maximum number of routes that can be configured on\n         this virtual router.  If the value is -1, then there\n         is no limit.')
vRtrBgpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 6), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrBgpStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrBgpStatus.setDescription("The desired state for BGP on this virtual router.  An attempt\n         to set vRtrBgpStatus to 'delete' will fail if the BGP protocol\n         is not in the administrative outOfService state.")
vRtrMplsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 7), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStatus.setDescription("The desired state for MPLS on this virtual router.  An attempt\n         to set vRtrMplsStatus to 'delete' will fail if the MPLS\n         protocol is not in the administrative outOfService state,\n         i.e. ALCATEL-IND1-TIMETRA-MPLS-MIB::vRtrMplsGeneralAdminState must be \n         set to 'outOfService'.")
vRtrOspfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 8), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrOspfStatus.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrOspfStatus.setDescription("The desired state for OSPFv2 on this virtual router.  An attempt\n         to set vRtrOspfStatus to 'delete' will fail if the OSPFv2\n         protocol is not in the administrative outOfService state,\n         i.e. TIMETRA-OSPF-NG-MIB::tmnxOspfAdminState must be set \n         to 'disabled'.\n\n         This object was obsoleted in release 5.0.")
vRtrRipStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 9), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrRipStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrRipStatus.setDescription("The desired state for RIP on this virtual router.  An attempt\n         to set vRtrRipStatus to 'delete' will fail if the RIP\n         protocol is not in the admininistrative outOfService state.")
vRtrRsvpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 10), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrRsvpStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrRsvpStatus.setDescription("The desired state for RSVP on this virtual router.  An attempt\n         to set vRtrRsvpStatus to 'delete' will fail if the RSVP\n         protocol is not in the administrative outOfService state,\n         i.e. TIMETRA-RSVP-MIB::vRtrRsvpGeneralAdminState must be set \n         to 'outOfService'.")
vRtrEcmpMaxRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrEcmpMaxRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrEcmpMaxRoutes.setDescription('The value of vRtrEcmpMaxRoutes specifies the maximum number\n         of equal cost routes allowed on this routing table instance.\n         When the number ecmp routes available at the best preference\n         value exceed the number of vRtrEcmpMaxRoutes allowed, then\n         the lowest next-hop IP address algorithm is used to select\n         the ecmp routes used.\n\n         When vRtrEcmpMaxRoutes is set to zero (0), and multiple routes\n         are available with the same best preference value and equal\n         cost values, then the route with the lowest next-hop IP address\n         is used.')
vRtrAS = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 12), TmnxBgpAutonomousSystem()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAS.setReference('')
if mibBuilder.loadTexts: vRtrAS.setStatus('current')
if mibBuilder.loadTexts: vRtrAS.setDescription('The value of vRtrAS specifies the autonomous system number to be\n         advertised to this peer.  This object is MUST be set before BGP\n         can be activated.')
vRtrNewIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 13), TestAndIncr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrNewIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrNewIfIndex.setDescription("This object is used to assign values to vRtrIfIndex as\n         described in 'Textual Conventions for SNMPv2'.  The network\n         manager reads the object, and then writes the value back\n         in the SET request that creates a new instance of vRtrIfEntry.\n         If the SET fails with the code 'inconsistentValue', then\n         the process must be repeated.  If the the SET succeeds, then\n         the object is incremented and the new instance is created\n         according to the manager's directions.")
vRtrLdpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 14), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatus.setDescription("The desired state for LDP on this virtual router.  An attempt\n         to set vRtrLdpStatus to 'delete' will fail if the LDP\n         protocol is not in the administrative outOfService state,\n         i.e. ALCATEL-IND1-TIMETRA-LDP-MIB::vRtrLdpGenAdminState must be set \n         to 'outOfService'.")
vRtrIsIsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 15), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIsIsStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrIsIsStatus.setDescription("The desired state for ISIS on this virtual router.  An attempt\n         to set vRtrIsIsStatus to 'delete' will fail if the ISIS\n         protocol is not in the administrative outOfService state.")
vRtrRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 16), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrRouterId.setStatus('current')
if mibBuilder.loadTexts: vRtrRouterId.setDescription("A 32-bit integer uniquely identifying the router in the\n         Autonomous System.  By convention, to ensure uniqueness, this\n         should default to the value of one of the router's IP interface\n         addresses.")
vRtrTriggeredPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrTriggeredPolicy.setStatus('current')
if mibBuilder.loadTexts: vRtrTriggeredPolicy.setDescription("If the value of vRtrTriggeredPolicy is 'false', all routing\n         protocols automatically reevaluate their routes when the route\n         policies are changed. If this value is 'true', then the user\n         must trigger the recalculation of routes when the route policies\n         are changed.")
vRtrConfederationAS = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 18), TmnxBgpAutonomousSystem()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrConfederationAS.setStatus('current')
if mibBuilder.loadTexts: vRtrConfederationAS.setDescription('The value of vRtrConfederationAS specifies the confederation AS\n         number for the virtual router. A value of 0 means no confederation\n         AS.')
vRtrRouteDistinguisher = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 19), TmnxVPNRouteDistinguisher().clone(hexValue="0000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrRouteDistinguisher.setStatus('current')
if mibBuilder.loadTexts: vRtrRouteDistinguisher.setDescription("The value of vRtrRouteDistinguisher is an identifier attached to\n         routes that distinguishes to which VPN it belongs.  The VPRN\n         cannot be operationally 'inService' until a route distinguisher\n         has been assigned.")
vRtrMidRouteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMidRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: vRtrMidRouteThreshold.setDescription('The value of vRtrMidRouteThreshold specifies the mid-level\n         water marker for the number of routes which this VRF may hold.\n         When this limit is exceeded a tmnxVRtrMidRouteTCA\n         notification is generated.\n\n         A value of 0 (zero) for this object indicates that the threshold\n         is infinite, and the notification will never be sent.')
vRtrHighRouteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrHighRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: vRtrHighRouteThreshold.setDescription('The value of vRtrHighRouteThreshold specifies the high-level\n         water marker for the number of routes which this VRF may hold.\n         When this limit is exceeded a tmnxVRtrHighRouteTCA\n         notification is generated.\n\n         A value of 0 (zero) for this object indicates that the threshold\n         is infinite, and the notification will never be sent.')
vRtrIllegalLabelThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 22), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIllegalLabelThreshold.setStatus('current')
if mibBuilder.loadTexts: vRtrIllegalLabelThreshold.setDescription('The value of vRtrIllegalLabelThreshold specifies the\n         allowed limit for illegal label violations on this VRF.\n         When this limit is exceeded a tmnxVRtrIllegalLabelTCA\n         notification is generated.\n\n         A value of 0 (zero) for this object indicates that the threshold\n         is infinite, and the notification will never be sent.')
vRtrVpnId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 23), TmnxVPNId().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrVpnId.setStatus('current')
if mibBuilder.loadTexts: vRtrVpnId.setDescription('The value of vRtrVpnId is the Virtual Private Network Identifier\n         of this virtual router.')
vRtrDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 25), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrDescription.setStatus('current')
if mibBuilder.loadTexts: vRtrDescription.setDescription('The value of vRtrDescription is a user provided description\n         string for this virtual router.  It can consist of any printable,\n         seven-bit ASCII characters up to 80 characters in length.')
vRtrGracefulRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrGracefulRestart.setStatus('current')
if mibBuilder.loadTexts: vRtrGracefulRestart.setDescription("The value of vRtrGracefulRestart indicates whether or not\n         graceful restart capabilities are enabled on this virtual\n         router.  In order for any protocol to perform graceful\n         restart vRtrGracefulRestart must have a value of 'true'.\n         Graceful restart capabilities can then be enabled or disabled\n         on an individual protocol basis.")
vRtrGracefulRestartType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("never", 0), ("manual", 1), ("automatic", 2))).clone('never')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrGracefulRestartType.setStatus('current')
if mibBuilder.loadTexts: vRtrGracefulRestartType.setDescription("The value of vRtrGracefulRestartType specifies when to include\n         grace restart of routing protocols as a result of a switchover\n         from primary CPM in a redundant system.\n            'never'     - always switch without graceful restart\n            'manual'    - perform graceful restart only on a forced switchover\n            'automatic' - perform graceful restart on either a switchover\n                          caused by an error or a forced switchover")
vRtrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("baseRouter", 1), ("vprn", 2), ("vr", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrType.setStatus('current')
if mibBuilder.loadTexts: vRtrType.setDescription("The value of vRtrType specifies the type of virtual router\n         represented by this row entry.  When a row is created in this\n         table using 'createAndGo', vRtrType must be specified or the\n         row creation will fail.\n\n         Only the value of 'vr (3)' can be set with a SNMP SET request.\n         The other values are used for row entries created internally by\n         the agent.\n\n         The value of vRtrType cannot be modified if vRtrRowStatus has\n         a value of 'active'.")
vRtrServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 29), TmnxServId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrServiceId.setStatus('current')
if mibBuilder.loadTexts: vRtrServiceId.setDescription("When vRtrType has a value of 'vprn', the value of vRtrServiceId\n         indicates the service-id of the associated service that created\n         this row entry.")
vRtrCustId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 30), TmnxCustId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrCustId.setStatus('current')
if mibBuilder.loadTexts: vRtrCustId.setDescription("When vRtrType has a value of 'vprn', the value of vRtrCustId\n         indicates the customer-id of the associated service that created\n         this row entry.")
vRtrIgmpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 31), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIgmpStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrIgmpStatus.setDescription("The desired state for IGMP on this virtual router.  An attempt\n         to set vRtrIgmpStatus to 'delete' will fail if the IGMP\n         protocol is not in the administrative outOfService state,\n         i.e. TIMETRA-IGMP-MIB::vRtrIgmpGenAdminState must be set to\n         'outOfService'.")
vRtrMaxNumRoutesLogOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 32), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMaxNumRoutesLogOnly.setStatus('current')
if mibBuilder.loadTexts: vRtrMaxNumRoutesLogOnly.setDescription("The value of vRtrMaxNumRoutesLogOnly specifies the action to\n         be taken when the maximum number of routes that can be held\n         within a given VRF context is reached.  If the value is 'true'\n         the event is logged (a trap is sent) and the learning of\n         new routes is not disabled.  If the value is 'false' the event\n         is logged and the learning of new routes is disabled.")
vRtrVrfTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 33), TNamedItemOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrVrfTarget.setStatus('current')
if mibBuilder.loadTexts: vRtrVrfTarget.setDescription('The value of vRtrVrfTarget specifies the extended community\n         name for the default vrf-import or vrf-export policy to use for\n         the vRtrID if no entries are configured in the vRtrPolicyTable for\n         this vRtrID instance.\n\n         This object can not be set if either vRtrVrfExportTarget or\n         vRtrVrfImportTarget has been set.')
vRtrVrfExportTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 34), TNamedItemOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrVrfExportTarget.setStatus('current')
if mibBuilder.loadTexts: vRtrVrfExportTarget.setDescription('The value of vRtrVrfExportTarget specifies the extended community\n         name for the default vrf-export policy to use for the vRtrID if no\n         entries are configured in the vRtrPolicyTable for this vRtrID\n         instance.\n\n         This object can not be set if vRtrVrfTarget has been set.')
vRtrVrfImportTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 35), TNamedItemOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrVrfImportTarget.setStatus('current')
if mibBuilder.loadTexts: vRtrVrfImportTarget.setDescription('The value of vRtrVrfImportTarget specifies the extended community\n         name for the default vrf-import policy to use for the vRtrID if no\n         entries are configured in the vRtrPolicyTable for this vRtrID\n         instance.\n\n         This object can not be set if vRtrVrfTarget has been set.')
vRtrPimStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 36), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrPimStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrPimStatus.setDescription("The desired state for PIM on this virtual router. When the object\n         is set to 'create', PIM protocol instance is enabled on the\n         virtual router. Setting the value to 'delete' disables PIM on the\n         virtual router.")
vRtrMaxMcastNumRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMaxMcastNumRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrMaxMcastNumRoutes.setDescription('The maximum number of multicast routes that can be configured on\n         this virtual router.  If the value is -1, then there\n         is no limit.')
vRtrMaxMcastNumRoutesLogOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 38), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMaxMcastNumRoutesLogOnly.setStatus('current')
if mibBuilder.loadTexts: vRtrMaxMcastNumRoutesLogOnly.setDescription("The value of vRtrMaxMcastNumRoutesLogOnly specifies the action to\n         be taken when the maximum number of multicast routes that can be held\n         within a given VRF context is reached.  If the value is 'true'\n         the event is logged (a trap is sent) and the learning of\n         new multicast routes is not disabled.  If the value is 'false' the\n         event is logged and the learning of new routes is disabled.")
vRtrMcastMidRouteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 39), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMcastMidRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: vRtrMcastMidRouteThreshold.setDescription('The value of vRtrMcastMidRouteThreshold specifies the mid-level\n         water marker for the number of multicast routes which this VRF may\n         hold. When this limit is exceeded a tmnxVRtrMcastMidRouteTCA\n         notification is generated.\n\n         A value of 0 (zero) for this object indicates that the threshold\n         is infinite, and the notification will never be sent.')
vRtrIgnoreIcmpRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 40), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIgnoreIcmpRedirect.setStatus('current')
if mibBuilder.loadTexts: vRtrIgnoreIcmpRedirect.setDescription("If the value of vRtrIgnoreIcmpRedirect is 'true', the virtual\n         router will drop all ICMP Redirects received on the management\n         interface. If the value of vRtrIgnoreIcmpRedirect is 'false'\n         and an ICMP Redirect is received on the management interface,\n         a /32 route will be created in the route table.\n\n         If the value of vRtrName is not 'management', an SNMP set\n         request to vRtrIgnoreIcmpRedirect will fail with an\n         'inconsistentValue' error.")
vRtrOspfv3Status = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 41), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrOspfv3Status.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrOspfv3Status.setDescription("The desired state for OSPFv3 on this virtual router.  An attempt\n         to set vRtrOspfv3Status to 'delete' will fail if the OSPFv3\n         protocol is not in the administrative outOfService state,\n         i.e. TIMETRA-OSPF-NG-MIB::tmnxOspfAdminState must be set \n         to 'disabled'.\n\n         This object was obsoleted in release 5.0.")
vRtrMsdpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 42), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMsdpStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMsdpStatus.setDescription("The desired state for Msdp on this virtual router.  An attempt\n         to set vRtrMsdpStatus to 'delete' will fail if the Msdp\n         protocol is not in the administrative outOfService state,\n         i.e. TIMETRA-MSDP-MIB::tmnxMsdpAdminState must be \n         set to 'outOfService'.")
vRtrVprnType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("regular", 1), ("hub", 2), ("spoke", 3), ("subscriberSplitHorizon", 4))).clone('regular')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrVprnType.setStatus('current')
if mibBuilder.loadTexts: vRtrVprnType.setDescription("The value of vRtrVprnType specifies how traffic is routed.\n\n        regular (1)                - All traffic is routed to all\n                                     destinations.\n\n        hub (2)                    - Network traffic is routed only to\n                                     the access side. Access traffic is\n                                     routed to all destinations.\n\n        spoke (3)                  - Networks traffic is routed to all\n                                     destinations. Access traffic is\n                                     routed only to the network side.\n\n        subscriberSplitHorizon (4) - Subscriber-interface traffic is\n                                     routed only to the network side.\n                                     All other traffic is routed to\n                                     all destinations.\n\n        This object cannot be modified if vRtrType is not 'vprn'.")
vRtrSecondaryVrfId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 44), TmnxVRtrIDOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrSecondaryVrfId.setStatus('current')
if mibBuilder.loadTexts: vRtrSecondaryVrfId.setDescription('The unique value of vRtrSecondaryVrfId specifies the secondary vrf-id\n         for hub and spoke vprn.\n\n         Non-zero value of vRtrSecondaryVrfId indicates that two\n         route-tables exist for hub and spoke vprn system one each for hub and\n         spoke. One of which is indexed by vRtrSecondaryVrfId.\n\n         If the value of  vRtrSecondaryVrfId  is zero, it indicates that\n         there is only one route-table for hub and spoke vprn system.')
vRtrMldStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 45), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMldStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMldStatus.setDescription("The desired state for Multicast Listener Discovery (MLD) Protocol\n         on this virtual router.  An attempt to set vRtrMldStatus to 'delete' \n         will fail if the MLD protocol is not in the administrative \n         outOfService state, i.e. TIMETRA-MLD-MIB::vRtrMldGenAdminState \n         must be set to 'outOfService'.")
vRtrIPv6MaxNumRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIPv6MaxNumRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrIPv6MaxNumRoutes.setDescription("The maximum number of IPv6 routes that can be configured on\n         this virtual router.  If the value is -1, then there\n         is no limit.\n\n         This object is not supported on SR-1, where the value of\n         ALCATEL-IND1-TIMETRA-CHASSIS-MIB::tmnxChassisType is '5'.")
vRtrIPv6MidRouteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 47), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIPv6MidRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: vRtrIPv6MidRouteThreshold.setDescription('The value of vRtrIPv6MidRouteThreshold specifies the mid-level\n         water marker for the number of IPv6 routes which this VRF may hold.\n         When this limit is exceeded a tmnxVRtrIPv6MidRouteTCA\n         notification is generated.\n\n         A value of 0 (zero) for this object indicates that the threshold\n         is infinite, and the notification will never be sent.')
vRtrIPv6HighRouteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 48), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIPv6HighRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: vRtrIPv6HighRouteThreshold.setDescription('The value of vRtrIPv6HighRouteThreshold specifies the high-level\n         water marker for the number of IPv6 routes which this VRF may hold.\n         When this limit is exceeded a tmnxVRtrIPv6HighRouteTCA\n         notification is generated.\n\n         A value of 0 (zero) for this object indicates that the threshold\n         is infinite, and the notification will never be sent.')
vRtrIPv6MaxNumRoutesLogOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 49), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIPv6MaxNumRoutesLogOnly.setStatus('current')
if mibBuilder.loadTexts: vRtrIPv6MaxNumRoutesLogOnly.setDescription("The value of vRtrIPv6MaxNumRoutesLogOnly specifies the action to\n         be taken when the maximum number of IPv6 routes that can be held\n         within a given VRF context is reached.  If the value is 'true'\n         the event is logged (a trap is sent) and the learning of\n         new routes is not disabled.  If the value is 'false' the event\n         is logged and the learning of new routes is disabled.")
vRtrIPv6IgnoreIcmpRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 50), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIPv6IgnoreIcmpRedirect.setStatus('current')
if mibBuilder.loadTexts: vRtrIPv6IgnoreIcmpRedirect.setDescription("If the value of vRtrIPv6IgnoreIcmpRedirect is 'true', the virtual\n         router will drop all IPv6 ICMP Redirects received on the management\n         interface. If the value of vRtrIPv6IgnoreIcmpRedirect is 'false'\n         and an IPv6 ICMP Redirect is received on the management interface,\n         a /128 route will be created in the route table.\n\n         If the value of vRtrName is not 'management', an SNMP set\n         request to vRtrIPv6IgnoreIcmpRedirect will fail with an\n         'inconsistentValue' error.")
vRtrMcPathMgmtPlcyName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 1, 1, 51), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMcPathMgmtPlcyName.setStatus('current')
if mibBuilder.loadTexts: vRtrMcPathMgmtPlcyName.setDescription('The value of vRtrMcPathMgmtPlcyName specifies the multicast policy \n         name configured on this virtual router.')
vRtrPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16), )
if mibBuilder.loadTexts: vRtrPolicyTable.setStatus('current')
if mibBuilder.loadTexts: vRtrPolicyTable.setDescription('The vRtrPolicyTable has an entry for each virtual router configured\n         in the system.')
vRtrPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1), )
vRtrConfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrPolicyEntry"))
vRtrPolicyEntry.setIndexNames(*vRtrConfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrPolicyEntry.setDescription('Each row entry represents a collection of statistics for a\n         virtual router in the system.\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrImportPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 1), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrImportPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrImportPolicy1.setDescription("The value of vRtrImportPolicy1 is the name of the first\n         policy to be used for determining which routes are imported\n         into the VRF for this virtual router.  If no import policy\n         is defined, no routes are accepted into the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The import policy name list, vRtrImportPolicy1 through\n         vRtrImportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrImportPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 2), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrImportPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrImportPolicy2.setDescription("The value of vRtrImportPolicy2 is the name of the second\n         policy to be used for determining which routes are imported\n         into the VRF for this virtual router.  If no import policy\n         is defined, no routes are accepted into the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The import policy name list, vRtrImportPolicy1 through\n         vRtrImportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrImportPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 3), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrImportPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrImportPolicy3.setDescription("The value of vRtrImportPolicy3 is the name of the third\n         policy to be used for determining which routes are imported\n         into the VRF for this virtual router.  If no import policy\n         is defined, no routes are accepted into the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The import policy name list, vRtrImportPolicy1 through\n         vRtrImportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrImportPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 4), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrImportPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrImportPolicy4.setDescription("The value of vRtrImportPolicy4 is the name of the fourth\n         policy to be used for determining which routes are imported\n         into the VRF for this virtual router.  If no import policy\n         is defined, no routes are accepted into the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The import policy name list, vRtrImportPolicy1 through\n         vRtrImportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrImportPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 5), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrImportPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrImportPolicy5.setDescription("The value of vRtrImportPolicy5 is the name of the fifth\n         policy to be used for determining which routes are imported\n         into the VRF for this virtual router.  If no import policy\n         is defined, no routes are accepted into the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The import policy name list, vRtrImportPolicy1 through\n         vRtrImportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrExportPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 6), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrExportPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrExportPolicy1.setDescription("The value of vRtrExportPolicy1 is the name of the first\n         policy to be used for determining which routes are exported\n         from the VRF for this virtual router.  If no export policy\n         is defined, no routes are exported from the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The export policy name list, vRtrExportPolicy1 through\n         vRtrExportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrExportPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 7), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrExportPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrExportPolicy2.setDescription("The value of vRtrExportPolicy2 is the name of the second\n         policy to be used for determining which routes are exported\n         from the VRF for this virtual router.  If no export policy\n         is defined, no routes are exported from the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The export policy name list, vRtrExportPolicy1 through\n         vRtrExportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrExportPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 8), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrExportPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrExportPolicy3.setDescription("The value of vRtrExportPolicy3 is the name of the third\n         policy to be used for determining which routes are exported\n         from the VRF for this virtual router.  If no export policy\n         is defined, no routes are exported from the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The export policy name list, vRtrExportPolicy1 through\n         vRtrExportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrExportPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 9), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrExportPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrExportPolicy4.setDescription("The value of vRtrExportPolicy4 is the name of the fourth\n         policy to be used for determining which routes are exported\n         from the VRF for this virtual router.  If no export policy\n         is defined, no routes are exported from the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The export policy name list, vRtrExportPolicy1 through\n         vRtrExportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrExportPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 16, 1, 10), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrExportPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrExportPolicy5.setDescription("The value of vRtrExportPolicy4 is the name of the fifth\n         policy to be used for determining which routes are exported\n         from the VRF for this virtual router.  If no export policy\n         is defined, no routes are exported from the VRF.\n\n         If multiple policy names are specified, the policies are evaluated\n         in the order they are specified.  The first policy that matches\n         is applied.\n\n         The export policy name list, vRtrExportPolicy1 through\n         vRtrExportPolicy5, is handled by the SNMP agent as a single\n         entity.  When an SNMP SET request is received to modify one or\n         more of the policy names, all the policy variables are first\n         set to the empty string, ''H, and then the new names are set\n         into the specified policy variables within a single SNMP SET PDU.")
vRtrStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2), )
if mibBuilder.loadTexts: vRtrStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrStatTable.setDescription('The vRtrStatTable has an entry for each virtual router configured\n        in the system.')
vRtrStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1), )
vRtrConfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatEntry"))
vRtrStatEntry.setIndexNames(*vRtrConfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrStatEntry.setDescription('Each row entry represents a collection of statistics for a\n        virtual router in the system.\n\n        Entries cannot be created and deleted via SNMP SET operations.')
vRtrOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 1), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrOperState.setDescription('vRtrOperState indicates current operational status of this\n        virtual router.')
vRtrDirectRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDirectRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrDirectRoutes.setDescription('vRtrDirectRoutes indicates the current number of direct routes\n        for this instance of the route table.')
vRtrDirectActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDirectActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrDirectActiveRoutes.setDescription('vRtrDirectActiveRoutes indicates the current number of active direct\n        routes for this instance of the route table.')
vRtrStaticRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRoutes.setDescription('vRtrStaticRoutes indicates the current number of static routes for\n        this instance of the route table.')
vRtrStaticActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticActiveRoutes.setDescription('vRtrStaticActiveRoutes indicates the current number of active static\n        routes for this instance of the route table.')
vRtrOSPFRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrOSPFRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrOSPFRoutes.setDescription('vRtrOSPFRoutes indicates the current number of ospf routes for this\n        instance of the route table.')
vRtrOSPFActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrOSPFActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrOSPFActiveRoutes.setDescription('vRtrOSPFActiveRoutes indicates the current number of active ospf\n        routes for this instance of the route table.')
vRtrBGPRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrBGPRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrBGPRoutes.setDescription('vRtrBGPRoutes indicates the current number of bgp routes for this\n        instance of the route table.')
vRtrBGPActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrBGPActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrBGPActiveRoutes.setDescription('vRtrBGPActiveRoutes indicates the current number of active bgp\n        routes for this instance of the route table.')
vRtrISISRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrISISRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrISISRoutes.setDescription('vRtrISISRoutes indicates the current number of isis routes for this\n        instance of the route table.')
vRtrISISActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrISISActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrISISActiveRoutes.setDescription('vRtrISISActiveRoutes indicates the current number of active\n        isis routes for this instance of the route table.')
vRtrRIPRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrRIPRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrRIPRoutes.setDescription('vRtrRIPRoutes indicates the current number of rip routes for this\n        instance of the route table.')
vRtrRIPActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrRIPActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrRIPActiveRoutes.setDescription('vRtrRIPActiveRoutes indicates the current number of active rip\n        routes for this instance of the route table.')
vRtrAggregateRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrAggregateRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregateRoutes.setDescription('vRtrAggregateRoutes indicates the current number of aggregate\n        routes for this instance of the route table.')
vRtrAggregateActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrAggregateActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregateActiveRoutes.setDescription('vRtrAggregateActiveRoutes indicates the current number of active\n        aggregate routes for this instance of the route table.')
vRtrStatConfiguredIfs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatConfiguredIfs.setStatus('current')
if mibBuilder.loadTexts: vRtrStatConfiguredIfs.setDescription('vRtrStatConfiguredIfs indicates the current number of router interfaces\n         configured on this virtual router.')
vRtrStatActiveIfs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatActiveIfs.setStatus('current')
if mibBuilder.loadTexts: vRtrStatActiveIfs.setDescription("vRtrStatActiveIfs indicates the current number of router interfaces\n         with vRtrIfAdminState equal 'inService' on this virtual router.")
vRtrStatIllegalLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatIllegalLabels.setStatus('current')
if mibBuilder.loadTexts: vRtrStatIllegalLabels.setDescription('vRtrStatIllegalLabels indicates the number of illegally received\n         labels on this virtual router.')
vRtrStatCurrNumRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatCurrNumRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrStatCurrNumRoutes.setDescription('vRtrStatCurrNumRoutes indicates the current number of routes\n         in the VRF for this virtual router.')
vRtrStatBGPVpnRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatBGPVpnRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrStatBGPVpnRoutes.setDescription('vRtrStatBGPVpnRoutes indicates the current number of VPN-IPV4 routes\n         learned by MP-BGP for this virtual router.')
vRtrStatBGPVpnActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatBGPVpnActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrStatBGPVpnActiveRoutes.setDescription('vRtrStatBGPVpnActiveRoutes indicates the current number of active\n         VPN-IPV4 routes learned by MP-BGP for this virtual router.')
vRtrStatTotalLdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatTotalLdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrStatTotalLdpTunnels.setDescription('vRtrStatTotalLdpTunnels indicates the current number of both active\n         and inactive LDP tunnels.')
vRtrStatTotalSdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatTotalSdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrStatTotalSdpTunnels.setDescription('vRtrStatTotalSdpTunnels indicates the current number of both active\n         and inactive SDP tunnels.')
vRtrStatActiveLdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatActiveLdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrStatActiveLdpTunnels.setDescription("vRtrStatActiveLdpTunnels indicates the current number of rows in\n         the vRtrTunnelTable where vRtrTunnelType has a value of 'ldp'.")
vRtrStatActiveSdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatActiveSdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrStatActiveSdpTunnels.setDescription("vRtrStatActiveSdpTunnels indicates the current number of rows in\n         the vRtrTunnelTable where vRtrTunnelType has a value of 'sdp'.")
vRtrMulticastRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMulticastRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrMulticastRoutes.setDescription('vRtrMulticastRoutes indicates the current number of rows in\n         the vRtrPimGrpSrcTable.')
vRtrStatActiveARPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatActiveARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrStatActiveARPEntries.setDescription('vRtrStatActiveARPEntries indicates the number of active\n         ARP entries for the specified virtual router in the system.')
vRtrStatTotalARPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatTotalARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrStatTotalARPEntries.setDescription('vRtrStatTotalARPEntries indicates the total number of active\n         and inactive ARP entries for the specified virtual router in\n         the system.')
vRtrV6DirectRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6DirectRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6DirectRoutes.setDescription('vRtrV6DirectRoutes indicates the current number of v6 direct\n         routes for this instance of the route table.')
vRtrV6DirectActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6DirectActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6DirectActiveRoutes.setDescription('vRtrV6DirectActiveRoutes indicates the current number of\n        v6 active direct routes for this instance of the route table.')
vRtrV6StaticRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StaticRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StaticRoutes.setDescription('vRtrV6StaticRoutes indicates the current number of v6 static\n         routes for this instance of the route table.')
vRtrV6StaticActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StaticActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StaticActiveRoutes.setDescription('vRtrV6StaticActiveRoutes indicates the current number of v6\n        active static routes for this instance of the route table.')
vRtrV6OSPFRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6OSPFRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6OSPFRoutes.setDescription('vRtrV6OSPFRoutes indicates the current number of v6 ospf\n        routes for this instance of the route table.')
vRtrV6OSPFActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6OSPFActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6OSPFActiveRoutes.setDescription('vRtrV6OSPFActiveRoutes indicates the current number of\n        v6 active ospf routes for this instance of the route table.')
vRtrV6BGPRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6BGPRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6BGPRoutes.setDescription('vRtrV6BGPRoutes indicates the current number of v6 bgp\n        routes for this instance of the route table.')
vRtrV6BGPActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6BGPActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6BGPActiveRoutes.setDescription('vRtrV6BGPActiveRoutes indicates the current number of\n        v6 active bgp routes for this instance of the route table.')
vRtrV6ISISRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6ISISRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6ISISRoutes.setDescription('vRtrV6ISISRoutes indicates the current number of v6\n         isis routes for this instance of the route table.')
vRtrV6ISISActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6ISISActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6ISISActiveRoutes.setDescription('vRtrV6ISISActiveRoutes indicates the current number\n        of v6 active isis routes for this instance of the route table.')
vRtrV6RIPRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 39), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6RIPRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6RIPRoutes.setDescription('vRtrV6RIPRoutes indicates the current number of v6 rip routes\n        for this instance of the route table.')
vRtrV6RIPActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 40), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6RIPActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6RIPActiveRoutes.setDescription('vRtrV6RIPActiveRoutes indicates the current number of active\n        v6 rip routes for this instance of the route table.')
vRtrV6AggregateRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 41), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6AggregateRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6AggregateRoutes.setDescription('vRtrV6AggregateRoutes indicates the current number of\n        v6 aggregate routes for this instance of the route table.')
vRtrV6AggregateActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 42), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6AggregateActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6AggregateActiveRoutes.setDescription('vRtrV6AggregateActiveRoutes indicates the current number of\n        active v6 aggregate routes for this instance of the route table.')
vRtrV6StatConfiguredIfs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 43), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatConfiguredIfs.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatConfiguredIfs.setDescription('vRtrV6StatConfiguredIfs indicates the current number of\n         v6 router interfaces configured on this virtual router.')
vRtrV6StatActiveIfs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 44), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatActiveIfs.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatActiveIfs.setDescription("vRtrV6StatActiveIfs indicates the current number of\n         v6 router interfaces with vRtrIfAdminState equal\n         'inService' on this virtual router.")
vRtrV6StatIllegalLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatIllegalLabels.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatIllegalLabels.setDescription('vRtrV6StatIllegalLabels indicates the number of illegally\n         received v6 labels on this virtual router.')
vRtrV6StatCurrNumRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 46), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatCurrNumRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatCurrNumRoutes.setDescription('vRtrV6StatCurrNumRoutes indicates the current number of v6 routes\n         in the VRF for this virtual router.')
vRtrV6StatBGPVpnRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 47), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatBGPVpnRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatBGPVpnRoutes.setDescription('vRtrV6StatBGPVpnRoutes indicates the current number of VPN-IPV6 routes\n         learned by MP-BGP for this virtual router.')
vRtrV6StatBGPVpnActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 48), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatBGPVpnActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatBGPVpnActiveRoutes.setDescription('vRtrV6StatBGPVpnActiveRoutes indicates the current number of active\n         VPN-IPV6 routes learned by MP-BGP for this virtual router.')
vRtrV6StatTotalLdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 49), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatTotalLdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatTotalLdpTunnels.setDescription('vRtrV6StatTotalLdpTunnels indicates the current number of both active\n         and inactive v6 LDP tunnels.')
vRtrV6StatTotalSdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 50), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatTotalSdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatTotalSdpTunnels.setDescription('vRtrV6StatTotalSdpTunnels indicates the current number of both active\n         and inactive v6 SDP tunnels.')
vRtrV6StatActiveLdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 51), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatActiveLdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatActiveLdpTunnels.setDescription("vRtrV6StatActiveLdpTunnels indicates the current number of v6 rows in\n         the vRtrTunnelTable where vRtrTunnelType has a value of 'ldp'.")
vRtrV6StatActiveSdpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 52), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatActiveSdpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatActiveSdpTunnels.setDescription("vRtrV6StatActiveSdpTunnels indicates the current number of v6 rows in\n         the vRtrTunnelTable where vRtrTunnelType has a value of 'sdp'.")
vRtrV6MulticastRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 53), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6MulticastRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6MulticastRoutes.setDescription('vRtrV6MulticastRoutes indicates the current number of v6 rows in\n         the vRtrPimGrpSrcTable.')
vRtrV6StatActiveNbrEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatActiveNbrEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatActiveNbrEntries.setDescription('vRtrV6StatActiveNbrEntries indicates the number of active V6 neighbor\n         discovery entries for the specified virtual router in the system.')
vRtrV6StatTotalNbrEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 55), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatTotalNbrEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatTotalNbrEntries.setDescription('vRtrV6StatTotalNbrEntries indicates the total number of active\n         and inactive v6 neighbor discovery entries for the specified\n          virtual router in the system.')
vRtrSubMgmtRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 56), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrSubMgmtRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrSubMgmtRoutes.setDescription('The value of vRtrSubMgmtRoutes  indicates the total number of\n         subscriber management routes in the route Table.')
vRtrSubMgmtActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 57), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrSubMgmtActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrSubMgmtActiveRoutes.setDescription('The value of vRtrSubMgmtActiveRoutes indicates the number of\n         active subscriber management routes.')
vRtrStatTotalRsvpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 58), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatTotalRsvpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrStatTotalRsvpTunnels.setDescription('The value of vRtrStatTotalRsvpTunnels indicates the current \n         number of both active and inactive RSVP tunnels.')
vRtrStatActiveRsvpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 59), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatActiveRsvpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrStatActiveRsvpTunnels.setDescription("The value of vRtrStatActiveRsvpTunnels indicates the current \n         number of rows in the vRtrTunnelTable where vRtrTunnelType has a \n         value of 'rsvp'.")
vRtrV6StatTotalRsvpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 60), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatTotalRsvpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatTotalRsvpTunnels.setDescription('The value of vRtrV6StatTotalRsvpTunnels indicates the current \n         number of both active and inactive IPv6 RSVP tunnels.')
vRtrV6StatActiveRsvpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 61), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6StatActiveRsvpTunnels.setStatus('current')
if mibBuilder.loadTexts: vRtrV6StatActiveRsvpTunnels.setDescription("The value of vRtrV6StatActiveRsvpTunnels indicates the current \n         number of IPv6 rows in the vRtrTunnelTable where vRtrTunnelType \n         has a value of 'rsvp'.")
vRtrHostRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 62), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrHostRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrHostRoutes.setDescription('The value of vRtrHostRoutes indicates the current number of\n         direct routes with prefix value 32 for this instance of the \n         route table.')
vRtrHostActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 63), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrHostActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrHostActiveRoutes.setDescription('The value of vRtrHostActiveRoutes indicates the current number of \n         active direct routes with prefix value 32 for this instance of the \n         route table.')
vRtrV6HostRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 64), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6HostRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6HostRoutes.setDescription('The value of vRtrV6HostRoutes indicates the current number of v6 \n         direct routes with prefix value 128 for this instance of the \n         route table.')
vRtrV6HostActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 65), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrV6HostActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrV6HostActiveRoutes.setDescription('The value of vRtrV6HostActiveRoutes indicates the current number of\n         v6 active direct routes with prefix value 128 for this instance \n         of the route table.')
vRtrStatLocalARPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 66), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatLocalARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrStatLocalARPEntries.setDescription('The value of vRtrStatLocalARPEntries indicates the total number of\n         active and inactive local ARP entries for the specified virtual\n         router in the system.')
vRtrStatStaticARPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 67), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatStaticARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrStatStaticARPEntries.setDescription('The value of vRtrStatStaticARPEntries indicates the total number of\n         active and inactive static ARP entries for the specified virtual\n         router in the system.')
vRtrStatDynamicARPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 68), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatDynamicARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrStatDynamicARPEntries.setDescription('The value of vRtrStatDynamicARPEntries indicates the total number of\n         active and inactive dynamic ARP entries for the specified virtual\n         router in the system.')
vRtrStatManagedARPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 69), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatManagedARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrStatManagedARPEntries.setDescription('The value of vRtrStatManagedARPEntries indicates the total number of\n         active and inactive managed ARP entries for the specified virtual\n         router in the system.')
vRtrStatInternalARPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 70), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStatInternalARPEntries.setStatus('current')
if mibBuilder.loadTexts: vRtrStatInternalARPEntries.setDescription('The value of vRtrStatInternalARPEntries indicates the total number of\n         active and inactive internal ARP entries for the specified virtual\n         router in the system.')
vRtrManagedRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 71), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrManagedRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrManagedRoutes.setDescription('The value of vRtrManagedRoutes indicates the total number of\n         active and inactive managed routes for the specified virtual\n         router in the system.')
vRtrManagedActiveRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 2, 1, 72), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrManagedActiveRoutes.setStatus('current')
if mibBuilder.loadTexts: vRtrManagedActiveRoutes.setDescription('The value of vRtrManagedActiveRoutes indicates the total number of\n         active managed routes for the specified virtual\n         router in the system.')
vRtrIfTotalNumber = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfTotalNumber.setStatus('current')
if mibBuilder.loadTexts: vRtrIfTotalNumber.setDescription('The number of router interfaces configured in this system.')
vRtrIfTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4), )
if mibBuilder.loadTexts: vRtrIfTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfTable.setDescription('The vRtrIfTable has an entry for each router interface configured in\n         the system.')
vRtrIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"))
if mibBuilder.loadTexts: vRtrIfEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfEntry.setDescription('Each row entry represents a virtual router interface in the system.\n         Entries can be created and deleted via SNMP SET operations using the\n         vRtrIfRowStatus variable.')
vRtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 1), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIndex.setDescription('The unique value which identifies this interface of this virtual\n         router in the Tmnx system. This field provides an identifier for\n         virtual router interfaces similar to the ifIndex values used in the\n         mib-2 interfaces table for physical interfaces. The vRtrIfIndex values\n         can be reused for different virtual routers, but are unique within\n         those entries with the same vRtrID.\n\n         The vRtrIfIndex value for each virtual interface must remain constant\n         at least from one re-initialization of the system management processor\n         to the next.')
vRtrIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrIfRowStatus.setDescription("The row status.  The creation or deletion of a router interface entry\n         causes creation or deletion of corresponding entries in other Tmnx MIB\n         tables with the same vRtrID and vRtrIfIndex values, such as the\n         vRtrIpAddrTable.  The router interface is associated to a physical port\n         interface through the vRtrIfPortID and vRtrIfEncapValue variables. The\n         RowStatus cannot be SET to 'active' unless vRtrIfName has been\n         initialized.")
vRtrIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("network", 1), ("service", 2), ("serviceIes", 3), ("serviceRtdVpls", 4), ("serviceVprn", 5), ("serviceIesSubscriber", 6), ("serviceIesGroup", 7), ("serviceVprnSubscriber", 8), ("serviceVprnGroup", 9), ("serviceIesRedundant", 10), ("serviceVprnRedundant", 11), ("serviceVpls", 12), ("serviceIesCem", 13), ("serviceVprnCem", 14), ("serviceVprnIPsec", 15), ("serviceVprnIPMirror", 16)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfType.setDescription('The value of vRtrIfType specifies the type of this interface. Different\n         virtual router interface types are defined as follows:\n\n         network               - defined on a network port.\n         service               - used internally.\n         serviceIes            - defined on a SAP or Spoke SDP.\n         serviceRtdVpls        - obsoleted.\n         serviceVprn           - defined on a SAP or Spoke SDP.\n         serviceIesSubscriber  - used internally.\n         serviceIesGroup       - defined on a SAP\n         serviceVprnSubscriber - used internally.\n         serviceVprnGroup      - defined on a SAP.\n         serviceIesRedundant   - defined on a Spoke SDP.\n         serviceVprnRedundant  - defined on a Spoke SDP.\n         serviceVpls           - defined on an IP endpoint for VPLS. \n         serviceIesCem         - defined on a SAP. --not supported\n         serviceVprnCem        - defined on a SAP. --not supported\n         serviceVprnIPsec      - defined on a SAP.\n         serviceVprnIPMirror   - defined on a Mirror.')
vRtrIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 4), TNamedItem()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfName.setStatus('current')
if mibBuilder.loadTexts: vRtrIfName.setDescription('The administrative name assigned this router interface. The interface\n         name must be unique among entries with the same vRtrID value.\n         In order for row creation to succeed, a value must also be assigned\n         to vRtrIfName.')
vRtrIfPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 5), TmnxPortID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfPortID.setStatus('current')
if mibBuilder.loadTexts: vRtrIfPortID.setDescription("The physical port to which this interface is bound. If vRtrIfPortID is\n         zero (0), then there is no binding between this virtual router\n         interface and a physical port. Once an interface has been bound to a\n         port, several steps are required to change the binding to some other\n         TmnxPortID value.\n         vRtrIfAdminState must be 'outOfService'; vRtrIfPortID must be set to\n         zero (0) to disassociate the interface from the original port binding;\n         finally, set vRtrIfPortID to the value for the new port binding.\n\n         Setting vRtrIfPortID to 0x20000001 indicates that this interface is the\n         system interface for the device.")
vRtrIfChannelID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfChannelID.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfChannelID.setDescription('When the physical port, vRtrIfPortID, is a SONET port, vRtrIfChannelID\n         is the STSx channel number used by this interface. If vRtrIfPortID is\n         not a SONET port or the interface has not yet been bound to a physical\n         port, vRtrIfChannelID will be zero (0).\n\n         This object was obsoleted in release 5.0.')
vRtrIfEncapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 7), TmnxEncapVal()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfEncapValue.setStatus('current')
if mibBuilder.loadTexts: vRtrIfEncapValue.setDescription('The value of the label used along with vRtrIfPortID to identify a SAP\n         on the specified access port.')
vRtrIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 8), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfAdminState.setDescription('The desired administrative state for this router interface.')
vRtrIfOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 9), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfOperState.setDescription('The current operational status of this router interface.')
vRtrIfAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfAlias.setStatus('current')
if mibBuilder.loadTexts: vRtrIfAlias.setDescription('An alternative administrative name assigned this router interface.')
vRtrIfPhysicalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 11), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfPhysicalAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrIfPhysicalAddress.setDescription("The interface's address at its protocol sub-layer. For example, for an\n         802.x interface, this object normally contains a MAC address. The\n         interface's media-specific MIB must define the bit and byte ordering\n         and the format of the value of this object. For interfaces which do\n         not have such an address (e.g., a serial line), this object should\n         contain an octet string of zero length.")
vRtrIfArpTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(14400)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfArpTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrIfArpTimeout.setDescription("The value of vRtrIfArpTimeout determines how long an ARP entry\n         associated with this interface remains in the ARP cache. When\n         vRtrIfArpTimeout has a value of zero, '0', the entry will never be\n         cleared from the cache.")
vRtrIfIcmpMaskReply = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpMaskReply.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpMaskReply.setDescription("When vRtrIfIcmpMaskReply is set to 'true', a reply will be\n         issued when this node is requested for the network mask for this\n         subnet.  The requesting node must be attached to the local\n         network.  When vRtrIfIcmpMaskReply is set to 'false', no reply\n         is  issued if an ICMP mask request is received.")
vRtrIfIcmpRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 14), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpRedirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpRedirects.setDescription("When vRtrIfIcmpRedirects is set to 'true', ICMP redirects are\n         generated when routes are not optimal on this router and another\n         router on the same subnetwork has a better route in order to\n         alert that node that a better route is available.  When\n         vRtrIfIcmpRedirects is set to 'false', ICMP redirects are not\n         generated.")
vRtrIfIcmpNumRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpNumRedirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpNumRedirects.setDescription('The value of vRtrIfIcmpNumRedirects limits the number of redirects\n         issued per the time frame specified in vRtrIfIcmpRedirectsTime.')
vRtrIfIcmpRedirectsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpRedirectsTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpRedirectsTime.setDescription('The value of vRtrIfIcmpRedirectsTime determines the time frame\n         in seconds that is used to limit the number of redirects issued\n         per time frame.')
vRtrIfIcmpUnreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 17), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpUnreachables.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpUnreachables.setDescription("When vRtrIfIcmpUnreachables is set to 'true', ICMP host and\n         network unreachable messages are generated by this interface.\n         When vRtrIfIcmpUnreachables is set to 'false', ICMP host and\n         network unreachable messages are not sent.")
vRtrIfIcmpNumUnreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpNumUnreachables.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpNumUnreachables.setDescription('The value of vRtrIfIcmpNumUnreachables determines how many\n         destination unreachable messages are issued in the time frame\n         specified by vRtrIfIcmpUnreachablesTime.')
vRtrIfIcmpUnreachablesTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpUnreachablesTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpUnreachablesTime.setDescription('The value of vRtrIfIcmpUnreachablesTime sets the time frame in\n         seconds that is used to limit the number of destination\n         unreachable messages issued per time frame.')
vRtrIfIcmpTtlExpired = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 20), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpTtlExpired.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpTtlExpired.setDescription("When vRtrIfIcmpTtlExpired is set to 'true', the rate that\n         ttl-expired messages by this interface is throttled based on\n         the values of vRtrIfIcmpNumTtlExpired and vRtrIfIcmpTtlExpiredTime.\n         When vRtrIfIcmpTtlExpired is set to 'false', unlimited ttl-expired\n         messages are sent.")
vRtrIfIcmpNumTtlExpired = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpNumTtlExpired.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpNumTtlExpired.setDescription('The value of vRtrIfIcmpNumTtlExpired defines how many ttl-expired\n         messages will be issued in the time frame specified by\n         vRtrIfIcmpTtlExpiredTime.')
vRtrIfIcmpTtlExpiredTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpTtlExpiredTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpTtlExpiredTime.setDescription('The value of vRtrIfIcmpTtlExpiredTime sets the time frame in\n         seconds that is used to limit the number of ttl-expired messages\n         issued by this interface with the specified time frame.')
vRtrIfNtpBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfNtpBroadcast.setStatus('current')
if mibBuilder.loadTexts: vRtrIfNtpBroadcast.setDescription("When vRtrIfNtpBroadcast is set to 'true', the NTP broadcasts\n         will be transmitted on this interface.")
vRtrIfUnnumbered = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 24), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfUnnumbered.setStatus('current')
if mibBuilder.loadTexts: vRtrIfUnnumbered.setDescription("The IP address to be used when generating packets on this interface.\n         This variable is complemented by vRtrIfUnnumbered. If\n         vRtrIfUnnumberedIf is a null-string and vRtrIfUnnumbered\n         is '0.0.0.0' it implies that no unnumbered interface is configured.\n         At any instant only one of the two members can be non-null.\n\n         A value of '255.255.255.255' implies the use of system-ip. It is\n         strongly suggested to use the node's system IP address as it is not\n         associated with a particular physical interface and is therefore always\n         reachable.")
vRtrIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 25), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 9000), ))).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfMtu.setStatus('current')
if mibBuilder.loadTexts: vRtrIfMtu.setDescription('The value of vRtrIfMtu is used to reflect the MTU size of this\n         interface in the header of an ICMP MTU exceeded message when\n         a packet is too large to be transmitted on this interface.\n         The default size is calculated by subtracting the DLC header\n         size from the physical MTU size of the interface.\n\n         When a SNMP SET request is received with a value of zero (0), the\n         agent actually sets vRtrIfMtu to the calculated default size.')
vRtrIfQosPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 26), TNetworkPolicyID().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfQosPolicyId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfQosPolicyId.setDescription('The value of vRtrIfQosPolicyId associates a pre-existing\n         network-policy-id to a network interface. Packets are marked\n         using qos policies on edge switches; invoking a qos policy on\n         a network port allows for the packets that match the policy\n         criteria to be remarked.\n\n         If this entry indicates a service virtual router interface or\n         the special out-of-band management interface, this object is\n         meaningless and is not applied to the interface.')
vRtrIfIngressFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 27), TIPFilterID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIngressFilterId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIngressFilterId.setDescription('The value of vRtrIfIngressFilterId associates an ip-filter-id\n         with an ingress interface. Filters control the forwarding and\n         dropping of packets based on IP criteria.  A value of zero (0)\n         indicates that there is no ip-filter-id associated with this\n         interface.\n\n         If this entry indicates a service virtual router interface or\n         the special out-of-band management interface, this object is\n         meaningless and is not applied to the interface.')
vRtrIfEgressFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 28), TIPFilterID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfEgressFilterId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfEgressFilterId.setDescription('The value of vRtrIfEgressFilterId associates an ip-filter-id\n         with an egress interface. Filters control the forwarding and\n         dropping of packets based on IP criteria.  A value of zero (0)\n         indicates that there is no ip-filter-id associated with this\n         interface.\n\n         If this entry indicates a service virtual router interface or\n         the special out-of-band management interface, this object is\n         meaningless and is not applied to the interface.')
vRtrIfDirectedBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 29), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDirectedBroadcast.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDirectedBroadcast.setDescription("When vRtrIfDirectedBroadcast is set to 'true', allows broadcasts\n         directed to this interface to be accepted.  When 'false',\n         directed broadcasts are dropped.  This is of particular use\n         when preventing denial of service attacks.")
vRtrIfMplsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 30), TmnxStatus().clone('delete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfMplsStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrIfMplsStatus.setDescription("Setting this variable to 'create' causes this interface to be\n         used with MPLS.  It also causes a row to be created in the\n         vRtrMplsIfTable.  Setting it to 'delete' removes the interface\n         from MPLS and causes the corresponding row in the vRtrMplsIfTable\n         to be removed.  However, an attempt to set vRtrIfMplsStatus to\n         'delete' will fail if MPLS activity on this interface is not\n         administratively in the outOfService state, i.e. vRtrMplsIfAdminState\n         of the vRtrMplsIfTable must be set to 'outOfService'.")
vRtrIfUnnumberedIf = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfUnnumberedIf.setStatus('current')
if mibBuilder.loadTexts: vRtrIfUnnumberedIf.setDescription("The name of the interface to which this unnumbered interface will\n         refer to. This variable is complemented by vRtrIfUnnumbered. If\n         vRtrIfUnnumberedIf is a null-string and vRtrIfUnnumbered is '0' it\n         implies that no unnumbered interface is configured. At any instant\n         only one of the two members can be non-null.")
vRtrIfCflowd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("acl", 2), ("interface", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfCflowd.setStatus('current')
if mibBuilder.loadTexts: vRtrIfCflowd.setDescription('The value of vRtrIfCflowd specifies the type of Cflowd analysis\n         applied to this interface. A Cflowd profile controls the sampling\n         and analysis of data flows through the router.  A value of none (1)\n         indicates that there is no Cflowd analysis associated with this\n         interface.')
vRtrIfVPNClass = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("carrierOfCarrier", 1), ("enterprise", 2), ("interProvider", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfVPNClass.setStatus('current')
if mibBuilder.loadTexts: vRtrIfVPNClass.setDescription('The value of vRtrIfVPNClass specifies the type of VPN scenario\n         supported on this virtual router interface.')
vRtrIfDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 34), TItemLongDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDescription.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDescription.setDescription('The value of vRtrIfDescription is a user provided description\n         string for this virtual router interface.  It can consist of\n         any printable, seven-bit ASCII characters up to 80 characters in\n         length.')
vRtrIfProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 35), Bits().clone(namedValues=NamedValues(("ospfv2", 0), ("rip", 1), ("isis", 2), ("bgp", 3), ("mpls", 4), ("rsvp", 5), ("ldp", 6), ("igmp", 7), ("pim", 8), ("ospf3", 9), ("mld", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfProtocol.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProtocol.setDescription('The value of vRtrIfProtocol indicates which protocols are running\n         on this virtual router interface. If the bit corresponding to a\n         protocol is set, then the protocol is enabled on this interface.')
vRtrIfTosMarkingTrusted = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 36), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfTosMarkingTrusted.setStatus('current')
if mibBuilder.loadTexts: vRtrIfTosMarkingTrusted.setDescription("The value of vRtrIfTosMarkingTrusted specifies whether the TOS\n         bits on the packets ingressing on the interface should be\n         trusted by the system or not. If the value is set to 'true', the\n         TOS bits should be trusted.\n\n         If the system does not trust these packets, it will remark the\n         packets upon egress as indicated by the value of the egress\n         remark flag, ALCATEL-IND1-TIMETRA-QOS-MIB:: tNetworkPolicyEgressRemark.\n         The egress remark flag is part of the QoS policy applied to the\n         network interface.\n\n         The interfaces belonging to the IES service have the egress\n         remark flag set to not trusted, 'false', by default. For all other\n         interface types, the TOS bits are trusted by default.")
vRtrIfServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 37), TmnxServId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfServiceId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfServiceId.setDescription('The value of vRtrIfServiceId specifies the service id for this\n          interface. This object must always be set at row creation when\n          the vRtrIfType is not network(1). This object cannot be modified\n          once the row is created.')
vRtrIfArpPopulate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfArpPopulate.setStatus('current')
if mibBuilder.loadTexts: vRtrIfArpPopulate.setDescription('The value of the object vRtrIfArpPopulate specifies the ARP\n         populate action.\n         The value disabled means that the normal ARP protocol is active.\n         The value enabled means that the system will not originate ARP\n         requests on this interface. The ARP cache is only populated with MAC\n         addresses learned via the DHCP protocol.\n         If the value of vRtrIfType is network, this object can only be set\n         to disabled.')
vRtrIfIPv6ConfigAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 39), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIPv6ConfigAllowed.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIPv6ConfigAllowed.setDescription("The value of vRtrIfIPv6ConfigAllowed specifies whether IPv6 can be\n         configured on this router interface. When the value is 'true', IPv6\n         can be configured on this interface. When it is 'false', IPv6\n         cannot be configured.")
vRtrIfIPv6OperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 40), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIPv6OperState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIPv6OperState.setDescription('The current operational status for IPv6 on this router interface.')
vRtrIfIPv6IngressFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 41), TIPFilterID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIPv6IngressFilterId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIPv6IngressFilterId.setDescription('The value of vRtrIfIPv6IngressFilterId associates an ip-filter-id\n         with an ingress v6 interface. Filters control the forwarding and\n         dropping of packets based on IP criteria.  A value of zero (0)\n         indicates that there is no ip-filter-id associated with this\n         interface.\n\n         If this entry indicates a service virtual router interface or\n         the special out-of-band management interface, this object is\n         meaningless and is not applied to the interface.')
vRtrIfIPv6EgressFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 42), TIPFilterID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIPv6EgressFilterId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIPv6EgressFilterId.setDescription('The value of vRtrIfIPv6EgressFilterId associates an ip-filter-id\n         with an egress v6 interface. Filters control the forwarding and\n         dropping of packets based on IP criteria.  A value of zero (0)\n         indicates that there is no ip-filter-id associated with this\n         interface.\n\n         If this entry indicates a service virtual router interface or\n         the special out-of-band management interface, this object is\n         meaningless and is not applied to the interface.')
vRtrIfIcmpV6Redirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 43), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6Redirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6Redirects.setDescription("When vRtrIfIcmpV6Redirects is set to 'true', ICMPv6 redirects are\n         generated when routes are not optimal on this router and another\n         router on the same subnetwork has a better route in order to\n         alert that node that a better route is available.  When\n         vRtrIfIcmpV6Redirects is set to 'false', ICMPv6 redirects are not\n         generated.")
vRtrIfIcmpV6NumRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 44), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6NumRedirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6NumRedirects.setDescription('The value of vRtrIfIcmpV6NumRedirects limits the number of v6 redirects\n         issued per the time frame specified in vRtrIfIcmpV6RedirectsTime.')
vRtrIfIcmpV6RedirectsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 45), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6RedirectsTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6RedirectsTime.setDescription('The value of vRtrIfIcmpV6RedirectsTime determines the time frame\n         in seconds that is used to limit the number of v6 redirects issued\n         per time frame.')
vRtrIfIcmpV6Unreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 46), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6Unreachables.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6Unreachables.setDescription("When vRtrIfIcmpV6Unreachables is set to 'true', ICMPv6 host and\n         network unreachable messages are generated by this interface.\n         When vRtrIfIcmpV6Unreachables is set to 'false', ICMPv6 host and\n         network unreachable messages are not sent.")
vRtrIfIcmpV6NumUnreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 47), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6NumUnreachables.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6NumUnreachables.setDescription('The value of vRtrIfIcmpV6NumUnreachables determines how many\n         destination unreachable ICMPv6 messages are issued in the time\n         frame specified by vRtrIfIcmpV6UnreachablesTime.')
vRtrIfIcmpV6UnreachablesTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 48), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6UnreachablesTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6UnreachablesTime.setDescription('The value of vRtrIfIcmpV6UnreachablesTime sets the time frame in\n         seconds that is used to limit the number of destination\n         unreachable ICMPv6 messages issued per time frame.')
vRtrIfIcmpV6TimeExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 49), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6TimeExceeded.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6TimeExceeded.setDescription("The value of vRtrIfIcmpV6TimeExceeded specifies whether\n         time-exceeded ICMP messages should be sent. When it is set to\n         'true', ICMPv6 time-exceeded messages are generated by this\n         interface. When vRtrIfIcmpV6TimeExceeded is set to 'false',\n         ICMPv6 time-exceeded messages are not sent.")
vRtrIfIcmpV6NumTimeExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6NumTimeExceeded.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6NumTimeExceeded.setDescription('The value of vRtrIfIcmpV6NumTimeExceeded specifies how many\n         time-exceeded ICMPv6 messages are issued in the time\n         frame specified by vRtrIfIcmpV6TimeExceededTime.')
vRtrIfIcmpV6TimeExceededTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 51), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6TimeExceededTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6TimeExceededTime.setDescription('The value of vRtrIfIcmpV6TimeExceededTime specifies the time frame\n         in seconds that is used to limit the number of time-exceeded\n         ICMPv6 messages issued per time frame.')
vRtrIfIcmpV6PktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 52), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6PktTooBig.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6PktTooBig.setDescription("The value of vRtrIfIcmpV6PktTooBig specifies whether\n         packet-too-big ICMP messages should be sent. When it is set to\n         'true', ICMPv6 packet-too-big messages are generated by this\n         interface. When vRtrIfIcmpV6PktTooBig is set to 'false',\n         ICMPv6 packet-too-big messages are not sent.")
vRtrIfIcmpV6NumPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 53), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6NumPktTooBig.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6NumPktTooBig.setDescription('The value of vRtrIfIcmpV6NumPktTooBig specifies how many\n         packet-too-big ICMPv6 messages are issued in the time\n         frame specified by vRtrIfIcmpV6PktTooBigTime.')
vRtrIfIcmpV6PktTooBigTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 54), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6PktTooBigTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6PktTooBigTime.setDescription('The value of vRtrIfIcmpV6PktTooBigTime specifies the time frame\n         in seconds that is used to limit the number of packet-too-big\n         ICMPv6 messages issued per time frame.')
vRtrIfIcmpV6ParamProblem = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 55), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6ParamProblem.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6ParamProblem.setDescription("The value of vRtrIfIcmpV6ParamProblem specifies whether\n         parameter-problem ICMP messages should be sent. When it is set to\n         'true', ICMPv6 parameter-problem messages are generated by this\n         interface. When vRtrIfIcmpV6ParamProblem is set to 'false',\n         ICMPv6 parameter-problem messages are not sent.")
vRtrIfIcmpV6NumParamProblem = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 56), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6NumParamProblem.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6NumParamProblem.setDescription('The value of vRtrIfIcmpV6NumParamProblem specifies how many\n         parameter-problem ICMPv6 messages are issued in the time\n         frame specified by vRtrIfIcmpV6ParamProblemTime.')
vRtrIfIcmpV6ParamProblemTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 57), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIcmpV6ParamProblemTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmpV6ParamProblemTime.setDescription('The value of vRtrIfIcmpV6ParamProblemTime specifies the time frame\n         in seconds that is used to limit the number of parameter-problem\n         ICMPv6 messages issued per time frame.')
vRtrIfLinkLocalAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 58), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfLinkLocalAddressType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfLinkLocalAddressType.setDescription("The value of vRtrIfLinkLocalAddressType indicates the IP address\n         type of the link local address of this virtual router interface.\n         When the value of vRtrIfIPv6OperState is 'inService', this object\n         will have a value of 'ipv6z', and 'unknown' otherwise.")
vRtrIfLinkLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 59), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfLinkLocalAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrIfLinkLocalAddress.setDescription("The value of vRtrIfLinkLocalAddress indicates the link local IP\n         address of this virtual router interface. This address valid when\n         the value of vRtrIfIPv6OperState is 'inService'.")
vRtrIfLinkLocalAddressState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 60), TmnxInetAddrState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfLinkLocalAddressState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfLinkLocalAddressState.setDescription("The value of vRtrIfLinkLocalAddressState indicates the address\n         state of vRtrIfLinkLocalAddress. When vRtrIfIPv6OperState is\n         'outOfService', the value of this object is 'unknown'.")
vRtrIfLastOperStateChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 61), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfLastOperStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrIfLastOperStateChange.setDescription('The value of vRtrIfLastOperStateChange indicates the sysUpTime when\n         the operational state of this interface last changed.')
vRtrIfOperMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 62), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfOperMtu.setStatus('current')
if mibBuilder.loadTexts: vRtrIfOperMtu.setDescription('The value of vRtrIfOperMtu indicates the operational value of the\n         IP MTU on this interface. It is the minimum of the vRtrIfMtu and\n         the MTU of the physical port this interface is bound to.')
vRtrIfGlobalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 63), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfGlobalIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrIfGlobalIndex.setDescription('The value of vRtrIfGlobalIndex uniquely identifies this interface\n         in the tmnx system. This field provides an identifier for router\n         interfaces similar to the vRtrIfIndex value, except that vRtrIfIndex\n         is unique within each virtual router. The vRtrIfGlobalIndex is unique\n         system wide regardless of the vRtrID.\n\n         The vRtrIfGlobalIndex value for each virtual interface must remain\n         constant at least from one re-initialization of the system management\n         processor to the next.')
vRtrIfDelaySeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 64), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1200))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDelaySeconds.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDelaySeconds.setDescription('The value of vRtrIfDelaySeconds specifies the time in seconds\n         that is used to bring up the interface.\n\n         When interface comes up, it will not become operational until\n         after the specified delay.\n\n         The default value of vRtrIfDelaySeconds is 0. It indicates\n         that the interface will become operational as soon as\n         it is enabled.')
vRtrIfDelayUpTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 65), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDelayUpTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDelayUpTimer.setDescription("The value of vRtrIfDelayUpTimer indicates the time left before the\n         interface comes up when vRtrIfDelaySeconds is configured to a\n         non-zero value.\n\n         When the interface is down, this object will return the value -1.\n         It's value can be in the range 0 to vRtrIfDelaySeconds's value\n         if the interface is 'about to come up'.\n\n         If the interface is up, the value of vRtrIfDelayUpTimer will be 0.")
vRtrIfLocalDhcpServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 66), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfLocalDhcpServerName.setStatus('current')
if mibBuilder.loadTexts: vRtrIfLocalDhcpServerName.setDescription('The value of vRtrIfLocalDhcpServerName specifies the local DHCP server\n         that can be reached via this interface.\n\n         The server itself is configured on virtual router level in object\n         TIMETRA-DHCP-SERVER-MIB::tmnxDhcpServerCfgServerName. Assigning\n         an ip-address to it is done here by linking it to an interface.\n         A server can be linked to several interfaces on the same virtual\n         router.')
vRtrIfInitDelayEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 67), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfInitDelayEnable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfInitDelayEnable.setDescription("The value of vRtrIfInitDelayEnable specifies whether vRtrIfDelaySeconds\n         is used only the next time or everytime the system attempts to bring \n         the interface operationally up.\n         \n         The value of vRtrIfInitDelayEnable is ignored if the value of \n         vRtrIfDelaySeconds is set to 0.\n\n         The value of vRtrIfInitDelayEnable is only set when interface is of \n         type subscriber-interface.\n\n         When the value vRtrIfInitDelayEnable is set to 'false', everytime \n         the system attempts to bring the interface operationally up, \n         it will be delayed by the value of vRtrIfDelaySeconds.\n\n         When the value vRtrIfInitDelayEnable is set to 'true', only the next \n         time the system attempts to bring the interface operationally up, \n         it will be delayed by the value of vRtrIfDelaySeconds.")
vRtrIfCpmProtPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 68), TCpmProtPolicyID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfCpmProtPolicyId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfCpmProtPolicyId.setDescription("The value of vRtrIfCpmProtPolicyId associates a CPM Protection policy\n         with an interface. \n         \n         A value of zero (0) specifies that no CPM Protection policy is\n         associated with this interface.\n\n         A value of one (1) specifies that the default CPM Protection policy is\n         associated with this interface.\n\n         If no value for vRtrIfCpmProtPolicyId is specified when the \n         vRtrIfEntry is created, the system assigns a default value, \n         derived from the value of the object vRtrIfType, as follows:\n\n         vRtrIfType              vRtrIfCpmProtPolicyId\n         ---------------------------------------------------------------------\n         network                 1\n         service                 used internally.\n         serviceIes              1\n         serviceRtdVpls          obsoleted.\n         serviceVprn             1\n         serviceIesSubscriber    0\n         serviceIesGroup         0\n         serviceVprnSubscriber   used internally.\n         serviceVprnGroup        0\n         serviceIesRedundant     0\n         serviceVprnRedundant    0\n         serviceVpls             0 \n         serviceIesCem           defined on a SAP. --not supported\n         serviceVprnCem          defined on a SAP. --not supported\n         serviceVprnIPsec        0\n         serviceVprnIPMirror     0\n\n         If an interface would get a default value of 'one', it is not\n         allowed to set the value of vRtrIfCpmProtPolicyId to 'zero'.\n\n         If an interface would get a default value of 'zero', it is not\n         allowed to modify the value of vRtrIfCpmProtPolicyId.\n\n         This object is not supported on SR-1 and ESS-1, where the \n         value of ALCATEL-IND1-TIMETRA-CHASSIS-MIB::tmnxChassisType is '5',\n         and 7710, where the value of ALCATEL-IND1-TIMETRA-CHASSIS-MIB::tmnxChassisType is\n         '7' or '9'.")
vRtrIfCpmProtUncfgdProtoDropCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 69), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfCpmProtUncfgdProtoDropCnt.setStatus('current')
if mibBuilder.loadTexts: vRtrIfCpmProtUncfgdProtoDropCnt.setDescription("The value of vRtrIfCpmProtUncfgdProtoDropCnt indicates the number of  \n         network control protocol messages dropped due to the operation of the\n         protocol protection facility. \n         \n         The protocol protection facility can be enabled and disabled by means\n         of the object TIMETRA-SECURITY-MIB::tmnxCpmProtDropUncfgdProtocolMsg.\n\n         When the protocol protection facility is enabled,\n         network control protocol traffic received on this virtual router \n         interface is dropped if the protocol is not configured on this virtual\n         router interface.\n\n         The value of vRtrIfProtocol indicates which protocols are configured\n         on this virtual router interface.\n\n         This object is not supported on SR-1 and ESS-1, where the \n         value of ALCATEL-IND1-TIMETRA-CHASSIS-MIB::tmnxChassisType is '5',\n         and 7710, where the value of ALCATEL-IND1-TIMETRA-CHASSIS-MIB::tmnxChassisType is\n         '7' or '9'.")
vRtrIfLdpSyncTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 4, 1, 70), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1800), ))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfLdpSyncTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrIfLdpSyncTimer.setDescription("The value of vRtrIfLdpSyncTimer specifies a time interval used \n         for IGP-LDP synchronization. The timer is started from the time the LDP \n         session to the neighbor is up over the interface. This is to allow \n         for the label FEC bindings to be exchanged. \n\n         When the timer expires, the link cost is restored and is re-advertised.\n         IGP will announce a new best next-hop and LDP will use it if the \n         label binding for the neighbor's FEC is available.")
vRtrIcmp6Table = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31), )
if mibBuilder.loadTexts: vRtrIcmp6Table.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6Table.setDescription('The vRtrIcmp6Table table contains statistics\n         of ICMPv6 messages that are received and sourced by\n         a router instance.')
vRtrIcmp6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1), )
vRtrConfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6Entry"))
vRtrIcmp6Entry.setIndexNames(*vRtrConfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIcmp6Entry.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6Entry.setDescription('Each row entry represents the ICMP statistics of a\n         virtual router instance. Entries are created and deleted\n         when entries in the vRtrConfEntry are created and deleted.')
vRtrIcmp6InMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InMsgs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InMsgs.setDescription('The value of vRtrIcmp6InMsgs indicates the total number\n         of ICMP messages received by this router instance which\n         includes all those counted by vRtrIcmp6InErrors.')
vRtrIcmp6InErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InErrors.setDescription('The value of vRtrIcmp6InErrors indicates the number of\n         ICMP messages which this router instance received but determined\n         as having ICMP-specific errors (bad ICMP checksums, bad length\n         , etc.).')
vRtrIcmp6InDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InDestUnreachs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InDestUnreachs.setDescription('The value of vRtrIcmp6InDestUnreachs indicates the number of\n         ICMP Destination Unreachable messages received by this router\n         instance.')
vRtrIcmp6InAdminProhibs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InAdminProhibs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InAdminProhibs.setDescription('The value of vRtrIcmp6InAdminProhibs indicates the number of\n         ICMP destination unreachable/communication administratively\n         prohibited messages received by this router instance.')
vRtrIcmp6InTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InTimeExcds.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InTimeExcds.setDescription('The value of vRtrIcmp6InTimeExcds indicates the number of\n          ICMP Time Exceeded messages received by this router instance.')
vRtrIcmp6InParmProblems = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InParmProblems.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InParmProblems.setDescription('The value of vRtrIcmp6InParmProblems indicates the number of\n         ICMP Parameter Problem messages received by this router instance.')
vRtrIcmp6InPktTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InPktTooBigs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InPktTooBigs.setDescription('The value of vRtrIcmp6InPktTooBigs indicates the number of\n         ICMP Packet Too Big messages received by this router instance.')
vRtrIcmp6InEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InEchos.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InEchos.setDescription('The value of vRtrIcmp6InEchos indicates the number of ICMP\n         Echo (request) messages received by this router instance.')
vRtrIcmp6InEchoReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InEchoReplies.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InEchoReplies.setDescription('The value of vRtrIcmp6InEchoReplies indicates the number of ICMP\n         Echo Reply messages received by this router instance.')
vRtrIcmp6InRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InRtrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InRtrSolicits.setDescription('The value of vRtrIcmp6InRtrSolicits indicates the number of ICMP\n         Router Solicit messages received by this router instance.')
vRtrIcmp6InRtrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InRtrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InRtrAdvertisements.setDescription('The value of vRtrIcmp6InRtrAdvertisements indicates the number of\n         ICMP Router Advertisement messages received by this router instance.')
vRtrIcmp6InNbrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InNbrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InNbrSolicits.setDescription('The value of vRtrIcmp6InNbrSolicits indicates the number of ICMP\n         Neighbor Solicit messages received by this router instance.')
vRtrIcmp6InNbrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InNbrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InNbrAdvertisements.setDescription('The value of vRtrIcmp6InNbrAdvertisements indicates the number\n         of ICMP Neighbor Advertisement messages received by this router\n         instance.')
vRtrIcmp6InRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InRedirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InRedirects.setDescription('The value of vRtrIcmp6InRedirects indicates number of ICMP\n         Redirect messages received by this router instance.')
vRtrIcmp6InGrpMembQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InGrpMembQueries.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InGrpMembQueries.setDescription('The value of vRtrIcmp6InGrpMembQueries indicates the number of\n         ICMP Group Membership Query messages received by this router\n         instance.')
vRtrIcmp6InGrpMembResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InGrpMembResponses.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InGrpMembResponses.setDescription('The value of vRtrIcmp6InGrpMembResponses indicates the number of\n         ICMP Group Membership Response messages received by this router\n         instance.')
vRtrIcmp6InGrpMembReductions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6InGrpMembReductions.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6InGrpMembReductions.setDescription('The value of vRtrIcmp6InGrpMembReductions indicates the number of\n         ICMP Group Membership Reduction messages received by this router\n         instance.')
vRtrIcmp6OutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutMsgs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutMsgs.setDescription('The value of vRtrIcmp6OutMsgs indicates the total number of ICMP\n         messages which this router instance attempted to send.  Note that\n         this counter includes all those counted by icmpOutErrors.')
vRtrIcmp6OutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutErrors.setDescription("The value of vRtrIcmp6OutErrors indicates the number of ICMP\n         messages which this router instance did not send due to problems\n         discovered within ICMP such as a lack of buffers.  This value\n         should not include errors discovered outside the ICMP layer such\n         as the inability of VRtrIpv6 to route the resultant datagram.  In\n         some implementations there may be no types of error which contribute\n         to this counter's value.")
vRtrIcmp6OutDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutDestUnreachs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutDestUnreachs.setDescription('The value of vRtrIcmp6OutDestUnreachs indicates the number of ICMP\n         Destination Unreachable messages sent by this router instance.')
vRtrIcmp6OutAdminProhibs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutAdminProhibs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutAdminProhibs.setDescription('The value of vRtrIcmp6OutAdminProhibs indicates the number of ICMP\n         destination unreachable/communication administratively prohibited\n         messages sent by this router instance.')
vRtrIcmp6OutTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutTimeExcds.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutTimeExcds.setDescription('The value of vRtrIcmp6OutTimeExcds indicates the number of ICMP\n         Time Exceeded messages sent by this router instance.')
vRtrIcmp6OutParmProblems = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutParmProblems.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutParmProblems.setDescription('The value of vRtrIcmp6OutParmProblems indicates the number of ICMP\n         Parameter Problem messages sent by this router instance.')
vRtrIcmp6OutPktTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutPktTooBigs.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutPktTooBigs.setDescription('The value of vRtrIcmp6OutPktTooBigs indicates the number\n         of ICMP Packet Too Big messages sent by this router\n         instance.')
vRtrIcmp6OutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutEchos.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutEchos.setDescription('The value of vRtrIcmp6OutEchos indicates the number of ICMP\n         Echo Request messages sent by this router instance.')
vRtrIcmp6OutEchoReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutEchoReplies.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutEchoReplies.setDescription('The value of vRtrIcmp6OutEchoReplies indicates the number\n         of ICMP Echo Reply messages sent by this router instance.')
vRtrIcmp6OutRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutRtrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutRtrSolicits.setDescription('The value of vRtrIcmp6OutRtrSolicits indicates the number\n         of ICMP Router Solicitation messages sent by this router\n         instance.')
vRtrIcmp6OutRtrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutRtrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutRtrAdvertisements.setDescription('The value of vRtrIcmp6OutRtrAdvertisements indicates the\n         number of ICMP Router Advertisement messages\n         sent by this router instance.')
vRtrIcmp6OutNbrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutNbrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutNbrSolicits.setDescription('The value of vRtrIcmp6OutNbrSolicits indicates the number\n         of ICMP Neighbor Solicitation messages sent by this router\n         instance.')
vRtrIcmp6OutNbrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutNbrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutNbrAdvertisements.setDescription('The value of vRtrIcmp6OutNbrAdvertisements indicates the number\n         of ICMP Neighbor Advertisement messages sent by this router\n         instance.')
vRtrIcmp6OutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutRedirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutRedirects.setDescription('The value of vRtrIcmp6OutRedirects indicates the number of\n         ICMP Redirect messages sent by this router instance.')
vRtrIcmp6OutGrpMembQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutGrpMembQueries.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutGrpMembQueries.setDescription('The value of vRtrIcmp6OutGrpMembQueries indicates the number of\n         ICMP Group Membership Query messages sent by this router instance.')
vRtrIcmp6OutGrpMembResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutGrpMembResponses.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutGrpMembResponses.setDescription('The value of vRtrIcmp6OutGrpMembResponses indicates the number of\n         ICMP Group Membership Response messages sent by this router\n         instance.')
vRtrIcmp6OutGrpMembReductions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 31, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIcmp6OutGrpMembReductions.setStatus('current')
if mibBuilder.loadTexts: vRtrIcmp6OutGrpMembReductions.setDescription('The value of vRtrIcmp6OutGrpMembReductions indicates the number of\n         ICMP Group Membership Reduction messages sent by this router\n         instance.')
vRtrIfIcmp6Table = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32), )
if mibBuilder.loadTexts: vRtrIfIcmp6Table.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6Table.setDescription('The vRtrIfIcmp6Table table contains statistics\n         of ICMPv6 messages that are received and sourced by\n         a router interface.')
vRtrIfIcmp6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6Entry"))
vRtrIfIcmp6Entry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfIcmp6Entry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6Entry.setDescription('Each row entry represents the ICMP statistics of a\n         virtual router interface. Entries are created and deleted\n         when entries in the vRtrIfTable are created and deleted.')
vRtrIfIcmp6InMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InMsgs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InMsgs.setDescription('The value of vRtrIfIcmp6InMsgs indicates the total number\n         of ICMP messages received by this interface which includes\n         all those counted by vRtrIfIcmp6InErrors. Note that this\n         interface is the interface to which the ICMP messages were\n         addressed which may not be necessarily the input interface\n         for the messages.')
vRtrIfIcmp6InErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InErrors.setDescription('The value of vRtrIfIcmp6InErrors indicates the number of\n         ICMP messages which this interface received but determined\n         as having ICMP-specific errors (bad ICMP checksums, bad length\n         , etc.).')
vRtrIfIcmp6InDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InDestUnreachs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InDestUnreachs.setDescription('The value of vRtrIfIcmp6InDestUnreachs indicates the number of\n         ICMP Destination Unreachable messages received by this interface.')
vRtrIfIcmp6InAdminProhibs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InAdminProhibs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InAdminProhibs.setDescription('The value of vRtrIfIcmp6InAdminProhibs indicates the number of\n         ICMP destination unreachable/communication administratively\n         prohibited messages received by this interface.')
vRtrIfIcmp6InTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InTimeExcds.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InTimeExcds.setDescription('The value of vRtrIfIcmp6InTimeExcds indicates the number of\n          ICMP Time Exceeded messages received by this interface.')
vRtrIfIcmp6InParmProblems = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InParmProblems.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InParmProblems.setDescription('The value of vRtrIfIcmp6InParmProblems indicates the number of\n         ICMP Parameter Problem messages received by this interface.')
vRtrIfIcmp6InPktTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InPktTooBigs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InPktTooBigs.setDescription('The value of vRtrIfIcmp6InPktTooBigs indicates the number of\n         ICMP Packet Too Big messages received by this interface.')
vRtrIfIcmp6InEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InEchos.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InEchos.setDescription('The value of vRtrIfIcmp6InEchos indicates the number of ICMP\n         Echo (request) messages received by this interface.')
vRtrIfIcmp6InEchoReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InEchoReplies.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InEchoReplies.setDescription('The value of vRtrIfIcmp6InEchoReplies indicates the number of ICMP\n         Echo Reply messages received by this interface.')
vRtrIfIcmp6InRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InRtrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InRtrSolicits.setDescription('The value of vRtrIfIcmp6InRtrSolicits indicates the number of ICMP\n         Router Solicit messages received by this interface.')
vRtrIfIcmp6InRtrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InRtrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InRtrAdvertisements.setDescription('The value of vRtrIfIcmp6InRtrAdvertisements indicates the number of\n         ICMP Router Advertisement messages received by this interface.')
vRtrIfIcmp6InNbrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InNbrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InNbrSolicits.setDescription('The value of vRtrIfIcmp6InNbrSolicits indicates the number of ICMP\n         Neighbor Solicit messages received by this interface.')
vRtrIfIcmp6InNbrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InNbrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InNbrAdvertisements.setDescription('The value of vRtrIfIcmp6InNbrAdvertisements indicates the number\n         of ICMP Neighbor Advertisement messages received by this interface.')
vRtrIfIcmp6InRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InRedirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InRedirects.setDescription('The value of vRtrIfIcmp6InRedirects indicates number of ICMP\n         Redirect messages received by this interface.')
vRtrIfIcmp6InGrpMembQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InGrpMembQueries.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InGrpMembQueries.setDescription('The value of vRtrIfIcmp6InGrpMembQueries indicates the number of\n         ICMP Group Membership Query messages received by this interface.')
vRtrIfIcmp6InGrpMembResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InGrpMembResponses.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InGrpMembResponses.setDescription('The value of vRtrIfIcmp6InGrpMembResponses indicates the number of\n         ICMP Group Membership Response messages received by this interface.')
vRtrIfIcmp6InGrpMembReductions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6InGrpMembReductions.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6InGrpMembReductions.setDescription('The value of vRtrIfIcmp6InGrpMembReductions indicates the number of\n         ICMP Group Membership Reduction messages received by this interface.')
vRtrIfIcmp6OutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutMsgs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutMsgs.setDescription('The value of vRtrIfIcmp6OutMsgs indicates the total number of ICMP\n         messages which this interface attempted to send.  Note that this\n         counter includes all those counted by icmpOutErrors.')
vRtrIfIcmp6OutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutErrors.setDescription("The value of vRtrIfIcmp6OutErrors indicates the number of ICMP\n         messages which this interface did not send due to problems discovered\n         within ICMP such as a lack of buffers.  This value should not include\n         errors discovered outside the ICMP layer such as the inability of\n         VRtrIpv6 to route the resultant datagram.  In some implementations\n         there may be no types of error which contribute to this counter's\n         value.")
vRtrIfIcmp6OutDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutDestUnreachs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutDestUnreachs.setDescription('The value of vRtrIfIcmp6OutDestUnreachs indicates the number of ICMP\n         Destination Unreachable messages sent by this interface.')
vRtrIfIcmp6OutAdminProhibs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutAdminProhibs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutAdminProhibs.setDescription('The value of vRtrIfIcmp6OutAdminProhibs indicates the number of ICMP\n         destination unreachable/communication administratively prohibited\n         messages sent by this interface.')
vRtrIfIcmp6OutTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutTimeExcds.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutTimeExcds.setDescription('The value of vRtrIfIcmp6OutTimeExcds indicates the number of ICMP\n         Time Exceeded messages sent by this interface.')
vRtrIfIcmp6OutParmProblems = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutParmProblems.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutParmProblems.setDescription('The value of vRtrIfIcmp6OutParmProblems indicates the number of ICMP\n         Parameter Problem messages sent by this interface.')
vRtrIfIcmp6OutPktTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutPktTooBigs.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutPktTooBigs.setDescription('The value of vRtrIfIcmp6OutPktTooBigs indicates the number of ICMP\n         Packet Too Big messages sent by this interface.')
vRtrIfIcmp6OutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutEchos.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutEchos.setDescription('The value of vRtrIfIcmp6OutEchos indicates the number of ICMP\n         Echo Request messages sent by this interface.')
vRtrIfIcmp6OutEchoReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutEchoReplies.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutEchoReplies.setDescription('The value of vRtrIfIcmp6OutEchoReplies indicates the number\n         of ICMP Echo Reply messages sent by this interface.')
vRtrIfIcmp6OutRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrSolicits.setDescription('The value of vRtrIfIcmp6OutRtrSolicits indicates the number\n         of ICMP Router Solicitation messages sent by this interface.')
vRtrIfIcmp6OutRtrSolicitsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 28), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrSolicitsTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrSolicitsTime.setDescription('The value of vRtrIfIcmp6OutRtrSolicitsTime indicates the system\n         time when the last router solicitation message was sent by this\n         interface.')
vRtrIfIcmp6OutRtrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrAdvertisements.setDescription('The value of vRtrIfIcmp6OutRtrAdvertisements indicates the\n         number of ICMP Router Advertisement messages\n         sent by this interface.')
vRtrIfIcmp6OutRtrAdvTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 30), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrAdvTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutRtrAdvTime.setDescription('The value of vRtrIfIcmp6OutRtrAdvTime indicates the system\n         time when the last router advertisement message was sent by\n         this interface.')
vRtrIfIcmp6OutNbrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrSolicits.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrSolicits.setDescription('The value of vRtrIfIcmp6OutNbrSolicits indicates the number\n         of ICMP Neighbor Solicitation messages sent by this interface.')
vRtrIfIcmp6OutNbrSolicitsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 32), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrSolicitsTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrSolicitsTime.setDescription('The value of vRtrIfIcmp6OutNbrSolicitsTime indicates the system\n         time when the last neighbor solicitation message was sent by this\n         interface.')
vRtrIfIcmp6OutNbrAdvertisements = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrAdvertisements.setDescription('The value of vRtrIfIcmp6OutNbrAdvertisements indicates the number\n         of ICMP Neighbor Advertisement messages sent by this interface.')
vRtrIfIcmp6OutNbrAdvTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 34), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrAdvTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutNbrAdvTime.setDescription('The value of vRtrIfIcmp6OutNbrAdvTime indicates the system\n         time when the last neighbor advertisement message was sent by\n         this interface.')
vRtrIfIcmp6OutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutRedirects.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutRedirects.setDescription('The value of vRtrIfIcmp6OutRedirects indicates the number of\n         ICMP Redirect messages sent by this interface.')
vRtrIfIcmp6OutGrpMembQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutGrpMembQueries.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutGrpMembQueries.setDescription('The value of vRtrIfIcmp6OutGrpMembQueries indicates the number of\n         ICMP Group Membership Query messages sent by this interface.')
vRtrIfIcmp6OutGrpMembResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutGrpMembResponses.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutGrpMembResponses.setDescription('The value of vRtrIfIcmp6OutGrpMembResponses indicates the number of\n         ICMP Group Membership Response messages sent by this interface.')
vRtrIfIcmp6OutGrpMembReductions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 32, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfIcmp6OutGrpMembReductions.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIcmp6OutGrpMembReductions.setDescription('The value of vRtrIfIcmp6OutGrpMembReductions indicates the number of\n         ICMP Group Membership Reduction messages sent by this interface.')
vRtrIfBfdTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 33), )
if mibBuilder.loadTexts: vRtrIfBfdTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdTable.setDescription('The vRtrIfBfdTable table contains the configuration for\n         Bi-directional Forwarding Detection (BFD) on the vRtrIfEntry\n         with the same indices.')
vRtrIfBfdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 33, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdEntry"))
vRtrIfBfdEntry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfBfdEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdEntry.setDescription('Each row entry represents the BFD configuration for an\n         interface. Entries are created and deleted when entries\n         in the vRtrIfTable are created and deleted.')
vRtrIfBfdAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 33, 1, 1), TmnxAdminState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrIfBfdAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdAdminState.setDescription("The value of vRtrIfBfdAdminState specifies the admin state of\n         BFD on this interface. When it is 'inService', BFD sessions can be\n         established on this interface. When it is 'outOfService', they\n         cannot.")
vRtrIfBfdTransmitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 33, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 100000)).clone(100)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrIfBfdTransmitInterval.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdTransmitInterval.setDescription('The value of vRtrIfBfdTransmitInterval specifies the BFD transmit\n         interval over this interface.')
vRtrIfBfdReceiveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 33, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 100000)).clone(100)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrIfBfdReceiveInterval.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdReceiveInterval.setDescription('The value of vRtrIfBfdReceiveInterval specifies the BFD receive\n         interval over this interface.')
vRtrIfBfdMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 33, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 20)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrIfBfdMultiplier.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdMultiplier.setDescription('The value of vRtrIfBfdMultiplier specifies the the number of\n         consecutive BFD messages that must be missed from the peer before\n         the BFD session state is changed to down and the upper level\n         protocols (OSPF, IS-IS or PIM) are notified of the fault.')
vRtrIfBfdEchoInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 33, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(100, 100000), ))).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrIfBfdEchoInterval.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdEchoInterval.setDescription('The value of vRtrIfBfdEchoInterval specifies the BFD echo\n         interval over this interface.')
vRtrIfBfdSessionTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34), )
if mibBuilder.loadTexts: vRtrIfBfdSessionTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionTable.setDescription('The vRtrIfBfdSessionTable table contains per BFD session statistics\n         and operational settings.')
vRtrIfBfdSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclAddrType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclAddr"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionRemAddrType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionRemAddr"))
if mibBuilder.loadTexts: vRtrIfBfdSessionEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionEntry.setDescription('Each row entry represents a BFD session. Entries are created\n         automatically by the system, or when a static-route is\n         configured to use BFD.')
vRtrIfBfdSessionLclAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 1), InetAddressType())
if mibBuilder.loadTexts: vRtrIfBfdSessionLclAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionLclAddrType.setDescription('The value of vRtrIfBfdSessionLclAddrType indicates the address\n         type in vRtrIfBfdSessionLclAddr.')
vRtrIfBfdSessionLclAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), )))
if mibBuilder.loadTexts: vRtrIfBfdSessionLclAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionLclAddr.setDescription('The value of vRtrIfBfdSessionLclAddr indicates the address of the\n         local endpoint of this BFD session. Its type is specified by\n         vRtrIfBfdSessionLclAddrType.')
vRtrIfBfdSessionRemAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 3), InetAddressType())
if mibBuilder.loadTexts: vRtrIfBfdSessionRemAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionRemAddrType.setDescription('The value of vRtrIfBfdSessionRemAddrType indicates the address\n         type in vRtrIfBfdSessionRemAddr.')
vRtrIfBfdSessionRemAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), )))
if mibBuilder.loadTexts: vRtrIfBfdSessionRemAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionRemAddr.setDescription('The value of vRtrIfBfdSessionRemAddr indicates the address of the\n         local endpoint of this BFD session. Its type is specified by\n         vRtrIfBfdSessionRemAddrType.')
vRtrIfBfdSessionOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 5), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionOperState.setDescription('The value of vRtrIfBfdSessionOperState indicates the operational state\n         of BFD on this interface.')
vRtrIfBfdSessionState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("adminDown", 0), ("down", 1), ("init", 2), ("up", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionState.setDescription('The value of vRtrIfBfdSessionState indicates the state of the BFD\n         protocl on this interface.')
vRtrIfBfdSessionOperFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 7), Bits().clone(namedValues=NamedValues(("noProtocols", 0), ("noHeartBeat", 1), ("echoFailed", 2), ("nbrSignalDown", 3), ("fwdPlaneReset", 4), ("pathDown", 5), ("nbrAdminDown", 6), ("adminClear", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionOperFlags.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionOperFlags.setDescription('The value of vRtrIfBfdSessionOperFlags indicates the reasons why a BFD\n         session is not up.')
vRtrIfBfdSessionMesgRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionMesgRecv.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionMesgRecv.setDescription('The value of vRtrIfBfdSessionMesgRecv indicates the number of messages\n         received in this session.')
vRtrIfBfdSessionMesgSent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionMesgSent.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionMesgSent.setDescription('The value of vRtrIfBfdSessionMesgSent indicates the number of messages\n         sent in this session.')
vRtrIfBfdSessionLastDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionLastDownTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionLastDownTime.setDescription('The value of vRtrIfBfdSessionLastDownTime indicates the system time\n         when this session last went down.')
vRtrIfBfdSessionLastUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionLastUpTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionLastUpTime.setDescription('The value of vRtrIfBfdSessionLastUpTime indicates the system time\n         when this session last came up.')
vRtrIfBfdSessionUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionUpCount.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionUpCount.setDescription("The value of vRtrIfBfdSessionUpCount indicates the number of times\n         vRtrIfBfdSessionOperState changed from 'outOfService' to 'inService'.")
vRtrIfBfdSessionDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionDownCount.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionDownCount.setDescription("The value of vRtrIfBfdSessionDownCount indicates the number of times\n         vRtrIfBfdSessionOperState changed from 'inService' to 'outOfService'.")
vRtrIfBfdSessionLclDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionLclDisc.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionLclDisc.setDescription('The value of vRtrIfBfdSessionLclDisc indicates the unique local\n         discriminator for this session.')
vRtrIfBfdSessionRemDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionRemDisc.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionRemDisc.setDescription('The value of vRtrIfBfdSessionRemDisc indicates the remote\n         discriminator for this session.')
vRtrIfBfdSessionProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 16), Bits().clone(namedValues=NamedValues(("ospfv2", 0), ("pim", 1), ("isis", 2), ("staticRoute", 3), ("mcRing", 4), ("rsvp", 5), ("bgp", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionProtocols.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionProtocols.setDescription('The value of vRtrIfBfdSessionProtocols indicates which protocols\n         are using this BFD session.')
vRtrIfBfdSessionTxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 17), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionTxInterval.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionTxInterval.setDescription("The value of vRtrIfBfdSessionTxInterval indicates the negotiated\n         transmit interval. This value is the minimum of the local node's\n         'vRtrIfBfdTransmitInterval' and the remote node's receive interval.")
vRtrIfBfdSessionRxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 18), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionRxInterval.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionRxInterval.setDescription("The value of vRtrIfBfdSessionRxInterval indicates the negotiated\n         receive interval. This value is the minimum of the local node's\n         'vRtrIfBfdReceiveInterval' and the remote node's transmit interval.")
vRtrIfBfdSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 34, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("iom", 1), ("cpm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfBfdSessionType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfBfdSessionType.setDescription('The value of vRtrIfBfdSessionType indicates if the bfd session is \n         running on IOM or CPM.')
vRtrIfProxyArpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18), )
if mibBuilder.loadTexts: vRtrIfProxyArpTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpTable.setDescription('The vRtrIfProxyArpTable provides an extension to the vRtrIfTable.\n         It has an entry for each virtual router interface configured in\n         the system.')
vRtrIfProxyArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpEntry"))
vRtrIfProxyArpEntry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfProxyArpEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpEntry.setDescription('Each row entry represents information related to Proxy ARP for a\n         virtual router interface in the system.\n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrIfProxyArp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyArp.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArp.setDescription("If the value of vRtrIfProxyArp is set to 'true', proxy ARP is\n         enabled on this interface. If this value is 'false', proxy ARP\n         is disabled on the interface.")
vRtrIfProxyArpLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyArpLocal.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpLocal.setDescription("If the value of vRtrIfProxyArpLocal is set to 'true', local proxy\n         ARP is enabled, that is, the interface will reply to ARP requests\n         even if both the hosts are on the same subnet. In this case ICMP\n         redirects will be disabled. If the value of vRtrIfProxyArpLocal\n         is set to 'false', the interface will not reply to ARP requests\n         if both the hosts are on the same subnet.")
vRtrIfProxyArpPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1, 3), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy1.setDescription("The value of vRtrIfProxyArpPolicy1 is used to specify the first\n         proxy ARP policy for this interface. This policy determines\n         networks and sources for which proxy ARP will be attempted. If\n         this value is set to an empty string, ''H, the interface does\n         not have a proxy ARP policy associated with it.\n\n         The value of vRtrIfProxyArpPolicy1 has no effect if vRtrIfProxyArp\n         is set to 'false'.")
vRtrIfProxyArpPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1, 4), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy2.setDescription("The value of vRtrIfProxyArpPolicy2 is used to specify the second\n         proxy ARP policy for this interface. This policy determines\n         networks and sources for which proxy ARP will be attempted. If\n         this value is set to an empty string, ''H, the interface does\n         not have a proxy ARP policy associated with it.\n\n         The value of vRtrIfProxyArpPolicy2 has no effect if vRtrIfProxyArp\n         is set to 'false'.")
vRtrIfProxyArpPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1, 5), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy3.setDescription("The value of vRtrIfProxyArpPolicy3 is used to specify the third\n         proxy ARP policy for this interface. This policy determines\n         networks and sources for which proxy ARP will be attempted. If\n         this value is set to an empty string, ''H, the interface does\n         not have a proxy ARP policy associated with it.\n\n         The value of vRtrIfProxyArpPolicy3 has no effect if vRtrIfProxyArp\n         is set to 'false'.")
vRtrIfProxyArpPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1, 6), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy4.setDescription("The value of vRtrIfProxyArpPolicy4 is used to specify the fourth\n         proxy ARP policy for this interface. This policy determines\n         networks and sources for which proxy ARP will be attempted. If\n         this value is set to an empty string, ''H, the interface does\n         not have a proxy ARP policy associated with it.\n\n         The value of vRtrIfProxyArpPolicy4 has no effect if vRtrIfProxyArp\n         is set to 'false'.")
vRtrIfProxyArpPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 18, 1, 7), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyArpPolicy5.setDescription("The value of vRtrIfProxyArpPolicy5 is used to specify the fifth\n         proxy ARP policy for this interface. This policy determines\n         networks and sources for which proxy ARP will be attempted. If\n         this value is set to an empty string, ''H, the interface does\n         not have a proxy ARP policy associated with it.\n\n         The value of vRtrIfProxyArpPolicy5 has no effect if vRtrIfProxyArp\n         is set to 'false'.")
vRtrIfDHCPTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19), )
if mibBuilder.loadTexts: vRtrIfDHCPTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPTable.setDescription('The vRtrIfDHCPTable is used to configure the interface\n         parameters for the DHCP Relay agent.')
vRtrIfDHCPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPEntry"))
vRtrIfDHCPEntry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfDHCPEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPEntry.setDescription('Each row entry represents information related to DHCP Relay for a\n         virtual router interface in the system.\n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrIfDHCPRelayInfoOption = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayInfoOption.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPRelayInfoOption.setDescription("vRtrIfDHCPRelayInfoOption is used to enable/disable DHCP\n         Option 82. If the value of this object is set to 'false', DHCP\n         Relay is disabled.")
vRtrIfDHCPRelayInfoAction = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("replace", 1), ("drop", 2), ("keep", 3))).clone('keep')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayInfoAction.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayInfoAction.setDescription('vRtrIfDHCPRelayInfoAction is used to configure the DHCP Relay\n         reforwarding policy.\n\n         replace(1) - replace existing information with\n                      DHCP relay information\n         drop(2)    - discard messages with existing relay information if\n                      the option-82 information is also present.\n         keep(3)    - retain the existing relay information.')
vRtrIfDHCPRelayCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("ifIndex", 1), ("asciiTuple", 2), ("sapId", 3), ("vlanAsciiTuple", 4))).clone('asciiTuple')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayCircuitId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayCircuitId.setDescription("The value of the object vRtrIfDHCPRelayCircuitId specifies whether or\n         not the circuit-id suboption is present, and if it is present what\n         information goes in it.\n         If the value of this object is set to 'none', the circuit-id suboption\n         will not be part of the information option (option 82).\n         If the value of this object is set to 'ifIndex', the value of the\n         interface index is used.\n         If the value of this object is set to 'asciiTuple', the ASCII-encoded\n         concatenated tuple consisting of the\n         - access-node-identifier\n         - service-id\n         - interface-name\n         - SAP-id (only if the value of vRtrIfType is 'serviceIesGroup')\n         is used.\n         If the value of this object is set to 'sapId', the ASCII-encoded\n         SAP-id is used.\n         If the value of this object is set to 'vlan-ascii-tuple' - the format\n         will include VLAN-id and dot1p bits in addition to what is included in\n         ascii-tuple already.  The format is supported on dot1q and qinq\n         encapsulated ports only.  Thus, when the option 82 bits are\n         stripped, dot1p bits will be copied to the Ethernet header of an\n         outgoing packet.")
vRtrIfDHCPRelayRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mac", 1), ("none", 2), ("remote-id", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayRemoteId.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayRemoteId.setDescription("The value of vRtrIfDHCPRelayRemoteId specifies what information goes\n         into the remote-id suboption in the DHCP Relay packet.  If the\n         value of this object is set to 'none', the remote-id suboption is\n         left blank. If the value of this object is set to 'mac',\n         the MAC address of the remote end is encoded in the suboption.  If the\n         value of the object is set to 'remote-id', vRtrIfDHCPRelayRemoteIdStr\n         will be the remote-id.")
vRtrIfDHCPAutoFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPAutoFilter.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPAutoFilter.setDescription('vRtrIfDHCPAutoFilter allows the router to automatically build\n         anti-spoofing filter lists. When this object is set to a non-zero\n         value, auto-filtering is enabled and a filter allowing only\n         PPPoE or DHCP traffic is established on the interface. The non-zero\n         value indicates the maximum number of entries that the auto-filter\n         can have. These entries are created by the agent upon snooping a\n         valid DHCP Reply packet and are used to allow traffic sourced by\n         the given DHCP-assigned IP address.')
vRtrIfDHCPRelayServer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 6), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer1.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer1.setDescription('vRtrIfDHCPRelayServer1 is used to configure the first DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayServer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer2.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer2.setDescription('vRtrIfDHCPRelayServer2 is used to configure the second DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayServer3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer3.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer3.setDescription('vRtrIfDHCPRelayServer3 is used to configure the third DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayServer4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 9), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer4.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer4.setDescription('vRtrIfDHCPRelayServer4 is used to configure the fourth DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayServer5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 10), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer5.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer5.setDescription('vRtrIfDHCPRelayServer5 is used to configure the fifth DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayServer6 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 11), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer6.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer6.setDescription('vRtrIfDHCPRelayServer6 is used to configure the sixth DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayServer7 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 12), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer7.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer7.setDescription('vRtrIfDHCPRelayServer7 is used to configure the seventh DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayServer8 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 13), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer8.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServer8.setDescription('vRtrIfDHCPRelayServer8 is used to configure the eighth DHCP server\n         where the requests will be forwarded.')
vRtrIfDHCPRelayTrusted = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayTrusted.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayTrusted.setDescription("When the value of vRtrIfDHCPRelayTrusted is set to 'true(1)', the\n         router will relay requests where the DHCP giaddr is zero.")
vRtrIfDHCPAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 15), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPAdminState.setDescription("vRtrIfDHCPAdminState is used to configure the desired\n         administrative state of DHCP on this interface.\n         If the value of vRtrIfType is network this object can only be set\n         to 'outOfService'.")
vRtrIfDHCPSnooping = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPSnooping.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPSnooping.setDescription('vRtrIfDHCPSnooping is used to enable/disable snooping of DHCP\n         packets received on interface.')
vRtrIfDHCPDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 17), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPDescription.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPDescription.setDescription('The value of vRtrIfDHCPDescription is a user provided description\n         string for DHCP on this virtual router interface.  It can consist of\n         any printable, seven-bit ASCII characters up to 80 characters in\n         length.')
vRtrIfDHCPAutoFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 18), TFilterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPAutoFilterId.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPAutoFilterId.setDescription('vRtrIfDHCPAutoFilterId maintains the auto-filter identifier being\n         used for this interface.')
vRtrIfDHCPOperAutoFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPOperAutoFilter.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPOperAutoFilter.setDescription("The value of vRtrIfDHCPOperAutoFilter indicates the number of active\n         auto-filter entries per interface. These entries are created in the\n         ALCATEL-IND1-TIMETRA-FILTER-MIB::tIPFilterTable by the agent by snooping\n         valid 'DHCP ACK' messages.")
vRtrIfDHCPAuthPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 20), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPAuthPolicy.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPAuthPolicy.setDescription('Defines which subscriber authentication policy must be applied when a\n         subscriber message (e.g. DHCP, PPPoE, ...) is received on the\n         interface.\n         The authentication policy must be defined in tmnxSubAuthPlcyTable.')
vRtrIfDHCPLeasePopulate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPLeasePopulate.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPLeasePopulate.setDescription('The value of the object vRtrIfDHCPLeasePopulate specifies the\n         maximum number of DHCP lease states allowed on this interface.')
vRtrIfDHCPOperLeasePopulate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPOperLeasePopulate.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPOperLeasePopulate.setDescription('The value of the object vRtrIfDHCPOperLeasePopulate indicates the\n         maximum number of DHCP lease states allocated on this interface.')
vRtrIfDHCPGiAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 23), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPGiAddressType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPGiAddressType.setDescription('The value of vRtrIfDHCPGiAddressType specifies the type of\n         vRtrIfDHCPGiAddress, the gateway interface address.')
vRtrIfDHCPGiAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 24), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPGiAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPGiAddress.setDescription('The value of vRtrIfDHCPGiAddress specifies the gateway interface\n         address. The type of this address is specified by the value of\n         vRtrIfDHCPGiAddressType.')
vRtrIfDHCPGiAddressAsSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPGiAddressAsSrc.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPGiAddressAsSrc.setDescription("The value of vRtrIfDHCPGiAddressAsSrc specifies whether the DHCP\n         relay should use the gateway interface address as the source IP\n         address when communicating with the DHCP server. When it is set\n         to 'true(1)', the source IP address used to communicate with the DHCP\n         server is the gateway interface address. When it is 'false', the\n         source IP is the IP of the egress interface the IP packet goes\n         out on.")
vRtrIfDHCPMatchOption82 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPMatchOption82.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPMatchOption82.setDescription("The value of vRtrIfDHCPMatchOption82 specifies whether the\n         DHCP relay should use the circuit ID in the option 82 field\n         in DHCP packets to match DHCP messages. When it is set to 'true(1)',\n         the option 82 circuit ID is used in addition to the MAC address and\n         transaction ID. When it is set to 'false', only the MAC address and\n         transaction ID are used.")
vRtrIfDHCPRelayRemoteIdStr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPRelayRemoteIdStr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayRemoteIdStr.setDescription("The value of vRtrIfDHCPRelayRemoteIdStr specifies the remote-id\n         in the DHCP Relay packet if value of vRtrIfDHCPRelayRemoteId is set\n         to 'remote-id'.")
vRtrIfDHCPProxyAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 28), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPProxyAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPProxyAdminState.setDescription("The value of vRtrIfDHCPProxyAdminState specifies the desired\n         administrative state of the proxy server on this interface.\n\n         When it is set to 'inService', the proxy server is enabled only if\n         vRtrIfDHCPAdminState is also set to 'inService'.")
vRtrIfDHCPProxyServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 29), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPProxyServerAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPProxyServerAddr.setDescription('The value of vRtrIfDHCPProxyServerAddr specifies the IP address\n         which will be used as the source address of the emulated DHCP server.\n\n         If this IP address is not configured, the value of vRiaIpAddress\n         will be used as the source address of the emulated DHCP server.')
vRtrIfDHCPProxyLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(300, 315446399), ))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPProxyLeaseTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPProxyLeaseTime.setDescription('The value of vRtrIfDHCPProxyLeaseTime specifies in seconds how long a\n         DHCP client is allowed to use the offered IP address.\n\n         Value 0 means the lease time provided by a RADIUS or an upstream DHCP\n         server will not be overridden. A lease time of 7 days is used when\n         RADIUS does not provide a lease time.')
vRtrIfDHCPProxyLTRadiusOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 31), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPProxyLTRadiusOverride.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPProxyLTRadiusOverride.setDescription("The value of vRtrIfDHCPProxyLTRadiusOverride specifies whether or not\n         the lease time provided by the RADIUS server is presented to the DHCP\n         client.\n\n         By default the proxy-server will always make use of\n         vRtrIfDHCPProxyLeaseTime, regardless of what lease time information is\n         provided from the RADIUS server.\n         When vRtrIfDHCPProxyLTRadiusOverride is set to 'true(1)', the\n         proxy-server will use the lease time information provided by the\n         RADIUS server, regardless of the configured one.")
vRtrIfDHCPVendorIncludeOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 32), Bits().clone(namedValues=NamedValues(("systemId", 0), ("clientMac", 1), ("serviceId", 2), ("sapId", 3))).clone(namedValues=NamedValues(("systemId", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPVendorIncludeOptions.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPVendorIncludeOptions.setDescription("The value of vRtrIfDHCPVendorIncludeOptions specifies what is\n         encoded in the Alcatel vendor specific sub-option of option 82.\n\n         The value of this object is only used when vRtrIfDHCPRelayInfoAction\n         is 'replace(1)'.")
vRtrIfDHCPVendorOptionString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPVendorOptionString.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPVendorOptionString.setDescription("The value of vRtrIfDHCPVendorOptionString specifies the string that\n         goes into the Alcatel vendor specific sub-option of option 82.\n\n         This string is only used when vRtrIfDHCPRelayInfoAction is set to\n         'replace(1)'.")
vRtrIfDHCPLayer2Header = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 34), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPLayer2Header.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPLayer2Header.setDescription("The value of vRtrIfDHCPLayer2Header specificies,\n         together with the value of object vRtrIfDHCPAntiSpoofMacAddr,\n         the MAC address that is used in anti-spoof entries for the lease\n         states on this interface.\n         \n         When it is set to 'false (2)', the client hardware address from the\n         DHCP payload, stored in ALCATEL-IND1-TIMETRA-SERV-MIB::svcDhcpLseStateChAddr,\n         is used.\n\n         When it is set to 'true (1)', the behavior depends on the value of\n         vRtrIfDHCPAntiSpoofMacAddr. If vRtrIfDHCPAntiSpoofMacAddr is set to\n         all zeros, the source MAC address in the L2 header of the DHCP packet\n         is used. If vRtrIfDHCPAntiSpoofMacAddr is configured, then its value\n         is used.")
vRtrIfDHCPAntiSpoofMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 35), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPAntiSpoofMacAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPAntiSpoofMacAddr.setDescription("The value of vRtrIfDHCPAntiSpoofMacAddr specifies,\n         together with the value of object vRtrIfDHCPLayer2Header,\n         the MAC address that is used in anti-spoof entries for the lease\n         states on this interface.\n\n         When vRtrIfDHCPLayer2Header is 'false (2)', the client hardware\n         address from the DHCP payload, stored in\n         ALCATEL-IND1-TIMETRA-SERV-MIB::svcDhcpLseStateChAddr, is used.\n\n         When vRtrIfDHCPLayer2Header is 'true (1)' and the value of this object\n         is all zeros, the source MAC address in the L2 header of the DHCP\n         packet is used.\n         \n         When vRtrIfDHCPLayer2Header is 'true (1)' and the value of this object\n         is not all zeros, then this value is used.\n\n         This object can only be configured if the value of object\n         vRtrIfDHCPLayer2Header is set to 'true (1)'.")
vRtrIfDHCPClientApplications = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 19, 1, 36), Bits().clone(namedValues=NamedValues(("dhcp", 0), ("pppoe", 1))).clone(namedValues=NamedValues(("dhcp", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCPClientApplications.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPClientApplications.setDescription('The value of vRtrIfDHCPClientApplications specifies the set of\n         client applications that can make use of the DHCP relay functionality\n         on this interface.')
vRtrIfDHCPRelayStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20), )
if mibBuilder.loadTexts: vRtrIfDHCPRelayStatsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayStatsTable.setDescription('The vRtrIfDHCPRelayStatsTable contains the statistics for the\n         DHCP Relay agent.')
vRtrIfDHCPRelayStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayStatsEntry"))
vRtrIfDHCPRelayStatsEntry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfDHCPRelayStatsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayStatsEntry.setDescription('Each row entry represents information related to DHCP Relay statistics\n         for a virtual router interface in the system.\n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrIfDHCPRelayRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayRxPkts.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayRxPkts.setDescription('vRtrIfDHCPRelayRxPkts indicates the total number of packets received\n         by the DHCP relay agent.')
vRtrIfDHCPRelayTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayTxPkts.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayTxPkts.setDescription('vRtrIfDHCPRelayTxPkts indicates the total number of packets transmitted\n         by the DHCP relay agent.')
vRtrIfDHCPRelayRxMalformedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayRxMalformedPkts.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayRxMalformedPkts.setDescription('vRtrIfDHCPRelayRxMalformedPkts indicates the total number of\n         malformed packets received by the DHCP relay agent.')
vRtrIfDHCPRelayRxUntrustedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayRxUntrustedPkts.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayRxUntrustedPkts.setDescription('vRtrIfDHCPRelayRxUntrustedPkts indicates the total number of\n         untrusted packets received by the DHCP relay agent.')
vRtrIfDHCPRelayClientPktsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsDiscarded.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsDiscarded.setDescription('vRtrIfDHCPRelayClientPktsDiscarded indicates the total number of\n         client packets dicarded by the DHCP relay agent.')
vRtrIfDHCPRelayClientPktsRelayed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsRelayed.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsRelayed.setDescription('vRtrIfDHCPRelayClientPktsRelayed indicates the total number of\n         client packets relayed by the DHCP relay agent.')
vRtrIfDHCPRelayServerPktsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServerPktsDiscarded.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServerPktsDiscarded.setDescription('vRtrIfDHCPRelayServerPktsDiscarded indicates the total number of\n         server packets discarded by the DHCP relay agent.')
vRtrIfDHCPRelayServerPktsRelayed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServerPktsRelayed.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServerPktsRelayed.setDescription('vRtrIfDHCPRelayServerPktsRelayed indicates the total number of\n         server packets relayed by the DHCP relay agent.')
vRtrIfDHCPRelayAuthPktsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayAuthPktsDiscarded.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayAuthPktsDiscarded.setDescription('vRtrIfDHCPRelayAuthPktsDiscarded indicates the total number of\n         packets discarded because authentication was not successful.')
vRtrIfDHCPRelayAuthPktsSuccess = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayAuthPktsSuccess.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayAuthPktsSuccess.setDescription('vRtrIfDHCPRelayAuthPktsSuccess indicates the total number of\n         packets for which authentication was successful.')
vRtrIfDHCPRelayClientPktsSnooped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsSnooped.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsSnooped.setDescription('vRtrIfDHCPRelayClientPktsSnooped indicates the total number of\n         client packets snooped by the DHCP relay agent.')
vRtrIfDHCPRelayServerPktsSnooped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayServerPktsSnooped.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayServerPktsSnooped.setDescription('vRtrIfDHCPRelayServerPktsSnooped indicates the total number of\n         server packets snooped by the DHCP relay agent.')
vRtrIfDHCPRelayClientPktsProxRad = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsProxRad.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsProxRad.setDescription('vRtrIfDHCPRelayClientPktsProxRad indicates the total number of\n         client packets proxied by the DHCP relay agent based on data received\n         from a RADIUS server.')
vRtrIfDHCPRelayClientPktsProxLS = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsProxLS.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayClientPktsProxLS.setDescription('vRtrIfDHCPRelayClientPktsProxLS indicates the total number of\n         client packets proxied by the DHCP relay agent based on a lease\n         state. The lease itself can have been obtained from a DHCP or RADIUS\n         server. This is the so called lease split functionality.')
vRtrIfDHCPRelayPktsGenRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayPktsGenRelease.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayPktsGenRelease.setDescription('vRtrIfDHCPRelayPktsGenRelease indicates the total number of DHCP\n         RELEASE messages spoofed by the DHCP relay agent to the DHCP server.')
vRtrIfDHCPRelayPktsGenForceRenew = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 20, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPRelayPktsGenForceRenew.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCPRelayPktsGenForceRenew.setDescription('vRtrIfDHCPRelayPktsGenForceRenew indicates the total number of DHCP\n         FORCERENEW messages spoofed by the DHCP relay agent to the DHCP\n         clients.')
vRtrIfDHCPLeaseStateTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 22), )
if mibBuilder.loadTexts: vRtrIfDHCPLeaseStateTable.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPLeaseStateTable.setDescription('vRtrIfDHCPLeaseStateTable contains DHCP lease state info for a\n         virtual router interface in the system.\n         The content of this table is moved to the\n         ALCATEL-IND1-TIMETRA-SERV-MIB::svcDhcpLeaseStateTable.')
vRtrIfDHCPLeaseStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 22, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLseStateCiAddr"))
if mibBuilder.loadTexts: vRtrIfDHCPLeaseStateEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPLeaseStateEntry.setDescription('DHCP lease state information for a virtual router interface.')
vRtrIfDHCPLseStateCiAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 22, 1, 1), IpAddress())
if mibBuilder.loadTexts: vRtrIfDHCPLseStateCiAddr.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPLseStateCiAddr.setDescription('The value of the object vRtrIfDHCPLseStateCiAddr indicates the IP\n         address of the DHCP lease state.')
vRtrIfDHCPLseStateChAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 22, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPLseStateChAddr.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPLseStateChAddr.setDescription('The value of the object vRtrIfDHCPLseStateChAddr indicates the MAC\n         address of the DHCP lease state.')
vRtrIfDHCPLseStateRemainLseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 22, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPLseStateRemainLseTime.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPLseStateRemainLseTime.setDescription('The value of the object vRtrIfDHCPLseStateRemainLseTime indicates the\n         remaining lease time of the IP address of the DHCP lease state.')
vRtrIfDHCPLseStateOption82 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 22, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPLseStateOption82.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPLseStateOption82.setDescription('vRtrIfDHCPLseStateOption82 indicates the content of the\n                 Option82 for this DHCP lease state.')
vRtrIfDHCPLseStatePersistKey = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 22, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCPLseStatePersistKey.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrIfDHCPLseStatePersistKey.setDescription('The value of the object vRtrIfDHCPLseStatePersistKey indicates a\n         key value that can be used to track this lease state in the\n         persistence file.')
vRtrIfDHCP6TableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 35), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCP6TableLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6TableLastChanged.setDescription('The value of the object vRtrIfDHCP6TableLastChanged indicates\n         the time of the last change to any row of vRtrIfDHCP6Table')
vRtrIfDHCP6Table = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36), )
if mibBuilder.loadTexts: vRtrIfDHCP6Table.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6Table.setDescription('The vRtrIfDHCP6Table is used to configure the interface parameters\n         for the DHCP6 Relay agent.')
vRtrIfDHCP6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6Entry"))
vRtrIfDHCP6Entry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfDHCP6Entry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6Entry.setDescription('Each row entry represents information related to DHCP6 Relay for a\n         virtual router interface in the system.\n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrIfDHCP6LastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCP6LastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6LastChanged.setDescription('The value of the object vRtrIfDHCP6LastChanged indicates the time of\n         the last change to this row of VRtrIfDHCP6Entry.')
vRtrIfDHCP6AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 2), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6AdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6AdminState.setDescription('The value of the object vRtrIfDHCP6AdminState specifies the desired\n         administrative status of the DHCP6 relay agent on this interface.\n\n         The value can only be set to inService if the value of vRtrIfType\n         is serviceIesGroup.\n         The value noop(3) is never allowed.')
vRtrIfDHCP6OperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("noIPv6Pfx", 3), ("noServerConfigured", 4), ("noValidSourceAddr", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCP6OperState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6OperState.setDescription('The value of the object vRtrIfDHCP6OperState indicates the current\n         operational state of the DHCP6 relay agent on this interface.\n         Following value are possible:\n         up (1)           - the DHCP6 relay agent is running.\n\n         down (2),        - the DHCP6 relay agent is administratively disabled.\n\n         noIPv6Pfx (3),   - the DHCP6 relay agent cannot be operational as\n                            no ipv6 prefix is assigned to this link.\n\n         noServerConfigured(4) - the DHCP6 relay agent cannot be operational\n                                 as no DHCP6 servers are configured.\n         noValidSourceAddr(5)  - the DHCP6 relay agent cannot be operational\n                                 because a source address has been configured\n                                 and the address is not local to this node.')
vRtrIfDHCP6Description = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 4), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6Description.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6Description.setDescription('The value of the object vRtrIfDHCP6Description specifies a user\n         provided description string for DHCP6 relay agent on this virtual\n         router interface.\n         It can consist of any printable, seven-bit ASCII characters up to\n         80 characters in length.')
vRtrIfDHCP6RelayServer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 5), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer1.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer1.setDescription('The value of the object vRtrIfDHCP6RelayServer1 specifies the first\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayServer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 6), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer2.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer2.setDescription('The value of the object vRtrIfDHCP6RelayServer2 specifies the 2nd\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayServer3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 7), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer3.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer3.setDescription('The value of the object vRtrIfDHCP6RelayServer3 specifies the 3rd\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayServer4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 8), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer4.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer4.setDescription('The value of the object vRtrIfDHCP6RelayServer4 specifies the 4rd\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayServer5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 9), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer5.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer5.setDescription('The value of the object vRtrIfDHCP6RelayServer5 specifies the 5th\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayServer6 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 10), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer6.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer6.setDescription('The value of the object vRtrIfDHCP6RelayServer6 specifies the 6th\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayServer7 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 11), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer7.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer7.setDescription('The value of the object vRtrIfDHCP6RelayServer7 specifies the 7th\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayServer8 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 12), InetAddressIPv6z().clone(hexValue="0000000000000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer8.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayServer8.setDescription('The value of the object vRtrIfDHCP6RelayServer8 specifies the 8th\n         DHCP6 server where the DHCP6 requests will be forwarded to.')
vRtrIfDHCP6RelayItfIdOption = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("ifIndex", 1), ("asciiTuple", 2), ("sapId", 3), ("string", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RelayItfIdOption.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RelayItfIdOption.setDescription("The value of the object vRtrIfDHCP6RelayItfIdOption specifies whether\n         or not the interface-id option is added by the DHCP6 relay agent,\n         and, if it is present, what information goes in it.\n         If the value of this object is set to 'none', the option is not added\n         by the relay agent. In all other cases the option is added to the relay\n         message. The content of the option is defined as follows:\n         - 'ifIndex'    - the value of the interface index is used.\n         - 'asciiTuple' - the ASCII-encoded concatenated tuple consisting of the\n             - access-node-identifier\n             - service-id\n             - interface-name\n             - SAP-id (only if the value of vRtrIfType is 'serviceIesGroup')\n         - 'sapId'      - the ASCII-encoded SAP-id is used.\n         - 'string'     - the value of the object vRtrIfDHCP6ItfIdString\n                          is used.\n        ")
vRtrIfDHCP6LeasePopulate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6LeasePopulate.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6LeasePopulate.setDescription('The value of the object vRtrIfDHCP6LeasePopulate specifies the\n         maximum number of lease states allocated by the DHCP6 relay function,\n         allowed on this interface.')
vRtrIfDHCP6CurrLeasePopulate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCP6CurrLeasePopulate.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6CurrLeasePopulate.setDescription('The value of the object vRtrIfDHCP6CurrLeasePopulate indicates the\n         number of lease states currently allocated on this interface by\n         the DHCP6 relay function.')
vRtrIfDHCP6SourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 16), InetAddressIPv6().clone(hexValue="00000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6SourceAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6SourceAddress.setDescription('The value of the object vRtrIfDHCP6SourceAddress specifies the ipv6\n         address that will be used by the DHCP6 relay agent as source IP\n         address in all messages sent to the DHCP6 servers.\n         If set to ::, the system will use the IPv6 address assigned on the\n         link on which the relay message is sent out, if such an address is\n         defined. As a last resort the system Ipv6 address is taken.')
vRtrIfDHCP6EnableNgbrResolution = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6EnableNgbrResolution.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6EnableNgbrResolution.setDescription('The value of the object vRtrIfDHCP6EnableNgbrResolution specifies\n         whether or not neighbor resolution via DHCP6 Relay must be enabled\n         on this interface.\n         This feature is similar to the arp-populate feature in ipv4.')
vRtrIfDHCP6RemoteIdOption = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6RemoteIdOption.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6RemoteIdOption.setDescription('The value of the object vRtrIfDHCP6RemoteIdOption specifies\n         whether or not the remote Id option is sent to the DHCP6 server.\n         The client DUID is used as remoteId.')
vRtrIfDHCP6PfxdAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdAdminState.setDescription('The value of the object vRtrIfDHCP6PfxdAdminState specifies the\n         administrative state of the row. If set to enabled, this\n         IPv6 prefix will be delegated by the system.')
vRtrIfDHCP6ServerMaxLeaseStates = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000)).clone(8000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6ServerMaxLeaseStates.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6ServerMaxLeaseStates.setDescription('The value of the object vRtrIfDHCP6ServerMaxLeaseStates specifies\n         the maximum number of lease states installed by the DHCP6 server\n         function allowed on this interface.')
vRtrIfDHCP6CurrServerLeaseStates = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCP6CurrServerLeaseStates.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6CurrServerLeaseStates.setDescription('The value of the object vRtrIfDHCP6CurrServerLeaseStates indicates the\n         number of lease states currently allocated on this interface\n         by the DHCP6 server function.')
vRtrIfDHCP6ItfIdString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 36, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6ItfIdString.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6ItfIdString.setDescription('The value of the object vRtrIfDHCP6ItfIdString specifies the string\n         that will be put in the interface-id option added by the relay agent.\n         This value is only meaningful if the object vRtrIfDHCP6RelayItfIdOption\n         is set to string(4).')
vRtrIfNameTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 5), )
if mibBuilder.loadTexts: vRtrIfNameTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfNameTable.setDescription('This is a read-only table, each row of which represents a one to\n         one equivalence between a router interface name (vRtrIfName)\n         and its corresponding index in the vRtrIfTable (vRtrIfIndex).')
vRtrIfNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 5, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (1, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfName"))
if mibBuilder.loadTexts: vRtrIfNameEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfNameEntry.setDescription('Each row entry in the vRtrIfNameTable corresponds to a row\n         in the vRtrIfTable. When an entry is created or deleted in the\n         vRtrIfTable, a corresponding entry is created or deleted in this\n         table.')
vRtrIfNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 5, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfNameIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrIfNameIndex.setDescription('The value of vRtrIfNameIndex gives the value of vRtrIfIndex\n         for a row in the vRtrIfTable. This row corresponds to the\n         virtual router interface which has interface name as vRtrIfName.\n         Every vRtrIfName is unique within a specific instance of vRtrID.')
vRtrIpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6), )
if mibBuilder.loadTexts: vRtrIpAddrTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIpAddrTable.setDescription('The vRtrIpAddrTable has an entry for each IP address configured\n         for a virtual router in the system.  An interface on the\n         virtual router may have more than one IP address assigned to\n         it.')
vRtrIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaIndex"))
if mibBuilder.loadTexts: vRtrIpAddrEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIpAddrEntry.setDescription("Each row entry represents an IP address assigned a virtual\n         router interface.  Entries can be created and deleted via\n         SNMP SET operations.  Setting RowStatus to 'active' requires\n         a values for all column variables to have been assigned.")
vRiaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: vRiaIndex.setStatus('current')
if mibBuilder.loadTexts: vRiaIndex.setDescription('The unique value which identifies this IP address entry for\n         this interface of this virtual router in the Tmnx system.\n         Those row entries with vRiaIndex = 1 represent the primary\n         IP address for the interface identified by the vRtrID and\n         vRtrIfIndex pair.  Row entries with other values for vRiaIndex\n         are secondary IP addresses.  There must always be a primary\n         IP address assigned an interface.  This implies that if the\n         primary address row is deleted, the secondary rows are also\n         deleted.')
vRiaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRiaRowStatus.setDescription("The row status used for creation, deletion, or control\n         of vRtrIpAddrTable entries.  All the other row variables\n         must have been assigned values before the row can be\n         place into the 'active' state.")
vRiaIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaIpAddress.setStatus('current')
if mibBuilder.loadTexts: vRiaIpAddress.setDescription("The IP address assigned to a router's interface.")
vRiaNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 4), IpAddress().clone(hexValue="FFFFFF00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaNetMask.setStatus('current')
if mibBuilder.loadTexts: vRiaNetMask.setDescription('The subnet mask associated with the IP address of this\n         entry.  The value of the mask is an IP address with all\n         the network bits set to 1 and all the host bits set to\n         0.')
vRiaBcastAddrFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allOnes", 1), ("hostOnes", 2))).clone('hostOnes')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaBcastAddrFormat.setStatus('current')
if mibBuilder.loadTexts: vRiaBcastAddrFormat.setDescription("When vRiaBcastAddrFormat is set to 'allOnes', the\n         255.255.255.255 address is used for local broadcast.\n         When vRiaBcastAddrFormat is set to 'hostOnes', the\n         <prefix>-1 address is used for the local broadcast.\n         For example for subnet 10.10.16.0/20 the <prefix>-1\n         address is 10.10.31.255.")
vRiaReasmMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaReasmMaxSize.setStatus('current')
if mibBuilder.loadTexts: vRiaReasmMaxSize.setDescription('The size of the largest IP datagram which this entry\n         can reassemble from incoming IP fragmented datagrams\n         received on this interface.')
vRiaIgpInhibit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaIgpInhibit.setStatus('current')
if mibBuilder.loadTexts: vRiaIgpInhibit.setDescription("This variable should only be associated with secondary\n         ip addresses, i.e., when the value of vRiaIndex is other\n         than 1. When vRiaIgpInhibit has a value of 'true',\n         it indicates that the given secondary IP address should\n         not be recognized as a local interface by the running IGP.\n         For OSPF and IS-IS, this means that the given secondary\n         IP addresses will not be injected as passive interfaces\n         and will not be advertised as internal IP interfaces into\n         the IGP's link state database.  For RIP this means these\n         secondary IP interfaces will not source RIP updates.")
vRiaInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 8), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetAddressType.setStatus('current')
if mibBuilder.loadTexts: vRiaInetAddressType.setDescription("vRiaInetAddressType specifies the type of the\n         vRiaInetAddress address assigned to a router's interface.")
vRiaInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 9), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetAddress.setStatus('current')
if mibBuilder.loadTexts: vRiaInetAddress.setDescription("The type of this address is determined by the value of\n         the vRiaInetAddressType object.\n\n         vRiaInetAddress indicates the IPv4/IPv6 address assigned\n         to a router's interface.")
vRiaInetPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 10), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetPrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRiaInetPrefixLen.setDescription('The value of vRiaInetPrefixLen specifies the length of\n         the IP netmask for this interface address.')
vRiaInetAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 11), TmnxInetAddrState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRiaInetAddrState.setStatus('current')
if mibBuilder.loadTexts: vRiaInetAddrState.setDescription('The value of vRiaInetAddrState indicates the address\n         state of the IPv6 address of the interface.')
vRiaInetEui64 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetEui64.setStatus('current')
if mibBuilder.loadTexts: vRiaInetEui64.setDescription("The value of vRiaInetEui64 specifies whether the\n         vRiaInetOperAddress is an eui64 address.  This object\n         can only be set at creation time.\n\n         When vRiaInetEui64 is 'true', then the vRiaInetOperAddress\n         is derived from the vRiaInetAddress and the physical address\n         of the interface this address is attached to.  vRiaInetAddress\n         has to have all zeros the least significant 8 bytes. Also,\n         vRiaInetPrefixLen cannot be longer than 64.\n\n         When vRiaInetEui64 is 'false', then the vRiaInetOperAddress\n         is a copy of vRiaInetAddress.  The value is always 'false' when\n         vRiaInetAddressType is not 'ipv6'.")
vRiaInetOperAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 13), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRiaInetOperAddress.setStatus('current')
if mibBuilder.loadTexts: vRiaInetOperAddress.setDescription('The value of vRiaInetOperAddress indicates the operational\n         address of this entry.  The type of this address is determined\n         by the value of the vRiaInetAddressType object.')
vRiaInetGwAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 14), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetGwAddressType.setStatus('current')
if mibBuilder.loadTexts: vRiaInetGwAddressType.setDescription('The value of vRiaInetGwAddressType specifies the address type\n         of vRiaInetGwAddress.')
vRiaInetGwAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 15), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetGwAddress.setStatus('current')
if mibBuilder.loadTexts: vRiaInetGwAddress.setDescription('The value of vRiaInetGwAddress specifies the gateway address\n         for the subnet specified by vRiaInetAddress and vRiaInetPrefixLen.\n         The address type is defined by vRiaInetGwAddressType. This field\n         is only valid when the address is configured on a subscriber\n         interface.')
vRiaInetRemoteIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 16), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetRemoteIpType.setStatus('current')
if mibBuilder.loadTexts: vRiaInetRemoteIpType.setDescription('The value of vRiaInetRemoteIpType specifies the address type\n         of vRiaInetRemoteIp.')
vRiaInetRemoteIp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 6, 1, 17), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRiaInetRemoteIp.setStatus('current')
if mibBuilder.loadTexts: vRiaInetRemoteIp.setDescription('The value of vRiaInetRemoteIp specifies the IP address of the remote\n         redundant interface. This field is only valid when the address is\n         configured on a redundant interface.')
vRtrIpCidrRouteTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 7), )
if mibBuilder.loadTexts: vRtrIpCidrRouteTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIpCidrRouteTable.setDescription('The vRtrIpCidrRouteTable provides an extension of the ipCidrRouteTable\n         in the IP-FORWARD-MIB.')
vRtrIpCidrRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 7, 1), )
ipCidrRouteEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpCidrRouteEntry"))
vRtrIpCidrRouteEntry.setIndexNames(*ipCidrRouteEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIpCidrRouteEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIpCidrRouteEntry.setDescription('Each row entry in the vRtrIpCidrRouteTable represents additional\n         columns for attributes specific to the Alcatel 7x50 SR series\n         implementation for the IP route table.')
vRtrIpCidrRouteLastEnabledTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 7, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIpCidrRouteLastEnabledTime.setStatus('current')
if mibBuilder.loadTexts: vRtrIpCidrRouteLastEnabledTime.setDescription('The vRtrIpCidrRouteLastEnabledTime variable contains the sysUpTime\n         value when ipCidrRouteStatus was last set to active (1) to\n         allow IP forwarding on this route entry.')
vRtrIpCidrRoutePreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 7, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIpCidrRoutePreference.setStatus('current')
if mibBuilder.loadTexts: vRtrIpCidrRoutePreference.setDescription("When ipCidrRouteProto has a value of 'netmgmt' to indicate that\n         this entry is a static route, the value of\n         vRtrIpCidrRoutePreference determines the priority of this\n         static route versus the routes from different sources such as\n         BGP or OSPF etc.\n\n         Different protocols should not be configured with the same\n         preference, if this occurs the tiebreaker is determined per the\n         default preference value as defined in the table below.\n\n         If multiple routes are learned with an identical preference\n         using the same protocol, the lowest cost is used. If multiple\n         routes are learned with an identical preference using the same\n         protocol and the costs (metrics) are equal, then the decision\n         as to what route to use is determined by the configuration of\n         the ecmp command.\n\n         Default preferences:\n\n         Route Type             Preference      Configurable\n         ----------             ----------      ------------\n         Direct attached                 0                no\n         Static-route                    5               yes\n         MPLS (post FCS)                 7\n         OSPF Internal routes           10                no\n         OSPF External                 150               yes\n         BGP                           170               yes\n         ")
vRtrIpCidrRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 7, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIpCidrRouteMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrIpCidrRouteMetric.setDescription("The primary routing metric  for this route. The semantics\n         of this metric are determined by the routing-protocol specified\n         in the route's ipCidrRouteProto value.")
vRtrStaticRouteNumber = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteNumber.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteNumber.setDescription("The number of current vRtrStaticRouteTable entries that are 'active'.")
vRtrStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9), )
if mibBuilder.loadTexts: vRtrStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteTable.setDescription("This entity's Static Routing table.")
vRtrStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteDest"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteMask"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndex"))
if mibBuilder.loadTexts: vRtrStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteEntry.setDescription('A particular route to  a  particular  destination, through a\n        particular next hop.')
vRtrStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteDest.setDescription('The destination IP address of this route.\n        This object may not take a Multicast (Class  D) address value.\n\n        Any assignment (implicit or  otherwise) of an instance of this object to\n        a value x must be rejected if the bitwise logical-AND of x with the\n        value of the corresponding instance of the vRtrStaticRouteMask object\n        is not equal to x.')
vRtrStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteMask.setDescription('Indicate the mask to be logical-ANDed  with  the  destination  address\n        before  being compared to the value  in  the  vRtrStaticRouteDest field.\n        For those  systems  that  do  not support arbitrary subnet masks, an\n        agent constructs the value  of the  vRtrStaticRouteMask  by  reference\n        to the IP Address Class.\n\n        Any assignment (implicit or  otherwise)  of  an instance of this object\n        to a value x must be rejected if the bitwise logical-AND of x with the\n        value of the corresponding instance of the vRtrStaticRouteDest object is\n        not equal to vRtrStaticRouteDest.')
vRtrStaticRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteIndex.setDescription('The quaternary index for the vRtrStaticRouteTable.')
vRtrStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteRowStatus.setDescription('The row status variable, used according to\n        row installation and removal conventions.')
vRtrStaticRouteLastEnabledTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteLastEnabledTime.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteLastEnabledTime.setDescription('The vRtrStaticRouteLastEnabledTime variable contains the sysUpTime\n         value when vRtrStaticRouteStatus was last set to active (1) to\n         allow IP forwarding on this static route entry.')
vRtrStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteStatus.setDescription("The value of vRtrStaticRouteStatus indicates whether or not this\n         route entry is active in the system.  When an interface\n         transitions to the down state, any associated route entries\n         are marked as 'inactive' and are usually not displayed in a\n         standard route table listing.  When the interface transitions\n         to the up state, the agent marks the associated routes as\n         'active'")
vRtrStaticRouteStaticType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("nextHop", 1), ("indirect", 2), ("blackHole", 3))).clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteStaticType.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteStaticType.setDescription('The value of vRtrStaticRouteStaticType indicates the\n         type of static route represented by this row entry.')
vRtrStaticRoutePreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRoutePreference.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRoutePreference.setDescription('The value of vRtrStaticRoutePreference determines the priority\n         of this static route versus the routes from different sources\n         such as BGP or OSPF etc.\n\n         Different protocols should not be configured with the same\n         preference, if this occurs the tiebreaker is determined per the\n         default preference value as defined in the table below.\n\n         If multiple routes are learned with an identical preference\n         using the same protocol, the lowest cost is used. If multiple\n         routes are learned with an identical preference using the same\n         protocol and the costs (metrics) are equal, then the decision\n         as to what route to use is determined by the configuration of\n         the ecmp command.\n\n         Default preferences.\n\n\n         Route Type             Preference      Configurable\n         ----------             ----------      ------------\n         Direct attached                 0                no\n         Static-route                    5               yes\n         MPLS (post FCS)                 7\n         OSPF Internal routes           10                no\n         OSPF External                 150               yes\n         BGP                           170               yes\n         ')
vRtrStaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteMetric.setDescription("When ipCidrRouteProto has a value of 'netmgmt' to indicate that\n         this entry is a static route, the value of vRtrStaticRouteMetric\n         associates a metric value with the route. This value is used\n         when importing this static route into other protocols such as\n         OSPF.  When the metric is configured as zero then the metric\n         configured in OSPF, default-import-metric, applies.  This value\n         is also used to determine which static route to install in the\n         forwarding table:\n\n         If there are multiple static routes with the same preference\n         but unequal metric then the lower cost (metric) route will be\n         installed.\n\n         If there are multiple static routes with equal preference and\n         metrics then ecmp rules apply.\n\n         If there are multiple routes with unequal preference then the\n         lower preference route will be installed.\n         ")
vRtrStaticRouteEgressIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteEgressIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteEgressIfIndex.setDescription("The outgoing ifIndex for this route as computed by the\n         static-route module. This variable will have a value of 0\n         if vRtrStaticRouteStatus is 'inactive' or if this static\n         route is configured as a black hole.")
vRtrStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 12), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteNextHop.setDescription("In case of remote routes, the address of the next system en route.\n         This member is complemented by vRtrStaticRouteNextHopUnnumberedIf.\n         Atmost only one of them can be non-null. If vRtrStaticRouteNextHop\n         is '0.0.0.0' and vRtrStaticRouteNextHopUnnumberedIf is a null\n         string then this static route is configured as a black hole.")
vRtrStaticRouteNextHopUnnumberedIf = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteNextHopUnnumberedIf.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteNextHopUnnumberedIf.setDescription("The name of the unnumbered Interface which will be the nexthop for\n             this route. This member is complemented by vRtrStaticRouteNextHop.\n\n             Atmost only one of them can be non-null. If vRtrStaticRouteNextHop\n             is '0.0.0.0' and vRtrStaticRouteNextHopUnnumberedIf is a null\n             string then this static route is configured as a black hole.")
vRtrStaticRouteAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 14), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteAdminState.setDescription('The desired administrative state for this virtual router static route')
vRtrStaticRouteIgpShortcut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 15), Bits().clone(namedValues=NamedValues(("te", 0), ("ldp", 1), ("ip", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteIgpShortcut.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteIgpShortcut.setDescription("The value of vRtrStaticRouteIgpShortcut is valid only for indirect\n         static routes (i.e. vRtrStaticRouteStaticType is 'indirect'). The\n         bits of vRtrStaticRouteIgpShortcut identify Layer 2 tunneling\n         mechanisms used for IGP shortcuts. If a bit is set, IGP shortcuts\n         associated with that tunneling mechanism will be used to resolve\n         next-hop for the static-route. If no bits are set, IGP shortcuts\n         will not be used to resolve next-hop for the static routes.\n\n         The tunneling mechanisms represented by each bit are:\n           te(0)  - RSVP Traffic Engineering\n           ldp(1) - LDP /32 Route Forwarding Equivalence Class (FEC)\n           ip(2)  - IP (IP-in-IP or GRE)\n\n         Evaluation of tunnel preference is based on the following order, in\n         descending priority:\n           1. Traffic Engineered Shortcut (RSVP-TE)\n           2. LDP /32 Route FEC Shortcut\n           3. IP Shortcut (IP-in-IP or GRE)\n           4. Actual IGP Next-Hop.")
vRtrStaticRouteDisallowIgp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteDisallowIgp.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteDisallowIgp.setDescription("The value of vRtrStaticRouteDisallowIgp is valid only for indirect\n         static routes (i.e. vRtrStaticRouteStaticType is 'indirect'). If\n         the value of vRtrStaticRouteDisallowIgp is set to 'true', and if\n         none of the defined tunneling mechanisms (RSVP-TE, LDP or IP)\n         qualify as a next-hop, the normal IGP next-hop to the indirect\n         next-hop address will not be used. If the value is set to 'false',\n         IGP next-hop to the indirect next-hop address can be used as the\n         next-hop of the last resort.")
vRtrStaticRouteTag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 9, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrStaticRouteTag.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteTag.setDescription('The value of vRtrStaticRouteTag is used to add a 32-bit integer tag\n         to the static route. This tag could then be used in route policies\n         to control distribution of the route into other protocols. A value\n         of 0 indicates that the tag has not been set.')
vRtrSvcIpRangeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 10), )
if mibBuilder.loadTexts: vRtrSvcIpRangeTable.setStatus('current')
if mibBuilder.loadTexts: vRtrSvcIpRangeTable.setDescription('The vRtrSvcIpRangeTable has an entry for each IP address\n         range configured for a virtual interface in a virtual router\n         in the system.  An interface on the virtual router may have\n         more than one Service IP address ranges assigned to it.')
vRtrSvcIpRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 10, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSvcIpRangeAddress"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSvcIpRangeMask"))
if mibBuilder.loadTexts: vRtrSvcIpRangeEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrSvcIpRangeEntry.setDescription("Each row entry represents an IP address range assigned a\n         virtual router service interface.  Entries can be created\n         and deleted via SNMP SET operations.  Setting RowStatus to\n         'active' requires values for all column variables to have\n         been assigned.")
vRtrSvcIpRangeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 10, 1, 1), IpAddress())
if mibBuilder.loadTexts: vRtrSvcIpRangeAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrSvcIpRangeAddress.setDescription("The IP address prefix range assigned to a router's service\n         interface.")
vRtrSvcIpRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32)))
if mibBuilder.loadTexts: vRtrSvcIpRangeMask.setStatus('current')
if mibBuilder.loadTexts: vRtrSvcIpRangeMask.setDescription('The subnet mask associated with the Service IP address of this\n         entry.  The value of the mask is an 32-bit integer with all\n         the network bits set to 1 and all the host bits set to 0.')
vRtrSvcIpRangeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 10, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrSvcIpRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrSvcIpRangeRowStatus.setDescription('The row status used for creation, deletion, or control\n         of vRtrSvcIpRangeTable entries.')
vRtrSvcIpRangeExclusive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 10, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrSvcIpRangeExclusive.setStatus('current')
if mibBuilder.loadTexts: vRtrSvcIpRangeExclusive.setDescription("When vRtrSvcIpRangeExclusive has a value of 'true', this\n         set of addresses is reserved for services only and cannot be\n         assigned to network ports.  When it has a value of 'false',\n         it could be used for services as well as network ports.")
vRtrIpNetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 11), )
if mibBuilder.loadTexts: vRtrIpNetToMediaTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIpNetToMediaTable.setDescription('The vRtrIpNetToMediaTable provides an extension of the\n         ipNetToMediaTable in the IP-MIB.')
vRtrIpNetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 11, 1), )
ipNetToMediaEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpNetToMediaEntry"))
vRtrIpNetToMediaEntry.setIndexNames(*ipNetToMediaEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIpNetToMediaEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIpNetToMediaEntry.setDescription('Each row entry in the vRtrIpNetToMediaTable represents additional\n         columns for attributes specific to the Alcatel 7x50 SR series\n         implementation for the vRtrIpNetToMediaTable.')
vRtrIpNetToMediaTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIpNetToMediaTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrIpNetToMediaTimer.setDescription("The value of vRtrIpNetToMediaTimer determines how much longer an ARP\n          entry associated with an vRtrIpNetToMediaTable entry remains in the ARP\n          cache. It is initially set to vRtrIfArpTimeout. When\n          vRtrIpNetToMediaTimer has a value of zero, '0', the entry is cleared\n          from the cache.")
vRtrIpNetToMediaOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 11, 1, 2), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIpNetToMediaOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrIpNetToMediaOperState.setDescription("The value of vRtrIpNetToMediaOperState specifies if the ARP entry is\n          being used actively in the ARP Table. When ipNetToMediaType has a\n          value 'dynamic', vRtrIpNetToMediaOperState will never have a value of\n          'outOfService'.")
vRtrInstanceAggregationTableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInstanceAggregationTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrInstanceAggregationTableLastChanged.setDescription('Timestamp of the last change to the vRtrInstanceAggregationTable\n         either from adding a row or removing a row.')
vRtrInstanceAggregationTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13), )
if mibBuilder.loadTexts: vRtrInstanceAggregationTable.setStatus('current')
if mibBuilder.loadTexts: vRtrInstanceAggregationTable.setDescription('The vRtrInstanceAggregationTable is the list of configured\n         VRtr aggregations and their operational status information.\n\n         Specifies the route aggregates that should be generated\n         into the virtual router if at least one contributing route\n         (more specific) is learned.\n\n         A route could match multiple aggregate statements.\n         For instance, with the following entries:\n         aggregate 10.0.0.0/8\n         aggregate 10.1.0.0/16\n\n         If the route 10.1.1.0/24 is learned, both aggregates would be\n         generated.')
vRtrInstanceAggregationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationIpPrefix"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationIpPrefixMask"))
if mibBuilder.loadTexts: vRtrInstanceAggregationEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrInstanceAggregationEntry.setDescription('An entry (conceptual row) in the vRtrInstanceAggregationTable.\n         Entries are created by user. Entries are destroyed by user.')
vRtrAggregationIpPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 1), IpAddress())
if mibBuilder.loadTexts: vRtrAggregationIpPrefix.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationIpPrefix.setDescription('IP address prefix to match for the aggregation.')
vRtrAggregationIpPrefixMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 2), IpAddressPrefixLength())
if mibBuilder.loadTexts: vRtrAggregationIpPrefixMask.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationIpPrefixMask.setDescription('Mask length for vRtrAggregationIpPrefix, to match for the\n         aggregation.')
vRtrAggregationRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAggregationRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationRowStatus.setDescription('Row status for this entry.')
vRtrAggregationLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 4), TimeStamp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAggregationLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationLastChanged.setDescription('Time stamp of last change of any object for this entry.')
vRtrAggregationSummaryOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAggregationSummaryOnly.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationSummaryOnly.setDescription('When true(1), only the aggregate is advertised, the more\n         specfic routes that make up the aggregate are not.\n\n         When false(2), both the aggregate and more specific\n         components are advertised.')
vRtrAggregationASSet = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAggregationASSet.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationASSet.setDescription('When true(1), the AS-Path of the resulting aggregate will contain\n         an AS-SET containing all AS numbers from the contributing routes.\n\n         When false(2), the AS-Path will contain no AS-SET and will be\n         originated by the ESR.')
vRtrAggregationAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 7), TmnxBgpAutonomousSystem()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAggregationAggregatorAS.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationAggregatorAS.setDescription('When vRtrAggregationAggregatorAS is set to non zero, and\n         vRtrAggregationAggregatorIPAddr is set to non-zero,\n         the supplied ASN and IP address will be used for the aggregator path\n         attributes.\n\n         When omitted, automatically uses its own ASN & Router-ID.')
vRtrAggregationAggregatorIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAggregationAggregatorIPAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationAggregatorIPAddr.setDescription('When vRtrAggregationAggregatorAS is set to non zero, and\n         vRtrAggregationAggregatorIPAddr is set to non-zero,\n         the supplied ASN and IP address will be used for the aggregator path\n         attributes.\n\n         When omitted, automatically uses its own ASN & Router-ID.')
vRtrAggregationOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 13, 1, 9), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrAggregationOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrAggregationOperState.setDescription('vRtrAggregationOperState specifies the current operational status\n         of the aggregation entry.')
vRtrStaticRouteIndexTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 14), )
if mibBuilder.loadTexts: vRtrStaticRouteIndexTable.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteIndexTable.setDescription("This entity's Static Route Index Table.")
vRtrStaticRouteIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 14, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndexDest"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndexMask"))
if mibBuilder.loadTexts: vRtrStaticRouteIndexEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteIndexEntry.setDescription('The available index for the vRtrStaticRouteTable for every\n        destination per virtual router.')
vRtrStaticRouteIndexDest = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 14, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteIndexDest.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteIndexDest.setDescription('The destination IP address of this index entry.\n         This object may not take a Multicast (Class  D) address value.\n\n         Any  assignment  (implicit  or  otherwise)  of an instance of this\n         object to a value x must be rejected if the bitwise logical-AND of\n         x   with   the   value   of  the  corresponding  instance  of  the\n         vRtrStaticRouteMask object is not equal to x.')
vRtrStaticRouteIndexMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 14, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteIndexMask.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteIndexMask.setDescription('Indicate the mask to be logical-ANDed with the destination address\n         before  being  compared  to  the  value in the vRtrStaticRouteDest\n         field.  For  those  systems  that  do not support arbitrary subnet\n         masks, an agent constructs the value of the vRtrStaticRouteMask by\n         reference  to  the  IP  Address Class. Any assignment (implicit or\n         otherwise)  of  an  instance  of  this object to a value x must be\n         rejected  if  the  bitwise  logical-AND of x with the value of the\n         corresponding  instance  of  the vRtrStaticRouteDest object is not\n         equal to vRtrStaticRouteDest.')
vRtrStaticRouteAvailableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 14, 1, 3), TestAndIncr().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrStaticRouteAvailableIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrStaticRouteAvailableIndex.setDescription('The available quaternary index for the vRtrStaticRouteTable.')
vRtrTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17), )
if mibBuilder.loadTexts: vRtrTunnelTable.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelTable.setDescription('vRtrTunnelTable maintains a list of tunnels for the specific router\n        instance.')
vRtrTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelDest"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelMask"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelPreference"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelNexthop"))
if mibBuilder.loadTexts: vRtrTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelEntry.setDescription('vRtrTunnelEntry defines a tunnel to a particular destination in a\n        specific router context. A tunnel to a specific destination could\n        established using GRE, LDP, RSVP or could be a static LSP.')
vRtrTunnelDest = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 1), IpAddress())
if mibBuilder.loadTexts: vRtrTunnelDest.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelDest.setDescription('vRtrTunnelDest maintains the destination IP address of this tunnel.\n        This object may not take a Multicast (Class  D) address value.\n\n        Any assignment (implicit or otherwise) of an instance of this object\n        to a value x must be rejected if the bitwise logical-AND of x with the\n        value of the corresponding instance of the vRtrTunnelMask object is not\n        equal to x.')
vRtrTunnelMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 2), IpAddress())
if mibBuilder.loadTexts: vRtrTunnelMask.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelMask.setDescription('vRtrTunnelMask indicates the mask to be logical-ANDed with the\n        destination address before being compared to the value in the\n        vRtrTunnelDest field. For those systems that do not support arbitrary\n        subnet masks, an agent constructs the value of the vRtrTunnelMask\n        by reference to the IP Address Class.\n\n        Any assignment (implicit or otherwise) of an instance of this object\n        to a value x must be rejected if the bitwise logical-AND of x with\n        the value of the corresponding instance of the ipCidrRouteDest object\n        is not equal to ipCidrRouteDest.')
vRtrTunnelPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: vRtrTunnelPreference.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelPreference.setDescription('The value of vRtrTunnelPreference determines the priority of this\n         tunnel versus the other tunnels from different sources such as LDP,\n         RSVP, GRE etc. This is an absolute number used internally by the\n         system to specify preferences for the tunnel.\n\n         Lowest number signifies the most preferred entry in the table.')
vRtrTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 4), TmnxTunnelType())
if mibBuilder.loadTexts: vRtrTunnelType.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelType.setDescription('The type of this tunnel entity.')
vRtrTunnelID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 5), TmnxTunnelID())
if mibBuilder.loadTexts: vRtrTunnelID.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelID.setDescription("Additional index provided to distinguish between multiple tunnels to\n        same destination having same characteristics.\n\n        There could be multiple tunnels for the type 'sdp'. In such cases the\n        vRtrTunnelID will hold the SDP Id.\n\n        There could be multiple tunnels for the type 'ldp'. In such cases the\n        vRtrTunnelID will hold the LSPId of the LSP in use.\n\n        For other vRtrTunnelType values this field will always be 0 as only a\n        single tunnel is established using other tunnel types.")
vRtrTunnelNexthop = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 6), IpAddress())
if mibBuilder.loadTexts: vRtrTunnelNexthop.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelNexthop.setDescription('The address of the next system en route; Otherwise, 0.0.0.0.')
vRtrTunnelMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrTunnelMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelMetric.setDescription('vRtrTunnelMetric maintains the metric of the tunnel. This is used\n        in addition to the preference for this tunnel.')
vRtrTunnelAge = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 17, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrTunnelAge.setStatus('current')
if mibBuilder.loadTexts: vRtrTunnelAge.setDescription("The number of seconds  since this tunnel entry was last\n        updated or otherwise determined to be correct. No semantics\n        of  `too  old' can  be implied except through knowledge of\n        owner of the tunnel.")
vRtrAdvPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23), )
if mibBuilder.loadTexts: vRtrAdvPrefixTable.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixTable.setDescription('This table allows the user to configure IPv6 prefixes for\n            router advertisements on an interface')
vRtrAdvPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixIfIndex"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixPrefix"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixLength"))
if mibBuilder.loadTexts: vRtrAdvPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixEntry.setDescription('An entry in the vRtrAdvPrefixTable.')
vRtrAdvPrefixIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: vRtrAdvPrefixIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixIfIndex.setDescription("The index value which uniquely identifies the interface on\n            which this prefix is configured.  The interface identified\n            by a particular value of this index is the same interface as\n            identified by the same value of the IF-MIB's ifIndex.")
vRtrAdvPrefixPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16))
if mibBuilder.loadTexts: vRtrAdvPrefixPrefix.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixPrefix.setDescription('The ipv6 address prefix. The length of this object\n            is the standard length (16 bytes ) for IPv6 prefixes.')
vRtrAdvPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 3), InetAddressPrefixLength().subtype(subtypeSpec=ValueRangeConstraint(4, 127)))
if mibBuilder.loadTexts: vRtrAdvPrefixLength.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixLength.setDescription('The prefix length associated with this prefix.\n            The value 0 has no special meaning for this object.')
vRtrAdvPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAdvPrefixRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixRowStatus.setDescription('The row status used for creation and deletion of router\n            advertisement prefix entries.')
vRtrAdvPrefixOnLinkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 5), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAdvPrefixOnLinkFlag.setReference('For IPv6 RFC2461, especially sections 2 and 4.6.2 and\n    RFC2462')
if mibBuilder.loadTexts: vRtrAdvPrefixOnLinkFlag.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixOnLinkFlag.setDescription("This object has the value 'true(1)', if this prefix can be\n            used  for on-link determination and the value 'false(2)'\n            otherwise.")
vRtrAdvPrefixAutonomousFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 6), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAdvPrefixAutonomousFlag.setReference('For IPv6 RFC2461, especially sections 2 and 4.6.2 and\n    RFC2462')
if mibBuilder.loadTexts: vRtrAdvPrefixAutonomousFlag.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixAutonomousFlag.setDescription('Autonomous address configuration flag. When true(1),\n            indicates that this prefix can be used for autonomous\n            address configuration (i.e. can be used to form a local\n            interface address).  If false(2), it is not used to auto-\n            configure a local interface address.')
vRtrAdvPrefixPreferredLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 7), Unsigned32().clone(604800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAdvPrefixPreferredLifetime.setReference('For IPv6 RFC2461, especially sections 2 and 4.6.2 and\n    RFC2462')
if mibBuilder.loadTexts: vRtrAdvPrefixPreferredLifetime.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixPreferredLifetime.setDescription('The remaining length of time in seconds that this prefix\n            will continue to be preferred, i.e. time until deprecation.\n            A value of 4,294,967,295 represents infinity.\n\n            The address generated from a deprecated prefix should no\n            longer be used as a source address in new communications,\n            but packets received on such an interface are processed as\n            expected.')
vRtrAdvPrefixValidLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 23, 1, 8), Unsigned32().clone(2592000)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrAdvPrefixValidLifetime.setReference('For IPv6 RFC2461, especially sections 2 and 4.6.2 and\n    RFC2462')
if mibBuilder.loadTexts: vRtrAdvPrefixValidLifetime.setStatus('current')
if mibBuilder.loadTexts: vRtrAdvPrefixValidLifetime.setDescription('The remaining length of time, in seconds, that this prefix\n            will continue to be valid, i.e. time until invalidation.  A\n            value of 4,294,967,295 represents infinity.\n\n            The address generated from an invalidated prefix should not\n            appear as the destination or source address of a packet.')
vRtrInetStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24), )
if mibBuilder.loadTexts: vRtrInetStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteTable.setDescription("The table of addressing information relevant\n        to this entity's Static Routing table.")
vRtrInetStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDestType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDest"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDestPfxLen"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteIndex"))
if mibBuilder.loadTexts: vRtrInetStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteEntry.setDescription('A particular route to a particular destination,\n        through a particular next hop.')
vRtrInetStaticRouteDestType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 1), InetAddressType())
if mibBuilder.loadTexts: vRtrInetStaticRouteDestType.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteDestType.setDescription('The value of vRtrInetStaticRouteDestType indicates\n        the address type of vRtrInetStaticRouteDest address.')
vRtrInetStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 2), InetAddress())
if mibBuilder.loadTexts: vRtrInetStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteDest.setDescription('The value of vRtrInetStaticRouteDest indicates the\n        destination IP address of this static route.')
vRtrInetStaticRouteDestPfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: vRtrInetStaticRouteDestPfxLen.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteDestPfxLen.setDescription('The value of vRtrInetStaticRouteDestPfxLen indicates\n        the prefix length associated with the\n        vRtrInetStaticRouteDest address.')
vRtrInetStaticRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: vRtrInetStaticRouteIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteIndex.setDescription('The value of vRtrInetStaticRouteIndex indicates the fifth\n        index for the vRtrInetStaticRouteTable.\n\n        The fifth index to vRtrInetStaticRouteTable identifies a\n        specific next-hop route to distinguish it from other\n        routes that share the same destination address.')
vRtrInetStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteRowStatus.setDescription('vRtrInetStaticRouteRowStatus controls the creation\n        and deletion of rows in the table.')
vRtrInetStaticRouteLastEnabledTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStaticRouteLastEnabledTime.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteLastEnabledTime.setDescription('The value of vRtrInetStaticRouteLastEnabledTime\n         indicates the sysUpTime value when\n         vRtrInetStaticRouteStatus was last set to active (1) to\n         allow IP forwarding on this static route entry.')
vRtrInetStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStaticRouteStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteStatus.setDescription("The value of vRtrInetStaticRouteStatus indicates\n         whether or not this route entry is active in the system.\n         When an interface transitions to the down state, any\n         associated route entries are marked as 'inactive'\n         and are usually not displayed in a standard route\n         table listing.  When the interface transitions\n         to the up state, the agent marks the associated routes as\n         'active'")
vRtrInetStaticRouteStaticType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("nextHop", 1), ("indirect", 2), ("blackHole", 3))).clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteStaticType.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteStaticType.setDescription('The value of vRtrInetStaticRouteStaticType specifies the\n         type of static route represented by this row entry.')
vRtrInetStaticRoutePreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRoutePreference.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRoutePreference.setDescription('The value of vRtrInetStaticRoutePreference specifies the priority\n         of this static route versus the routes from different sources\n         such as BGP or OSPF etc.\n\n         Different protocols should not be configured with the same\n         preference, if this occurs the tiebreaker is determined per the\n         default preference value as defined in the table below.\n\n         If multiple routes are learned with an identical preference\n         using the same protocol, the lowest cost is used. If multiple\n         routes are learned with an identical preference using the same\n         protocol and the costs (metrics) are equal, then the decision\n         as to what route to use is determined by the configuration of\n         the ecmp command.\n\n         Default preferences.\n\n\n         Route Type             Preference      Configurable\n         ----------             ----------      ------------\n         Direct attached                 0                no\n         Static-route                    5               yes\n         MPLS (post FCS)                 7\n         OSPF Internal routes           10                no\n         OSPF External                 150               yes\n         BGP                           170               yes\n         ')
vRtrInetStaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteMetric.setDescription("The value of vRtrInetStaticRouteMetric specifies\n         the metric for the static route.\n\n         When ipCidrRouteProto has a value of 'netmgmt' to specify that\n         this entry is a static route, the value of vRtrInetStaticRouteMetric\n         associates a metric value with the route. This value is used\n         when importing this static route into other protocols such as\n         OSPF.  When the metric is configured as zero then the metric\n         configured in OSPF, default-import-metric, applies.  This value\n         is also used to determine which static route to install in the\n         forwarding table:\n\n         If there are multiple static routes with the same preference\n         but unequal metric then the lower cost (metric) route will be\n         installed.\n\n         If there are multiple static routes with equal preference and\n         metrics then ecmp rules apply.\n\n         If there are multiple routes with unequal preference then the\n         lower preference route will be installed.\n         ")
vRtrInetStaticRouteEgressIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStaticRouteEgressIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteEgressIfIndex.setDescription("The value of vRtrInetStaticRouteEgressIfIndex indicates\n         the outgoing ifIndex for this route as computed by the\n         static-route module. This variable will have a value of 0\n         if vRtrInetStaticRouteStatus is 'inactive' or if this static\n         route is configured as a black hole.")
vRtrInetStaticRouteNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 12), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteNextHopType.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteNextHopType.setDescription('The value of vRtrInetStaticRouteNextHopType specifies\n         the address type of vRtrInetStaticRouteNextHop address.')
vRtrInetStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 13), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteNextHop.setDescription("The value of vRtrInetStaticRouteNextHop specifies\n         the address of the next hop for the static route.\n\n         In case of remote routes, the address of the\n         next system en route. This member is\n         complemented by vRtrInetStaticRouteNextHopIf.\n\n         At most only one of the two objects:\n         vRtrInetStaticRouteNextHop, vRtrInetStaticRouteNextHopIf\n         and can be non-null. If vRtrInetStaticRouteNextHopType\n         is 'unknown' and vRtrInetStaticRouteNextHopIf is a\n         null string then this static route is configured as\n         a black hole.")
vRtrInetStaticRouteNextHopIf = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteNextHopIf.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteNextHopIf.setDescription("The value of vRtrInetStaticRouteNextHopIf specifies\n         the interface of the next hop for the static route.\n\n         The name of the Interface which will be the nexthop for\n         this route. This member is complemented by\n         vRtrInetStaticRouteNextHop.\n\n         At most only one of the two objects:\n         vRtrInetStaticRouteNextHop, vRtrInetStaticRouteNextHopIf\n         and can be non-null. If vRtrInetStaticRouteNextHopType\n         is 'unknown' and vRtrInetStaticRouteNextHopIf is a\n         null string then this static route is configured as\n         a black hole.")
vRtrInetStaticRouteAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 15), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteAdminState.setDescription('The value of vRtrInetStaticRouteAdminState specifies\n          the desired administrative state for this\n         virtual router static route')
vRtrInetStaticRouteIgpShortcut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 16), Bits().clone(namedValues=NamedValues(("te", 0), ("ldp", 1), ("ip", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteIgpShortcut.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteIgpShortcut.setDescription("The value of vRtrInetStaticRouteIgpShortcut specifies the\n         Layer 2 tunneling mechanism used for IGP shortcuts.\n\n         The value of vRtrInetStaticRouteIgpShortcut is valid only for indirect\n         static routes (i.e. vRtrInetStaticRouteStaticType is 'indirect'). The\n         bits of vRtrInetStaticRouteIgpShortcut identify Layer 2 tunneling\n         mechanisms used for IGP shortcuts. If a bit is set, IGP shortcuts\n         associated with that tunneling mechanism will be used to resolve\n         next-hop for the static-route. If no bits are set, IGP shortcuts\n         will not be used to resolve next-hop for the static routes.\n\n         The tunneling mechanisms represented by each bit are:\n           te(0)  - RSVP Traffic Engineering\n           ldp(1) - LDP /32 Route Forwarding Equivalence Class (FEC)\n           ip(2)  - IP (IP-in-IP or GRE)\n\n         Evaluation of tunnel preference is based on the following order, in\n         descending priority:\n           1. Traffic Engineered Shortcut (RSVP-TE)\n           2. LDP /32 Route FEC Shortcut\n           3. IP Shortcut (IP-in-IP or GRE)\n           4. Actual IGP Next-Hop.")
vRtrInetStaticRouteDisallowIgp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteDisallowIgp.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteDisallowIgp.setDescription("The value of vRtrInetStaticRouteDisallowIgp specifies if\n         IGP shortcuts are to be used or not.\n\n         The value of vRtrInetStaticRouteDisallowIgp is valid only for indirect\n         static routes (i.e. vRtrInetStaticRouteStaticType is 'indirect'). If\n         the value of vRtrInetStaticRouteDisallowIgp is set to 'true', and if\n         none of the defined tunneling mechanisms (RSVP-TE, LDP or IP)\n         qualify as a next-hop, the normal IGP next-hop to the indirect\n         next-hop address will not be used. If the value is set to 'false',\n         IGP next-hop to the indirect next-hop address can be used as the\n         next-hop of the last resort.")
vRtrInetStaticRouteTag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteTag.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteTag.setDescription('The value of vRtrInetStaticRouteTag specifies a 32-bit integer tag\n         that is used to add to the static route. This tag could then be used\n         in route policies to control distribution of the route into other\n         protocols. A value of 0 indicates that the tag has not been set.')
vRtrInetStaticRouteEnableBfd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteEnableBfd.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteEnableBfd.setDescription("The value of vRtrInetStaticRouteEnableBfd specifies whether or not\n         Bi-directional Forwarding Detection is enabled on this static route.\n\n         When the value is 'true', this static-route can establish BFD sessions\n         and use BFD as a signalling mechanism.\n         When it is 'false', it cannot use BFD.")
vRtrInetStaticRouteCpeAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 20), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeAddrType.setDescription("The value of vRtrInetStaticRouteCpeAddrType specifies the address\n         type of vRtrInetStaticRouteCpeAddr address.\n\n         When the value of vRtrInetStaticRouteCpeAddrType is not 'unknown',\n         statitistics for the Customer-Provided Equipment (CPE) host checks\n         for this static route entry will be found in the sparsely dependent\n         table extension, vRtrInetStatRteCpeChkStatsTable.")
vRtrInetStaticRouteCpeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 21), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeAddr.setDescription('The value of vRtrInetStaticRouteCpeAddr specifies the IP address \n         of the target CPE device. When this object is configured, ICMP pings \n         will be sent to this target IP address to determine CPE connectivity\n         and whether this static route should be active.\n\n         When the value of vRtrInetStaticRouteCpeAddr is non-empty,\n         statitistics for the CPE host checks for this static route entry\n         will be found in the sparsely dependent table extension,\n         vRtrInetStatRteCpeChkStatsTable.')
vRtrInetStaticRouteCpeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeInterval.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeInterval.setDescription('The value of vRtrInetStaticRouteCpeInterval specifies the interval,\n         in seconds, between ICMP pings to the target CPE IP address,\n         vRtrInetStaticRouteCpeAddr.')
vRtrInetStaticRouteCpeDropCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeDropCnt.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeDropCnt.setDescription('The value of vRtrInetStaticRouteCpeDropCnt specifies the number of\n         consecutive ping-replies that must be missed before concluding the \n         CPE is down. If the CPE is determined to be down, the associated \n         static route will be deactivated.')
vRtrInetStaticRouteCpeEnableLog = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 24, 1, 24), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeEnableLog.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeEnableLog.setDescription("The value of vRtrInetStaticRouteCpeEnableLog specifies whether to enable\n         the logging of transitions between active and in-active based on the CPE\n         connectivity check.\n\n         A value of 'true (1)' indicates that logging should be enabled.")
vRtrInetStaticRouteIndexTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 25), )
if mibBuilder.loadTexts: vRtrInetStaticRouteIndexTable.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteIndexTable.setDescription("This entity's Static Route Index Table.")
vRtrInetStaticRouteIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 25, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDestType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDest"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDestPfxLen"))
if mibBuilder.loadTexts: vRtrInetStaticRouteIndexEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteIndexEntry.setDescription('The available index for the vRtrInetStaticRouteTable for every\n        destination per virtual router.')
vRtrInetStaticRouteAvailIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 25, 1, 1), TestAndIncr().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStaticRouteAvailIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteAvailIndex.setDescription('The value of vRtrInetStaticRouteAvailIndex indicates\n         the available fifth index for the vRtrInetStaticRouteTable.\n\n         The fifth index to vRtrInetStaticRouteTable identifies a\n         specific next-hop route to distinguish it from other\n         routes that share the same destination address.')
vRtrInetInstAggrTblLastChged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 26), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetInstAggrTblLastChged.setStatus('current')
if mibBuilder.loadTexts: vRtrInetInstAggrTblLastChged.setDescription('Timestamp of the last change to the vRtrInetInstAggrTable\n         either from adding a row or removing a row.')
vRtrInetInstAggrTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27), )
if mibBuilder.loadTexts: vRtrInetInstAggrTable.setStatus('current')
if mibBuilder.loadTexts: vRtrInetInstAggrTable.setDescription('The vRtrInetInstAggrTable is the list of configured\n         virtual router aggregations and their operational\n         status information.\n\n         vRtrInetInstAggrTable specifies the route aggregates\n         that should be generated into the virtual router if at\n         least one contributing route (more specific) is learned.\n\n         A route could match multiple aggregate statements.\n         For instance, with the following entries:\n         aggregate 10.0.0.0/8\n         aggregate 10.1.0.0/16\n\n         If the route 10.1.1.0/24 is learned, both aggregates would be\n         generated.')
vRtrInetInstAggrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrIpPrefixType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrIpPrefix"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrIpPrefixLen"))
if mibBuilder.loadTexts: vRtrInetInstAggrEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrInetInstAggrEntry.setDescription('vRtrInetInstAggrEntry indicates an entry (conceptual row)\n         in the vRtrInetInstAggrTable.\n         Entries are created and destroyed by user.')
vRtrInetAggrIpPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 1), InetAddressType())
if mibBuilder.loadTexts: vRtrInetAggrIpPrefixType.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrIpPrefixType.setDescription('The value of vRtrInetAggrIpPrefixType indicates\n         the IP address type of vRtrInetAggrIpPrefix.')
vRtrInetAggrIpPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 2), InetAddress())
if mibBuilder.loadTexts: vRtrInetAggrIpPrefix.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrIpPrefix.setDescription('The value of vRtrInetAggrIpPrefixType indicates\n         the IP address prefix to match for the aggregation.')
vRtrInetAggrIpPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: vRtrInetAggrIpPrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrIpPrefixLen.setDescription('The value of vRtrInetAggrIpPrefixLen indicates\n         the prefix length for vRtrInetAggrIpPrefix, to match\n         for the aggregation.')
vRtrInetAggrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetAggrRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrRowStatus.setDescription('vRtrInetAggrRowStatus controls the creation\n         and deletion of rows in the table.')
vRtrInetAggrLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 5), TimeStamp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetAggrLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrLastChanged.setDescription('The value of vRtrInetAggrLastChanged specifies the\n         time stamp of the last change to this row of\n         vRtrInetInstAggrTable .')
vRtrInetAggrSummaryOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetAggrSummaryOnly.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrSummaryOnly.setDescription("The value of vRtrInetAggrSummaryOnly specifies if\n         specific routes that make up aggregates are advertised or\n         not.\n\n         When vRtrInetAggrSummaryOnly has value of 'true(1)', only the\n         aggregate is advertised, the more specfic routes that make\n         up the aggregate are not.\n\n         When vRtrInetAggrSummaryOnly has value of 'false(2)', both the\n         aggregate and more specific components are advertised.")
vRtrInetAggrASSet = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetAggrASSet.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrASSet.setDescription("The value of vRtrInetAggrASSet specifies whether the\n         aggregate route has AS-SET.\n\n         When vRtrInetAggrASSet has value of 'true(1)', the AS-Path\n         of the resulting aggregate will contain an AS-SET\n         containing all AS numbers from the contributing routes.\n\n         When vRtrInetAggrASSet has value of 'false(2)', the AS-Path\n         will contain no AS-SET and will be originated by the ESR.")
vRtrInetAggrAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 8), TmnxBgpAutonomousSystem()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetAggrAggregatorAS.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrAggregatorAS.setDescription("The value of vRtrInetAggrAggregatorAS specifies the\n         aggregator's ASN.\n\n         When vRtrInetAggrAggregatorAS is set to non zero, and\n         vRtrInetAggrAggregatorIPAddr is set to non-zero,\n         the supplied ASN and IP address will be used for the\n         aggregator path attributes.\n\n         When vRtrInetAggrAggregatorAS is not set, the aggregate\n         routes ASN & Router-ID will be used for the aggregator\n         path attributes.")
vRtrInetAggrAggregatorIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 9), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetAggrAggregatorIPAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrAggregatorIPAddr.setDescription("The value of vRtrInetAggrAggregatorIPAddr specifies the\n         aggregator's IP address.\n\n         When vRtrInetAggrAggregatorAS is set to non zero, and\n         vRtrInetAggrAggregatorIPAddr is set to non-zero,\n         the supplied ASN and IP address will be used for the\n         aggregator path attributes.\n\n         When vRtrInetAggrAggregatorIPAddr is not set, the aggregate\n         routes ASN & Router-ID will be used for the aggregator\n         path attributes.")
vRtrInetAggrOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 27, 1, 10), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetAggrOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrInetAggrOperState.setDescription('The value of vRtrInetAggrOperState specifies the current\n         operational status of the aggregation entry.')
vRtrInetSvcIpRangeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 28), )
if mibBuilder.loadTexts: vRtrInetSvcIpRangeTable.setStatus('current')
if mibBuilder.loadTexts: vRtrInetSvcIpRangeTable.setDescription('The vRtrInetSvcIpRangeTable has an entry for each IP address\n         range configured for a virtual interface in a virtual router\n         in the system.  An interface on the virtual router may have\n         more than one Service IP address range assigned to it.')
vRtrInetSvcIpRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 28, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetSvcIpRangeAddrType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetSvcIpRangeAddr"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetSvcIpRangePfxLen"))
if mibBuilder.loadTexts: vRtrInetSvcIpRangeEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrInetSvcIpRangeEntry.setDescription("Each row entry represents an IP address range assigned a\n         virtual router service interface. Setting RowStatus to\n         'active' requires values for all column variables to have\n         been assigned.")
vRtrInetSvcIpRangeAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 28, 1, 1), InetAddressType())
if mibBuilder.loadTexts: vRtrInetSvcIpRangeAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrInetSvcIpRangeAddrType.setDescription('The value of vRtrInetSvcIpRangeAddrType indicates the IP\n         address type of vRtrInetSvcIpRangeAddr.')
vRtrInetSvcIpRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 28, 1, 2), InetAddress())
if mibBuilder.loadTexts: vRtrInetSvcIpRangeAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrInetSvcIpRangeAddr.setDescription("The value of vRtrInetSvcIpRangeAddr indicates the IP address\n         service range assigned to a router's service interface. The\n         address type of vRtrInetSvcIpRangeAddr is indicated by\n         vRtrInetSvcIpRangeAddrType.")
vRtrInetSvcIpRangePfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 28, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: vRtrInetSvcIpRangePfxLen.setStatus('current')
if mibBuilder.loadTexts: vRtrInetSvcIpRangePfxLen.setDescription('The value of vRtrInetSvcIpRangePfxLen specifies the prefix length\n         to be used with vRtrInetSvcIpRangeAddr for determining the IP\n         address range.')
vRtrInetSvcIpRangeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 28, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetSvcIpRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrInetSvcIpRangeRowStatus.setDescription('The value of vRtrInetSvcIpRangeRowStatus is used for creation and\n         deletion of IP service prefix ranges.')
vRtrInetSvcIpRangeExclusive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 28, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrInetSvcIpRangeExclusive.setStatus('current')
if mibBuilder.loadTexts: vRtrInetSvcIpRangeExclusive.setDescription("The value of vRtrInetSvcIpRangeExclusive specifies how the set\n         of addresses specified by this entry are interpreted. When the\n         value is 'true', they are reserved for services only and cannot be\n         assigned to network ports.  When the value is 'false',\n         it could be used for services as well as network ports.")
vRtrIfGlobalIndexTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 37), )
if mibBuilder.loadTexts: vRtrIfGlobalIndexTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfGlobalIndexTable.setDescription('This is a read-only table, each row of which represents a one to\n         one equivalence between a unique system wide router interface index\n         (vRtrIfGlobalIndex) and its corresponding virtual router ID (vRtrID)\n         and index in the vRtrIfTable (vRtrIfIndex).')
vRtrIfGlobalIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 37, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfGlobalIndex"))
if mibBuilder.loadTexts: vRtrIfGlobalIndexEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfGlobalIndexEntry.setDescription('Each row entry in the vRtrIfGlobalIndexTable corresponds to a row\n         in the vRtrIfTable. When an entry is created or deleted in the\n         vRtrIfTable, a corresponding entry is created or deleted in this\n         table.')
vRtrIfGlobalIndexvRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 37, 1, 1), TmnxVRtrID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfGlobalIndexvRtrID.setStatus('current')
if mibBuilder.loadTexts: vRtrIfGlobalIndexvRtrID.setDescription('The value of vRtrIfGlobalIndexvRtrID indicates the vRtrID that\n         maps to the vRtrIfGlobalIndex. The combination of a vRtrID and\n         a vRtrIfIndex correspond to a system wide unique vRtrIfGlobalIndex.\n         This value represents the specific instance of virtual router\n         which the vRtrIfGlobalIndex belongs to.')
vRtrIfGlobalIndexvRtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 37, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfGlobalIndexvRtrIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrIfGlobalIndexvRtrIfIndex.setDescription('The value of vRtrIfGlobalIndexvRtrIfIndex gives the value of\n         vRtrIfIndex for a row in the vRtrIfTable. This row corresponds\n         to the virtual router interface that maps to the\n         vRtrIfGlobalIndex. The combination of a vRtrID and\n         a vRtrIfIndex correspond to a system wide unique vRtrIfGlobalIndex.')
vRtrIfProxyNDTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38), )
if mibBuilder.loadTexts: vRtrIfProxyNDTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDTable.setDescription('The vRtrIfProxyNDTable provides an extension to the vRtrIfTable.\n         It has an entry for each virtual router interface configured in\n         the system.')
vRtrIfProxyNDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyNDEntry"))
vRtrIfProxyNDEntry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfProxyNDEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDEntry.setDescription('Each row entry represents information related to Proxy Neighbor\n         Discovery for a virtual router interface in the system.\n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrIfProxyNDLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyNDLocal.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDLocal.setDescription("If the value of vRtrIfProxyNDLocal is set to 'true', local proxy\n         Neighbor Discovery is enabled, that is, the interface will reply to\n         Neighbor Solicitation requests when both the hosts are on the same\n         subnet. In this case ICMP redirects will be disabled. If the value\n         of vRtrIfProxyNDLocal is set to 'false', the interface will not\n         reply to Neighbor Solicitation requests if both the hosts are on the\n         same subnet.")
vRtrIfProxyNDPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38, 1, 2), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy1.setDescription('The value of vRtrIfProxyNDPolicy1 specifies the first proxy ND\n         policy for this interface. This policy determines networks and\n         sources for which proxy ND will be attempted, when local proxy\n         ND is enabled.')
vRtrIfProxyNDPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38, 1, 3), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy2.setDescription('The value of vRtrIfProxyNDPolicy2 specifies the second proxy ND\n         policy for this interface. This policy determines networks and\n         sources for which proxy ND will be attempted, when local proxy\n         ND is enabled.')
vRtrIfProxyNDPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38, 1, 4), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy3.setDescription('The value of vRtrIfProxyNDPolicy3 specifies the third proxy ND\n         policy for this interface. This policy determines networks and\n         sources for which proxy ND will be attempted, when local proxy\n         ND is enabled.')
vRtrIfProxyNDPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38, 1, 5), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy4.setDescription('The value of vRtrIfProxyNDPolicy4 specifies the fourth proxy ND\n         policy for this interface. This policy determines networks and\n         sources for which proxy ND will be attempted, when local proxy\n         ND is enabled.')
vRtrIfProxyNDPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 38, 1, 6), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrIfProxyNDPolicy5.setDescription('The value of vRtrIfProxyNDPolicy5 specifies the fifth proxy ND\n         policy for this interface. This policy determines networks and\n         sources for which proxy ND will be attempted, when local proxy\n         ND is enabled.')
vRtrIfDHCP6PfxDelegationLstChgd = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 39), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxDelegationLstChgd.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxDelegationLstChgd.setDescription('The value of the object vRtrIfDHCP6PfxDelegationLstChgd indicates\n         the Timestamp of the last change to any row the\n         vRtrIfDHCP6PfxDelegationTable')
vRtrIfDHCP6PfxDelegationTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40), )
if mibBuilder.loadTexts: vRtrIfDHCP6PfxDelegationTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxDelegationTable.setDescription('The table vRtrIfDHCP6PfxDelegationTable is used to configure\n         the feature of automated delegation of IPv6 prefixes using DHCP6.\n\n         This feature is intended for delegating a long-lived prefix from\n         a delegating router to a requesting router, where the delegating\n         router does not require knowledge about the topology of the\n         links in the network to which the prefixes will be assigned.')
vRtrIfDHCP6PfxDelegationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdPrefix"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdPrefixLen"))
if mibBuilder.loadTexts: vRtrIfDHCP6PfxDelegationEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxDelegationEntry.setDescription('Each row entry represents a delegated IPv6 prefix.\n         Entries can be created and deleted via SNMP SET operations.\n         Creation requires a SET request containing the vRtrRowStatus.')
vRtrIfDHCP6PfxdPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 1), InetAddressIPv6())
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdPrefix.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdPrefix.setDescription('The value of the object vRtrIfDHCP6PfxdPrefix specifies,\n         together with the object vRtrIfDHCP6PfxdPrefixLen the ipv6\n         prefix that will be delegated.')
vRtrIfDHCP6PfxdPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 2), InetAddressPrefixLength())
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdPrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdPrefixLen.setDescription('The value of the object vRtrIfDHCP6PfxdPrefixLen specifies,\n         together with the object vRtrIfDHCP6PfxdPrefix the ipv6\n         prefix that will be delegated by this system.')
vRtrIfDHCP6PfxdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdRowStatus.setDescription('The value of the object vRtrIfDHCP6PfxdRowStatus specifies the\n         Row status of this table row. This object is used to create or\n         delete rows in this table.\n\n         The only allowed values for this object are: active(1),\n         createAndGo(4), and destroy(6).')
vRtrIfDHCP6PfxdLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdLastChanged.setDescription('The value of vRtrIfDHCP6PfxdLastChanged indicates the sysUpTime\n         when any object of the row is last changed.')
vRtrIfDHCP6PfxdDUID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdDUID.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdDUID.setDescription('The value of the object vRtrIfDHCP6PfxdDUID specifies\n         the ID of the requesting router. If set to a non zero value\n         the prefix defined in this row will only be delegated to this\n         router. If set to zero, the prefix will be delegated to any\n         requesting router.')
vRtrIfDHCP6PfxdIAID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdIAID.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdIAID.setDescription('The value of the object vRtrIfDHCP6PfxdIAID specifies\n         the IAID from the requesting router\n         that needs to match in order to delegate the prefix defined\n         in this row.If set to 0 no match on the received IAID is done.')
vRtrIfDHCP6PfxdPrefLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(604800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdPrefLifetime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdPrefLifetime.setDescription('The value of the object vRtrIfDHCP6PfxdPrefLifetime specifies\n         the time in seconds that this prefix remains preferred.\n\n         The value of vRtrIfDHCP6PfxdPrefLifetime cannot be bigger then\n         the value of vRtrIfDHCP6PfxdValidLifetime.\n\n         The value 4294967295 is considered equal to infinity.')
vRtrIfDHCP6PfxdValidLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 40, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(2592000)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdValidLifetime.setStatus('current')
if mibBuilder.loadTexts: vRtrIfDHCP6PfxdValidLifetime.setDescription('The value of the object vRtrIfDHCP6PfxdValidLifetime specifies\n         the time in seconds that the prefix is valid.\n         The value 4294967295 is considered equal to infinity.')
vRtrDHCP6DropStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 41), )
if mibBuilder.loadTexts: vRtrDHCP6DropStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6DropStatTable.setDescription('The vRtrDHCP6DropStatTable has an entry for each virtual router\n         configured in the system.')
vRtrDHCP6DropStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 41, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6DropStatReason"))
if mibBuilder.loadTexts: vRtrDHCP6DropStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6DropStatEntry.setDescription('Each row entry represents a collection of DHCP6 drop reason\n         statistics for a virtual router in the system.\n\n        Entries cannot be created and deleted via SNMP SET operations.')
vRtrDHCP6DropStatReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 41, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("none", 0), ("srcOperDown", 1), ("dstOperDown", 2), ("rlyReplyOnClientItf", 3), ("hopCount", 4), ("badRelayedMsg", 5), ("clientItfNotFound", 6), ("noMemory", 7), ("noGlobalPfx", 8), ("noSrcIp", 9), ("noRteToServer", 10), ("subMgmtUpdFail", 11), ("relayForw", 12), ("msgTooSmall", 13), ("msgNotForServer", 14), ("noServerId", 15), ("noClientId", 16), ("serverIdInClientMsg", 17), ("wrongServerId", 18), ("illegalUnicast", 19), ("illegalSrcIp", 20), ("pdMsgNotSupported", 21), ("nbrAddrsExceeded", 22), ("clientMacNotResolved", 23), ("illegalAssignedAddr", 24), ("msgEncodingError", 25))))
if mibBuilder.loadTexts: vRtrDHCP6DropStatReason.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6DropStatReason.setDescription("The object vRtrDHCP6DropStatReason indicates the drop reason for\n         which the object vRtrDHCP6DropStatPktsDropped contains the counter.\n         none\n         srcOperDown            Dhcp6 oper state is not Up on src itf\n         dstOperDown            Dhcp6 oper state is not Up on dst itf\n         rlyReplyOnClientItf    Relay Reply Msg on Client Itf\n         hopCount               Hop Count Limit reached\n         badRelayedMsg          Missing Relay Msg option, or illegal msg type\n         clientItfNotFound      Unable to determine destinatinon client Itf\n         noMemory               Out of Memory\n         noGlobalPfx            No global Pfx on Client Itf\n         noSrcIp                Unable to determine src Ip Addr\n         noRteToServer          No route to server\n         subMgmtUpdFail         Subscr. Mgmt. Update failed\n         relayForw              Received Relay Forw Message\n         msgTooSmall            Packet too small to contain valid dhcp6 msg\n         msgNotForServer        Server cannot respond to this message\n         noServerId             No Server Id option in msg from server\n         noClientId             No Client Id option in msg from client\n         serverIdInClientMsg    Server Id option in client msg\n         wrongServerId          Server DUID in client msg does not match ours\n         illegalUnicast         Client sent message to unicast while not\n                                allowed\n         illegalSrcIp           Client sent message with illegal src Ip\n         pdMsgNotSupported      Client message type not supported in\n                                pfx delegation\n         nbrAddrsExceeded       Nbr of addrs or pfxs exceeds allowed\n                                maximum in msg\n         clientMacNotResolved   Unable to resolve client's mac address\n         illegalAssignedAddr    The client was assigned an illegal address\n         msgEncodingError       Illegal pfx length in a IA_PREFIX option\n        ")
vRtrDHCP6DropStatLastCleared = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 41, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDHCP6DropStatLastCleared.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6DropStatLastCleared.setDescription('The value of vRtrDHCP6DropStatLastCleared indicates the sysUpTime\n         when the counters of this row were last reset. A value of zero for\n         this object indicates that the counters have not been reset since the\n         system has last been initialized.')
vRtrDHCP6DropStatPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 41, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDHCP6DropStatPktsDropped.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6DropStatPktsDropped.setDescription('The value of vRtrDHCP6DropStatPktsDropped indicates the number of\n         DHCP6 packets were dropped for the reason described in\n         vRtrDHCP6DropStatReason.')
vRtrDHCP6MsgStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 42), )
if mibBuilder.loadTexts: vRtrDHCP6MsgStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6MsgStatTable.setDescription('The vRtrDHCP6MsgStatTable has an entry for each virtual router\n         configured in the system.')
vRtrDHCP6MsgStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 42, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsMsgType"))
if mibBuilder.loadTexts: vRtrDHCP6MsgStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6MsgStatEntry.setDescription('Each row entry represents a collection of counters for each DHCP6\n         message type for a virtual router in the system.\n\n        Entries cannot be created and deleted via SNMP SET operations.')
vRtrDHCP6MsgStatsMsgType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 42, 1, 1), TmnxDHCP6MsgType())
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsMsgType.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsMsgType.setDescription('The object vRtrDHCP6MsgStatsMsgType indicates the DHCP6 message type\n         for which statistics are kept on a per vrtr basis.')
vRtrDHCP6MsgStatsLstClrd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 42, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsLstClrd.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsLstClrd.setDescription('The value of vRtrDHCP6MsgStatsLstClrd indicates the sysUpTime\n         when the counters of this row were last reset. A value of zero for\n         this object indicates that the counters have not been reset since the\n         system has last been initialized.')
vRtrDHCP6MsgStatsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 42, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsRcvd.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsRcvd.setDescription('The value of vRtrDHCP6MsgStatsRcvd indicates the number of\n         DHCP6 packets were received of the DHCP6 message type indicated by\n         vRtrDHCP6MsgStatsMsgType.')
vRtrDHCP6MsgStatsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 42, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsSent.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsSent.setDescription('The value of vRtrDHCP6MsgStatsSent indicates the number of\n         DHCP6 packets were sent of the DHCP6 message type indicated by\n         vRtrDHCP6MsgStatsMsgType.')
vRtrDHCP6MsgStatsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 42, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsDropped.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6MsgStatsDropped.setDescription('The value of vRtrDHCP6MsgStatsDropped indicates the number of\n         DHCP6 packets were dropped of the DHCP6 message type indicated by\n         vRtrDHCP6MsgStatsMsgType.')
vRtrIfIpcpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43), )
if mibBuilder.loadTexts: vRtrIfIpcpTable.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpTable.setDescription('The vRtrIfIpcpTable table contains the configuration for\n         IPCP interface configuration on the vRtrIfEntry\n         with the same indices.')
vRtrIfIpcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43, 1), )
vRtrIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIpcpEntry"))
vRtrIfIpcpEntry.setIndexNames(*vRtrIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrIfIpcpEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpEntry.setDescription('Each row entry represents the IPCP configuration for an\n         interface. Entries are created and deleted when entries\n         in the vRtrIfTable are created and deleted.')
vRtrIfIpcpPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43, 1, 1), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIpcpPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpPeerAddrType.setDescription("The value of vRtrIfIpcpPeerAddrType specifies the type of\n         vRtrIfIpcpPeerAddr, the remote peer's IP address.         \n         \n         vRtrIfIpcpPeerAddrType can be set to non-default only when the \n         following rules are met for objects in vRtrIfEntry with the same \n         indices:\n          - The value of vRtrIfType is set to serviceIes(3) or serviceVprn(5)\n          - The value of tmnxPortEncapType in tmnxPortEntry indexed using\n            the value of vRtrIfPortID is set to unknown (0) or nullEncap (1) \n            or ipcpEncap (6)\n         \n         When the value of vRtrIfIpcpPeerAddrType is unknown, the value of \n         vRtrIfIpcpPeerAddr is assumed to be of size 0.")
vRtrIfIpcpPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIpcpPeerAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpPeerAddr.setDescription("The value of vRtrIfIpcpPeerAddr specifies the IP address that will\n         be exchanged by IPCP, if applicable on a given interface, to configure\n         the remote peer's IP address. The type of this address is specified \n         by the value of vRtrIfIpcpPeerAddrType\n         \n         vRtrIfIpcpPeerAddr can be set to on-default only when the following \n         rules are met for objects in vRtrIfEntry with the same indices:\n          - The value of vRtrIfType is set to serviceIes(3) or serviceVprn(5)\n          - The value of tmnxPortEncapType in tmnxPortEntry indexed using\n            the value of vRtrIfPortID is set to unknown (0) or nullEncap (1)\n            or ipcpEncap (6)")
vRtrIfIpcpPriDnsAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43, 1, 3), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIpcpPriDnsAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpPriDnsAddrType.setDescription('The value of vRtrIfIpcpPriDnsAddrType specifies the type of\n         vRtrIfIpcpPriDnsAddr, the IP address of the primary DNS to be used \n         by the remote peer.         \n         \n         vRtrIfIpcpPriDnsAddrType can be set ito non-default only when the \n         following rules are met for objects in vRtrIfEntry with the same \n         indices:\n          - The value of vRtrIfType is set to serviceIes(3) or serviceVprn(5)\n          - The value of tmnxPortEncapType in tmnxPortEntry indexed using\n            the value of vRtrIfPortID is set to unknown (0) or nullEncap (1) \n            or ipcpEncap (6)\n \n         When the value of vRtrIfIpcpPriDnsAddrType is unknown, the value of \n         vRtrIfIpcpPriDnsAddr is assumed to be of size 0.')
vRtrIfIpcpPriDnsAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIpcpPriDnsAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpPriDnsAddr.setDescription("The value of vRtrIfIpcpPriDnsAddr specifies the IP address that will\n         be exchanged by IPCP, if applicable on a given interface, to configure\n         the primary DNS's IP address on the remote peer. The type of this \n         address is specified by the value of vRtrIfIpcpPriDnsAddrType\n         \n         vRtrIfIpcpPriDnsAddr can be set to non-default only when the following \n         rules are met for objects in vRtrIfEntry with the same indices:\n          - The value of vRtrIfType is set to serviceIes(3) or serviceVprn(5)\n          - The value of tmnxPortEncapType in tmnxPortEntry indexed using\n            the value of vRtrIfPortID is set to unknown (0) or nullEncap (1)\n            or ipcpEncap (6)")
vRtrIfIpcpSecDnsAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43, 1, 5), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIpcpSecDnsAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpSecDnsAddrType.setDescription('The value of vRtrIfIpcpSecDnsAddrType specifies the type of\n         vRtrIfIpcpSecDnsAddr, the IP address of the secondary DNS to be used \n         by the remote peer.         \n         \n         vRtrIfIpcpSecDnsAddrType can be set to non-deffault only when the \n         following rules are met for objects in vRtrIfEntry with the same \n         indices:\n          - The value of vRtrIfType is set to serviceIes(3) or serviceVprn(5)\n          - The value of tmnxPortEncapType in tmnxPortEntry indexed using\n            the value of vRtrIfPortID is set to unknown (0) or nullEncap (1) \n            or ipcpEncap (6)\n          \n         When the value of vRtrIfIpcpSecDnsAddrType is unknown, the value of \n         vRtrIfIpcpSecDnsAddr is assumed to be of size 0.')
vRtrIfIpcpSecDnsAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 43, 1, 6), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrIfIpcpSecDnsAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrIfIpcpSecDnsAddr.setDescription("The value of vRtrIfIpcpSecDnsAddr specifies the IP address that will\n         be exchanged by IPCP, if applicable on a given interface, to configure\n         the secondary DNS's IP address on the remote peer. The type of this \n         address is specified by the value of vRtrIfIpcpSecDnsAddrType.\n         \n         vRtrIfIpcpSecDnsAddr can be set to non-default only when the following \n         rules are met for objects in vRtrIfEntry with the same indices:\n          - The value of vRtrIfType is set to serviceIes(3) or serviceVprn(5)\n          - The value of tmnxPortEncapType in tmnxPortEntry indexed using\n            the value of vRtrIfPortID is set to unknown (0) or nullEncap (1)\n            or ipcpEncap (6)")
vRtrInetStatRteCpeChkStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44), )
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkStatsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkStatsTable.setDescription('The vRtrInetStatRteCpeChkStatsTable has an entry for each entry\n         in the vRtrInetStaticRouteTable that has a non-default values set\n         for the vRtrInetStaticRouteCpeAddrType and vRtrInetStaticRouteCpeAddr\n         objects.')
vRtrInetStatRteCpeChkStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDestType"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDest"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDestPfxLen"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteIndex"))
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkStatsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkStatsEntry.setDescription('Each row entry represents a collection of\n         Customer-Provided Equipment (CPE) availability statistics\n         for a virtual router static route in the system with non-default\n         values set for the vRtrInetStaticRouteCpeAddrType and\n         vRtrInetStaticRouteCpeAddr objects.\n\n         Entries cannot be created and deleted via SNMP SET operations.')
vRtrInetStatRteCpeChkUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkUpTime.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkUpTime.setDescription('The value of vRtrInetStatRteCpeChkUpTime indicates\n         how long (in hundredths of a second) that the CPE has been\n         available.')
vRtrInetStatRteCpeChkInPktCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkInPktCnt.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkInPktCnt.setDescription('The value of vRtrInetStatRteCpeChkInPktCnt indicates the \n         number of echo-reply packets received.')
vRtrInetStatRteCpeChkOutPktCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkOutPktCnt.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkOutPktCnt.setDescription('The value of vRtrInetStatRteCpeChkOutPktCnt indicates the \n         number of echo-request packets sent.')
vRtrInetStatRteCpeChkDownTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkDownTrans.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkDownTrans.setDescription('The value of vRtrInetStatRteCpeChkDownTrans indicates the number of\n         times the CPE has transitioned to the unavailable state.')
vRtrInetStatRteCpeChkUpTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkUpTrans.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkUpTrans.setDescription('The value of vRtrInetStatRteCpeChkUpTrans indicates the number of\n         times the CPE has transitioned to the available state.')
vRtrInetStatRteCpeChkTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 44, 1, 6), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkTTL.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeChkTTL.setDescription('The value of vRtrInetStatRteCpeChkTTL indicates the time, in seconds,\n         before the CPE will be declared down. Upon receipt of an echo\n         reply, it has the value of \n         vRtrInetStaticRouteCpeInterval * vRtrInetStaticRouteCpeDropCnt and is\n         decremented by 1 every second.')
tmnxDscpAppTableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 45), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDscpAppTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpAppTableLastChanged.setDescription('The value of tmnxDscpAppTableLastChanged indicates the sysUpTime\n         at the time of the last modification of tmnxDscpAppTable.\n\n         If no changes were made to the table since the last\n         re-initialization of the local network management subsystem,\n         then this object contains a zero value.')
tmnxDscpAppTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 46), )
if mibBuilder.loadTexts: tmnxDscpAppTable.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpAppTable.setDescription('The tmnxDscpAppTable has an entry for each application to\n         Differential Services Code Point (DSCP) mapping in a\n         virtual routing context on this system.')
tmnxDscpAppEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 46, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpAppId"))
if mibBuilder.loadTexts: tmnxDscpAppEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpAppEntry.setDescription('Each row represents a mapping from an application to a DSCP\n         value for particular virtual routing context.\n\n         Entries are created at system initialization.')
tmnxDscpAppId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 46, 1, 1), TDSCPAppId())
if mibBuilder.loadTexts: tmnxDscpAppId.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpAppId.setDescription('The value of tmnxDscpAppId indicates the DSCP application identifier\n         for a protocol on the Alcatel 7x50 SR router which generates\n         control traffic over IP.')
tmnxDscpAppLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 46, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDscpAppLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpAppLastChanged.setDescription('The value of tmnxDscpAppLastChanged indicates the sysUpTime\n         at the time of the last modification of this entry.\n\n         If no changes were made to the entry since the last\n         re-initialization of the local network management subsystem,\n         then this object contains a zero value.')
tmnxDscpAppDscpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 46, 1, 3), TDSCPValueOrNone()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxDscpAppDscpValue.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpAppDscpValue.setDescription('The value of tmnxDscpAppDscpValue specifies a DSCP Value\n         to assign to the traffic generated by the application\n         specified by tmnxDscpAppId.\n\n         A value of -1 specifies that no explicit DSCP re-marking\n         will be done for the traffic generated by the application\n         specified by tmnxDscpAppId.\n\n         The default value is protocol specific.')
tmnxDscpFCTableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 47), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDscpFCTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpFCTableLastChanged.setDescription('The value of tmnxDscpFCTableLastChanged indicates the sysUpTime\n         at the time of the last modification of tmnxDscpFCTable.\n\n         If no changes were made to the entry since the last\n         re-initialization of the local network management subsystem,\n         then this object contains a zero value.')
tmnxDscpFCTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 48), )
if mibBuilder.loadTexts: tmnxDscpFCTable.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpFCTable.setDescription('The tmnxDscpFCTable has an entry for each mapping between\n         a DSCP value and a Forwarding Class for self-generated\n         protocol traffic in a virtual routing context on this system.')
tmnxDscpFCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 48, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpFCDscpValue"))
if mibBuilder.loadTexts: tmnxDscpFCEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpFCEntry.setDescription('Each row represents a mapping between a DSCP value and a\n         Forwarding Class for self-generated protocol traffic\n         in particular virtual routing context.\n\n         Entries are created at system initialization.')
tmnxDscpFCDscpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 48, 1, 1), TDSCPValue())
if mibBuilder.loadTexts: tmnxDscpFCDscpValue.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpFCDscpValue.setDescription('The value of tmnxDscpFCDscpValue specifies a DSCP value which\n         will be mapped to the Forwarding Class specified by\n         tmnxDscpFCValue.')
tmnxDscpFCLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 48, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDscpFCLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpFCLastChanged.setDescription('The value of tmnxDscpFCLastChanged indicates the sysUpTime\n         at the time of the last modification of this entry.\n\n         If no changes were made to the entry since the last\n         re-initialization of the local network management subsystem,\n         then this object contains a zero value.')
tmnxDscpFCValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 48, 1, 4), TFCType().clone('be')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxDscpFCValue.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpFCValue.setDescription('The value of tmnxDscpFCValue specifies the Forwarding Class value\n         for this mapping entry.\n\n         The default value is best effort, which is specified by a value of 0.')
tmnxDot1pAppTableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 49), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDot1pAppTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxDot1pAppTableLastChanged.setDescription('The value of tmnxDot1pAppTableLastChanged indicates the\n         sysUpTime at the time of the last modification of\n         tmnxDot1pAppTable.\n\n         If no changes were made to the table since the last\n         re-initialization of the local network management\n         subsystem, then this object contains a zero value.')
tmnxDot1pAppTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 50), )
if mibBuilder.loadTexts: tmnxDot1pAppTable.setStatus('current')
if mibBuilder.loadTexts: tmnxDot1pAppTable.setDescription('The tmnxDot1pAppTable has an entry for each application to\n         IEEE 802.1p priority (Dot1p) mapping in a virtual routing\n         context on this system.')
tmnxDot1pAppEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 50, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDot1pAppId"))
if mibBuilder.loadTexts: tmnxDot1pAppEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxDot1pAppEntry.setDescription('Each row represents a mapping from an application to a Dot1p\n         value for particular virtual routing context.\n\n         Entries are created at system initialization.')
tmnxDot1pAppId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 50, 1, 1), TDot1pAppId())
if mibBuilder.loadTexts: tmnxDot1pAppId.setStatus('current')
if mibBuilder.loadTexts: tmnxDot1pAppId.setDescription('The value of tmnxDot1pAppId indicates the Dot1p application\n         identifier for a Layer-2 protocol on the Alcatel 7x50 SR router.')
tmnxDot1pAppLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 50, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxDot1pAppLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxDot1pAppLastChanged.setDescription('The value of tmnxDot1pAppLastChanged indicates the sysUpTime\n         at the time of the last modification of this entry.\n\n         If no changes were made to the entry since the last\n         re-initialization of the local network management subsystem,\n         then this object contains a zero value.')
tmnxDot1pAppValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 50, 1, 3), Dot1PPriority()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxDot1pAppValue.setStatus('current')
if mibBuilder.loadTexts: tmnxDot1pAppValue.setDescription('The value of tmnxDot1pAppValue specifies a Dot1p\n         value to assign to the traffic generated by the application\n         specified by tmnxDot1pAppId.\n\n         The default value is protocol specific.')
tmnxVRtrNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21))
vRtrAutoFilterDHCPClientAddress = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 1), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrAutoFilterDHCPClientAddress.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrAutoFilterDHCPClientAddress.setDescription("The Client IP address from the PDU causing the trap.\n         Used by tmnxVRtrDHCPAFEntriesExceeded to report\n         the client's IP address.")
vRtrAutoFilterDHCPClientLease = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 2), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrAutoFilterDHCPClientLease.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrAutoFilterDHCPClientLease.setDescription('The lease time specified in the PDU causing the trap.\n         Used by tmnxVRtrDHCPAFEntriesExceeded to report\n         the lease time.')
vRtrDHCPClientLease = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 3), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCPClientLease.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDHCPClientLease.setDescription('The value of the object vRtrDHCPClientLease indicates the\n                    lease time specified in the PDU causing the trap.')
vRtrDhcpLseStateOldCiAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 4), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpLseStateOldCiAddr.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpLseStateOldCiAddr.setDescription('The value of the object vRtrDhcpLseStateOldCiAddr indicates\n                    the Client IP address that was formerly assigned to this\n                    Least state.')
vRtrDhcpLseStateOldChAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 5), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpLseStateOldChAddr.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpLseStateOldChAddr.setDescription('The value of the object vRtrDhcpLseStateOldChAddr indicates\n                    the Client MAC address that was formerly assigned to this\n                    Least state.')
vRtrDhcpLseStateNewCiAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 6), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpLseStateNewCiAddr.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpLseStateNewCiAddr.setDescription('The value of the object vRtrDhcpLseStateNewCiAddr indicates\n                    the Client IP address specified in the PDU causing\n                    the trap.')
vRtrDhcpLseStateNewChAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 7), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpLseStateNewChAddr.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpLseStateNewChAddr.setDescription('The value of the object vRtrDhcpLseStateNewChAddr indicates\n                    the Client MAC address specified in the PDU causing\n                    the trap.')
vRtrDhcpRestoreLseStateCiAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 8), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateCiAddr.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateCiAddr.setDescription('The value of the object vRtrDhcpRestoreLseStateCiAddr indicates\n                    the IP address specified in the persistency record causing\n                    the trap.')
vRtrDhcpRestoreLseStateVRtrId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 9), TmnxVRtrID()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateVRtrId.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateVRtrId.setDescription('The value of the object vRtrDhcpRestoreLseStateVRtrId indicates\n                    the serviceId specified in the persistency record causing\n                    the trap.')
vRtrDhcpRestoreLseStateIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 10), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateIfIndex.setDescription('The value of the object vRtrDhcpRestoreLseStateIfIndex indicates\n                    the Port ID specified in the persistency record causing\n                    the trap.')
vRtrDhcpRestoreLseStateProblem = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 11), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateProblem.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpRestoreLseStateProblem.setDescription('The value of the object vRtrDhcpRestoreLseStateProblem\n                    indicates why the persisency record cannot be restored.')
vRtrDhcpPacketProblem = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 12), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpPacketProblem.setStatus('current')
if mibBuilder.loadTexts: vRtrDhcpPacketProblem.setDescription('The value of the object vRtrDhcpPacketProblem indicates\n                    information on a received DHCP packet is considered\n                    suspicious by the system.')
vRtrDhcpLseStatePopulateError = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 13), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDhcpLseStatePopulateError.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrDhcpLseStatePopulateError.setDescription('The value of the object vRtrDhcpLseStatePopulateError\n                    indicates the reason why the system was unable to update\n                    the Lease state table with the information contained in\n                    the received DHCP ACK message.')
vRtrBfdSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 14), TmnxSlotNum()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrBfdSlotNumber.setStatus('current')
if mibBuilder.loadTexts: vRtrBfdSlotNumber.setDescription('The value of vRtrBfdSlotNumber indicates the IOM slot\n                    number where the number of supported BFD sessions has\n                    reached the maximum value. This object is reported\n                    when the tmnxVRtrBfdMaxSessionOnSlot notification\n                    is generated.')
vRtrNumberOfBfdSessionsOnSlot = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 15), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrNumberOfBfdSessionsOnSlot.setStatus('current')
if mibBuilder.loadTexts: vRtrNumberOfBfdSessionsOnSlot.setDescription('The value of vRtrNumberOfBfdSessionsOnSlot indicates the\n                    current number of BFD sessions on the slot indicated by\n                    vRtrBfdSlotNumber. This object is reported when the\n                    tmnxVRtrBfdMaxSessionOnSlot notification is generated.')
vRtrBfdMaxSessionReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 16), Bits().clone(namedValues=NamedValues(("maxSessionsPerSlot", 0), ("maxTxPacketRate", 1), ("maxRxPacketRate", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrBfdMaxSessionReason.setStatus('current')
if mibBuilder.loadTexts: vRtrBfdMaxSessionReason.setDescription('The value of vRtrBfdMaxSessionReason indicates the\n                    reason the maximum numbers of sessions on this IOM\n                    slot was reached. This object is reported when the\n                    tmnxVRtrBfdMaxSessionOnSlot notification is\n                    generated.')
vRtrDHCP6ServerNetAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 17), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6ServerNetAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6ServerNetAddrType.setDescription('The value of the object vRtrDHCP6ServerNetAddrType\n                    indicates the address type of vRtrDHCP6ServerNetAddr.')
vRtrDHCP6ServerNetAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 18), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6ServerNetAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6ServerNetAddr.setDescription('The value of the object vRtrDHCP6ServerNetAddr\n                    indicates the IP address of the DHCP server.')
vRtrDHCP6ClientNetAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 19), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6ClientNetAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6ClientNetAddrType.setDescription('The value of the object vRtrDHCP6ClientNetAddrType\n                    indicates the address type of vRtrDHCP6ClientNetAddr.')
vRtrDHCP6ClientNetAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 20), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6ClientNetAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6ClientNetAddr.setDescription('The value of the object vRtrDHCP6ClientNetAddr\n                    indicates the IP address of the DHCP client.')
vRtrDHCP6AssignedNetAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 21), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6AssignedNetAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6AssignedNetAddrType.setDescription('The value of the object vRtrDHCP6AssignedNetAddrType\n                    indicates the address type of vRtrDHCP6AssignedNetAddr.')
vRtrDHCP6AssignedNetAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 22), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6AssignedNetAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6AssignedNetAddr.setDescription('The value of the object vRtrDHCP6AssignedNetAddr\n                    indicates the IP address assigned to the DHCP client.')
vRtrDHCP6AssignedPrefixLen = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 23), InetAddressPrefixLength()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6AssignedPrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6AssignedPrefixLen.setDescription('The value of vRtrDHCP6AssignedPrefixLen specifies\n                    the length of the IP netmask for vRtrDHCP6AssignedNetAddr.')
vRtrDHCP6OldAssignedNetAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 24), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6OldAssignedNetAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6OldAssignedNetAddrType.setDescription('The value of the object vRtrDHCP6OldAssignedNetAddrType\n                    indicates the address type of vRtrDHCP6OldAssignedNetAddr.')
vRtrDHCP6OldAssignedNetAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 25), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6OldAssignedNetAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6OldAssignedNetAddr.setDescription('The value of the object vRtrDHCP6OldAssignedNetAddr\n                    indicates the IP address formerly assigned to the DHCP\n                    client.')
vRtrDHCP6OldAssignedPrefixLen = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 26), InetAddressPrefixLength()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6OldAssignedPrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6OldAssignedPrefixLen.setDescription('The value of vRtrDHCP6OldAssignedPrefixLen specifies the\n                    length of the IP netmask for vRtrDHCP6OldAssignedNetAddr.')
vRtrDHCP6NewClientId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6NewClientId.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6NewClientId.setDescription('The value of vRtrDHCP6NewClientId indicates the new\n                     DHCP6 clients unique identifier (DUID).')
vRtrDHCP6OldClientId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6OldClientId.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6OldClientId.setDescription('The value of vRtrDHCP6OldClientId indicates the old\n                     DHCP6 clients unique identifier (DUID).')
vRtrDHCP6LeaseOverrideResult = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 29), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrDHCP6LeaseOverrideResult.setStatus('current')
if mibBuilder.loadTexts: vRtrDHCP6LeaseOverrideResult.setDescription('The value of the object vRtrDHCP6LeaseOverrideResult\n                     indicates whether or not the lease state has been\n                     overridden.')
vRtrInetStatRteCpeNotifyAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 30), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrInetStatRteCpeNotifyAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeNotifyAddrType.setDescription('The value of the object vRtrInetStatRteCpeNotifyAddrType\n                    indicates the address type of\n                    vRtrInetStatRteCpeNotifyAddr.')
vRtrInetStatRteCpeNotifyAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 31), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrInetStatRteCpeNotifyAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStatRteCpeNotifyAddr.setDescription('The value of the object vRtrInetStatRteCpeNotifyAddr\n                    indicates the IP address of the CPE.')
vRtrInetStaticRouteCpeStatus = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("reachable", 0), ("unreachable", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrInetStaticRouteCpeStatus.setDescription("The value of the object vRtrInetStaticRouteCpeStatus\n                     indicates whether or not the CPE associated with a\n                     static route is 'reachable' or 'unreachable'.")
vRtrManagedRouteInetAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 33), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrManagedRouteInetAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrManagedRouteInetAddrType.setDescription('The value of vRtrManagedRouteInetAddrType indicates\n                     the address type of vRtrManagedRouteInetAddr.')
vRtrManagedRouteInetAddr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 34), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrManagedRouteInetAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrManagedRouteInetAddr.setDescription('The value of vRtrManagedRouteInetAddr indicates\n                     the IP address of the managed route.')
vRtrManagedRoutePrefixLen = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 35), InetAddressPrefixLength()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrManagedRoutePrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrManagedRoutePrefixLen.setDescription('The value of vRtrManagedRoutePrefixLen indicates\n                     the prefix length of the subnet associated with\n                     vRtrManagedRouteInetAddr.')
vRtrFailureDescription = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 3, 21, 36), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrFailureDescription.setStatus('current')
if mibBuilder.loadTexts: vRtrFailureDescription.setDescription('The value of the object vRtrFailureDescription is a\n                     printable character string which contains information\n                     about the reason why the notification is sent.')
tmnxVRtrMidRouteTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 1)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMidRouteThreshold"))
if mibBuilder.loadTexts: tmnxVRtrMidRouteTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrMidRouteTCA.setDescription('The tmnxVRtrMidRouteTCA notification is generated when the number\n         of routes contained in a VPRN exceeds the value specified by\n         vRtrMidRouteThreshold.  No other notifications of this type\n         are generated until after the soak period specified by\n         vRtrRouteThresholdSoakTime has expired.')
tmnxVRtrHighRouteTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 2)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrHighRouteThreshold"))
if mibBuilder.loadTexts: tmnxVRtrHighRouteTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrHighRouteTCA.setDescription('The tmnxVRtrHighRouteTCA notification is generated when the number\n         of routes contained in a VPRN exceeds the value specified by\n         vRtrHighRouteThreshold.  No other notifications of this type\n         are generated until after the soak period specified by\n         vRtrRouteThresholdSoakTime has expired.')
tmnxVRtrHighRouteCleared = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 3)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrHighRouteThreshold"))
if mibBuilder.loadTexts: tmnxVRtrHighRouteCleared.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrHighRouteCleared.setDescription('The tmnxVRtrHighRouteCleared notification is generated when the\n         number of routes contained in a VPRN has dropped below the\n         vRtrHighRouteThreshold value following the generation of a\n         tmnxVRtrHighRouteTCA notification.')
tmnxVRtrIllegalLabelTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 4)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatIllegalLabels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIllegalLabelThreshold"))
if mibBuilder.loadTexts: tmnxVRtrIllegalLabelTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIllegalLabelTCA.setDescription('The tmnxVRtrIllegalLabelTCA notification is generated when the\n         number of illegal label violations on a VRF has exceeded the\n         value specified by vRtrIllegalLabelThreshold.')
tmnxVRtrMcastMidRouteTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 5)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMulticastRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMcastMidRouteThreshold"))
if mibBuilder.loadTexts: tmnxVRtrMcastMidRouteTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrMcastMidRouteTCA.setDescription('The tmnxVRtrMcastMidRouteTCA notification is generated when the number\n         of multicast routes contained in a VPRN exceeds the value specified by\n         vRtrMcastMidRouteThreshold.  No other notifications of this type\n         are generated until after the soak period specified by\n         vRtrRouteThresholdSoakTime has expired.')
tmnxVRtrMcastMaxRoutesTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 6)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMulticastRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutes"))
if mibBuilder.loadTexts: tmnxVRtrMcastMaxRoutesTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrMcastMaxRoutesTCA.setDescription('The tmnxVRtrMcastMaxRoutesTCA notification is generated when the number\n         of multicast routes contained in a VPRN exceeds the value specified by\n         vRtrMaxMcastNumRoutes.  No other notifications of this type\n         are generated until after the soak period specified by\n         vRtrRouteThresholdSoakTime has expired.')
tmnxVRtrMcastMaxRoutesCleared = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 7)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMulticastRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutes"))
if mibBuilder.loadTexts: tmnxVRtrMcastMaxRoutesCleared.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrMcastMaxRoutesCleared.setDescription('The tmnxVRtrMcastMaxRoutesCleared notification is generated when the\n         number of multicast routes contained in a VPRN has dropped below the\n         vRtrMaxMcastNumRoutes value following the generation of a\n         tmnxVRtrMcastMaxRoutesTCA notification.')
tmnxVRtrMaxArpEntriesTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 8)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxARPEntries"))
if mibBuilder.loadTexts: tmnxVRtrMaxArpEntriesTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrMaxArpEntriesTCA.setDescription('The tmnxVRtrMaxArpEntriesTCA notification is generated when the\n         number of ARP entries in a VPRN exceeds the maximum supported.')
tmnxVRtrMaxArpEntriesCleared = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 9)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxARPEntries"))
if mibBuilder.loadTexts: tmnxVRtrMaxArpEntriesCleared.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrMaxArpEntriesCleared.setDescription('The tmnxVRtrMaxArpEntriesCleared notification is generated when the\n         number of ARP entries contained in a VPRN has dropped below the\n         maximum value following the generation of a tmnxVRtrMaxArpEntriesTCA\n         notification.')
tmnxVRtrDHCPAFEntriesExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 10)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPOperAutoFilter"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAutoFilterDHCPClientAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAutoFilterDHCPClientLease"))
if mibBuilder.loadTexts: tmnxVRtrDHCPAFEntriesExceeded.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrDHCPAFEntriesExceeded.setDescription("The tmnxVRtrDHCPAFEntriesExceeded notification is generated\n        when the number of DHCP 'AutoFilter' entries on a given interface\n        reaches a user configurable upper limit given by vRtrIfDHCPAutoFilter.")
tmnxVRtrMaxRoutes = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 11)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxNumRoutes"))
if mibBuilder.loadTexts: tmnxVRtrMaxRoutes.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrMaxRoutes.setDescription('The tmnxVRtrMaxRoutes notification is\n                     generated when the number of routes contained in a\n                     VPRN reaches the value specified by vRtrMaxNumRoutes.')
tmnxVRtrDHCPLseStsExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 12)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateNewCiAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateNewChAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCPClientLease"))
if mibBuilder.loadTexts: tmnxVRtrDHCPLseStsExceeded.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrDHCPLseStsExceeded.setDescription('The tmnxVRtrDHCPLseStsExceeded notification is\n                     generated when the number  of  DHCP  lease states\n                     entries on a given interface reaches a user configurable\n                     upper limit.')
tmnxVRtrDHCPLeaseStateOverride = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 13)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateNewCiAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateNewChAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateOldCiAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateOldChAddr"))
if mibBuilder.loadTexts: tmnxVRtrDHCPLeaseStateOverride.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrDHCPLeaseStateOverride.setDescription('The tmnxVRtrDHCPLeaseStateOverride notification is\n                     generated when an existing DHCP lease state is\n                     overridden by a new lease state which has the same\n                     IP address but a different MAC address.')
tmnxVRtrDHCPSuspiciousPcktRcvd = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 14)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpPacketProblem"))
if mibBuilder.loadTexts: tmnxVRtrDHCPSuspiciousPcktRcvd.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCPSuspiciousPcktRcvd.setDescription('The tmnxVRtrDHCPSuspiciousPcktRcvd notification is\n                     generated when a DHCP packet is received with suspicious\n                     content.')
tmnxVRtrDHCPLseStRestoreProblem = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 15)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateVRtrId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateCiAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateProblem"))
if mibBuilder.loadTexts: tmnxVRtrDHCPLseStRestoreProblem.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrDHCPLseStRestoreProblem.setDescription('The tmnxVRtrDHCPLseStRestoreProblem notification is\n                     generated when an an error is detected while\n                     processing a persistency record.')
tmnxVRtrDHCPLseStatePopulateErr = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 16)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStatePopulateError"))
if mibBuilder.loadTexts: tmnxVRtrDHCPLseStatePopulateErr.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrDHCPLseStatePopulateErr.setDescription('The tmnxVRtrDHCPLseStatePopulateErr notification\n                     indicates that the system was unable to update the\n                     Lease State Table with the information contained in\n                     the DHCP ACK message. The DHCP ACK message has been\n                     discarded.')
tmnxVRtrBfdSessionDown = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 17)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclDisc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionOperFlags"))
if mibBuilder.loadTexts: tmnxVRtrBfdSessionDown.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrBfdSessionDown.setDescription('The tmnxVRtrBfdSessionDown notification is generated when\n                     a BFD session goes down.')
tmnxVRtrBfdMaxSessionOnSlot = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 18)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBfdSlotNumber"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNumberOfBfdSessionsOnSlot"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBfdMaxSessionReason"))
if mibBuilder.loadTexts: tmnxVRtrBfdMaxSessionOnSlot.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrBfdMaxSessionOnSlot.setDescription("The tmnxVRtrBfdMaxSessionOnSlot notification is generated\n                     when the maximum number of BFD sessions has been reached\n                     on the slot indicated in 'vRtrBfdSlotNumber'.")
tmnxVRtrBfdPortTypeNotSupported = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 19)).setObjects(("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortNotifyPortId"), ("ALCATEL-IND1-TIMETRA-PORT-MIB", "tmnxPortType"))
if mibBuilder.loadTexts: tmnxVRtrBfdPortTypeNotSupported.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrBfdPortTypeNotSupported.setDescription("The tmnxVRtrBfdPortTypeNotSupported notification is\n                     generated when BFD is not supported on the port specified\n                     in 'tmnxPortNotifyPortId'.")
tmnxVRtrDHCPIfLseStatesExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 20)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-SAP-MIB", "sapPortId"), ("ALCATEL-IND1-TIMETRA-SAP-MIB", "sapEncapValue"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLeasePopulate"), ("ALCATEL-IND1-TIMETRA-SERV-MIB", "svcDhcpLseStateNewCiAddr"), ("ALCATEL-IND1-TIMETRA-SERV-MIB", "svcDhcpLseStateNewChAddr"), ("ALCATEL-IND1-TIMETRA-SERV-MIB", "svcDhcpClientLease"))
if mibBuilder.loadTexts: tmnxVRtrDHCPIfLseStatesExceeded.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCPIfLseStatesExceeded.setDescription('The tmnxVRtrDHCPIfLseStatesExceeded notifications is\n                     generated when the number of lease states on an interface\n                     exceeds vRtrIfDHCPLeasePopulate.')
tmnxVRtrDHCP6RelayLseStExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 21)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6LeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6NewClientId"), ("ALCATEL-IND1-TIMETRA-SERV-MIB", "svcDhcpClientLease"))
if mibBuilder.loadTexts: tmnxVRtrDHCP6RelayLseStExceeded.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCP6RelayLseStExceeded.setDescription('The tmnxVRtrDHCP6RelayLseStExceeded notifications is\n                     generated when the number of lease states populated by\n                     dhcp6 relay on an interface exceeds\n                     vRtrIfDHCP6LeasePopulate.')
tmnxVRtrDHCP6ServerLseStExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 22)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6ServerMaxLeaseStates"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6NewClientId"), ("ALCATEL-IND1-TIMETRA-SERV-MIB", "svcDhcpClientLease"))
if mibBuilder.loadTexts: tmnxVRtrDHCP6ServerLseStExceeded.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCP6ServerLseStExceeded.setDescription('The tmnxVRtrDHCP6ServerLseStExceeded notifications is\n                     generated when the number of lease states populated by\n                     dhcp6 server on an interface exceeds\n                     vRtrIfDHCP6ServerMaxLeaseStates.')
tmnxVRtrDHCP6LseStateOverride = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 23)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateOldChAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldClientId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateNewChAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6NewClientId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6LeaseOverrideResult"))
if mibBuilder.loadTexts: tmnxVRtrDHCP6LseStateOverride.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCP6LseStateOverride.setDescription('The tmnxVRtrDHCP6LseStateOverride notifications is\n                     generated when an existing DHCP6 lease state can be\n                     overridden by a new lease state.\n\n                     This is allowed if the new lease state has the same IP\n                     address but a different client id or mac address.\n                     This is not allowed if the new lease state has the same IP\n                     address but a different prefix length.')
tmnxVRtrDHCP6RelayReplyStripUni = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 24)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ServerNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ServerNetAddr"))
if mibBuilder.loadTexts: tmnxVRtrDHCP6RelayReplyStripUni.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCP6RelayReplyStripUni.setDescription('The tmnxVRtrDHCP6RelayReplyStripUni notifications is\n                     generated when a unicast option is stripped from a message\n                     relayed from a server to a client\n                     in a relay reply message.')
tmnxVRtrDHCP6IllegalClientAddr = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 25)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddr"))
if mibBuilder.loadTexts: tmnxVRtrDHCP6IllegalClientAddr.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCP6IllegalClientAddr.setDescription("The tmnxVRtrDHCP6IllegalClientAddr notifications is\n                     generated when an incoming message is dropped\n                     because the client's source IP does not match the subnet\n                     of the incoming interface.")
tmnxVRtrDHCP6AssignedIllegSubnet = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 26)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedPrefixLen"))
if mibBuilder.loadTexts: tmnxVRtrDHCP6AssignedIllegSubnet.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCP6AssignedIllegSubnet.setDescription('The tmnxVRtrDHCP6AssignedIllegSubnet notifications is\n                     generated when an IP address assigned to the client\n                     does not match the subnet of the interface.')
tmnxVRtrDHCP6ClientMacUnresolved = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 27)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddr"))
if mibBuilder.loadTexts: tmnxVRtrDHCP6ClientMacUnresolved.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrDHCP6ClientMacUnresolved.setDescription("The tmnxVRtrDHCP6ClientMacUnresolved notifications is\n                     generated when we receive a relay reply for a client,\n                     and the client's MAC address has not been resolved yet.")
tmnxVRtrBfdSessionUp = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 28)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclDisc"))
if mibBuilder.loadTexts: tmnxVRtrBfdSessionUp.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrBfdSessionUp.setDescription('The tmnxVRtrBfdSessionUp notification is generated when\n                     a BFD session goes up.')
tmnxVRtrIPv6MidRouteTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 29)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6MidRouteThreshold"))
if mibBuilder.loadTexts: tmnxVRtrIPv6MidRouteTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIPv6MidRouteTCA.setDescription('The tmnxVRtrIPv6MidRouteTCA notification is generated when\n                     the number of IPv6 routes contained in a VPRN exceeds\n                     the value specified by vRtrIPv6MidRouteThreshold. No other\n                     notifications of this type are generated until after the\n                     soak period specified by vRtrIPv6RouteThresholdSoakTime\n                     has expired.')
tmnxVRtrIPv6HighRouteTCA = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 30)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6HighRouteThreshold"))
if mibBuilder.loadTexts: tmnxVRtrIPv6HighRouteTCA.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIPv6HighRouteTCA.setDescription('The tmnxVRtrIPv6HighRouteTCA notification is generated when\n                     the number of IPv6 routes contained in a VPRN exceeds\n                     the value specified by vRtrIPv6HighRouteThreshold. No other\n                     notifications of this type are generated until after the\n                     soak period specified by vRtrIPv6RouteThresholdSoakTime\n                     has expired.')
tmnxVRtrIPv6HighRouteCleared = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 31)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6HighRouteThreshold"))
if mibBuilder.loadTexts: tmnxVRtrIPv6HighRouteCleared.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIPv6HighRouteCleared.setDescription('The tmnxVRtrIPv6HighRouteCleared notification is generated\n                     when the number of IPv6 routes contained in a VPRN has\n                     dropped below the vRtrIPv6HighRouteThreshold value\n                     following the generation of a tmnxVRtrIPv6HighRouteTCA\n                     notification.')
tmnxVRtrStaticRouteCPEStatus = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 32)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeNotifyAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeNotifyAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteCpeStatus"))
if mibBuilder.loadTexts: tmnxVRtrStaticRouteCPEStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrStaticRouteCPEStatus.setDescription('The tmnxVRtrStaticRouteCPEStatus notification is generated\n                     when a CPE associated with a static route, as specified\n                     by the vRtrInetStatRteCpeNotifyAddr object, becomes\n                     reachable or unreachable.')
tmnxVRtrBfdSessionDeleted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 33)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclDisc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionOperFlags"))
if mibBuilder.loadTexts: tmnxVRtrBfdSessionDeleted.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrBfdSessionDeleted.setDescription('The tmnxVRtrBfdSessionDeleted notification is generated when\n                     a BFD session is deleted.')
tmnxVRtrBfdSessionProtChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 34)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclDisc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionProtocols"))
if mibBuilder.loadTexts: tmnxVRtrBfdSessionProtChange.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrBfdSessionProtChange.setDescription('The tmnxVRtrBfdSessionProtChange notification is generated when\n                     there is a change in the list of protocols using the BFD session.')
tmnxVRtrManagedRouteAddFailed = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 3, 0, 35)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedRouteInetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedRouteInetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedRoutePrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrFailureDescription"))
if mibBuilder.loadTexts: tmnxVRtrManagedRouteAddFailed.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrManagedRouteAddFailed.setDescription('The tmnxVRtrManagedRouteAddFailed notification\n                     is generated when a managed route could not be installed.')
tmnxVRtrCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 1))
tmnxVRtrGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2))
tmnxVRtr7450V4v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 1, 4)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrGlobalR2r1Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIpV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrNotificationV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfSubscrAuthV3v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdV4v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtr7450V4v0Compliance = tmnxVRtr7450V4v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtr7450V4v0Compliance.setDescription('The compliance statement for management of VRTR instances\n             on Alcatel 7450 ESS series systems release R4.0.')
tmnxVRtr7750V4v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 1, 5)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrGlobalR2r1Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIpV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6V4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6IpV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6IfV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrNotificationV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfSubscrAuthV3v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdV4v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtr7750V4v0Compliance = tmnxVRtr7750V4v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtr7750V4v0Compliance.setDescription('The compliance statement for management of VRTR instances\n             on Alcatel 7750 SR series systems release R4.0.')
tmnxVRtr7450V5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 1, 6)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrGlobalR2r1Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIpV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrNotificationV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfSubscrAuthV3v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdV4v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtr7450V5v0Compliance = tmnxVRtr7450V5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtr7450V5v0Compliance.setDescription('The compliance statement for management of VRTR instances\n             on Alcatel 7450 ESS series systems release R5.0.')
tmnxVRtr7750V5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 1, 7)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrGlobalR2r1Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIpV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6V4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6IpV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6IfV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrNotificationV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfSubscrAuthV3v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdV4v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtr7750V5v0Compliance = tmnxVRtr7750V5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtr7750V5v0Compliance.setDescription('The compliance statement for management of VRTR instances\n             on Alcatel 7750 SR series systems release R5.0.')
tmnxVRtr7450V6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 1, 8)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrGlobalV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIpV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrNotificationV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfSubscrAuthV3v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrStaticRteCPEChkV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpAppV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfDHCPRelayGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtr7450V6v0Compliance = tmnxVRtr7450V6v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtr7450V6v0Compliance.setDescription('The compliance statement for management of VRTR instances\n             on Alcatel 7450 ESS series systems release R6.0.')
tmnxVRtr77x0V6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 1, 9)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrGlobalV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIpV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6V4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6IpV5v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6IfV4v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfDhcpServerGroup"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrNotificationV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfSubscrAuthV3v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrStaticRteCPEChkV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfIpcpV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfCpmProtectGroup"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpAppV6v0Group"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIfDHCPRelayGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtr77x0V6v0Compliance = tmnxVRtr77x0V6v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtr77x0V6v0Compliance.setDescription('The compliance statement for management of VRTR instances\n             on Alcatel 7x50 SR series systems release R6.0.')
tmnxVRtrGlobalR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 10)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNextVRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrConfiguredVRtrs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrActiveVRtrs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouteThresholdSoakTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxARPEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrGlobalR2r1Group = tmnxVRtrGlobalR2r1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrGlobalR2r1Group.setDescription('The group of objects supporting management of general\n         capabilities for transport and virtual routers\n         on version 2.1 Alcatel 7x50 SR series systems.')
tmnxVRtrIfSubscrAuthV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 11)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPAuthPolicy"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayAuthPktsDiscarded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayAuthPktsSuccess"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIfSubscrAuthV3v0Group = tmnxVRtrIfSubscrAuthV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIfSubscrAuthV3v0Group.setDescription('The  group  of  objects  supporting management of DHCP\n         authentication  on  version  3.0 Alcatel 7x50 SR series\n         systems.')
tmnxVRtrV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 14)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrName"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBgpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMplsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOspfStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRipStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRsvpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrEcmpMaxRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNewIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrLdpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIsIsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTriggeredPolicy"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrConfederationAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouteDistinguisher"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMidRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrHighRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIllegalLabelThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVpnId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrGracefulRestart"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrGracefulRestartType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrCustId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIgmpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxNumRoutesLogOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfExportTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfImportTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrPimStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutesLogOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMcastMidRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIgnoreIcmpRedirect"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOspfv3Status"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDirectRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDirectActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOSPFRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOSPFActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBGPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBGPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrISISRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrISISActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRIPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRIPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregateRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregateActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatConfiguredIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatIllegalLabels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatBGPVpnRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatBGPVpnActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMulticastRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSubMgmtRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSubMgmtActiveRoutes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrV4v0Group = tmnxVRtrV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrV4v0Group.setDescription('The group of objects supporting management of transport and\n         virtual routers on version 4.0 Alcatel 7x50 SR series systems.')
tmnxVRtrIfV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 15)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfTotalNumber"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfName"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfPortID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfChannelID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfEncapValue"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfAlias"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfPhysicalAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfArpTimeout"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpMaskReply"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpNumRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpRedirectsTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpUnreachables"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpNumUnreachables"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpUnreachablesTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpTtlExpired"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpNumTtlExpired"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpTtlExpiredTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfNtpBroadcast"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfUnnumbered"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfMtu"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfQosPolicyId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIngressFilterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfEgressFilterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDirectedBroadcast"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfMplsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfUnnumberedIf"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfCflowd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfVPNClass"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProtocol"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfTosMarkingTrusted"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfArpPopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpLocal"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfNameIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayInfoAction"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayCircuitId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRemoteId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer6"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer7"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer8"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayTrusted"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayTxPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxMalformedPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxUntrustedPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsDiscarded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsRelayed"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsDiscarded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsRelayed"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsSnooped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsSnooped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPOperLeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddressType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddressAsSrc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPMatchOption82"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIfV4v0Group = tmnxVRtrIfV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrIfV4v0Group.setDescription('The group of objects supporting management of virtual\n         interfaces on version 4.0 Alcatel 7x50 SR series systems.')
tmnxVRtrIpV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 16)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaIpAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaNetMask"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaBcastAddrFormat"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaReasmMaxSize"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaIgpInhibit"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetAddressType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetAddrState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetEui64"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetOperAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpCidrRouteLastEnabledTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpCidrRoutePreference"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpCidrRouteMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteDest"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteMask"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteNumber"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteLastEnabledTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteStaticType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRoutePreference"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteEgressIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteNextHop"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteNextHopUnnumberedIf"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIgpShortcut"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteDisallowIgp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteTag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndexDest"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndexMask"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteAvailableIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteLastEnabledTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteStaticType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRoutePreference"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteEgressIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteNextHopType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteNextHop"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteNextHopIf"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteIgpShortcut"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDisallowIgp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteTag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteEnableBfd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteAvailIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSvcIpRangeRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSvcIpRangeExclusive"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpNetToMediaTimer"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpNetToMediaOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInstanceAggregationTableLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationSummaryOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationASSet"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationAggregatorAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationAggregatorIPAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelAge"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixOnLinkFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixAutonomousFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixPreferredLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixValidLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetInstAggrTblLastChged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrSummaryOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrASSet"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrAggregatorAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrAggregatorIPAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetSvcIpRangeRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetSvcIpRangeExclusive"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIpV4v0Group = tmnxVRtrIpV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrIpV4v0Group.setDescription('The group of objects supporting management of IP capabilities\n         for transport and virtual routers on version 4.0 Alcatel 7x50 SR\n         series systems.')
tmnxVRtrObsoletedObjectsV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 17)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLseStateChAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLseStateRemainLseTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLseStateOption82"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLseStatePersistKey"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCPClientLease"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateOldCiAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateOldChAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateNewCiAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStateNewChAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateCiAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateVRtrId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpRestoreLseStateProblem"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpLseStatePopulateError"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayInfoOption"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPAutoFilter"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPSnooping"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPAutoFilterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPOperAutoFilter"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAutoFilterDHCPClientAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAutoFilterDHCPClientLease"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrObsoletedObjectsV4v0Group = tmnxVRtrObsoletedObjectsV4v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrObsoletedObjectsV4v0Group.setDescription('The group of objects no longer supported in version 4.0\n         of Alcatel 7x50 SR  series systems.')
tmnxVRtrBfdV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 18)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdTransmitInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdReceiveInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdMultiplier"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionOperFlags"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionMesgRecv"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionMesgSent"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLastDownTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLastUpTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionUpCount"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionDownCount"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclDisc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionRemDisc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionProtocols"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionTxInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionRxInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrBfdV4v0Group = tmnxVRtrBfdV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrBfdV4v0Group.setDescription('The group of objects supporting Bi-directional Forwarding\n          Detection on version 4.0 Alcatel 7x50 series systems.')
tmnxVRtrNotificationV4v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 19)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMidRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrHighRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrHighRouteCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIllegalLabelTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMidRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMaxRoutesTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMaxRoutesCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxArpEntriesTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxArpEntriesCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPSuspiciousPcktRcvd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdSessionDown"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdMaxSessionOnSlot"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdPortTypeNotSupported"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrNotificationV4v0Group = tmnxVRtrNotificationV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrNotificationV4v0Group.setDescription('The group of notifications supporting the transport and\n         virtual router capabilities on version 4.0 Alcatel 7x50 SR series\n         systems.')
tmnxVRtrIPv6IfV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 20)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIPv6ConfigAllowed"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIPv6OperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIPv6IngressFilterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIPv6EgressFilterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6Redirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6NumRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6RedirectsTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6Unreachables"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6NumUnreachables"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6UnreachablesTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6TimeExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6NumTimeExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6TimeExceededTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6PktTooBig"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6NumPktTooBig"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6PktTooBigTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6ParamProblem"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6NumParamProblem"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpV6ParamProblemTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfLinkLocalAddressType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfLinkLocalAddressState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfLinkLocalAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InMsgs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InErrors"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InDestUnreachs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InAdminProhibs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InTimeExcds"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InParmProblems"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InPktTooBigs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InEchos"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InEchoReplies"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InRtrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InRtrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InNbrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InNbrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InGrpMembQueries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InGrpMembResponses"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6InGrpMembReductions"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutMsgs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutErrors"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutDestUnreachs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutAdminProhibs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutTimeExcds"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutParmProblems"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutPktTooBigs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutEchos"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutEchoReplies"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutRtrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutRtrSolicitsTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutRtrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutRtrAdvTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutNbrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutNbrSolicitsTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutNbrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutNbrAdvTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutGrpMembQueries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutGrpMembResponses"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmp6OutGrpMembReductions"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InMsgs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InErrors"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InDestUnreachs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InAdminProhibs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InTimeExcds"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InParmProblems"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InPktTooBigs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InEchos"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InEchoReplies"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InRtrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InRtrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InNbrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InNbrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InGrpMembQueries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InGrpMembResponses"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6InGrpMembReductions"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutMsgs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutErrors"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutDestUnreachs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutAdminProhibs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutTimeExcds"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutParmProblems"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutPktTooBigs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutEchos"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutEchoReplies"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutRtrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutRtrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutNbrSolicits"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutNbrAdvertisements"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutGrpMembQueries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutGrpMembResponses"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIcmp6OutGrpMembReductions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIPv6IfV4v0Group = tmnxVRtrIPv6IfV4v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIPv6IfV4v0Group.setDescription('The group of objects supporting management of IPv6 virtual\n         interfaces on version 4.0 Alcatel 7x50 SR series systems.')
tmnxVRtrIPv6V4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 21)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6DirectRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6DirectActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StaticRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StaticActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6OSPFRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6OSPFActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6BGPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6BGPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6ISISRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6ISISActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6RIPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6RIPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6AggregateRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6AggregateActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatConfiguredIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatActiveIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatIllegalLabels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatBGPVpnRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatBGPVpnActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatTotalLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatTotalSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatActiveLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatActiveSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6MulticastRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatActiveNbrEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatTotalNbrEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIPv6V4v0Group = tmnxVRtrIPv6V4v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIPv6V4v0Group.setDescription('The group of objects supporting management of IPv6 transport and\n         virtual routers on version 4.0 Alcatel 7x50 SR series systems.')
tmnxVRtrIPv6IpV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 22)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixOnLinkFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixAutonomousFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixPreferredLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixValidLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIPv6IpV4v0Group = tmnxVRtrIPv6IpV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrIPv6IpV4v0Group.setDescription('The group of objects supporting management of Ipv6 IP capabilities\n         for transport and virtual routers on version 4.0 Alcatel 7x50 SR\n         series systems.')
tmnxVRtrObsoleteNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 23)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPAFEntriesExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPLseStsExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPLeaseStateOverride"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPLseStRestoreProblem"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPLseStatePopulateErr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrObsoleteNotificationGroup = tmnxVRtrObsoleteNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrObsoleteNotificationGroup.setDescription('The group of obsolete notifications for the transport and\n         virtual router capabilities on Alcatel 7x50 SR series systems.')
tmnxVRtrIPv6IpV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 24)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixOnLinkFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixAutonomousFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixPreferredLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixValidLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6TableLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6LastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6AdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6OperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6Description"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer6"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer7"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayServer8"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RelayItfIdOption"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6LeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6CurrLeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6SourceAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6EnableNgbrResolution"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6RemoteIdOption"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6ServerMaxLeaseStates"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6CurrServerLeaseStates"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6ItfIdString"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyNDLocal"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyNDPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyNDPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyNDPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyNDPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyNDPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdDUID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdIAID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdPrefLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxdValidLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCP6PfxDelegationLstChgd"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIPv6IpV5v0Group = tmnxVRtrIPv6IpV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIPv6IpV5v0Group.setDescription('The group of objects supporting management of Ipv6 IP capabilities\n         for transport and virtual routers on version 5.0 Alcatel 7x50 SR\n         series systems.')
tmnxVRtrIfV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 25)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfTotalNumber"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfName"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfPortID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfEncapValue"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfAlias"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfPhysicalAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfArpTimeout"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpMaskReply"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpNumRedirects"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpRedirectsTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpUnreachables"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpNumUnreachables"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpUnreachablesTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpTtlExpired"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpNumTtlExpired"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIcmpTtlExpiredTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfNtpBroadcast"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfUnnumbered"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfMtu"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfQosPolicyId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIngressFilterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfEgressFilterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDirectedBroadcast"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfMplsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfUnnumberedIf"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfCflowd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfVPNClass"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProtocol"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfTosMarkingTrusted"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfArpPopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfLastOperStateChange"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfOperMtu"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfGlobalIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpLocal"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfProxyArpPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfNameIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayInfoAction"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayCircuitId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRemoteId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer6"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer7"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer8"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayTrusted"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayTxPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxMalformedPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxUntrustedPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsDiscarded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsRelayed"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsDiscarded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsRelayed"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsSnooped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsSnooped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsProxRad"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsProxLS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayPktsGenRelease"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayPktsGenForceRenew"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPOperLeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddressType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddressAsSrc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPMatchOption82"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRemoteIdStr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyServerAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyLeaseTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyLTRadiusOverride"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPVendorIncludeOptions"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPVendorOptionString"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfGlobalIndexvRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfGlobalIndexvRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDelaySeconds"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDelayUpTimer"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfInitDelayEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIfV5v0Group = tmnxVRtrIfV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIfV5v0Group.setDescription('The group of objects supporting management of virtual\n         interfaces on version 5.0 Alcatel 7x50 SR series systems.')
tmnxVRtrIpV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 26)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaIpAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaNetMask"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaBcastAddrFormat"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaReasmMaxSize"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaIgpInhibit"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetAddressType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetAddrState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetEui64"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetOperAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetGwAddressType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetGwAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetRemoteIpType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRiaInetRemoteIp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpCidrRouteLastEnabledTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpCidrRoutePreference"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpCidrRouteMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteDest"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteMask"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteNumber"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteLastEnabledTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteStaticType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRoutePreference"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteEgressIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteNextHop"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteNextHopUnnumberedIf"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIgpShortcut"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteDisallowIgp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteTag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndexDest"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteIndexMask"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRouteAvailableIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteLastEnabledTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteStaticType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRoutePreference"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteEgressIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteNextHopType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteNextHop"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteNextHopIf"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteIgpShortcut"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteDisallowIgp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteTag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteEnableBfd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteAvailIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSvcIpRangeRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSvcIpRangeExclusive"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpNetToMediaTimer"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIpNetToMediaOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInstanceAggregationTableLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationSummaryOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationASSet"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationAggregatorAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationAggregatorIPAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregationOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelMetric"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTunnelAge"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixOnLinkFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixAutonomousFlag"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixPreferredLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixValidLifetime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdvPrefixRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetInstAggrTblLastChged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrSummaryOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrASSet"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrAggregatorAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrAggregatorIPAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetAggrOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetSvcIpRangeRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetSvcIpRangeExclusive"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIpV5v0Group = tmnxVRtrIpV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIpV5v0Group.setDescription('The group of objects supporting management of IP capabilities\n         for transport and virtual routers on version 4.0 Alcatel 7x50 SR\n         series systems.')
tmnxVRtrV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 27)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrName"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBgpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMplsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRipStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRsvpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrEcmpMaxRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNewIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrLdpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIsIsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTriggeredPolicy"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrConfederationAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouteDistinguisher"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMidRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrHighRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIllegalLabelThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVpnId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrGracefulRestart"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrGracefulRestartType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrCustId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIgmpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxNumRoutesLogOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfExportTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfImportTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrPimStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutesLogOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMcastMidRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIgnoreIcmpRedirect"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMsdpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVprnType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSecondaryVrfId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMldStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDirectRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDirectActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOSPFRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOSPFActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBGPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBGPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrISISRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrISISActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRIPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRIPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregateRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregateActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatConfiguredIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatIllegalLabels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatBGPVpnRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatBGPVpnActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMulticastRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSubMgmtRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSubMgmtActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatTotalRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatActiveRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6DropStatLastCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6DropStatPktsDropped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsLstClrd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsRcvd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsSent"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsDropped"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrV5v0Group = tmnxVRtrV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrV5v0Group.setDescription('The group of objects supporting management of transport and\n         virtual routers on version 5.0 Alcatel 7x50 SR series systems.')
tmnxVRtrNotificationV5v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 28)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMidRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrHighRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrHighRouteCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIllegalLabelTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMidRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMaxRoutesTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMaxRoutesCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxArpEntriesTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxArpEntriesCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPSuspiciousPcktRcvd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdSessionDown"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdMaxSessionOnSlot"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdPortTypeNotSupported"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPIfLseStatesExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6RelayLseStExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6ServerLseStExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6LseStateOverride"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6RelayReplyStripUni"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6IllegalClientAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6AssignedIllegSubnet"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6ClientMacUnresolved"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdSessionUp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrNotificationV5v0Group = tmnxVRtrNotificationV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrNotificationV5v0Group.setDescription('The group of notifications supporting the transport and\n         virtual router capabilities on version 5.0 Alcatel 7xx0 SR series\n         systems.')
tmnxVRtrObsoleteV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 29)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOspfStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOspfv3Status"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfChannelID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrObsoleteV5v0Group = tmnxVRtrObsoleteV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrObsoleteV5v0Group.setDescription('The group of objects in ALCATEL-IND1-TIMETRA-VRTR-MIB which are obsoleted in\n         Alcatel 7x50 SR 5.0 series systems.')
tmnxVRtrNotificationObjV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 30)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpPacketProblem"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBfdSlotNumber"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNumberOfBfdSessionsOnSlot"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBfdMaxSessionReason"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ServerNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ServerNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6NewClientId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldClientId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6LeaseOverrideResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrNotificationObjV5v0Group = tmnxVRtrNotificationObjV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxVRtrNotificationObjV5v0Group.setDescription('The group of objects supporting management of notification objects\n         on Alcatel 7x50 SR 5.0 series systems.')
tmnxVRtrIfDhcpServerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 31)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfLocalDhcpServerName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIfDhcpServerGroup = tmnxVRtrIfDhcpServerGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIfDhcpServerGroup.setDescription('The group of objects supporting the DHCP server capabilities\n         on version 6.0 Alcatel 7x50 SR series systems.')
tmnxVRtrV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 32)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRowStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrName"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBgpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMplsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRipStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRsvpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrEcmpMaxRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNewIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrLdpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIsIsStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouterId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrTriggeredPolicy"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrConfederationAS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouteDistinguisher"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMidRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrHighRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIllegalLabelThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVpnId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrGracefulRestart"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrGracefulRestartType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrServiceId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrCustId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIgmpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxNumRoutesLogOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfExportTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVrfImportTarget"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrPimStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxMcastNumRoutesLogOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMcastMidRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIgnoreIcmpRedirect"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMsdpStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrVprnType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSecondaryVrfId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMldStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6MaxNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6MidRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6HighRouteThreshold"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6MaxNumRoutesLogOnly"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6IgnoreIcmpRedirect"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMcPathMgmtPlcyName"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrImportPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrExportPolicy5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDirectRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDirectActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStaticActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOSPFRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrOSPFActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBGPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBGPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrISISRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrISISActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRIPRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRIPActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregateRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrAggregateActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatConfiguredIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveIfs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatIllegalLabels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatCurrNumRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatBGPVpnRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatBGPVpnActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveLdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveSdpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMulticastRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSubMgmtRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrSubMgmtActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatTotalRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatActiveRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatTotalRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6StatActiveRsvpTunnels"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrHostRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrHostActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6HostRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrV6HostActiveRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatLocalARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatStaticARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatDynamicARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatManagedARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrStatInternalARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6DropStatLastCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6DropStatPktsDropped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsLstClrd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsRcvd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsSent"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6MsgStatsDropped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedActiveRoutes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrV6v0Group = tmnxVRtrV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrV6v0Group.setDescription('The group of objects supporting management of transport and\n         virtual routers on version 6.0 Alcatel 7x50 SR series systems.')
tmnxVRtrStaticRteCPEChkV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 33)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteCpeAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteCpeAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteCpeInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteCpeDropCnt"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteCpeEnableLog"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeChkUpTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeChkInPktCnt"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeChkOutPktCnt"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeChkUpTrans"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeChkDownTrans"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeChkTTL"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrStaticRteCPEChkV6v0Group = tmnxVRtrStaticRteCPEChkV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrStaticRteCPEChkV6v0Group.setDescription('The group of objects supporting the Static Route CPE Check\n         capability on version 6.0 Alcatel 7x50 SR series systems.')
tmnxVRtrIfIpcpV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 34)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIpcpPeerAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIpcpPeerAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIpcpPriDnsAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIpcpPriDnsAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIpcpSecDnsAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIpcpSecDnsAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIfIpcpV6v0Group = tmnxVRtrIfIpcpV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIfIpcpV6v0Group.setDescription('The group of objects supporting management of IPCP\n        extensions for virtual interfaces on version 6.0 Alcatel \n        7x50 SR series systems')
tmnxVRtrIfCpmProtectGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 35)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfCpmProtPolicyId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfCpmProtUncfgdProtoDropCnt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIfCpmProtectGroup = tmnxVRtrIfCpmProtectGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIfCpmProtectGroup.setDescription('The group of objects supporting management of CPM Protection \n         for virtual interfaces on Alcatel 7xxx series systems.')
tmnxDscpAppV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 36)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpAppLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpAppDscpValue"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpFCLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpFCValue"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpAppTableLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDscpFCTableLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDot1pAppTableLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDot1pAppLastChanged"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxDot1pAppValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxDscpAppV6v0Group = tmnxDscpAppV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxDscpAppV6v0Group.setDescription('The group of objects supporting management of DSCP marking for\n         self-generated protocol control traffic on Alcatel 7x50 SR series\n         systems release 6.0.')
tmnxVRtrIfDHCPRelayGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 37)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayInfoAction"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayCircuitId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRemoteId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer1"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer2"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer3"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer4"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer5"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer6"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer7"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServer8"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayTrusted"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPDescription"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayTxPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxMalformedPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRxUntrustedPkts"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsDiscarded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsRelayed"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsDiscarded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsRelayed"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsSnooped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayServerPktsSnooped"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsProxRad"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayClientPktsProxLS"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayPktsGenRelease"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayPktsGenForceRenew"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPOperLeasePopulate"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddressType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddress"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPGiAddressAsSrc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPMatchOption82"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPRelayRemoteIdStr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyServerAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyLeaseTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPProxyLTRadiusOverride"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPVendorIncludeOptions"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPVendorOptionString"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPLayer2Header"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPAntiSpoofMacAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfDHCPClientApplications"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfLdpSyncTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrIfDHCPRelayGroup = tmnxVRtrIfDHCPRelayGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrIfDHCPRelayGroup.setDescription('The group of objects supporting management of DHCP Relay\n        on virtual interfaces on version 6.0 Alcatel 7x50 SR series systems')
tmnxVRtrGlobalV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 38)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNextVRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrConfiguredVRtrs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrActiveVRtrs"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrRouteThresholdSoakTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrMaxARPEntries"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIPv6RouteThresholdSoakTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrGlobalV6v0Group = tmnxVRtrGlobalV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrGlobalV6v0Group.setDescription('The group of objects supporting management of general\n         capabilities for transport and virtual routers\n         on version 6.0 Alcatel 7x50 SR series systems.')
tmnxVRtrNotificationObjV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 39)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDhcpPacketProblem"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBfdSlotNumber"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrNumberOfBfdSessionsOnSlot"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrBfdMaxSessionReason"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ServerNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ServerNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6ClientNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6AssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedNetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedNetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldAssignedPrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6NewClientId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6OldClientId"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrDHCP6LeaseOverrideResult"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeNotifyAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStatRteCpeNotifyAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrInetStaticRouteCpeStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedRouteInetAddrType"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedRouteInetAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrManagedRoutePrefixLen"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrFailureDescription"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrNotificationObjV6v0Group = tmnxVRtrNotificationObjV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrNotificationObjV6v0Group.setDescription('The group of objects supporting management of notification objects\n         on Alcatel 7x50 SR 6.0 series systems.')
tmnxVRtrNotificationV6v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 40)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMidRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrHighRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrHighRouteCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIllegalLabelTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMidRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMaxRoutesTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMcastMaxRoutesCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxArpEntriesTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxArpEntriesCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrMaxRoutes"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPSuspiciousPcktRcvd"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdSessionDown"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdMaxSessionOnSlot"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdPortTypeNotSupported"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCPIfLseStatesExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6RelayLseStExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6ServerLseStExceeded"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6LseStateOverride"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6RelayReplyStripUni"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6IllegalClientAddr"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6AssignedIllegSubnet"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrDHCP6ClientMacUnresolved"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdSessionUp"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6MidRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6HighRouteTCA"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrIPv6HighRouteCleared"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrStaticRouteCPEStatus"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdSessionDeleted"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrBfdSessionProtChange"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "tmnxVRtrManagedRouteAddFailed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrNotificationV6v0Group = tmnxVRtrNotificationV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrNotificationV6v0Group.setDescription('The group of notifications supporting the transport and\n         virtual router capabilities on version 6.0 Alcatel 7xx0 SR series\n         systems.')
tmnxVRtrBfdV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 3, 2, 41)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdAdminState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdTransmitInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdReceiveInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdMultiplier"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionOperState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionState"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionOperFlags"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionMesgRecv"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionMesgSent"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLastDownTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLastUpTime"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionUpCount"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionDownCount"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionLclDisc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionRemDisc"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionProtocols"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionTxInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionRxInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdEchoInterval"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfBfdSessionType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxVRtrBfdV6v0Group = tmnxVRtrBfdV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxVRtrBfdV6v0Group.setDescription('The group of objects supporting Bi-directional Forwarding\n          Detection on version 6.0 Alcatel 7xxx series systems.')
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-VRTR-MIB", vRtrAggregateRoutes=vRtrAggregateRoutes, tmnxVRtrNotificationObjects=tmnxVRtrNotificationObjects, vRtrIfProxyArp=vRtrIfProxyArp, vRtrIfDHCPRelayCircuitId=vRtrIfDHCPRelayCircuitId, vRtrIfDHCPGiAddressType=vRtrIfDHCPGiAddressType, vRtrIfIPv6ConfigAllowed=vRtrIfIPv6ConfigAllowed, tmnxVRtrBfdSessionUp=tmnxVRtrBfdSessionUp, tmnxVRtrDHCP6ClientMacUnresolved=tmnxVRtrDHCP6ClientMacUnresolved, vRtrIfDHCP6RelayItfIdOption=vRtrIfDHCP6RelayItfIdOption, vRtrIfCpmProtUncfgdProtoDropCnt=vRtrIfCpmProtUncfgdProtoDropCnt, vRtrIfDHCPRelayClientPktsSnooped=vRtrIfDHCPRelayClientPktsSnooped, vRtrIfDHCPLseStateRemainLseTime=vRtrIfDHCPLseStateRemainLseTime, vRtrAggregationASSet=vRtrAggregationASSet, vRtrIcmp6Table=vRtrIcmp6Table, vRtrIfIcmp6OutGrpMembResponses=vRtrIfIcmp6OutGrpMembResponses, vRtrAdvPrefixLength=vRtrAdvPrefixLength, vRtrIpNetToMediaTable=vRtrIpNetToMediaTable, vRtrDhcpRestoreLseStateIfIndex=vRtrDhcpRestoreLseStateIfIndex, vRtrIfDHCP6PfxdPrefix=vRtrIfDHCP6PfxdPrefix, vRtrIfDHCP6ServerMaxLeaseStates=vRtrIfDHCP6ServerMaxLeaseStates, vRtrStaticRouteNumber=vRtrStaticRouteNumber, vRtrStaticRouteNextHopUnnumberedIf=vRtrStaticRouteNextHopUnnumberedIf, vRtrOSPFRoutes=vRtrOSPFRoutes, vRtrIfNameEntry=vRtrIfNameEntry, vRtrTunnelMask=vRtrTunnelMask, vRiaRowStatus=vRiaRowStatus, vRiaInetPrefixLen=vRiaInetPrefixLen, tmnxVRtrMaxRoutes=tmnxVRtrMaxRoutes, vRtrRipStatus=vRtrRipStatus, timetraVRtrMIBModule=timetraVRtrMIBModule, tmnxVRtrBfdV4v0Group=tmnxVRtrBfdV4v0Group, vRtrInetAggrIpPrefix=vRtrInetAggrIpPrefix, vRtrIfDHCP6PfxdPrefLifetime=vRtrIfDHCP6PfxdPrefLifetime, vRtrIfIngressFilterId=vRtrIfIngressFilterId, vRtrInetAggrOperState=vRtrInetAggrOperState, vRtrIfDHCPRelayTxPkts=vRtrIfDHCPRelayTxPkts, vRtrInetStaticRouteCpeAddr=vRtrInetStaticRouteCpeAddr, vRtrMcastMidRouteThreshold=vRtrMcastMidRouteThreshold, vRtrV6StaticActiveRoutes=vRtrV6StaticActiveRoutes, vRtrVrfExportTarget=vRtrVrfExportTarget, vRtrStaticRouteNextHop=vRtrStaticRouteNextHop, vRtrIfDHCPRelayInfoAction=vRtrIfDHCPRelayInfoAction, vRtrIfBfdSessionOperState=vRtrIfBfdSessionOperState, vRtrInetStaticRouteAdminState=vRtrInetStaticRouteAdminState, vRtrInetStaticRouteCpeDropCnt=vRtrInetStaticRouteCpeDropCnt, vRtrStatCurrNumRoutes=vRtrStatCurrNumRoutes, tmnxVRtrMcastMaxRoutesTCA=tmnxVRtrMcastMaxRoutesTCA, vRtrIfIcmp6InRtrAdvertisements=vRtrIfIcmp6InRtrAdvertisements, vRtrIfIcmpV6NumUnreachables=vRtrIfIcmpV6NumUnreachables, vRtrMsdpStatus=vRtrMsdpStatus, vRtrIfBfdSessionLclAddr=vRtrIfBfdSessionLclAddr, vRtrIfLastOperStateChange=vRtrIfLastOperStateChange, vRtrV6OSPFRoutes=vRtrV6OSPFRoutes, vRiaInetRemoteIp=vRiaInetRemoteIp, vRtrIfOperState=vRtrIfOperState, vRtrTunnelAge=vRtrTunnelAge, vRtrIfBfdSessionOperFlags=vRtrIfBfdSessionOperFlags, vRtrV6HostActiveRoutes=vRtrV6HostActiveRoutes, vRtrIfBfdSessionLclDisc=vRtrIfBfdSessionLclDisc, vRtrManagedRoutePrefixLen=vRtrManagedRoutePrefixLen, vRtrDhcpLseStateOldChAddr=vRtrDhcpLseStateOldChAddr, vRtrIfBfdTransmitInterval=vRtrIfBfdTransmitInterval, vRtrRouteThresholdSoakTime=vRtrRouteThresholdSoakTime, vRtrStaticRouteRowStatus=vRtrStaticRouteRowStatus, tmnxDscpFCTableLastChanged=tmnxDscpFCTableLastChanged, tmnxVRtrCompliances=tmnxVRtrCompliances, vRtrDHCP6MsgStatEntry=vRtrDHCP6MsgStatEntry, vRtrAdminState=vRtrAdminState, vRtrStatTotalARPEntries=vRtrStatTotalARPEntries, vRtrIcmp6InGrpMembResponses=vRtrIcmp6InGrpMembResponses, vRtrDHCP6NewClientId=vRtrDHCP6NewClientId, vRtrIfBfdSessionType=vRtrIfBfdSessionType, vRtrIfIcmpV6TimeExceededTime=vRtrIfIcmpV6TimeExceededTime, vRtrIfDHCPProxyAdminState=vRtrIfDHCPProxyAdminState, vRtrManagedRoutes=vRtrManagedRoutes, vRtrIfIcmpV6NumRedirects=vRtrIfIcmpV6NumRedirects, vRtrStaticRouteDest=vRtrStaticRouteDest, vRtrIfIcmp6InNbrAdvertisements=vRtrIfIcmp6InNbrAdvertisements, vRtrIfTotalNumber=vRtrIfTotalNumber, vRiaIndex=vRiaIndex, vRtrInetSvcIpRangeEntry=vRtrInetSvcIpRangeEntry, vRtrIfCflowd=vRtrIfCflowd, vRtrPolicyEntry=vRtrPolicyEntry, vRtrIfIcmp6Table=vRtrIfIcmp6Table, vRtrIfBfdSessionRemDisc=vRtrIfBfdSessionRemDisc, tmnxVRtrV5v0Group=tmnxVRtrV5v0Group, PYSNMP_MODULE_ID=timetraVRtrMIBModule, vRtrRIPActiveRoutes=vRtrRIPActiveRoutes, vRtrIfDHCPRelayServer6=vRtrIfDHCPRelayServer6, TDot1pAppId=TDot1pAppId, vRtrInstanceAggregationEntry=vRtrInstanceAggregationEntry, vRtrIfIpcpPriDnsAddr=vRtrIfIpcpPriDnsAddr, vRtrIfDHCPLseStatePersistKey=vRtrIfDHCPLseStatePersistKey, vRtrDHCP6AssignedNetAddrType=vRtrDHCP6AssignedNetAddrType, vRtrInetStaticRouteIndexEntry=vRtrInetStaticRouteIndexEntry, vRtrIfDHCPProxyServerAddr=vRtrIfDHCPProxyServerAddr, vRtrTunnelPreference=vRtrTunnelPreference, vRtrIfUnnumbered=vRtrIfUnnumbered, vRtrInetStatRteCpeChkDownTrans=vRtrInetStatRteCpeChkDownTrans, vRtrV6StatActiveNbrEntries=vRtrV6StatActiveNbrEntries, vRtrID=vRtrID, vRtrIfDHCPRelayServer4=vRtrIfDHCPRelayServer4, vRtrV6StatActiveLdpTunnels=vRtrV6StatActiveLdpTunnels, vRtrIfBfdSessionUpCount=vRtrIfBfdSessionUpCount, vRtrBfdSlotNumber=vRtrBfdSlotNumber, vRtrMplsStatus=vRtrMplsStatus, vRtrInetSvcIpRangeAddrType=vRtrInetSvcIpRangeAddrType, vRtrImportPolicy4=vRtrImportPolicy4, vRtrIfNameIndex=vRtrIfNameIndex, vRtrDHCP6OldAssignedNetAddr=vRtrDHCP6OldAssignedNetAddr, vRtrStatActiveIfs=vRtrStatActiveIfs, vRtrIfLinkLocalAddress=vRtrIfLinkLocalAddress, tmnxVRtrIPv6HighRouteTCA=tmnxVRtrIPv6HighRouteTCA, vRtrIfDescription=vRtrIfDescription, vRtrIfProxyNDPolicy4=vRtrIfProxyNDPolicy4, vRtrIfIcmp6OutRtrAdvertisements=vRtrIfIcmp6OutRtrAdvertisements, tmnxDscpAppTableLastChanged=tmnxDscpAppTableLastChanged, vRtrStaticRouteDisallowIgp=vRtrStaticRouteDisallowIgp, vRtrIfDHCPEntry=vRtrIfDHCPEntry, vRtrIfDHCP6ItfIdString=vRtrIfDHCP6ItfIdString, vRtrIfIcmp6OutPktTooBigs=vRtrIfIcmp6OutPktTooBigs, vRtrIfIcmp6InTimeExcds=vRtrIfIcmp6InTimeExcds, vRtrDHCP6MsgStatsLstClrd=vRtrDHCP6MsgStatsLstClrd, vRtrTunnelMetric=vRtrTunnelMetric, vRtrDHCP6OldAssignedNetAddrType=vRtrDHCP6OldAssignedNetAddrType, vRtrDHCP6ClientNetAddrType=vRtrDHCP6ClientNetAddrType, vRtrIcmp6InRtrSolicits=vRtrIcmp6InRtrSolicits, vRtrIfDHCPOperAutoFilter=vRtrIfDHCPOperAutoFilter, vRtrInetStaticRouteIndex=vRtrInetStaticRouteIndex, vRtrIfBfdSessionRxInterval=vRtrIfBfdSessionRxInterval, vRiaInetOperAddress=vRiaInetOperAddress, tmnxVRtrBfdSessionDown=tmnxVRtrBfdSessionDown, vRtrIPv6MaxNumRoutes=vRtrIPv6MaxNumRoutes, vRtrInetStaticRouteEgressIfIndex=vRtrInetStaticRouteEgressIfIndex, vRtrConfEntry=vRtrConfEntry, vRtrStatBGPVpnActiveRoutes=vRtrStatBGPVpnActiveRoutes, vRtrIfIcmp6InGrpMembReductions=vRtrIfIcmp6InGrpMembReductions, vRtrSubMgmtRoutes=vRtrSubMgmtRoutes, vRtrIpNetToMediaTimer=vRtrIpNetToMediaTimer, vRtrIfIcmpTtlExpiredTime=vRtrIfIcmpTtlExpiredTime, vRtrStatTable=vRtrStatTable, vRtrIfDHCP6PfxdRowStatus=vRtrIfDHCP6PfxdRowStatus, vRtrStaticRouteMask=vRtrStaticRouteMask, tmnxVRtrDHCPIfLseStatesExceeded=tmnxVRtrDHCPIfLseStatesExceeded, vRtrIfDHCP6TableLastChanged=vRtrIfDHCP6TableLastChanged, vRtrInetStaticRouteAvailIndex=vRtrInetStaticRouteAvailIndex, vRtrInetAggrAggregatorIPAddr=vRtrInetAggrAggregatorIPAddr, vRtrIfDHCP6PfxdPrefixLen=vRtrIfDHCP6PfxdPrefixLen, vRtrIcmp6InEchos=vRtrIcmp6InEchos, vRtrInstanceAggregationTableLastChanged=vRtrInstanceAggregationTableLastChanged, vRtrIfIcmp6InRtrSolicits=vRtrIfIcmp6InRtrSolicits, vRtrInetSvcIpRangeTable=vRtrInetSvcIpRangeTable, vRtrInetAggrIpPrefixType=vRtrInetAggrIpPrefixType, vRtrV6StaticRoutes=vRtrV6StaticRoutes, vRtrInetStatRteCpeChkUpTrans=vRtrInetStatRteCpeChkUpTrans, vRtrIcmp6InParmProblems=vRtrIcmp6InParmProblems, vRtrDHCPClientLease=vRtrDHCPClientLease, vRtrIfDHCP6Entry=vRtrIfDHCP6Entry, vRtrVrfImportTarget=vRtrVrfImportTarget, vRtrAggregationOperState=vRtrAggregationOperState, vRtrIfProxyNDTable=vRtrIfProxyNDTable, tmnxVRtrIfV4v0Group=tmnxVRtrIfV4v0Group, vRtrIfDHCPRelayClientPktsProxRad=vRtrIfDHCPRelayClientPktsProxRad, vRtrIfIcmp6Entry=vRtrIfIcmp6Entry, vRtrStatManagedARPEntries=vRtrStatManagedARPEntries, vRtrIfDHCP6RelayServer6=vRtrIfDHCP6RelayServer6, vRtrBGPActiveRoutes=vRtrBGPActiveRoutes, vRiaReasmMaxSize=vRiaReasmMaxSize, vRtrIfAdminState=vRtrIfAdminState, vRtrIfIcmp6InAdminProhibs=vRtrIfIcmp6InAdminProhibs, vRtrIfBfdSessionMesgRecv=vRtrIfBfdSessionMesgRecv, vRtrIfDHCP6PfxdIAID=vRtrIfDHCP6PfxdIAID, vRtrIfBfdSessionProtocols=vRtrIfBfdSessionProtocols, tmnxVRtrHighRouteCleared=tmnxVRtrHighRouteCleared, vRtrIfDelaySeconds=vRtrIfDelaySeconds, tmnxVRtr77x0V6v0Compliance=tmnxVRtr77x0V6v0Compliance, tmnxVRtrNotifications=tmnxVRtrNotifications, vRiaBcastAddrFormat=vRiaBcastAddrFormat, tmnxVRtrObsoleteNotificationGroup=tmnxVRtrObsoleteNotificationGroup, vRtrIfIcmp6OutParmProblems=vRtrIfIcmp6OutParmProblems, vRtrIfIpcpPeerAddr=vRtrIfIpcpPeerAddr, vRtrIfBfdSessionMesgSent=vRtrIfBfdSessionMesgSent, tmnxVRtrIPv6IfV4v0Group=tmnxVRtrIPv6IfV4v0Group, vRtrIfDHCP6PfxdValidLifetime=vRtrIfDHCP6PfxdValidLifetime, vRtrIfDHCP6Description=vRtrIfDHCP6Description, tmnxDscpFCEntry=tmnxDscpFCEntry, vRtrInetStatRteCpeChkStatsTable=vRtrInetStatRteCpeChkStatsTable, vRtrIfMplsStatus=vRtrIfMplsStatus, vRtrDhcpLseStateNewCiAddr=vRtrDhcpLseStateNewCiAddr, vRtrIfTable=vRtrIfTable, vRtrInetStatRteCpeChkOutPktCnt=vRtrInetStatRteCpeChkOutPktCnt, vRtrRowStatus=vRtrRowStatus, vRtrIfIcmp6OutRtrAdvTime=vRtrIfIcmp6OutRtrAdvTime, vRtrIfBfdSessionTxInterval=vRtrIfBfdSessionTxInterval, vRtrIfDHCPRelayClientPktsProxLS=vRtrIfDHCPRelayClientPktsProxLS, vRtrSvcIpRangeRowStatus=vRtrSvcIpRangeRowStatus, vRtrStatDynamicARPEntries=vRtrStatDynamicARPEntries, vRtrIfDHCPProxyLTRadiusOverride=vRtrIfDHCPProxyLTRadiusOverride, vRtrIfDHCPProxyLeaseTime=vRtrIfDHCPProxyLeaseTime, vRtrInetStaticRouteNextHopIf=vRtrInetStaticRouteNextHopIf, vRtrIcmp6OutNbrSolicits=vRtrIcmp6OutNbrSolicits, vRtrHighRouteThreshold=vRtrHighRouteThreshold, vRtrIfDHCP6RelayServer1=vRtrIfDHCP6RelayServer1, vRtrIfLdpSyncTimer=vRtrIfLdpSyncTimer, vRtrIfEntry=vRtrIfEntry, vRtrInetStaticRouteDestType=vRtrInetStaticRouteDestType, vRtrIfDHCPRelayServerPktsDiscarded=vRtrIfDHCPRelayServerPktsDiscarded, vRtrInetStaticRouteIgpShortcut=vRtrInetStaticRouteIgpShortcut, vRtrDirectActiveRoutes=vRtrDirectActiveRoutes, vRtrIcmp6OutNbrAdvertisements=vRtrIcmp6OutNbrAdvertisements, vRtrIPv6MidRouteThreshold=vRtrIPv6MidRouteThreshold, vRtrIfIcmp6OutGrpMembQueries=vRtrIfIcmp6OutGrpMembQueries, tmnxDot1pAppValue=tmnxDot1pAppValue, vRiaInetGwAddress=vRiaInetGwAddress, vRtrTunnelDest=vRtrTunnelDest, tmnxVRtrObsoleteV5v0Group=tmnxVRtrObsoleteV5v0Group, vRtrV6StatConfiguredIfs=vRtrV6StatConfiguredIfs, vRiaInetGwAddressType=vRiaInetGwAddressType, vRtrIfDHCPRelayRxUntrustedPkts=vRtrIfDHCPRelayRxUntrustedPkts, vRtrIpCidrRoutePreference=vRtrIpCidrRoutePreference, vRtrIfIcmpV6UnreachablesTime=vRtrIfIcmpV6UnreachablesTime, vRtrInetStaticRouteDestPfxLen=vRtrInetStaticRouteDestPfxLen, tmnxVRtrBfdSessionDeleted=tmnxVRtrBfdSessionDeleted, tmnxVRtrDHCPLseStsExceeded=tmnxVRtrDHCPLseStsExceeded, vRtrAutoFilterDHCPClientLease=vRtrAutoFilterDHCPClientLease, tmnxVRtrV4v0Group=tmnxVRtrV4v0Group, vRtrIfProtocol=vRtrIfProtocol, vRtrIfGlobalIndexvRtrID=vRtrIfGlobalIndexvRtrID, tmnxVRtr7450V4v0Compliance=tmnxVRtr7450V4v0Compliance, tmnxVRtrNotificationObjV5v0Group=tmnxVRtrNotificationObjV5v0Group, vRtrImportPolicy2=vRtrImportPolicy2, vRtrDHCP6AssignedPrefixLen=vRtrDHCP6AssignedPrefixLen, vRtrIfDHCPSnooping=vRtrIfDHCPSnooping, tmnxVRtrNotifyPrefix=tmnxVRtrNotifyPrefix, vRtrIfGlobalIndexTable=vRtrIfGlobalIndexTable, vRtrStaticRouteMetric=vRtrStaticRouteMetric, vRtrTunnelType=vRtrTunnelType, vRtrOperState=vRtrOperState, vRtrIfIcmpV6ParamProblemTime=vRtrIfIcmpV6ParamProblemTime, vRtrIfDHCPVendorIncludeOptions=vRtrIfDHCPVendorIncludeOptions, vRtrISISRoutes=vRtrISISRoutes, vRtrIfIpcpPeerAddrType=vRtrIfIpcpPeerAddrType, vRtrIfDHCPAutoFilterId=vRtrIfDHCPAutoFilterId, vRtrIfName=vRtrIfName, vRtrIfProxyArpLocal=vRtrIfProxyArpLocal, vRtrIfQosPolicyId=vRtrIfQosPolicyId, vRtrIfIndex=vRtrIfIndex, vRtrIpCidrRouteEntry=vRtrIpCidrRouteEntry, vRtrInetStatRteCpeNotifyAddrType=vRtrInetStatRteCpeNotifyAddrType, vRtrDHCP6OldAssignedPrefixLen=vRtrDHCP6OldAssignedPrefixLen, vRtrSecondaryVrfId=vRtrSecondaryVrfId, vRtrIfProxyArpPolicy2=vRtrIfProxyArpPolicy2, tmnxVRtrMaxArpEntriesTCA=tmnxVRtrMaxArpEntriesTCA, vRtrHostRoutes=vRtrHostRoutes)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-VRTR-MIB", vRtrConfiguredVRtrs=vRtrConfiguredVRtrs, vRtrAggregateActiveRoutes=vRtrAggregateActiveRoutes, vRtrIfRowStatus=vRtrIfRowStatus, tmnxVRtr7450V6v0Compliance=tmnxVRtr7450V6v0Compliance, vRtrIcmp6OutRtrAdvertisements=vRtrIcmp6OutRtrAdvertisements, vRtrIfDHCPRelayServerPktsRelayed=vRtrIfDHCPRelayServerPktsRelayed, vRtrDescription=vRtrDescription, TmnxVPNId=TmnxVPNId, vRtrIfNtpBroadcast=vRtrIfNtpBroadcast, vRtrInetStaticRouteTag=vRtrInetStaticRouteTag, vRtrStaticRouteStaticType=vRtrStaticRouteStaticType, vRtrIfDHCPRelayPktsGenRelease=vRtrIfDHCPRelayPktsGenRelease, vRtrIcmp6OutErrors=vRtrIcmp6OutErrors, vRtrIcmp6OutEchoReplies=vRtrIcmp6OutEchoReplies, tmnxVRtrNotificationV4v0Group=tmnxVRtrNotificationV4v0Group, vRtrV6StatTotalSdpTunnels=vRtrV6StatTotalSdpTunnels, vRtrIfDHCP6LeasePopulate=vRtrIfDHCP6LeasePopulate, vRtrStaticRouteAvailableIndex=vRtrStaticRouteAvailableIndex, tmnxDot1pAppTable=tmnxDot1pAppTable, vRtrConfTable=vRtrConfTable, vRtrIfDHCP6RelayServer3=vRtrIfDHCP6RelayServer3, vRtrIfDHCP6CurrLeasePopulate=vRtrIfDHCP6CurrLeasePopulate, vRtrDhcpRestoreLseStateProblem=vRtrDhcpRestoreLseStateProblem, vRtrInetStatRteCpeChkUpTime=vRtrInetStatRteCpeChkUpTime, tmnxVRtrNotificationObjV6v0Group=tmnxVRtrNotificationObjV6v0Group, vRtrNewIfIndex=vRtrNewIfIndex, vRtrManagedActiveRoutes=vRtrManagedActiveRoutes, vRtrIpCidrRouteLastEnabledTime=vRtrIpCidrRouteLastEnabledTime, vRtrGracefulRestart=vRtrGracefulRestart, vRtrIcmp6InNbrAdvertisements=vRtrIcmp6InNbrAdvertisements, vRtrIfBfdSessionLastUpTime=vRtrIfBfdSessionLastUpTime, vRtrIfIcmpV6PktTooBig=vRtrIfIcmpV6PktTooBig, vRtrIpCidrRouteTable=vRtrIpCidrRouteTable, vRtrDHCP6MsgStatsDropped=vRtrDHCP6MsgStatsDropped, vRtrIfPhysicalAddress=vRtrIfPhysicalAddress, vRtrIfBfdEchoInterval=vRtrIfBfdEchoInterval, vRtrStaticRouteTable=vRtrStaticRouteTable, vRtrIfDHCPRelayInfoOption=vRtrIfDHCPRelayInfoOption, vRtrInetStaticRouteCpeInterval=vRtrInetStaticRouteCpeInterval, tmnxVRtrGlobalR2r1Group=tmnxVRtrGlobalR2r1Group, tmnxVRtrConformance=tmnxVRtrConformance, vRtrIfIcmp6InEchos=vRtrIfIcmp6InEchos, vRtrIfIpcpPriDnsAddrType=vRtrIfIpcpPriDnsAddrType, vRtrIfDHCP6PfxDelegationTable=vRtrIfDHCP6PfxDelegationTable, vRtrStaticRouteEgressIfIndex=vRtrStaticRouteEgressIfIndex, vRtrDHCP6MsgStatsMsgType=vRtrDHCP6MsgStatsMsgType, vRtrIfIcmp6InGrpMembResponses=vRtrIfIcmp6InGrpMembResponses, vRtrIfBfdEntry=vRtrIfBfdEntry, tmnxDscpFCLastChanged=tmnxDscpFCLastChanged, vRtrIfLinkLocalAddressState=vRtrIfLinkLocalAddressState, vRtrInetSvcIpRangeRowStatus=vRtrInetSvcIpRangeRowStatus, vRtrInetAggrRowStatus=vRtrInetAggrRowStatus, vRtrIpAddrEntry=vRtrIpAddrEntry, vRtrExportPolicy5=vRtrExportPolicy5, vRtrIcmp6OutGrpMembReductions=vRtrIcmp6OutGrpMembReductions, vRtrIfProxyNDPolicy1=vRtrIfProxyNDPolicy1, vRtrIsIsStatus=vRtrIsIsStatus, vRtrIfIpcpTable=vRtrIfIpcpTable, vRtrIfIcmpTtlExpired=vRtrIfIcmpTtlExpired, vRtrTunnelNexthop=vRtrTunnelNexthop, vRtrStatIllegalLabels=vRtrStatIllegalLabels, vRtrLdpStatus=vRtrLdpStatus, vRtrAggregationRowStatus=vRtrAggregationRowStatus, vRtrIfDirectedBroadcast=vRtrIfDirectedBroadcast, vRtrIfDHCPRelayServer3=vRtrIfDHCPRelayServer3, vRtrIfProxyArpPolicy3=vRtrIfProxyArpPolicy3, vRtrInetStaticRouteStatus=vRtrInetStaticRouteStatus, tmnxVRtrDHCP6AssignedIllegSubnet=tmnxVRtrDHCP6AssignedIllegSubnet, tmnxVRtr7750V4v0Compliance=tmnxVRtr7750V4v0Compliance, vRtrIfIcmp6OutRedirects=vRtrIfIcmp6OutRedirects, vRtrMaxARPEntries=vRtrMaxARPEntries, vRtrStaticRouteLastEnabledTime=vRtrStaticRouteLastEnabledTime, vRtrDHCP6ServerNetAddrType=vRtrDHCP6ServerNetAddrType, vRtrIfIcmpRedirectsTime=vRtrIfIcmpRedirectsTime, vRtrIcmp6OutGrpMembResponses=vRtrIcmp6OutGrpMembResponses, vRiaInetEui64=vRiaInetEui64, vRtrInetSvcIpRangeAddr=vRtrInetSvcIpRangeAddr, vRtrRouterId=vRtrRouterId, vRtrV6AggregateRoutes=vRtrV6AggregateRoutes, vRtrStaticRoutePreference=vRtrStaticRoutePreference, vRtrMaxMcastNumRoutes=vRtrMaxMcastNumRoutes, vRtrTunnelEntry=vRtrTunnelEntry, vRtrIfProxyArpPolicy5=vRtrIfProxyArpPolicy5, vRtrInetStaticRouteCpeAddrType=vRtrInetStaticRouteCpeAddrType, vRtrIfDHCPAuthPolicy=vRtrIfDHCPAuthPolicy, vRtrIfUnnumberedIf=vRtrIfUnnumberedIf, vRtrInetStaticRouteMetric=vRtrInetStaticRouteMetric, vRtrManagedRouteInetAddrType=vRtrManagedRouteInetAddrType, vRtrVprnType=vRtrVprnType, vRtrV6StatBGPVpnRoutes=vRtrV6StatBGPVpnRoutes, vRtrIcmp6InAdminProhibs=vRtrIcmp6InAdminProhibs, vRtrIfDHCPLeaseStateEntry=vRtrIfDHCPLeaseStateEntry, vRtrTriggeredPolicy=vRtrTriggeredPolicy, vRtrIfIcmp6OutGrpMembReductions=vRtrIfIcmp6OutGrpMembReductions, vRtrIfDHCPRelayRxPkts=vRtrIfDHCPRelayRxPkts, vRtrRsvpStatus=vRtrRsvpStatus, vRtrIfArpPopulate=vRtrIfArpPopulate, vRtrIfDHCP6PfxdLastChanged=vRtrIfDHCP6PfxdLastChanged, vRtrStatTotalSdpTunnels=vRtrStatTotalSdpTunnels, tmnxVRtrBfdSessionProtChange=tmnxVRtrBfdSessionProtChange, vRtrIfLinkLocalAddressType=vRtrIfLinkLocalAddressType, vRtrDhcpRestoreLseStateVRtrId=vRtrDhcpRestoreLseStateVRtrId, vRtrV6StatActiveRsvpTunnels=vRtrV6StatActiveRsvpTunnels, vRtrIfDHCPLeasePopulate=vRtrIfDHCPLeasePopulate, vRtrDHCP6OldClientId=vRtrDHCP6OldClientId, vRtrSvcIpRangeEntry=vRtrSvcIpRangeEntry, vRtrAggregationIpPrefix=vRtrAggregationIpPrefix, vRtrDHCP6DropStatReason=vRtrDHCP6DropStatReason, tmnxDscpAppId=tmnxDscpAppId, tmnxDscpAppLastChanged=tmnxDscpAppLastChanged, vRiaIgpInhibit=vRiaIgpInhibit, vRtrIfDHCP6RemoteIdOption=vRtrIfDHCP6RemoteIdOption, vRtrIcmp6OutPktTooBigs=vRtrIcmp6OutPktTooBigs, vRtrIfDHCP6PfxDelegationEntry=vRtrIfDHCP6PfxDelegationEntry, tmnxVRtrDHCP6IllegalClientAddr=tmnxVRtrDHCP6IllegalClientAddr, vRtrV6BGPRoutes=vRtrV6BGPRoutes, vRtrInetAggrAggregatorAS=vRtrInetAggrAggregatorAS, vRtrIfProxyArpPolicy1=vRtrIfProxyArpPolicy1, vRtrIfEncapValue=vRtrIfEncapValue, vRtrStatBGPVpnRoutes=vRtrStatBGPVpnRoutes, vRtrIcmp6OutTimeExcds=vRtrIcmp6OutTimeExcds, vRtrStaticRouteEntry=vRtrStaticRouteEntry, vRtrSvcIpRangeExclusive=vRtrSvcIpRangeExclusive, vRtrIfDHCP6PfxdAdminState=vRtrIfDHCP6PfxdAdminState, vRtrInetStatRteCpeChkInPktCnt=vRtrInetStatRteCpeChkInPktCnt, vRtrIfIcmp6InEchoReplies=vRtrIfIcmp6InEchoReplies, vRtrIfDHCP6RelayServer4=vRtrIfDHCP6RelayServer4, tmnxVRtrMcastMaxRoutesCleared=tmnxVRtrMcastMaxRoutesCleared, vRtrMulticastRoutes=vRtrMulticastRoutes, vRiaIpAddress=vRiaIpAddress, vRtrImportPolicy3=vRtrImportPolicy3, vRtrDHCP6DropStatEntry=vRtrDHCP6DropStatEntry, vRtrRouteDistinguisher=vRtrRouteDistinguisher, vRtrV6StatActiveSdpTunnels=vRtrV6StatActiveSdpTunnels, tmnxVRtrMcastMidRouteTCA=tmnxVRtrMcastMidRouteTCA, tmnxVRtrIPv6MidRouteTCA=tmnxVRtrIPv6MidRouteTCA, vRtrIfDHCPLayer2Header=vRtrIfDHCPLayer2Header, vRtrDirectRoutes=vRtrDirectRoutes, vRtrIfDHCP6Table=vRtrIfDHCP6Table, vRtrIfProxyArpTable=vRtrIfProxyArpTable, vRtrV6OSPFActiveRoutes=vRtrV6OSPFActiveRoutes, vRtrIcmp6InRtrAdvertisements=vRtrIcmp6InRtrAdvertisements, vRtrIfServiceId=vRtrIfServiceId, vRtrAggregationIpPrefixMask=vRtrAggregationIpPrefixMask, tmnxDot1pAppEntry=tmnxDot1pAppEntry, vRtrStatEntry=vRtrStatEntry, vRtrExportPolicy2=vRtrExportPolicy2, vRtrIcmp6InPktTooBigs=vRtrIcmp6InPktTooBigs, vRtrIfIcmp6OutNbrAdvertisements=vRtrIfIcmp6OutNbrAdvertisements, vRtrIfProxyNDLocal=vRtrIfProxyNDLocal, vRtrInetStaticRouteCpeEnableLog=vRtrInetStaticRouteCpeEnableLog, tmnxVRtrStaticRteCPEChkV6v0Group=tmnxVRtrStaticRteCPEChkV6v0Group, vRtrExportPolicy1=vRtrExportPolicy1, vRtrServiceId=vRtrServiceId, tmnxVRtrDHCPAFEntriesExceeded=tmnxVRtrDHCPAFEntriesExceeded, vRtrInetAggrIpPrefixLen=vRtrInetAggrIpPrefixLen, tmnxVRtrDHCP6ServerLseStExceeded=tmnxVRtrDHCP6ServerLseStExceeded, tmnxVRtr7750V5v0Compliance=tmnxVRtr7750V5v0Compliance, vRtrIfDHCPRelayClientPktsRelayed=vRtrIfDHCPRelayClientPktsRelayed, vRtrIfIcmp6InPktTooBigs=vRtrIfIcmp6InPktTooBigs, vRtrIfBfdMultiplier=vRtrIfBfdMultiplier, vRtrStaticRoutes=vRtrStaticRoutes, vRtrIfDHCPRelayServer7=vRtrIfDHCPRelayServer7, vRtrIfDHCP6OperState=vRtrIfDHCP6OperState, vRtrRIPRoutes=vRtrRIPRoutes, vRtrIfIcmpNumUnreachables=vRtrIfIcmpNumUnreachables, vRtrIfDHCPLseStateOption82=vRtrIfDHCPLseStateOption82, vRtrOSPFActiveRoutes=vRtrOSPFActiveRoutes, vRtrStaticRouteIndex=vRtrStaticRouteIndex, vRtrIfIcmpV6PktTooBigTime=vRtrIfIcmpV6PktTooBigTime, tmnxVRtrIPv6IpV5v0Group=tmnxVRtrIPv6IpV5v0Group, tmnxVRtrDHCPLseStatePopulateErr=tmnxVRtrDHCPLseStatePopulateErr, vRtrIPv6RouteThresholdSoakTime=vRtrIPv6RouteThresholdSoakTime, vRtrInetStatRteCpeChkStatsEntry=vRtrInetStatRteCpeChkStatsEntry, vRtrName=vRtrName, vRtrIfDHCPGiAddress=vRtrIfDHCPGiAddress, vRtrIfDHCP6EnableNgbrResolution=vRtrIfDHCP6EnableNgbrResolution, vRtrDHCP6MsgStatsSent=vRtrDHCP6MsgStatsSent, vRtrMidRouteThreshold=vRtrMidRouteThreshold, tmnxVRtrBfdPortTypeNotSupported=tmnxVRtrBfdPortTypeNotSupported, vRtrType=vRtrType, vRtrIfCpmProtPolicyId=vRtrIfCpmProtPolicyId, vRtrIfDHCPOperLeasePopulate=vRtrIfDHCPOperLeasePopulate, vRtrIfDHCPLseStateChAddr=vRtrIfDHCPLseStateChAddr, vRtrAdvPrefixTable=vRtrAdvPrefixTable, tmnxVRtrNotificationV6v0Group=tmnxVRtrNotificationV6v0Group, vRtrIPv6MaxNumRoutesLogOnly=vRtrIPv6MaxNumRoutesLogOnly, vRtrIfDHCPClientApplications=vRtrIfDHCPClientApplications, vRtrInstanceAggregationTable=vRtrInstanceAggregationTable, vRtrAdvPrefixIfIndex=vRtrAdvPrefixIfIndex, tmnxVRtrDHCPSuspiciousPcktRcvd=tmnxVRtrDHCPSuspiciousPcktRcvd, tmnxVRtrIfSubscrAuthV3v0Group=tmnxVRtrIfSubscrAuthV3v0Group, vRiaNetMask=vRiaNetMask, vRtrIfIcmpV6NumPktTooBig=vRtrIfIcmpV6NumPktTooBig, vRtrV6StatTotalLdpTunnels=vRtrV6StatTotalLdpTunnels, vRtrAggregationAggregatorIPAddr=vRtrAggregationAggregatorIPAddr, vRtrInetStaticRoutePreference=vRtrInetStaticRoutePreference, tmnxDscpAppDscpValue=tmnxDscpAppDscpValue, vRtrAdvPrefixRowStatus=vRtrAdvPrefixRowStatus, vRtrIfGlobalIndexvRtrIfIndex=vRtrIfGlobalIndexvRtrIfIndex, vRtrStaticRouteIndexDest=vRtrStaticRouteIndexDest, vRtrIPv6IgnoreIcmpRedirect=vRtrIPv6IgnoreIcmpRedirect, vRtrDhcpLseStateOldCiAddr=vRtrDhcpLseStateOldCiAddr, vRtrIfLocalDhcpServerName=vRtrIfLocalDhcpServerName, vRtrIcmp6OutGrpMembQueries=vRtrIcmp6OutGrpMembQueries, vRtrIfDHCPRelayRemoteIdStr=vRtrIfDHCPRelayRemoteIdStr, tmnxVRtrIPv6IpV4v0Group=tmnxVRtrIPv6IpV4v0Group, tmnxVRtrIfIpcpV6v0Group=tmnxVRtrIfIpcpV6v0Group, vRtrIfIcmpV6ParamProblem=vRtrIfIcmpV6ParamProblem, tmnxDot1pAppId=tmnxDot1pAppId, vRtrIcmp6InTimeExcds=vRtrIcmp6InTimeExcds, vRtrInetStatRteCpeChkTTL=vRtrInetStatRteCpeChkTTL, vRtrIfIcmp6InErrors=vRtrIfIcmp6InErrors, vRtrInetSvcIpRangeExclusive=vRtrInetSvcIpRangeExclusive, vRtrIfDHCPLseStateCiAddr=vRtrIfDHCPLseStateCiAddr, vRtrIfDHCP6RelayServer7=vRtrIfDHCP6RelayServer7, vRtrIfIcmp6OutErrors=vRtrIfIcmp6OutErrors, vRtrIpCidrRouteMetric=vRtrIpCidrRouteMetric, vRtrIfIcmpMaskReply=vRtrIfIcmpMaskReply, vRtrIfIpcpEntry=vRtrIfIpcpEntry, tmnxVRtrBfdV6v0Group=tmnxVRtrBfdV6v0Group, vRtrIfIPv6OperState=vRtrIfIPv6OperState, vRtrIfBfdSessionLclAddrType=vRtrIfBfdSessionLclAddrType, vRtrV6StatTotalRsvpTunnels=vRtrV6StatTotalRsvpTunnels, vRiaInetAddress=vRiaInetAddress, vRtrIfIcmp6InRedirects=vRtrIfIcmp6InRedirects, vRtrBfdMaxSessionReason=vRtrBfdMaxSessionReason, vRtrIfIcmp6InGrpMembQueries=vRtrIfIcmp6InGrpMembQueries, vRtrInetStatRteCpeNotifyAddr=vRtrInetStatRteCpeNotifyAddr, vRtrIpNetToMediaOperState=vRtrIpNetToMediaOperState, vRtrIfIPv6IngressFilterId=vRtrIfIPv6IngressFilterId, vRtrIfDHCPRelayAuthPktsDiscarded=vRtrIfDHCPRelayAuthPktsDiscarded, tmnxVRtrMidRouteTCA=tmnxVRtrMidRouteTCA, vRtrIfIcmpV6TimeExceeded=vRtrIfIcmpV6TimeExceeded, vRtrIfIcmp6OutRtrSolicitsTime=vRtrIfIcmp6OutRtrSolicitsTime, vRtrIfDHCPRelayServer2=vRtrIfDHCPRelayServer2, vRtrIcmp6InErrors=vRtrIcmp6InErrors, tmnxVRtrIfV5v0Group=tmnxVRtrIfV5v0Group, vRtrIfEgressFilterId=vRtrIfEgressFilterId, vRtrTunnelID=vRtrTunnelID, vRtrIfIcmp6OutAdminProhibs=vRtrIfIcmp6OutAdminProhibs, vRtrISISActiveRoutes=vRtrISISActiveRoutes, vRtrDHCP6MsgStatTable=vRtrDHCP6MsgStatTable, vRtrAggregationLastChanged=vRtrAggregationLastChanged, vRtrStaticRouteAdminState=vRtrStaticRouteAdminState, vRtrV6HostRoutes=vRtrV6HostRoutes, vRtrManagedRouteInetAddr=vRtrManagedRouteInetAddr, vRtrIfChannelID=vRtrIfChannelID, vRtrDHCP6ClientNetAddr=vRtrDHCP6ClientNetAddr, vRtrOspfStatus=vRtrOspfStatus, vRtrDhcpLseStateNewChAddr=vRtrDhcpLseStateNewChAddr, vRtrStatConfiguredIfs=vRtrStatConfiguredIfs, vRiaInetAddressType=vRiaInetAddressType, vRtrDHCP6ServerNetAddr=vRtrDHCP6ServerNetAddr)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-VRTR-MIB", vRtrIfProxyNDEntry=vRtrIfProxyNDEntry, vRtrIfMtu=vRtrIfMtu, vRtrIfIcmpNumTtlExpired=vRtrIfIcmpNumTtlExpired, vRtrIfDHCPRelayAuthPktsSuccess=vRtrIfDHCPRelayAuthPktsSuccess, vRtrInetStaticRouteLastEnabledTime=vRtrInetStaticRouteLastEnabledTime, vRtrIfDHCPGiAddressAsSrc=vRtrIfDHCPGiAddressAsSrc, vRtrDHCP6MsgStatsRcvd=vRtrDHCP6MsgStatsRcvd, vRtrIfDHCP6CurrServerLeaseStates=vRtrIfDHCP6CurrServerLeaseStates, vRtrDHCP6DropStatLastCleared=vRtrDHCP6DropStatLastCleared, vRtrStatTotalRsvpTunnels=vRtrStatTotalRsvpTunnels, tmnxVRtrHighRouteTCA=tmnxVRtrHighRouteTCA, vRtrMaxNumRoutes=vRtrMaxNumRoutes, vRtrInetAggrASSet=vRtrInetAggrASSet, tmnxVRtrObsoletedObjectsV4v0Group=tmnxVRtrObsoletedObjectsV4v0Group, tmnxVRtrIpV5v0Group=tmnxVRtrIpV5v0Group, vRtrIfDHCPMatchOption82=vRtrIfDHCPMatchOption82, vRtrIcmp6InMsgs=vRtrIcmp6InMsgs, tmnxVRtrIPv6V4v0Group=tmnxVRtrIPv6V4v0Group, vRtrIcmp6InRedirects=vRtrIcmp6InRedirects, vRtrIcmp6OutRedirects=vRtrIcmp6OutRedirects, vRtrIfIcmp6OutNbrSolicits=vRtrIfIcmp6OutNbrSolicits, vRtrIfBfdTable=vRtrIfBfdTable, vRtrInetStaticRouteRowStatus=vRtrInetStaticRouteRowStatus, vRtrIfGlobalIndexEntry=vRtrIfGlobalIndexEntry, vRtrIfDHCPLeaseStateTable=vRtrIfDHCPLeaseStateTable, vRtrNextVRtrID=vRtrNextVRtrID, vRtrIfGlobalIndex=vRtrIfGlobalIndex, vRtrIfInitDelayEnable=vRtrIfInitDelayEnable, vRtrInetInstAggrTable=vRtrInetInstAggrTable, vRtrIcmp6InNbrSolicits=vRtrIcmp6InNbrSolicits, vRtrIfIcmp6InParmProblems=vRtrIfIcmp6InParmProblems, vRtrIfDHCPVendorOptionString=vRtrIfDHCPVendorOptionString, vRtrStaticRouteStatus=vRtrStaticRouteStatus, vRtrIfDHCPRelayServer1=vRtrIfDHCPRelayServer1, tmnxVRtrMaxArpEntriesCleared=tmnxVRtrMaxArpEntriesCleared, tmnxVRtrV6v0Group=tmnxVRtrV6v0Group, vRtrV6RIPRoutes=vRtrV6RIPRoutes, vRtrIfIcmp6InMsgs=vRtrIfIcmp6InMsgs, TmnxInetAddrState=TmnxInetAddrState, vRtrIfAlias=vRtrIfAlias, vRtrIcmp6InGrpMembQueries=vRtrIcmp6InGrpMembQueries, vRtrAdvPrefixOnLinkFlag=vRtrAdvPrefixOnLinkFlag, vRtrIfBfdSessionTable=vRtrIfBfdSessionTable, vRtrStatStaticARPEntries=vRtrStatStaticARPEntries, vRtrHostActiveRoutes=vRtrHostActiveRoutes, vRtrIfIPv6EgressFilterId=vRtrIfIPv6EgressFilterId, tmnxVRtrGlobalV6v0Group=tmnxVRtrGlobalV6v0Group, vRtrV6DirectRoutes=vRtrV6DirectRoutes, vRtrExportPolicy4=vRtrExportPolicy4, vRtrV6RIPActiveRoutes=vRtrV6RIPActiveRoutes, vRtrDHCP6DropStatTable=vRtrDHCP6DropStatTable, vRtrMldStatus=vRtrMldStatus, vRtrIcmp6OutDestUnreachs=vRtrIcmp6OutDestUnreachs, vRtrIpAddrTable=vRtrIpAddrTable, vRtrInetSvcIpRangePfxLen=vRtrInetSvcIpRangePfxLen, vRiaInetRemoteIpType=vRiaInetRemoteIpType, vRtrV6StatBGPVpnActiveRoutes=vRtrV6StatBGPVpnActiveRoutes, vRtrIfDHCPRelayStatsTable=vRtrIfDHCPRelayStatsTable, vRtrIfProxyNDPolicy2=vRtrIfProxyNDPolicy2, vRtrIfDHCPRelayPktsGenForceRenew=vRtrIfDHCPRelayPktsGenForceRenew, vRtrImportPolicy5=vRtrImportPolicy5, vRtrIPv6HighRouteThreshold=vRtrIPv6HighRouteThreshold, vRtrIfOperMtu=vRtrIfOperMtu, vRtrInetStaticRouteNextHopType=vRtrInetStaticRouteNextHopType, vRtrIcmp6OutEchos=vRtrIcmp6OutEchos, vRtrAdvPrefixEntry=vRtrAdvPrefixEntry, vRtrIfDHCP6AdminState=vRtrIfDHCP6AdminState, vRtrIpNetToMediaEntry=vRtrIpNetToMediaEntry, vRtrVrfTarget=vRtrVrfTarget, vRtrConfederationAS=vRtrConfederationAS, vRtrIfProxyArpEntry=vRtrIfProxyArpEntry, vRtrIfIcmp6OutRtrSolicits=vRtrIfIcmp6OutRtrSolicits, tmnxDot1pAppLastChanged=tmnxDot1pAppLastChanged, vRtrIfBfdSessionLastDownTime=vRtrIfBfdSessionLastDownTime, vRtrCustId=vRtrCustId, vRtrIfIcmp6OutNbrAdvTime=vRtrIfIcmp6OutNbrAdvTime, vRtrIfProxyNDPolicy5=vRtrIfProxyNDPolicy5, tmnxVRtrIpV4v0Group=tmnxVRtrIpV4v0Group, vRtrIfBfdSessionEntry=vRtrIfBfdSessionEntry, vRtrDHCP6AssignedNetAddr=vRtrDHCP6AssignedNetAddr, vRtrAS=vRtrAS, vRiaInetAddrState=vRiaInetAddrState, vRtrV6StatIllegalLabels=vRtrV6StatIllegalLabels, vRtrInetInstAggrEntry=vRtrInetInstAggrEntry, vRtrIfDHCP6SourceAddress=vRtrIfDHCP6SourceAddress, vRtrInetStaticRouteDisallowIgp=vRtrInetStaticRouteDisallowIgp, vRtrEcmpMaxRoutes=vRtrEcmpMaxRoutes, vRtrV6ISISActiveRoutes=vRtrV6ISISActiveRoutes, vRtrV6StatTotalNbrEntries=vRtrV6StatTotalNbrEntries, vRtrInetStaticRouteDest=vRtrInetStaticRouteDest, vRtrIfIcmpV6NumTimeExceeded=vRtrIfIcmpV6NumTimeExceeded, vRtrStaticRouteIndexTable=vRtrStaticRouteIndexTable, vRtrIfDHCPDescription=vRtrIfDHCPDescription, vRtrStaticActiveRoutes=vRtrStaticActiveRoutes, vRtrDHCP6DropStatPktsDropped=vRtrDHCP6DropStatPktsDropped, vRtrIcmp6OutMsgs=vRtrIcmp6OutMsgs, vRtrIfDHCPRelayClientPktsDiscarded=vRtrIfDHCPRelayClientPktsDiscarded, tmnxDscpFCValue=tmnxDscpFCValue, vRtrOspfv3Status=vRtrOspfv3Status, vRtrInetStaticRouteEntry=vRtrInetStaticRouteEntry, vRtrIfDHCP6RelayServer8=vRtrIfDHCP6RelayServer8, vRtrV6MulticastRoutes=vRtrV6MulticastRoutes, vRtrStaticRouteTag=vRtrStaticRouteTag, tmnxVRtrIPv6HighRouteCleared=tmnxVRtrIPv6HighRouteCleared, tmnxVRtrNotificationV5v0Group=tmnxVRtrNotificationV5v0Group, vRtrBgpStatus=vRtrBgpStatus, vRtrIfProxyArpPolicy4=vRtrIfProxyArpPolicy4, vRtrV6AggregateActiveRoutes=vRtrV6AggregateActiveRoutes, vRtrIfDHCPRelayTrusted=vRtrIfDHCPRelayTrusted, vRtrIfDHCPRelayRxMalformedPkts=vRtrIfDHCPRelayRxMalformedPkts, vRtrDHCP6LeaseOverrideResult=vRtrDHCP6LeaseOverrideResult, vRtrV6StatActiveIfs=vRtrV6StatActiveIfs, tmnxVRtrGlobalObjs=tmnxVRtrGlobalObjs, vRtrIfProxyNDPolicy3=vRtrIfProxyNDPolicy3, vRtrSubMgmtActiveRoutes=vRtrSubMgmtActiveRoutes, vRtrTunnelTable=vRtrTunnelTable, vRtrIfIcmp6OutTimeExcds=vRtrIfIcmp6OutTimeExcds, vRtrIllegalLabelThreshold=vRtrIllegalLabelThreshold, vRtrStatActiveARPEntries=vRtrStatActiveARPEntries, tmnxVRtrIfCpmProtectGroup=tmnxVRtrIfCpmProtectGroup, vRtrIfBfdReceiveInterval=vRtrIfBfdReceiveInterval, tmnxVRtrDHCPLeaseStateOverride=tmnxVRtrDHCPLeaseStateOverride, vRtrAdvPrefixValidLifetime=vRtrAdvPrefixValidLifetime, vRtrIfType=vRtrIfType, vRtrIfDHCPTable=vRtrIfDHCPTable, vRtrV6DirectActiveRoutes=vRtrV6DirectActiveRoutes, vRtrIfDHCPRelayServerPktsSnooped=vRtrIfDHCPRelayServerPktsSnooped, vRtrV6ISISRoutes=vRtrV6ISISRoutes, vRtrIfVPNClass=vRtrIfVPNClass, vRtrIcmp6OutRtrSolicits=vRtrIcmp6OutRtrSolicits, vRtrSvcIpRangeMask=vRtrSvcIpRangeMask, vRtrIfTosMarkingTrusted=vRtrIfTosMarkingTrusted, vRtrV6StatCurrNumRoutes=vRtrV6StatCurrNumRoutes, vRtrInetStaticRouteCpeStatus=vRtrInetStaticRouteCpeStatus, vRtrMaxNumRoutesLogOnly=vRtrMaxNumRoutesLogOnly, vRtrIfIcmpUnreachables=vRtrIfIcmpUnreachables, vRtrIfBfdSessionDownCount=vRtrIfBfdSessionDownCount, tmnxVRtrIllegalLabelTCA=tmnxVRtrIllegalLabelTCA, vRtrIfIcmp6OutDestUnreachs=vRtrIfIcmp6OutDestUnreachs, vRtrIfIcmp6OutNbrSolicitsTime=vRtrIfIcmp6OutNbrSolicitsTime, tmnxVRtrDHCPLseStRestoreProblem=tmnxVRtrDHCPLseStRestoreProblem, vRtrAdvPrefixPrefix=vRtrAdvPrefixPrefix, vRtrIfDHCP6RelayServer2=vRtrIfDHCP6RelayServer2, vRtrFailureDescription=vRtrFailureDescription, vRtrIgmpStatus=vRtrIgmpStatus, vRtrInetStaticRouteTable=vRtrInetStaticRouteTable, vRtrInetStaticRouteNextHop=vRtrInetStaticRouteNextHop, tmnxDscpAppTable=tmnxDscpAppTable, vRtrIfIcmpV6Unreachables=vRtrIfIcmpV6Unreachables, tmnxDscpFCDscpValue=tmnxDscpFCDscpValue, tmnxVRtrBfdMaxSessionOnSlot=tmnxVRtrBfdMaxSessionOnSlot, vRtrIfDHCPAdminState=vRtrIfDHCPAdminState, tmnxDscpFCTable=tmnxDscpFCTable, tmnxDot1pAppTableLastChanged=tmnxDot1pAppTableLastChanged, vRtrStaticRouteIgpShortcut=vRtrStaticRouteIgpShortcut, vRtrInetInstAggrTblLastChged=vRtrInetInstAggrTblLastChged, vRtrIfIcmpUnreachablesTime=vRtrIfIcmpUnreachablesTime, vRtrStatActiveLdpTunnels=vRtrStatActiveLdpTunnels, vRtrStatInternalARPEntries=vRtrStatInternalARPEntries, vRtrInetStaticRouteStaticType=vRtrInetStaticRouteStaticType, vRtrIfDHCP6PfxdDUID=vRtrIfDHCP6PfxdDUID, vRtrIfIcmpV6RedirectsTime=vRtrIfIcmpV6RedirectsTime, vRtrIfDHCPAutoFilter=vRtrIfDHCPAutoFilter, vRtrDhcpRestoreLseStateCiAddr=vRtrDhcpRestoreLseStateCiAddr, vRtrDhcpPacketProblem=vRtrDhcpPacketProblem, vRtrIfIcmpV6Redirects=vRtrIfIcmpV6Redirects, tmnxVRtrDHCP6LseStateOverride=tmnxVRtrDHCP6LseStateOverride, vRtrStatTotalLdpTunnels=vRtrStatTotalLdpTunnels, vRtrIfArpTimeout=vRtrIfArpTimeout, tmnxVRtrIfDHCPRelayGroup=tmnxVRtrIfDHCPRelayGroup, vRtrStaticRouteIndexEntry=vRtrStaticRouteIndexEntry, vRtrIcmp6InEchoReplies=vRtrIcmp6InEchoReplies, vRtrDhcpLseStatePopulateError=vRtrDhcpLseStatePopulateError, vRtrPimStatus=vRtrPimStatus, vRtrAggregationAggregatorAS=vRtrAggregationAggregatorAS, vRtrSvcIpRangeTable=vRtrSvcIpRangeTable, vRtrV6BGPActiveRoutes=vRtrV6BGPActiveRoutes, vRtrIfDHCP6RelayServer5=vRtrIfDHCP6RelayServer5, vRtrIfIpcpSecDnsAddrType=vRtrIfIpcpSecDnsAddrType, tmnxVRtrStaticRouteCPEStatus=tmnxVRtrStaticRouteCPEStatus, vRtrInetStaticRouteIndexTable=vRtrInetStaticRouteIndexTable, vRtrIfBfdAdminState=vRtrIfBfdAdminState, vRtrAdvPrefixPreferredLifetime=vRtrAdvPrefixPreferredLifetime, vRtrBGPRoutes=vRtrBGPRoutes, tmnxVRtrIfDhcpServerGroup=tmnxVRtrIfDhcpServerGroup, vRtrNumberOfBfdSessionsOnSlot=vRtrNumberOfBfdSessionsOnSlot, vRtrInetAggrLastChanged=vRtrInetAggrLastChanged, vRtrIfBfdSessionRemAddrType=vRtrIfBfdSessionRemAddrType, vRtrIfIcmpV6NumParamProblem=vRtrIfIcmpV6NumParamProblem, vRtrAdvPrefixAutonomousFlag=vRtrAdvPrefixAutonomousFlag, tmnxVRtrManagedRouteAddFailed=tmnxVRtrManagedRouteAddFailed, vRtrIfIcmp6InNbrSolicits=vRtrIfIcmp6InNbrSolicits, vRtrStatActiveSdpTunnels=vRtrStatActiveSdpTunnels, vRtrStatActiveRsvpTunnels=vRtrStatActiveRsvpTunnels, vRtrImportPolicy1=vRtrImportPolicy1, vRtrActiveVRtrs=vRtrActiveVRtrs, tmnxVRtrDHCP6RelayLseStExceeded=tmnxVRtrDHCP6RelayLseStExceeded, vRtrVpnId=vRtrVpnId, vRtrIcmp6OutAdminProhibs=vRtrIcmp6OutAdminProhibs, vRtrIcmp6Entry=vRtrIcmp6Entry, vRtrAutoFilterDHCPClientAddress=vRtrAutoFilterDHCPClientAddress, vRtrIfIcmp6OutEchos=vRtrIfIcmp6OutEchos, vRtrIfDHCPRelayServer8=vRtrIfDHCPRelayServer8, vRtrMcPathMgmtPlcyName=vRtrMcPathMgmtPlcyName, vRtrSvcIpRangeAddress=vRtrSvcIpRangeAddress, tmnxVRtr7450V5v0Compliance=tmnxVRtr7450V5v0Compliance, vRtrIfDHCPRelayServer5=vRtrIfDHCPRelayServer5, vRtrAggregationSummaryOnly=vRtrAggregationSummaryOnly, vRtrPolicyTable=vRtrPolicyTable, vRtrIfIcmpNumRedirects=vRtrIfIcmpNumRedirects, vRtrIfIcmpRedirects=vRtrIfIcmpRedirects, vRtrExportPolicy3=vRtrExportPolicy3, tmnxVRtrGroups=tmnxVRtrGroups, TDSCPAppId=TDSCPAppId, vRtrIfIpcpSecDnsAddr=vRtrIfIpcpSecDnsAddr, vRtrStaticRouteIndexMask=vRtrStaticRouteIndexMask, tmnxVRtrObjs=tmnxVRtrObjs, vRtrIfPortID=vRtrIfPortID, vRtrInetAggrSummaryOnly=vRtrInetAggrSummaryOnly, vRtrIcmp6InDestUnreachs=vRtrIcmp6InDestUnreachs, vRtrIfBfdSessionState=vRtrIfBfdSessionState, tmnxDscpAppV6v0Group=tmnxDscpAppV6v0Group, vRtrIfDelayUpTimer=vRtrIfDelayUpTimer, vRtrIgnoreIcmpRedirect=vRtrIgnoreIcmpRedirect, vRtrIcmp6OutParmProblems=vRtrIcmp6OutParmProblems, tmnxVRtrDHCP6RelayReplyStripUni=tmnxVRtrDHCP6RelayReplyStripUni, vRtrInetStaticRouteEnableBfd=vRtrInetStaticRouteEnableBfd, vRtrIfIcmp6InDestUnreachs=vRtrIfIcmp6InDestUnreachs, vRtrIfDHCPRelayRemoteId=vRtrIfDHCPRelayRemoteId, vRtrIfDHCPAntiSpoofMacAddr=vRtrIfDHCPAntiSpoofMacAddr, vRtrIcmp6InGrpMembReductions=vRtrIcmp6InGrpMembReductions, vRtrIfIcmp6OutMsgs=vRtrIfIcmp6OutMsgs, vRtrMaxMcastNumRoutesLogOnly=vRtrMaxMcastNumRoutesLogOnly, vRtrIfDHCPRelayStatsEntry=vRtrIfDHCPRelayStatsEntry, vRtrStatLocalARPEntries=vRtrStatLocalARPEntries, vRtrIfBfdSessionRemAddr=vRtrIfBfdSessionRemAddr, vRtrIfDHCP6LastChanged=vRtrIfDHCP6LastChanged, vRtrIfDHCP6PfxDelegationLstChgd=vRtrIfDHCP6PfxDelegationLstChgd, vRtrIfNameTable=vRtrIfNameTable, vRtrIfIcmp6OutEchoReplies=vRtrIfIcmp6OutEchoReplies, vRtrGracefulRestartType=vRtrGracefulRestartType, tmnxDscpAppEntry=tmnxDscpAppEntry)
