#
# PySNMP MIB module ALCATEL-IND1-TIMETRA-LDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nokia/aos7/ALCATEL-IND1-TIMETRA-LDP-MIB
# Produced by pysmi-1.1.8 at Fri Jan 14 00:01:25 2022
# On host fv-az83-250 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
TFilterID, TFilterLogId = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-FILTER-MIB", "TFilterID", "TFilterLogId")
timetraSRMIBModules, tmnxSRNotifyPrefix, tmnxSRConfs, tmnxSRObjs = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-GLOBAL-MIB", "timetraSRMIBModules", "tmnxSRNotifyPrefix", "tmnxSRConfs", "tmnxSRObjs")
TdmOptionsSigPkts, TdmOptionsCasTrunkFraming, SdpId, ServType = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-SERV-MIB", "TdmOptionsSigPkts", "TdmOptionsCasTrunkFraming", "SdpId", "ServType")
TmnxVRtrMplsLspID, TmnxVcType, TNamedItemOrEmpty, TPolicyStatementNameOrEmpty, TmnxOperState, TmnxVcId, TmnxServId, TmnxAdminState = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-TC-MIB", "TmnxVRtrMplsLspID", "TmnxVcType", "TNamedItemOrEmpty", "TPolicyStatementNameOrEmpty", "TmnxOperState", "TmnxVcId", "TmnxServId", "TmnxAdminState")
vRtrID, vRtrLdpStatus = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID", "vRtrLdpStatus")
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
MplsLsrIdentifier, MplsLdpIdentifier = mibBuilder.importSymbols("MPLS-LDP-MIB", "MplsLsrIdentifier", "MplsLdpIdentifier")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Unsigned32, iso, ObjectIdentity, ModuleIdentity, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Integer32, MibIdentifier, IpAddress, Gauge32, Bits, TimeTicks, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "iso", "ObjectIdentity", "ModuleIdentity", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Integer32", "MibIdentifier", "IpAddress", "Gauge32", "Bits", "TimeTicks", "Counter64")
TextualConvention, DisplayString, TruthValue, TestAndIncr, RowStatus, TimeStamp, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue", "TestAndIncr", "RowStatus", "TimeStamp", "TimeInterval")
timetraLdpMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 8))
timetraLdpMIBModule.setRevisions(('1908-01-01 00:00', '1907-01-01 00:00', '1906-03-16 00:00', '1905-08-31 00:00', '1905-01-24 00:00', '1904-01-15 00:00', '1903-08-15 00:00', '1903-01-20 00:00', '1901-08-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: timetraLdpMIBModule.setRevisionsDescriptions(('Rev 6.0                01 Jan 2008 00:00\n                         6.0 release of the TIMETRA-LDP-MIB.', 'Rev 5.0                01 Jan 2007 00:00\n                         5.0 release of the TIMETRA-LDP-MIB.', 'Rev 4.0                16 Mar 2006 00:00\n                         4.0 release of the TIMETRA-LDP-MIB.', 'Rev 3.0                31 Aug 2005 00:00\n                         3.0 release of the TIMETRA-LDP-MIB.', 'Rev 2.1                24 Jan 2005 00:00\n                         2.1 release of the TIMETRA-LDP-MIB.', 'Rev 2.0                15 Jan 2004 00:00\n                         2.0 release of the TIMETRA-LDP-MIB.', 'Rev 1.2                15 Aug 2003 00:00\n                         1.2 release of the TIMETRA-LDP-MIB.', 'Rev 1.0                20 Jan 2003 00:00\n                         1.0 Release of the TIMETRA-LDP-MIB.', 'Rev 0.1                01 Aug 2001 00:00\n                         Initial version of the TIMETRA-LDP-MIB.',))
if mibBuilder.loadTexts: timetraLdpMIBModule.setLastUpdated('0801010000Z')
if mibBuilder.loadTexts: timetraLdpMIBModule.setOrganization('Alcatel')
if mibBuilder.loadTexts: timetraLdpMIBModule.setContactInfo('Alcatel 7x50 Support\n             Web: http://www.alcatel.com/comps/pages/carrier_support.jhtml')
if mibBuilder.loadTexts: timetraLdpMIBModule.setDescription("The MIB module to manage and provision the Alcatel 7x50 LDP\n        protocol features.\n\n        Copyright 2003-2008 Alcatel-Lucent. All rights reserved.\n        Reproduction of this document is authorized on the condition that\n        the foregoing copyright notice is included.\n\n        This SNMP MIB module (Specification) embodies Alcatel's\n        proprietary intellectual property.  Alcatel retains \n        all title and ownership in the Specification, including any \n        revisions.\n\n        Alcatel grants all interested parties a non-exclusive \n        license to use and distribute an unmodified copy of this \n        Specification in connection with management of Alcatel \n        products, and without fee, provided this copyright notice and \n        license appear on all copies.\n\n        This Specification is supplied 'as is', and Alcatel \n        makes no warranty, either express or implied, as to the use, \n        operation, condition, or performance of the Specification.")
tmnxLdpObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8))
tmnxLdpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8))
tmnxLdpNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 8))
tmnxLdpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 8, 0))
class TmnxLdpKeepAliveFactor(TextualConvention, Unsigned32):
    description = 'TmnxLdpKeepAliveFactor specifies the value by which the \n         keepalive timeout should be divided to give the keepalive \n         time i.e. the time interval, in seconds, between LDP \n         Keepalive messages. LDP Keepalive messages are sent to \n         keep the LDP session from timing out when no other LDP \n         traffic is being sent between the neighbors.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 255)

class TmnxLdpKeepAliveTimeout(TextualConvention, Unsigned32):
    description = 'TmnxLdpKeepAliveTimeout specifies the the time interval,\n         in seconds, that LDP waits before tearing down a session.\n         If no LDP messages are exchanged during this time interval,\n         the LDP session is torn down. Generally the keepalive\n         timeout interval should be configured to be 3 times the\n         keepalive time (the time interval between successive LDP \n         Keepalive messages).'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 65535)

class TmnxLdpHelloFactor(TextualConvention, Unsigned32):
    description = 'TmnxLdpHelloFactor specifies the value by which the hello\n         timeout should be divided to give the hello time i.e. the \n         time interval, in seconds, between LDP Hello messages. LDP\n         uses Hello messages to discover neighbors and to detect \n         loss of connectivity with its neighbors.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 255)

class TmnxLdpHelloTimeout(TextualConvention, Unsigned32):
    description = 'TmnxLdpHelloTimeout specifies the the time interval, in\n         seconds, that LDP waits before declaring a neighbor to  \n         be down. Hello timeout is local to the system and is sent\n         in the Hello messages to a neighbor. Hello timeout cannot\n         be set to a value that is less than 3 times the hello time.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 65535)

class TmnxLdpBackoffTime(TextualConvention, Unsigned32):
    description = 'TmnxLdpBackoffTime specifies the backoff interval (initial \n         and maximum). \n         The backoff interval is the time, in seconds, that LDP waits\n         after an LDP session setup has failed before it attempts to\n         setup the session again. After the LDP session startup fails\n         the first time, the backoff interval is set to an initial \n         value. Thereafter, if session startup fails again the backoff\n         interval increases exponentially until it reaches a maximum\n         value specified by the maximum backoff interval. \n         If the maximum backoff interval is set to zero (0), then the \n         backoff interval does not increase exponentially after the \n         first session startup attempt fails. Instead it remains\n         constant and LDP will keep retrying to establish a session \n         until it succeeds.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 2592000)

class TmnxLdpFECPolicy(TextualConvention, Integer32):
    description = "TmnxLdpFECPolicy determines whether the LSR should generate \n         FECs and which FECs it should generate.\n         \n         system(1) - LDP will distribute label bindings only for the \n         router's system IP address\n\n         interface(2) - LDP will distribute label bindings for all \n         LDP interfaces\n\n         all(3) - LDP will distribute label bindings for all prefixes\n         in the routing table\n         \n         none(4) - LDP will not distribute any label bindings."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("system", 1), ("interface", 2), ("all", 3), ("none", 4))

class TmnxLdpLabelDistMethod(TextualConvention, Integer32):
    description = "TmnxLdpLabelDistMethod describes the label distribution method used.\n             \n         When the value is 'downstreamOnDemand', label bindings are \n         distributed to the upstream LSR only when a label request message\n         is received.\n\n         When the value is 'downstreamUnsolicited', label bindings are \n         distributed to the upstream LSR, for each FEC, without requiring\n         a request message for the FEC from the upstream LSR."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("downstreamOnDemand", 1), ("downstreamUnsolicited", 2))

class TmnxLdpAdjacencyType(TextualConvention, Integer32):
    description = 'TmnxLdpAdjacencyType describes the type of adjacency, either \n         targeted or link, for a row in the vRtrLdpHelloAdjTable. It \n         also describes the type of adjacencies in an LDP Session row \n         in the vRtrLdpSessionTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("link", 1), ("targeted", 2), ("both", 3))

class TmnxVpnId(TextualConvention, OctetString):
    description = "TmnxVpnId specifies the value of a VPN (Virtual Private Network)\n         identifier. This is a 10 byte value - the VPN 'type' is stored  \n         in the first two bytes the TmnxVpnId. The next four bytes store\n         an 'AS (Autonomous System) number'. A 'local identifier' for the\n         VPN is stored as the last four bytes."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(10, 10)
    fixedLength = 10

class TmnxLabelStatus(TextualConvention, Bits):
    description = "TmnxLabelStatus bit flags specifies the status of an ingress or\n         egress label.\n         \n         Flags marked dummy* are not used and MUST be 0.\n\n         'statusSignalingSupported' - indicates whether status signaling is \n                       enabled or not.         \n         'inUsePush' - indicates that the label contains valid information \n                       that is currently being used as a 'push' label.\n         'inUseSwap' - indicates that the label contains valid information \n                       that is currently being used as a 'swap' label.\n         'inUsePop'  - indicates that the label contains valid information \n                       that is currently being used as a 'pop' label.\n         'released'  - indicates that the label is in the process of being \n                       freed. With this flag set, no other flags will be set.\n         'notInUse'  - indicates that the label contains valid information\n                       but is currently not being used possibly because the \n                       service is temporarily down.\n         'withdrawn' - indicates that the label has not been sent (possibly\n                       due to a mismatch in control word or status signaling)         \n         'controlWord' - indicates that the control word will be signaled"
    status = 'current'
    namedValues = NamedValues(("dummyB0", 0), ("dummyB1", 1), ("statusSignalingSupported", 2), ("inUsePush", 3), ("inUseSwap", 4), ("inUsePop", 5), ("released", 6), ("notInUse", 7), ("withdrawn", 8), ("controlWord", 9))

class TmnxLabelSigStatus(TextualConvention, Unsigned32):
    reference = 'IETF draft-ietf-pwe3-iana-allocation-07.txt, sections 2,3 and 4'
    description = 'TmnxLabelSigStatus specifies the status of the pseudowire and attached \n         circuit.  The values are defined in \n         draft-ietf-pwe3-iana-allocation-07.txt.'
    status = 'current'

class TmnxLdpFECType(TextualConvention, Integer32):
    description = 'TmnxLdpFECType determines the kind of FEC that the label \n         mapping, withdraw, release and request messages are \n         referring to.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 128, 129, 130))
    namedValues = NamedValues(("addrWildcard", 1), ("addrPrefix", 2), ("addrHost", 3), ("vll", 128), ("vpws", 129), ("vpls", 130))

class TmnxLdpFECFlags(TextualConvention, Bits):
    description = "TmnxLdpFECFlags bit flags define the characteristics of FEC.\n         Flags marked dummy* are not used and MUST be 0.\n\n         Flag 'egress':  this node is an egress for this FEC.\n         Flag 'ingress': this node is a potential ingress for this FEC.\n         Flag 'installedSwap': the label for this FEC has been programmed \n                               as a 'swap' label.\n         Flag 'installedPush': the label for this FEC has been programmed \n                               as a 'push' label.\n         Flag 'installedPop':  the label for this FEC has been programmed \n                               as a 'pop' label.\n         Flag 'local':   this FEC is local to this node.\n         Flag 'nextHop': the nextHop for this FEC is known.\n         Flag 'vcSwitching': vcSwitching is enabled for the FEC.\n         Flag 'importTargPolicyRejected': targeted LDP import policy has\n                                          rejected this FEC.\n         Flag 'exportTargPolicyRejected': targeted LDP export policy has\n                                          rejected this FEC."
    status = 'current'
    namedValues = NamedValues(("dummyB0", 0), ("egress", 1), ("ingress", 2), ("installedSwap", 3), ("installedPush", 4), ("installedPop", 5), ("local", 6), ("nextHop", 7), ("importPolicyRejected", 8), ("exportPolicyAccepted", 9), ("installedStaticFec", 10), ("vcSwitching", 11), ("importTargPolicyRejected", 12), ("exportTargPolicyRejected", 13))

class TmnxLdpGenOperDownReasonCode(TextualConvention, Integer32):
    description = 'TmnxLdpGenOperDownReasonCode is an enumerated integer that specifies \n         the reason that the LDP instance is operationally down.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("operUp", 0), ("adminDown", 1), ("noListenSocket", 2), ("noDiscoverySocket", 3), ("noRtm", 4), ("noTtm", 5), ("iomFailure", 6), ("recvFailure", 7), ("clearDown", 8), ("noResources", 9), ("systemIpDown", 10))

class TmnxLdpIntTargOperDownReasonCode(TextualConvention, Integer32):
    description = 'TmnxLdpIntTargOperDownReasonCode is an enumerated integer \n         that specifies the reason that the LDP interface and targeted peer\n         is operationally down.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
    namedValues = NamedValues(("operUp", 0), ("adminDown", 1), ("noListenSocket", 2), ("noDiscoverySocket", 3), ("noResources", 4), ("addrFecDeprogram", 5), ("svcFecDeprogram", 6), ("clearDown", 7), ("instanceDown", 8), ("interfaceDown", 9), ("targetIpInvalid", 10), ("interfaceInvalid", 11))

class TmnxLdpFec129Tlv(TextualConvention, OctetString):
    description = "TmnxLdpFec129Tlv is a Type-Length-Value (Tlv) that specifies\n         the value encoded as one-byte Type followed by one byte Length\n         followed by the 'Length' size Value used for FEC-129 attribute."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 32)

vRtrLdpGeneralTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1), )
if mibBuilder.loadTexts: vRtrLdpGeneralTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGeneralTable.setDescription('vRtrLdpGeneralTable has an entry for each virtual router \n         in the system capable of supporting an instance of the\n         Label Distribution Protocol (LDP).')
vRtrLdpGeneralEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"))
if mibBuilder.loadTexts: vRtrLdpGeneralEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGeneralEntry.setDescription("Each row entry represents an instance of the Label Distribution\n         Protocol (LDP) for a virtual router in the system. \n\n         An entry in this table is created by the agent when vRtrLdpStatus\n         in the vRtrConfTable is set to 'create'. \n         The entry is destroyed when vRtrLdpStatus is set to 'delete' but\n         only if vRtrLdpGenAdminState has a value of 'outOfService'.")
vRtrLdpGenLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenLastChange.setDescription('The value of vRtrLdpGenLastChange specifies the sysUpTime\n         when this row was last modified.')
vRtrLdpGenAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 2), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenAdminState.setDescription('The value of vRtrLdpGenAdminState specifies the desired \n         administrative state for this LDP instance.')
vRtrLdpGenOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 3), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenOperState.setDescription('The value of vRtrLdpGenOperState specifies the current \n         operational state of this LDP instance.')
vRtrLdpGenLdpLsrId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 4), MplsLsrIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenLdpLsrId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenLdpLsrId.setDescription('The value of vRtrLdpGenLdpLsrId is the Label Switch Router\n         (LSR) identifier which is used as the first 4 bytes or the \n         Router Id component of the Label Distribution Protocol (LDP) \n         identifier.')
vRtrLdpGenProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenProtocolVersion.setDescription('The value of  vRtrLdpGenProtocolVersion specifies the \n         version of the LDP protocol instance. A value of zero (0) \n         indicates that the version of the protocol is unknown.')
vRtrLdpGenDeaggregateFec = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenDeaggregateFec.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenDeaggregateFec.setDescription("When vRtrLdpGenDeaggregateFec has a value of 'false', LDP\n         aggregates multiple prefixes into a single Forwarding Equivalence\n         Class (FEC) and advertises a single label for the FEC. When the \n         value is 'true', LDP deaggregates prefixes into multiple\n         FECs.\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.")
vRtrLdpGenKeepAliveFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 7), TmnxLdpKeepAliveFactor().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenKeepAliveFactor.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenKeepAliveFactor.setDescription('The value of vRtrLdpGenKeepAliveFactor specifies the value\n         by which the keepalive timeout (vRtrLdpGenKeepAliveTimeout)\n         should be divided to give the keepalive time i.e. the time \n         interval, in seconds, between LDP keepalive messages. LDP \n         keepalive messages are sent to keep the LDP session from timing \n         out when no other LDP traffic is being sent between the neighbors.\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.')
vRtrLdpGenKeepAliveTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 8), TmnxLdpKeepAliveTimeout().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenKeepAliveTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenKeepAliveTimeout.setDescription('The value of vRtrLdpGenKeepAliveTimeout specifies the time\n         interval, in seconds, that LDP waits before tearing down a \n         session. If no LDP messages are exchanged during this time \n         interval, the LDP session is torn down. Generally the value of \n         vRtrLdpGenKeepAliveTimeout is configured to be 3 times the\n         keepalive time (the time interval between successive LDP \n         keepalive messages).\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.')
vRtrLdpGenHelloFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 9), TmnxLdpHelloFactor().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenHelloFactor.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenHelloFactor.setDescription('The value of vRtrLdpGenHelloFactor specifies the value by \n         which the hello timeout (vRtrLdpGenHelloTimeout) should be\n         divided to give the hello time i.e. the time interval, in seconds, \n         between LDP Hello messages. LDP uses hello messages to discover\n         neighbors and to detect loss of connectivity with its neighbors.\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.')
vRtrLdpGenHelloTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 10), TmnxLdpHelloTimeout().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenHelloTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenHelloTimeout.setDescription('The value of vRtrLdpGenHelloTimeout specifies the hello time \n         also known as hold time. It is the time interval, in seconds, that\n         LDP waits before declaring a neighbor to be down. Hello timeout \n         is local to the system and is sent in the hello messages to a\n         neighbor. Hello timeout cannot be set to a value that is less \n         than 3 times the hello time.\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.')
vRtrLdpGenRoutePreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(9)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenRoutePreference.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenRoutePreference.setDescription('The value of vRtrLdpGenRoutePreference specifies the route \n         preference assigned to LDP routes. When multiple routes are \n         available to a destination, the route with the lowest preference \n         will be used.\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.')
vRtrLdpGenControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ordered", 1), ("independent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenControlMode.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenControlMode.setDescription("The value of vRtrLdpGenControlMode specifies the mode used  \n         for distributing labels in response to label binding requests.\n             \n         When vRtrLdpGenControlMode has a value of 'ordered', label \n         bindings are not distributed in response to a label request until \n         a label binding has been received from the next hop for the \n         destination.\n                           \n         When vRtrLdpGenControlMode has a value of 'independent', label \n         bindings are distributed immediately in response to a label \n         request even if a label binding has not yet been received from \n         the next hop for the destination.")
vRtrLdpGenDistMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 13), TmnxLdpLabelDistMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenDistMethod.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenDistMethod.setDescription("The value of vRtrLdpGenDistMethod specifies the label\n         distribution method used.\n             \n         When vRtrLdpGenDistMethod has a value of 'downstreamOnDemand',\n         label bindings are distributed to the upstream LSR, for each FEC, \n         without requiring a request message for the FEC from the upstream \n         LSR.\n\n         When vRtrLdpGenDistMethod has a value of 'downstreamUnsolicited',\n         label bindings are distributed to the upstream LSR only when a \n         label request message is received.")
vRtrLdpGenRetentionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("conservative", 1), ("liberal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenRetentionMode.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenRetentionMode.setDescription("The value of vRtrLdpGenRetentionMode specifies the label\n         retention mode used.\n             \n         If the value of this object is 'conservative', then advertized \n         label mappings are retained only if they will be used to forward \n         packets, i.e. if the label came from a valid next hop.  Label\n         bindings received from non-nexthops for each FEC are discarded.\n\n         If the value of this object is 'liberal', then all advertized \n         label mappings are retained whether they are from a valid next \n         hop or not.  When vRtrLdpGenDistMethod has a value of\n         'downstreamUnsolicited', a LSR may receive label bindings for\n         the same destination for all its neighbors.  Labels for the\n         non-nexthops for the FECs are retained in the software but not\n         used.  When a network topology change occurs where a non-nexthop\n         becomes a true next hop, the label received earlier is then used.")
vRtrLdpGenTransportAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("interface", 1), ("system", 2))).clone('system')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTransportAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTransportAddrType.setDescription("The value of vRtrLdpGenTransportAddrType specifies the source\n         of the transport address to be used when setting up the LDP TCP\n         sessions.  The transport address can be configured globally\n         (applied to all interfaces) or per interface.\n             \n         When the value of this object is 'interface', the interface's \n         IP address is used to setup the LDP session between neighbors.  \n         If multiple interfaces exist between two neighbors, the \n         'interface' mode cannot be used since only one LDP session is \n         actually set up between the two neighbors.\n             \n         When the value of this object is 'system', the system's IP address\n         is used to set up the LDP session between neighbors.\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.")
vRtrLdpGenPropagatePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 16), TmnxLdpFECPolicy().clone('system')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenPropagatePolicy.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenPropagatePolicy.setDescription("The value of vRtrLdpGenPropagatePolicy determines whether the \n         LSR should generate FECs and which FECs it should generate.\n         \n         When the value of this object is 'system', LDP will distribute \n         label bindings only for the router's system IP address\n\n         When the value of this object is 'interface', LDP will distribute\n         label bindings for all LDP interfaces\n\n         When the value of this object is 'all', LDP will distribute label\n         bindings for all prefixes in the routing table\n         \n         When the value of this object is 'none', LDP will not distribute\n         any label bindings.\n\n         This value is only applicable to LDP interfaces and not for \n         targeted sessions.")
vRtrLdpGenLoopDetectCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("hopCount", 3), ("pathVector", 4), ("hopCountAndPathVector", 5))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenLoopDetectCapable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenLoopDetectCapable.setDescription("The value of vRtrLdpGenLoopDetectCapable indicate whether \n         this LSR supports loop detection and if so, what type of loop\n         detection is supported.\n\n         When the value is 'none' loop detection is not supported on this \n         LSR.\n\n         When the value is 'other' Loop Detection is supported but by a \n         method other than those listed below.\n         \n         When the value is 'hopCount' Loop Detection is supported by Hop \n         Count only.\n\n         When the value is 'pathVector' Loop Detection is supported by\n         Path Vector only.\n\n         When the value is 'hopCountAndPathVector' Loop Detection is\n         supported by both Hop Count and Path Vector.\n\n         Since Loop Detection is determined during Session Initialization, \n         an individual session may not be running with loop detection.  \n         This object simply gives an indication of whether or not the\n         LSR has the ability to support Loop Detection and which types.")
vRtrLdpGenHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenHopLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenHopLimit.setDescription("The value of vRtrLdpGenHopLimit specifies the maximum\n         allowable value for the hop count.  The value of this object\n         is valid and used only if vRtrLdpGenLoopDetectCapable has\n         a value of either 'hopCount' or 'hopCountAndPathVector'.")
vRtrLdpGenPathVectorLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenPathVectorLimit.setDescription("The value of vRtrLdpGenPathVectorLimit specifies the maximum\n         allowable value for the path vector count.  The value of this\n         object is valid and used only if vRtrLdpGenLoopDetectCapable\n         has a value of either 'pathVector' or 'hopCountAndPathVector'.")
vRtrLdpGenBackoffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 20), TmnxLdpBackoffTime().subtype(subtypeSpec=ValueRangeConstraint(1, 2592000)).clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenBackoffTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenBackoffTime.setDescription('The value of vRtrLdpGenBackoffTime specifies the initial \n         value for the backoff interval. \n\n         The backoff interval is the time, in seconds, that LDP waits \n         after an LDP session setup has failed before it attempts to \n         setup the session again. After the LDP session startup fails \n         the first time, the backoff interval is set to the value of \n         vRtrLdpGenBackoffTime. Thereafter, if session startup \n         fails again the backoff interval increases exponentially.')
vRtrLdpGenMaxBackoffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 21), TmnxLdpBackoffTime().clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenMaxBackoffTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenMaxBackoffTime.setDescription('The value of vRtrLdpGenMaxBackoffTime specifies the maximum\n         value for the backoff interval.\n\n         For each successive failure of the LDP session startup, the \n         backoff interval (the time for which the router waits before \n         retrying) increases exponentially. If the backoff interval \n         exceeds vRtrLdpGenMaxBackoffTime, the router will give \n         up trying to establish the LDP session. \n\n         If vRtrLdpGenMaxBackoffTime is set to zero (0), then the \n         backoff interval does not increase exponentially after the \n         first session startup attempt fails. Instead it remains\n         constant and LDP will keep retrying to establish a session \n         until it succeeds.')
vRtrLdpGenTargKeepAliveFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 22), TmnxLdpKeepAliveFactor().clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTargKeepAliveFactor.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTargKeepAliveFactor.setDescription('The value of vRtrLdpGenTargKeepAliveFactor specifies the value\n         by which the keepalive timeout (vRtrLdpGenTargKeepAliveTimeout)\n         should be divided to give the keepalive time i.e. the time \n         interval, in seconds, between LDP keepalive messages. LDP \n         keepalive messages are sent to keep the LDP session from timing \n         out when no other LDP traffic is being sent between the neighbors.\n\n         This value is only applicable to targeted sessions and not to LDP\n         interfaces.')
vRtrLdpGenTargKeepAliveTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 23), TmnxLdpKeepAliveTimeout().clone(40)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTargKeepAliveTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTargKeepAliveTimeout.setDescription('The value of vRtrLdpGenTargKeepAliveTimeout specifies the time \n         interval, in seconds, that LDP waits before tearing down a session.\n         If no LDP messages are exchanged during this time interval, the LDP\n         session is torn down. Genly the value of \n         vRtrLdpGenTargKeepAliveTimeout is configured to be 3 times the\n         keepalive time (the time interval between successive LDP keepalive\n         messages).\n\n         This value is only applicable to targeted sessions and not to LDP\n         interfaces.')
vRtrLdpGenTargHelloFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 24), TmnxLdpHelloFactor().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTargHelloFactor.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTargHelloFactor.setDescription('The value of vRtrLdpGenTargHelloFactor specifies the value by \n         which the hello timeout (vRtrLdpGenTargHelloTimeout) should be\n         divided to give the hello time i.e. the time interval, in seconds, \n         between LDP Hello messages. LDP uses hello messages to discover\n         neighbors and to detect loss of connectivity with its neighbors.\n\n         This value is only applicable to targeted sessions and not to LDP\n         interfaces.')
vRtrLdpGenTargHelloTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 25), TmnxLdpHelloTimeout().clone(45)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTargHelloTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTargHelloTimeout.setDescription('The value of vRtrLdpGenTargHelloTimeout specifies the hello time \n         also known as hold time. It is the time interval, in seconds, that\n         LDP waits before declaring a neighbor to be down. Hello timeout \n         is local to the system and is sent in the hello messages to a\n         neighbor. Hello timeout cannot be set to a value that is less \n         than 3 times the hello time.\n\n         This value is only applicable to targeted sessions and not to LDP\n         interfaces.')
vRtrLdpGenTargPassiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTargPassiveMode.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTargPassiveMode.setDescription("The value of vRtrLdpGenTargPassiveMode specifies the mode used\n         for setting up LDP sessions. When it has a value of 'true', LDP\n         responds only when it gets a connect request from a peer and will \n         not attempt to actively connect to its neighbors. When it has a \n         value of 'false', LDP actively tries to connect to its peers.\n\n         This value is only applicable to targeted sessions and not to LDP\n         interfaces.")
vRtrLdpGenTargetedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 27), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTargetedSessions.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTargetedSessions.setDescription("The value of vRtrLdpGenTargetedSessions specifies whether or\n         not targeted sessions are allowed.  Targeted sessions are LDP\n         sessions between indirectly connected peers.  The discovery\n         messages for an indirect LDP session are addressed to the\n         specified peer instead of to the multicast address.  When this\n         object has a value of 'true', targeted sessions are enabled.\n         When its value is 'false', targeted sessions are disabled.")
vRtrLdpGenCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 28), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenCreateTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenCreateTime.setDescription('The value of vRtrLdpGenCreateTime specifies the sysUpTime\n         when this LDP instance was created.')
vRtrLdpGenUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 29), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenUpTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenUpTime.setDescription('The value of vRtrLdpGenUpTime specifies the time, in \n         hundreds of seconds, that the LDP instance has been \n         operationally up.')
vRtrLdpGenImportPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 30), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy1.setDescription('The value of vRtrLdpGenImportPolicy1 specifies the first \n         import policy used to filter LDP label bindings received\n         from LDP peers.')
vRtrLdpGenImportPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 31), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy2.setDescription('The value of vRtrLdpGenImportPolicy2 specifies the second \n         import policy used to filter LDP label bindings received\n         from LDP peers.')
vRtrLdpGenImportPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 32), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy3.setDescription('The value of vRtrLdpGenImportPolicy3 specifies the third \n         import policy used to filter LDP label bindings received\n         from LDP peers.')
vRtrLdpGenImportPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 33), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy4.setDescription('The value of vRtrLdpGenImportPolicy4 specifies the fourth \n         import policy used to filter LDP label bindings received\n         from LDP peers.')
vRtrLdpGenImportPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 34), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenImportPolicy5.setDescription('The value of vRtrLdpGenImportPolicy5 specifies the fifth \n         import policy used to filter LDP label bindings received\n         from LDP peers.')
vRtrLdpGenExportPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 35), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy1.setDescription('The value of vRtrLdpGenExportPolicy1 specifies the first \n         export policy used to filter LDP label bindings advertised\n         to LDP peers.')
vRtrLdpGenExportPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 36), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy2.setDescription('The value of vRtrLdpGenExportPolicy2 specifies the second \n         export policy used to filter LDP label bindings advertised\n         to LDP peers.')
vRtrLdpGenExportPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 37), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy3.setDescription('The value of vRtrLdpGenExportPolicy3 specifies the third \n         export policy used to filter LDP label bindings advertised\n         to LDP peers.')
vRtrLdpGenExportPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 38), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy4.setDescription('The value of vRtrLdpGenExportPolicy4 specifies the fourth \n         export policy used to filter LDP label bindings advertised\n         to LDP peers.')
vRtrLdpGenExportPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 39), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenExportPolicy5.setDescription('The value of vRtrLdpGenExportPolicy5 specifies the fifth\n         export policy used to filter LDP label bindings advertised\n         to LDP peers.')
vRtrLdpGenTunnelDownDampTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 20)).clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTunnelDownDampTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenTunnelDownDampTime.setDescription('The value of vRtrLdpGenTunnelDownDampTime specifies the time \n         interval, in seconds, that LDP waits before posting a \n         tunnel down event to the Route Table Manager. If a tunnel\n         up event is generated before the damping interval has \n         elapsed, a tunnel modify event will be posted to the Route \n         Table Manager (RTM). If this value is set to 0, then tunnel\n         down events are not damped.')
vRtrLdpGenOperDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 41), TmnxLdpGenOperDownReasonCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpGenOperDownReason.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenOperDownReason.setDescription('The value of vRtrLdpGenOperDownReason specifies the reason\n         that the LDP instance is operationally down.')
vRtrLdpGenTrustList = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 42), TFilterID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenTrustList.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpGenTrustList.setDescription("The value of vRtrLdpGenTrustList specifies the IP filter ID used to\n         verify trusted T-LDP peers. The IP filter specified by this object \n         should contain a list of src-ip matches. The value '0' is not a valid\n         IP filter ID, but it is used to indicate that there is no trust list.\n\n         This object was obsoleted in release 5.0.")
vRtrLdpGenGracefulRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 43), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenGracefulRestart.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenGracefulRestart.setDescription("The value of vRtrLdpGenGracefulRestart specifies whether graceful \n         restart helper is allowed.  When this object has a value of 'true', \n         graceful restart helper is enabled.  When its value is 'false', graceful\n         restart helper is disabled.")
vRtrLdpGenGRNbrLiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 44), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 300)).clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenGRNbrLiveTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenGRNbrLiveTime.setDescription("The value of vRtrLdpGenGRNbrLiveTime specifies the value for neighbor\n         liveness timer.  The amount of time the Label Switching Router (LSR) \n         keeps its stale label-FEC bindings is set to the lesser of the FT Reconnect \n         Timeout, as was advertised by the  neighbor, and this local timer, called the\n         Neighbor Liveness Timer.  \n\n         The LSR waits for the specified time till a LDP session re-establishes \n         itself.  If within that time the LSR still does not establish an LDP session with \n         the neighbor, all the stale bindings are deleted.  This object has meaning\n         only when vRtrLdpGenGracefulRestart is 'true'.")
vRtrLdpGenGRMaxRecoveryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 1, 1, 45), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 1800)).clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpGenGRMaxRecoveryTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGenGRMaxRecoveryTime.setDescription("The value of vRtrLdpGenGRMaxRecoveryTime specifies the local maximum\n         recovery time. \n         \n         If the Label Switching Router (LSR)  determines that the neighbor was able\n         to preserve its MPLS forwarding  state (as was indicated by the non-zero \n         Recovery Time advertised by  the neighbor), the LSR should further keep\n         the stale label-FEC  bindings, received from the neighbor, for as long \n         as the lesser of the Recovery Time advertised by the neighbor, and a \n         local configurable value, called Maximum Recovery Time, allows.  This object\n         has meaning only when vRtrLdpGenGracefulRestart is 'true'.")
vRtrLdpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2), )
if mibBuilder.loadTexts: vRtrLdpStatsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsTable.setDescription('vRtrLdpStatsTable is a read-only table. The purpose of this table\n         is to keep statistical information about an LDP Instance.\n\n         Use of AUGMENTS clause implies a one-to-one dependent\n         relationship between the base table, vRtrLdpGeneralTable,\n         and the augmenting table, vRtrLdpStatsTable. This in\n         effect extends the vRtrLdpGeneralTable with additional\n         columns.  Creation or deletion of a row in the \n         vRtrLdpGeneralTable results in the same fate for the row \n         in the vRtrLdpStatsTable.')
vRtrLdpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1), )
vRtrLdpGeneralEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsEntry"))
vRtrLdpStatsEntry.setIndexNames(*vRtrLdpGeneralEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrLdpStatsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsEntry.setDescription('A row in this table represents statistical information about\n         an LDP instance.')
vRtrLdpStatsOperDownEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsOperDownEvents.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsOperDownEvents.setDescription('The value of vRtrLdpStatsOperDownEvents specifies the number \n         of times the LDP instance has gone operationally down since\n         the instance was created.')
vRtrLdpStatsActiveSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsActiveSessions.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsActiveSessions.setDescription('The value of vRtrLdpStatsActiveSessions specifies the number\n         of active sessions (i.e. session in some form of creation) \n         associated with the LDP instance.')
vRtrLdpStatsActiveAdjacencies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsActiveAdjacencies.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsActiveAdjacencies.setDescription('The value of vRtrLdpStatsActiveAdjacencies specifies the \n         number of active adjacencies (i.e. established sessions)\n         associated with the LDP instance.')
vRtrLdpStatsActiveInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsActiveInterfaces.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsActiveInterfaces.setDescription('The value of vRtrLdpStatsActiveInterfaces specifies the \n         number of active (i.e. operationally up) interfaces\n         associated with the LDP instance.')
vRtrLdpStatsInactiveInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsInactiveInterfaces.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsInactiveInterfaces.setDescription('The value of vRtrLdpStatsInactiveInterfaces specifies the\n         number of inactive (i.e. operationally down) interfaces\n         associated with the LDP instance.')
vRtrLdpStatsActiveTargSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsActiveTargSessions.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsActiveTargSessions.setDescription('The value of vRtrLdpStatsActiveTargSessions specifies the\n         number of active (i.e. operationally up) targeted sessions\n         associated with the LDP instance.')
vRtrLdpStatsInactiveTargSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsInactiveTargSessions.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsInactiveTargSessions.setDescription('The value of vRtrLdpStatsInactiveTargSessions specifies the\n         number of inactive (i.e. operationally down) targeted \n         sessions associated with the LDP instance.')
vRtrLdpStatsAddrFECRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsAddrFECRecv.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsAddrFECRecv.setDescription('The value of vRtrLdpStatsAddrFECRecv specifies the number of\n         Address FECs received by the LDP instance from its neighbors.')
vRtrLdpStatsAddrFECSent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsAddrFECSent.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsAddrFECSent.setDescription('The value of vRtrLdpStatsAddrFECSent specifies the number of\n         Address FECs sent by the LDP instance to its neighbors.')
vRtrLdpStatsSvcFECRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsSvcFECRecv.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsSvcFECRecv.setDescription('The value of vRtrLdpStatsSvcFECRecv specifies the number of\n         Service FECs received by the LDP instance from its neighbors.')
vRtrLdpStatsSvcFECSent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsSvcFECSent.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsSvcFECSent.setDescription('The value of vRtrLdpStatsSvcFECSent specifies the number of\n         Service FECs sent by the LDP instance to its neighbors.')
vRtrLdpStatsAttemptedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsAttemptedSessions.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsAttemptedSessions.setDescription('The value of vRtrLdpStatsAttemptedSessions specifies the total number \n         of attempted sessions for this LDP instance.')
vRtrLdpStatsSessRejNoHelloErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsSessRejNoHelloErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsSessRejNoHelloErrors.setDescription('The value of vRtrLdpStatsSessRejNoHelloErrors gives the total\n         number of Session Rejected/No Hello Error Notification Messages\n         sent or received by this LDP instance.')
vRtrLdpStatsSessRejAdvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsSessRejAdvErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsSessRejAdvErrors.setDescription('The value of vRtrLdpStatsSessRejAdvErrors gives the total\n         number of Session Rejected/Parameters Advertisement Mode Error\n         Notification Messages sent or received by this LDP instance.')
vRtrLdpStatsSessRejMaxPduErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsSessRejMaxPduErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsSessRejMaxPduErrors.setDescription('The value of vRtrLdpStatsSessRejMaxPduErrors gives the total\n         number of Session Rejected/Parameters Max Pdu Length Error \n         Notification Messages sent or received by this LDP instance.')
vRtrLdpStatsSessRejLabelRangeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsSessRejLabelRangeErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsSessRejLabelRangeErrors.setDescription('The value of vRtrLdpStatsSessRejLabelRangeErrors gives the total\n         number of Session Rejected/Parameters Label Range Error \n         Notification Messages sent or received by this LDP instance.')
vRtrLdpStatsBadLdpIdentifierErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsBadLdpIdentifierErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: vRtrLdpStatsBadLdpIdentifierErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsBadLdpIdentifierErrors.setDescription('The value of vRtrLdpStatsBadLdpIdentifierErrors gives the number of\n         Bad LDP Identifier Fatal Errors detected for sessions associated\n         with this LDP instance.')
vRtrLdpStatsBadPduLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsBadPduLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: vRtrLdpStatsBadPduLengthErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsBadPduLengthErrors.setDescription('The value of vRtrLdpStatsBadPduLengthErrors gives the number of \n         Bad Pdu Length Fatal Errors detected for sessions associated  \n         with this LDP instance.')
vRtrLdpStatsBadMessageLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsBadMessageLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: vRtrLdpStatsBadMessageLengthErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsBadMessageLengthErrors.setDescription('The value of vRtrLdpStatsBadMessageLengthErrors gives the number of\n         Bad Message Length Fatal Errors detected for sessions associated \n         with this LDP instance.')
vRtrLdpStatsBadTlvLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsBadTlvLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: vRtrLdpStatsBadTlvLengthErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsBadTlvLengthErrors.setDescription('The value of vRtrLdpStatsBadTlvLengthErrors gives the number of\n         Bad TLV Length Fatal Errors detected for sessions associated  \n         with this LDP instance.')
vRtrLdpStatsMalformedTlvValueErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsMalformedTlvValueErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: vRtrLdpStatsMalformedTlvValueErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsMalformedTlvValueErrors.setDescription('The value of vRtrLdpStatsMalformedTlvValueErrors gives the number of\n         Malformed TLV Value Fatal Errors detected for sessions associated\n         with this LDP instance.')
vRtrLdpStatsKeepAliveExpiredErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsKeepAliveExpiredErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: vRtrLdpStatsKeepAliveExpiredErrors.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsKeepAliveExpiredErrors.setDescription('The value of vRtrLdpStatsKeepAliveExpiredErrors gives the number of\n        Session Keep Alive Timer Expired Errors detected for sessions \n        associated with this LDP instance.')
vRtrLdpStatsShutdownNotifRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsShutdownNotifRecv.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsShutdownNotifRecv.setDescription('The value of vRtrLdpStatsShutdownNotifRecv gives the number of\n        Shutdown Notifications received related to sessions associated \n        with this LDP instance.')
vRtrLdpStatsShutdownNotifSent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStatsShutdownNotifSent.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStatsShutdownNotifSent.setDescription('The value of vRtrLdpStatsShutdownNotifSent gives the number of\n        Shutdown Notifications sent related to sessions associated with \n        this LDP instance.')
vRtrLdpPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 3), )
if mibBuilder.loadTexts: vRtrLdpPolicyTable.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpPolicyTable.setDescription('vRtrLdpPolicyTable has an entry for each policy used by\n         the LDP protocol instance running on the virtual router.\n\n         This table is obsoleted in release 2.1.')
vRtrLdpPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 3, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPolicyType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPolicyIndex"))
if mibBuilder.loadTexts: vRtrLdpPolicyEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpPolicyEntry.setDescription('Each row entry represents a policy used by the LDP protocol\n         instance.\n         \n         Entries can be created and deleted via SNMP SET operations \n         to vRtrLdpPolicyRowStatus.\n\n         This entry is obsoleted in release 2.1.')
vRtrLdpPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("import", 1), ("export", 2), ("ingress", 3), ("egress", 4))))
if mibBuilder.loadTexts: vRtrLdpPolicyType.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpPolicyType.setDescription("The value of vRtrLdpPolicyType indicates the type of policy\n         specified in this row entry.\n         \n         When vRtrLdpPolicyType has a value of 'import' this row\n         entry represents the policy filter to be applied to the label \n         binding received from a neighbor.\n         \n         When the value is 'export', this row entry represents the\n         policy filter to determine the labels to be advertised to the\n         neighbors.\n\n         When the value is 'ingress', this row entry represents the\n         policy filter to control the route prefixes that are advertised\n         by LDP to the route table.  LDP will advertise label bindings\n         of prefixes that are advertised into it.\n         \n         When the value is 'egress', this row entry represents the\n         policy filter to control the route prefixes that are advertised\n         into LDP from the route table.  LDP will advertise label bindings\n         of prefixes that are advertised into it.\n\n         This object is obsoleted in release 2.1.")
vRtrLdpPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: vRtrLdpPolicyIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpPolicyIndex.setDescription('vRtrLdpPolicyIndex is used to control the order that the LDP \n         policies are applied. If multiple entries exist in this table \n         with the same vRtrID and vRtrLdpPolicyType indexes, they are \n         evaluated in ascending numeric order of vRtrLdpPolicyIndex \n         (gaps are allowed). The first policy that matches is applied.\n\n         This object is obsoleted in release 2.1.')
vRtrLdpPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPolicyRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpPolicyRowStatus.setDescription('vRtrLdpPolicyRowStatus controls the creation and deletion of\n         rows in the vRtrLdpPolicyTable.\n\n         This object is obsoleted in release 2.1.')
vRtrLdpPolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 3, 1, 4), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPolicyName.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpPolicyName.setDescription("The value of vRtrLdpPolicyName is the name of the policy filter\n         to be used.  If this object has the value of the empty string,\n         ''H, there is no policy specified at this level.\n\n         This object is obsoleted in release 2.1.")
vRtrLdpIfTableSpinlock = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 4), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrLdpIfTableSpinlock.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfTableSpinlock.setDescription('Voluntary serialization control for vRtrLdpIfTable.  \n         Primarily used by SNMP manager to coordinate changes to \n         vRtrLdpIfInheritance.')
vRtrLdpIfTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5), )
if mibBuilder.loadTexts: vRtrLdpIfTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfTable.setDescription('vRtrLdpIfTable provides an entry for each virtual router\n         interface or targeted peer configured to be used with the Label\n         Distribution Protocol (LDP).')
vRtrLdpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfIndex"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAddress"))
if mibBuilder.loadTexts: vRtrLdpIfEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfEntry.setDescription("Each row entry represents an interface on this virtual router\n         that participates in the LDP protocol.  \n\n         Row entries can be created or deleted via SNMP SET requests. \n         A row with default attribute values is created by setting \n         vRtrLdpIfRowStatus to 'createAndGo'. A row entry can be \n         destroyed by setting vRtrLdpIfRowStatus to 'destroy'. An \n         attempt to destroy a row will fail if vRtrLdpIfAdminState \n         is not set to 'outOfService'.")
vRtrLdpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: vRtrLdpIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfIndex.setDescription('vRtrLdpIfIndex is an index for the row entry and is used \n         mutually exclusively with the vRtrLdpPeerAddress field. If \n         the vRtrLdpPeerAddress field is 0.0.0.0, then vRtrLdpIfIndex\n         is the index for the interface on the virtual router and \n         must be non-zero. Otherwise, vRtrLdpPeerAddress refers to\n         a targeted peer and its vRtrLdpIfIndex is 0.')
vRtrLdpPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 2), IpAddress())
if mibBuilder.loadTexts: vRtrLdpPeerAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerAddress.setDescription('vRtrLdpPeerAddress is an index for the row entry and is used \n         mutually exclusively with the vRtrLdpIfIndex field. If the \n         vRtrLdpIfIndex field is 0, then the vRtrLdpPeerAddress is the \n         IP address of the targeted peer and must be non-zero.\n         Otherwise, vRtrLdpIfIndex refers to the LDP interface index \n         and its vRtrLdpPeerAddress is 0.0.0.0')
vRtrLdpIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfRowStatus.setDescription("vRtrLdpIfRowStatus is used to control the creation and deletion\n         of rows in the vRtrLdpIfTable. \n\n         A row can be created by setting vRtrLdpIfRowStatus to 'createAndGo'.\n         The agent should assign the default attribute values and change \n         the row status to 'active'.\n\n         A row entry can be destroyed by setting vRtrLdpIfRowStatus to\n         'destroy'. An attempt to destroy a row will fail if \n         vRtrLdpIfAdminState is not set to 'outOfService'.")
vRtrLdpIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpIfLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfLastChange.setDescription('The value of vRtrLdpIfLastChange specifies the sysUpTime when this\n         row was last modified.')
vRtrLdpIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 5), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfAdminState.setDescription('The value of vRtrLdpIfAdminState indicates the desired administrative\n         state for LDP on this interface or targeted peer.')
vRtrLdpIfOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 6), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpIfOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfOperState.setDescription('The value of vRtrLdpIfOperState specifies the current operational\n         state of LDP on this interface or targeted peer.')
vRtrLdpIfInheritance = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfInheritance.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfInheritance.setDescription("Some writable object in this row that can be configured to\n         inherit its value from its corresponding object in the \n         vRtrLdpGeneralTable for LDP interfaces or from the corresponding\n         object in the vRtrLdpIfTable for targeted peers. \n         vRtrLdpIfInheritance controls whether to inherit the operational\n         value of that object, or use the administratively set value.\n        \n         This object is a bit-mask, with the following positions:\n         vRtrLdpIfKeepAliveFactor       0x1\n         vRtrLdpIfKeepAliveTimeout      0x2\n         vRtrLdpIfHelloFactor           0x4\n         vRtrLdpIfHelloTimeout          0x8\n         vRtrLdpIfBackoffTime           0x10\n         vRtrLdpIfMaxBackoffTime        0x20\n         vRtrLdpIfTransportAddrType     0x40\n         vRtrLdpIfPassiveMode           0x80\n\n         When the bit for an object is set to one, then the object's\n         administrative and operational value are whatever the DEFVAL \n         or most recently SET value is.\n        \n         When the bit for an object is set to zero, then the object's \n         administrative and operational value are inherited from the \n         corresponding object in vRtrLdpGeneralTable for LDP interfaces\n         or the vRtrLdpIfTable for targeted peers.")
vRtrLdpIfKeepAliveFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 8), TmnxLdpKeepAliveFactor().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfKeepAliveFactor.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfKeepAliveFactor.setDescription('The value of vRtrLdpIfKeepAliveFactor specifies the value by which\n         the keepalive timeout (vRtrLdpIfKeepAliveTimeout) should be divided \n         to give the keepalive time i.e. the time interval, in seconds, \n         between LDP keepalive messages. LDP keepalive messages are sent to \n         keep the LDP session from timing out when no other LDP traffic is \n         being sent between the neighbors.')
vRtrLdpIfKeepAliveTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 9), TmnxLdpKeepAliveTimeout().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfKeepAliveTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfKeepAliveTimeout.setDescription('The value of vRtrLdpIfKeepAliveTimeout specifies the time interval,\n         in seconds, that LDP waits before tearing down a session. If no LDP\n         messages are exchanged during this time interval, the LDP session \n         is torn down. Generally the value of vRtrLdpIfKeepAliveTimeout is \n         configured to be 3 times the keepalive time (the time interval \n         between successive LDP keepalive messages).')
vRtrLdpIfHelloFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 10), TmnxLdpHelloFactor().clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfHelloFactor.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfHelloFactor.setDescription('The value of vRtrLdpIfHelloFactor specifies the value by which\n         the hello timeout (vRtrLdpIfHelloTimeout) should be divided to \n         give the hello time i.e. the time interval, in seconds, between \n         LDP Hello messages. LDP uses hello messages to discover neighbors\n         and to detect loss of connectivity with its neighbors.')
vRtrLdpIfHelloTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 11), TmnxLdpHelloTimeout().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfHelloTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfHelloTimeout.setDescription('The value of vRtrLdpIfHelloTimeout specifies the hello time also\n         known as hold time. It is the time interval, in seconds, that\n         LDP waits before declaring a neighbor to be down. Hello timeout \n         is local to the system and is sent in the hello messages to a\n         neighbor. Hello timeout cannot be set to a value that is less \n         than 3 times the hello time.')
vRtrLdpIfBackoffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 12), TmnxLdpBackoffTime().subtype(subtypeSpec=ValueRangeConstraint(1, 2592000)).clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfBackoffTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfBackoffTime.setDescription('The value of vRtrLdpIfBackoffTime specifies the initial value\n         for the backoff interval. \n         \n         The backoff interval is the time, in seconds, that LDP waits \n         after an LDP session setup has failed before it attempts to \n         setup the session again. After the LDP session startup fails \n         the first time, the backoff interval is set to the value of \n         vRtrLdpIfBackoffTime. Thereafter, if session startup fails \n         again the backoff interval increases exponentially.')
vRtrLdpIfMaxBackoffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 13), TmnxLdpBackoffTime().clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfMaxBackoffTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfMaxBackoffTime.setDescription('The value of vRtrLdpIfMaxBackoffTime specifies the maximum\n         value for the backoff interval.\n\n         For each successive failure of the LDP session startup, the \n         backoff interval (the time for which the router waits before \n         retrying) increases exponentially. If the backoff interval \n         exceeds vRtrLdpIfMaxBackoffTime, the router will give \n         up trying to establish the LDP session. \n\n         If vRtrLdpIfMaxBackoffTime is set to zero (0), then the \n         backoff interval does not increase exponentially after the \n         first session startup attempt fails. Instead it remains\n         constant and LDP will keep retrying to establish a session \n         until it succeeds.')
vRtrLdpIfTransportAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("interface", 1), ("system", 2))).clone('system')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfTransportAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfTransportAddrType.setDescription("The value of vRtrLdpIfTransportAddrType specifies the source\n        of the transport address to be used when setting up the LDP TCP\n        sessions. This value is meaningful only in case of LDP\n        interfaces and not for targeted peers. \n              \n        When the value of this object is 'interface', the interface's \n        IP address is used to setup the LDP session between neighbors.  \n        If multiple interfaces exist between two neighbors, the \n        'interface' mode cannot be used since only one LDP session is \n        actually set up between the two neighbors.\n             \n        When the value of this object is 'system', the system's IP address\n        is used to set up the LDP session between neighbors.")
vRtrLdpIfPassiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfPassiveMode.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfPassiveMode.setDescription("The value of vRtrLdpIfPassiveMode specifies the mode used for \n         setting up LDP sessions. This object is meaningful only in case\n         of LDP targeted peers and not for interfaces. When it has a\n         value of 'true', LDP responds only when it gets a connect request\n         from a peer and will not attempt to actively connect to its \n         neighbors. When it has a value of 'false', LDP actively tries to\n         connect to its peers.")
vRtrLdpIfAutoCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpIfAutoCreate.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfAutoCreate.setDescription('The value of vRtrLdpIfAutoCreate specifies whether or not the\n         row entry represents a targeted peer that was automatically\n         created through Service Manager.  For an LDP interface, this\n         value is always false.')
vRtrLdpIfOperDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 17), TmnxLdpIntTargOperDownReasonCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpIfOperDownReason.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfOperDownReason.setDescription('The value of vRtrLdpIfOperDownReason specifies the reason \n         that the LDP interface or targeted peer is operationally\n         down.')
vRtrLdpIfTunneling = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 5, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfTunneling.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfTunneling.setDescription("The value of vRtrLdpIfTunneling specifies whether tunneling\n          of LDP over tunnels is enabled.  When this object has a value of\n          'true', tunneling is enabled.  When its value is 'false', \n           tunneling is disabled.")
vRtrLdpIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 6), )
if mibBuilder.loadTexts: vRtrLdpIfStatsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfStatsTable.setDescription('vRtrLdpIfStatsTable is a read-only table. The purpose of this \n         table is to keep statistical information about the LDP Interfaces\n         and Targeted peers on the LSR.\n\n         Use of AUGMENTS clause implies a one-to-one dependent relationship\n         between the base table, vRtrLdpIfTable, and the augmenting table,\n         vRtrLdpIfStatsTable. This in effect extends the vRtrLdpIfTable \n         with additional columns. Creation or deletion of a row in the \n         vRtrLdpIfTable results in the same fate for the row in the \n         vRtrLdpIfStatsTable.')
vRtrLdpIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 6, 1), )
vRtrLdpIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfStatsEntry"))
vRtrLdpIfStatsEntry.setIndexNames(*vRtrLdpIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrLdpIfStatsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfStatsEntry.setDescription('A row in this table contains statistical information about an LDP\n        Interface or Targeted peer. \n\n        Some counters contained in a row are for fatal errors received \n        during a former LDP Session associated with this entry. For example,\n        an LDP Pdu received on a TCP connection during an LDP Session \n        contains a fatal error.  That error is counted here, because the\n        session is terminated.\n\n        If the error is NOT fatal (i.e. and the Session remains), then the\n        error is counted in the vRtrLdpSessionStatsEntry.')
vRtrLdpIfExistingAdjacencies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 6, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpIfExistingAdjacencies.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfExistingAdjacencies.setDescription('The value of vRtrLdpIfExistingAdjacencies gives a count of the total\n         active adjacencies on this LDP interface or with this targeted peer.')
vRtrLdpHelloAdjTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7), )
if mibBuilder.loadTexts: vRtrLdpHelloAdjTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjTable.setDescription('vRtrLdpHelloAdjTable is a read-only table. The purpose of this\n         table is to keep information about Hello Adjacencies for Sessions.  \n         A hello adjacency can be associated with an LDP interface or with \n         a targeted peer. The index includes both the interface index and \n         the peer IP address thus referring to the LDP interface or \n         targeted peer.')
vRtrLdpHelloAdjEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfIndex"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAddress"))
if mibBuilder.loadTexts: vRtrLdpHelloAdjEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjEntry.setDescription('Each row represents a single LDP Hello Adjacency. An LDP Session \n         can have one or more Hello adjacencies.')
vRtrLdpPeerLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 1), MplsLdpIdentifier())
if mibBuilder.loadTexts: vRtrLdpPeerLdpId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerLdpId.setDescription('vRtrLdpPeerLdpId is an index for the row entry. It specifies the \n         LDP identifier of the peer.')
vRtrLdpHelloAdjLocalLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 2), MplsLdpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalLdpId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalLdpId.setDescription('The value of vRtrLdpHelloAdjLocalLdpId specifies the local LDP \n         identifier for this specific adjacency.')
vRtrLdpHelloAdjEntityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjEntityIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjEntityIndex.setDescription('The value of vRtrLdpHelloAdjEntityIndex specifies the Entity index\n         which is an index for the mplsLdpHelloAdjacencyEntry defined \n         in MPLS-LDP-MIB.')
vRtrLdpHelloAdjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjIndex.setDescription('The value of vRtrLdpHelloAdjIndex gives the Hello adjacency index \n         which is an index for the mplsLdpHelloAdjacencyEntry defined \n         in MPLS-LDP-MIB.')
vRtrLdpHelloAdjHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 5), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjHoldTimeRemaining.setDescription('The value of vRtrLdpHelloAdjHoldTimeRemaining specifies the hold \n         time remaining for this Hello Adjacency. This interval will change \n         when the next Hello message which corresponds to this Hello \n         Adjacency is received.')
vRtrLdpHelloAdjType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 6), TmnxLdpAdjacencyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjType.setDescription("The value of vRtrLdpHelloAdjType specifies the type of this Hello\n         Adjacency. If this value is 'link' then this adjacency is a result\n         of a Link Hello. If this value is 'hello', then the adjacency is a\n         result of a Targeted Hello.")
vRtrLdpHelloAdjRemoteConfSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjRemoteConfSeqNum.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjRemoteConfSeqNum.setDescription('The value of vRtrLdpHelloAdjRemoteConfSeqNum specifies the \n         Configuration sequence number that was in the Hello received when \n         this adjacency started up. This configuration sequence number \n         changes when there is a change of configuration.')
vRtrLdpHelloAdjRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjRemoteIpAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjRemoteIpAddress.setDescription('The value of vRtrLdpHelloAdjRemoteIpAddress specifies the peer \n         IP address of the interface/targeted session that sent hellos \n         for this specific adjacency.')
vRtrLdpHelloAdjUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 9), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjUpTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjUpTime.setDescription('The value of vRtrLdpHelloAdjUpTime specifies the time, in hundreds \n         of seconds, that this adjacency has been up.')
vRtrLdpHelloAdjLocalConfSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalConfSeqNum.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalConfSeqNum.setDescription('The value of vRtrLdpHelloAdjLocalConfSeqNum specifies the \n         Configuration sequence number that was used in the Hello sent \n         when this adjacency started up. This configuration sequence \n         number changes when there is a change of configuration.')
vRtrLdpHelloAdjLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalIpAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalIpAddress.setDescription('The value of vRtrLdpHelloAdjLocalIpAddress specifies the local \n         IP address of the interface/targeted session used in Hellos sent\n         for this specific adjacency.')
vRtrLdpHelloAdjInHelloMsgCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjInHelloMsgCount.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjInHelloMsgCount.setDescription('The value of vRtrLdpHelloAdjInHelloMsgCount specifies the number \n         of Hello messages that have been received for this adjacency.')
vRtrLdpHelloAdjOutHelloMsgCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjOutHelloMsgCount.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjOutHelloMsgCount.setDescription('The value of vRtrLdpHelloAdjOutHelloMsgCount specifies the number \n         of Hello messages that have been sent for this adjacency.')
vRtrLdpHelloAdjLocalHelloTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 14), TmnxLdpHelloTimeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalHelloTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjLocalHelloTimeout.setDescription('The value of vRtrLdpHelloAdjLocalHelloTimeout specifies the hello \n         timeout used in the Hellos sent for this specific adjacency.')
vRtrLdpHelloAdjRemoteHelloTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 7, 1, 15), TmnxLdpHelloTimeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjRemoteHelloTimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjRemoteHelloTimeout.setDescription('The value of vRtrLdpHelloAdjRemoteHelloTimeout specifies the hello \n         timeout used by the remote end that sent Hellos for this specific \n         adjacency.')
vRtrLdpHelloAdjMapTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 8), )
if mibBuilder.loadTexts: vRtrLdpHelloAdjMapTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjMapTable.setDescription('vRtrLdpHelloAdjMapTable is a read-only table which maps to the \n         vRtrLdpHelloAdjTable. This table has the same indexes as the \n         vRtrLdpHelloAdjTable but the order in which these indexes are \n         specified is different for the two tables.')
vRtrLdpHelloAdjMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 8, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfIndex"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAddress"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjMapLdpId"))
if mibBuilder.loadTexts: vRtrLdpHelloAdjMapEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjMapEntry.setDescription('Each row represents a single LDP Hello Adjacency. An LDP Session \n         can have one or more Hello adjacencies.')
vRtrLdpHelloAdjMapLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 8, 1, 1), MplsLdpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpHelloAdjMapLdpId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpHelloAdjMapLdpId.setDescription('vRtrLdpHelloAdjMapLdpId is an index for the row entry. It specifies\n         the LDP identifier of the peer.')
vRtrLdpSessionTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9), )
if mibBuilder.loadTexts: vRtrLdpSessionTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessionTable.setDescription('vRtrLdpSessionTable is a read-only table which parallels the\n         mplsLdpSessionTable in the MPLS-LDP-MIB. The purpose of this \n         table is to keep information about a single session between\n         an LDP entity and an LDP Peer.')
vRtrLdpSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"))
if mibBuilder.loadTexts: vRtrLdpSessionEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessionEntry.setDescription('A row in this table represents information about a  single \n         session between an LDP entity and an LDP Peer.')
vRtrLdpSessLocalLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 1), MplsLdpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLocalLdpId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLocalLdpId.setDescription('The value of vRtrLdpSessLocalLdpId specifies the local LDP\n         identifier for this LDP session.')
vRtrLdpSessEntityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessEntityIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessEntityIndex.setDescription('The value of vRtrLdpSessEntityIndex specifies the Entity index\n         for the LDP entity represented in this session.')
vRtrLdpSessLabelDistMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 3), TmnxLdpLabelDistMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLabelDistMethod.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLabelDistMethod.setDescription('The value of vRtrLdpSessLabelDistMethod specifies the label \n         distribution method used for this LDP session.')
vRtrLdpSessLoopDetectForPV = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLoopDetectForPV.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLoopDetectForPV.setDescription('The value of vRtrLdpSessLoopDetectForPV indicates whether\n         loop detection based on path vectors is disabled or enabled \n         for this LDP session.\n\n         If this object has a value of disabled(0), then loop detection\n         is disabled.  Otherwise, if this object has a value of enabled(1), \n         then loop detection based on path vectors is enabled.')
vRtrLdpSessPathVectorLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessPathVectorLimit.setDescription("If the value of vRtrLdpSessLoopDetectForPV for this entry \n         is 'enabled', then the value of vRtrLdpSessPathVectorLimit\n         represents the Path Vector Limit for this LDP Session.\n\n         If the value of vRtrLdpSessLoopDetectForPV for this entry \n         is 'disabled', then the value of vRtrLdpSessPathVectorLimit\n         be 0 (zero).")
vRtrLdpSessState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonexistent", 1), ("initialized", 2), ("openrec", 3), ("opensent", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessState.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessState.setDescription('The value of vRtrLdpSessState specifies the current state \n         of the LDP session. All of the states 1 - 5 are based on the \n         state machine for session negotiation behavior.')
vRtrLdpSessAdjacencyType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 7), TmnxLdpAdjacencyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessAdjacencyType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessAdjacencyType.setDescription('The value of vRtrLdpSessAdjacencyType specifies the adjacency\n         type(s) supporting this LDP Session.')
vRtrLdpSessProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessProtocolVersion.setDescription('The value of vRtrLdpSessProtocolVersion specifies the version\n         of the LDP Protocol used by this session.')
vRtrLdpSessLocalUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLocalUdpPort.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLocalUdpPort.setDescription('The value of vRtrLdpSessLocalUdpPort specifies the UDP port\n         used locally for LDP discovery.')
vRtrLdpSessPeerUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessPeerUdpPort.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessPeerUdpPort.setDescription('The value of vRtrLdpSessPeerUdpPort specifies the UDP port \n         used on the remote end for LDP discovery.')
vRtrLdpSessLocalTcpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLocalTcpPort.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLocalTcpPort.setDescription('The value of vRtrLdpSessLocalTcpPort specifies the TCP port \n         used locally for the LDP Session.')
vRtrLdpSessPeerTcpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessPeerTcpPort.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessPeerTcpPort.setDescription('The value of vRtrLdpSessPeerTcpPort specifies the TCP port \n         used on the remote end for the LDP Session.')
vRtrLdpSessLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLocalAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLocalAddress.setDescription('The value of vRtrLdpSessLocalAddress specifies the IP address\n         used locally for the LDP Session.')
vRtrLdpSessPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessPeerAddress.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessPeerAddress.setDescription('The value of vRtrLdpSessPeerAddress specifies the IP address\n         used on the remote end for the LDP Session.')
vRtrLdpSessKAHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 15), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessKAHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessKAHoldTimeRemaining.setDescription('The value of vRtrLdpSessKAHoldTimeRemaining specifies the \n         keep alive hold time remaining, in hundredths of seconds, for \n         this LDP session.')
vRtrLdpSessMaxPduLength = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessMaxPduLength.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessMaxPduLength.setDescription('The value of vRtrLdpSessMaxPduLength specifies the maximum\n         allowable length for LDP PDUs for this session. This value may \n         have been negotiated during Session Initialization.')
vRtrLdpSessUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 17), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessUpTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessUpTime.setDescription('The value of vRtrLdpSessUpTime specifies the time, in hundreds\n         of seconds, since the session was established.')
vRtrLdpSessLocalKATimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 18), TmnxLdpKeepAliveTimeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLocalKATimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLocalKATimeout.setDescription('The value of vRtrLdpSessLocalKATimeout specifies the keepalive \n         timeout used locally for the LDP Session.')
vRtrLdpSessPeerKATimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 19), TmnxLdpKeepAliveTimeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessPeerKATimeout.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessPeerKATimeout.setDescription('The value of vRtrLdpSessPeerKATimeout specifies the keepalive \n         timeout used at the remote end of the LDP Session.')
vRtrLdpSessAdvertise = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("address", 1), ("service", 2), ("addressAndService", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessAdvertise.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessAdvertise.setDescription('The value of vRtrLdpSessAdvertise indicates the type of FECs\n         that will be transported by the session.')
vRtrLdpSessRestartHelperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 21), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessRestartHelperState.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessRestartHelperState.setDescription('The value of vRtrLdpSessRestartHelperState indicates whether the \n         entity session is capable of supporting graceful restart.  This is\n         negotiated between peers during the session initialization setup.')
vRtrLdpSessPeerNumRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessPeerNumRestart.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessPeerNumRestart.setDescription('The value of vRtrLdpSessPeerNumRestart indicates the number of \n         times graceful restart helper was initiated for this session.')
vRtrLdpSessLastRestartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 23), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessLastRestartTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessLastRestartTime.setDescription('The value of vRtrLdpSessLastRestartTime indicates the last time \n         graceful restart helper was initiated.')
vRtrLdpSessFtReconnectTimeNego = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 24), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessFtReconnectTimeNego.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessFtReconnectTimeNego.setDescription("The value of vRtrLdpSessFtReconnectTimeNego indicates the session's\n        Fault Tolerant(FT) Reconnect Timeout, it is set to  the lesser of \n        the neighbor advertised FT Reconnect Timeout, \n        vRtrLdpSessFtReconTimeRemaining and the local timer Neighbor Liveness \n        Time, vRtrLdpGenGRNbrLiveTime.  It is within this period that the \n        transport session is expected to re-establish, failure to do so \n        will cause the teardown of the LDP session and deletion of stale \n        bindings.")
vRtrLdpSessFtRecoveryTimeNego = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 25), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessFtRecoveryTimeNego.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessFtRecoveryTimeNego.setDescription("The value of vRtrLdpSessFtRecoveryTimeNego indicates the session's\n        Fault Tolerant(FT) recovery timeout, it is set to the lesser of the\n        neighbor advertised FT recovery timeout, \n        vRtrLdpSessFtRecovTimeRemaining  and the local timer \n        maximum recovery time, vRtrLdpGenGRMaxRecoveryTime.  It is within \n        this period that label-FEC binding message exchanges are expected \n        to complete.  Any stale FEC entries left after this time will be \n        deleted from the FEC table.")
vRtrLdpSessFtReconTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 26), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessFtReconTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessFtReconTimeRemaining.setDescription("The value of vRtrLdpSessFtReconTimeRemaining indicates the amount \n        of time left before the session's Fault Tolerant(FT) reconnect \n        timeout,vRtrLdpSessFtReconnectTimeNego expires.")
vRtrLdpSessFtRecovTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 9, 1, 27), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessFtRecovTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessFtRecovTimeRemaining.setDescription("This value indicates the amount of time left before session's \n        Fault Tolerant(FT) recovery timeout, vRtrLdpSessFtRecoveryTimeNego\n        expires.")
vRtrLdpSessionStatsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10), )
if mibBuilder.loadTexts: vRtrLdpSessionStatsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessionStatsTable.setDescription('vRtrLdpSessionStatsTable is a read-only table. The purpose of this\n         table is to keep statistical information about a single session\n         between an LDP entity and an LDP Peer.\n\n         Use of AUGMENTS clause implies a one-to-one dependent relationship\n         between the base table, vRtrLdpSessionTable, and the augmenting \n         table, vRtrLdpSessionStatsTable. This in effect extends the \n         vRtrLdpSessionTable with additional columns. Creation or deletion\n         of a row in the vRtrLdpSessionTable results in the same fate for \n         the row in the vRtrLdpSessionStatsTable.')
vRtrLdpSessionStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1), )
vRtrLdpSessionEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessionStatsEntry"))
vRtrLdpSessionStatsEntry.setIndexNames(*vRtrLdpSessionEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrLdpSessionStatsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessionStatsEntry.setDescription('A row in this table represents statistical information about a \n         single session between an LDP entity and an LDP Peer.')
vRtrLdpSessStatsTargAdj = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsTargAdj.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsTargAdj.setDescription('The value of vRtrLdpSessStatsTargAdj specifies the number of\n         targeted adjacencies for this session.')
vRtrLdpSessStatsLinkAdj = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLinkAdj.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLinkAdj.setDescription('The value of vRtrLdpSessStatsLinkAdj specifies the number of\n         link adjacencies for this session.')
vRtrLdpSessStatsFECRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsFECRecv.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsFECRecv.setDescription('The value of vRtrLdpSessStatsFECRecv counts the number of\n         FECs received for this session.')
vRtrLdpSessStatsFECSent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsFECSent.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsFECSent.setDescription('The value of vRtrLdpSessStatsFECSent counts the number of\n         FECs sent for this session.')
vRtrLdpSessStatsHelloIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsHelloIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsHelloIn.setDescription('The value of vRtrLdpSessStatsHelloIn counts the number of \n         Hello Messages that have been received during this session.')
vRtrLdpSessStatsHelloOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsHelloOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsHelloOut.setDescription('The value of vRtrLdpSessStatsHelloOut counts the number of \n         Hello Messages that have been sent during this session.')
vRtrLdpSessStatsKeepaliveIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsKeepaliveIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsKeepaliveIn.setDescription('The value of vRtrLdpSessStatsKeepaliveIn counts the number of \n         Keepalive Messages that have been received during this session.')
vRtrLdpSessStatsKeepaliveOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsKeepaliveOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsKeepaliveOut.setDescription('The value of vRtrLdpSessStatsKeepaliveOut counts the number of \n         Keepalive Messages that have been sent during this session.')
vRtrLdpSessStatsInitIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsInitIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsInitIn.setDescription('The value of vRtrLdpSessStatsInitIn counts the number of \n         Init Messages that have been received during this session.')
vRtrLdpSessStatsInitOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsInitOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsInitOut.setDescription('The value of vRtrLdpSessStatsInitOut counts the number of \n         Init Messages that have been sent during this session.')
vRtrLdpSessStatsLabelMappingIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelMappingIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelMappingIn.setDescription('The value of vRtrLdpSessStatsLabelMappingIn counts the number of\n         Label Mapping Messages that have been received during this session.')
vRtrLdpSessStatsLabelMappingOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelMappingOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelMappingOut.setDescription('The value of vRtrLdpSessStatsLabelMappingOut counts the number of\n         Label Mapping Messages that have been sent during this session.')
vRtrLdpSessStatsLabelRequestIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelRequestIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelRequestIn.setDescription('The value of vRtrLdpSessStatsLabelRequestIn counts the number of\n         Label Request Messages that have been received during this session.')
vRtrLdpSessStatsLabelRequestOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelRequestOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelRequestOut.setDescription('The value of vRtrLdpSessStatsLabelRequestOut counts the number of\n         Label Request Messages that have been sent during this session.')
vRtrLdpSessStatsLabelReleaseIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelReleaseIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelReleaseIn.setDescription('The value of vRtrLdpSessStatsLabelReleaseIn counts the number of\n         Label Release Messages that have been received during this session.')
vRtrLdpSessStatsLabelReleaseOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelReleaseOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelReleaseOut.setDescription('The value of vRtrLdpSessStatsLabelReleaseOut counts the number of\n         Label Release Messages that have been sent during this session.')
vRtrLdpSessStatsLabelWithdrawIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelWithdrawIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelWithdrawIn.setDescription('The value of vRtrLdpSessStatsLabelWithdrawIn counts the number of\n         Label Withdraw Messages that have been received during this session.')
vRtrLdpSessStatsLabelWithdrawOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelWithdrawOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelWithdrawOut.setDescription('The value of vRtrLdpSessStatsLabelWithdrawOut counts the number of\n         Label Withdraw Messages that have been sent during this session.')
vRtrLdpSessStatsLabelAbortIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelAbortIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelAbortIn.setDescription('The value of vRtrLdpSessStatsLabelAbortIn counts the number of\n         Label Abort Messages that have been received during this session.')
vRtrLdpSessStatsLabelAbortOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelAbortOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsLabelAbortOut.setDescription('The value of vRtrLdpSessStatsLabelAbortOut counts the number of\n         Label Abort Messages that have been sent during this session.')
vRtrLdpSessStatsAddrIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrIn.setDescription('The value of vRtrLdpSessStatsAddrIn counts the number of \n         Address Messages that have been received during this session.')
vRtrLdpSessStatsAddrOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrOut.setDescription('The value of vRtrLdpSessStatsAddrOut counts the number of \n         Address Messages that have been sent during this session.')
vRtrLdpSessStatsAddrWithdrawIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrWithdrawIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrWithdrawIn.setDescription('The value of vRtrLdpSessStatsAddrWithdrawIn counts the number of\n         Address Withdraw Messages that have been received during this \n         session.')
vRtrLdpSessStatsAddrWithdrawOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrWithdrawOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsAddrWithdrawOut.setDescription('The value of vRtrLdpSessStatsAddrWithdrawOut counts the number of\n         Address Withdraw Messages that have been sent during this session.')
vRtrLdpSessStatsNotificationIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsNotificationIn.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsNotificationIn.setDescription('The value of vRtrLdpSessStatsNotificationIn counts the number of\n         Notification Messages that have been received during this session.')
vRtrLdpSessStatsNotificationOut = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 10, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpSessStatsNotificationOut.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpSessStatsNotificationOut.setDescription('The value of vRtrLdpSessStatsNotificationOut counts the number of\n         Notification Messages that have been sent during this session.')
vRtrLdpServFecTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11), )
if mibBuilder.loadTexts: vRtrLdpServFecTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecTable.setDescription('vRtrLdpServFecTable is a read-only table that represents all \n         service FECs either sent to or received from an LDP peer known\n         to the Virtual Router.')
vRtrLdpServFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecFecType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecVcType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecVcId"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"))
if mibBuilder.loadTexts: vRtrLdpServFecEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecEntry.setDescription('Each row entry represents an instance of a service FEC sent to \n         or received from an LDP peer.')
vRtrLdpServFecFecType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 1), TmnxLdpFECType())
if mibBuilder.loadTexts: vRtrLdpServFecFecType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecFecType.setDescription('The value of vRtrLdpServFecFecType specifies the FEC type.')
vRtrLdpServFecVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 2), TmnxVcType())
if mibBuilder.loadTexts: vRtrLdpServFecVcType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecVcType.setDescription('The value of vRtrLdpServFecVcType specifies the VC type  \n         associated with this service FEC.')
vRtrLdpServFecVcId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 3), TmnxVcId())
if mibBuilder.loadTexts: vRtrLdpServFecVcId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecVcId.setDescription('The value of vRtrLdpServFecVcId specifies the VC identifier \n         associated with this service FEC.')
vRtrLdpServFecServType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 4), ServType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecServType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecServType.setDescription('The value of vRtrLdpServFecServType specifies the Service type\n         associated with this service FEC.')
vRtrLdpServFecServId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 5), TmnxServId().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecServId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecServId.setDescription('The value of vRtrLdpServFecServId specifies the Service identifier\n         associated with this service FEC.')
vRtrLdpServFecVpnId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 6), TmnxVpnId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecVpnId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecVpnId.setDescription('The value of vRtrLdpServFecVpnId identifies the VPN associated \n         with the FEC.')
vRtrLdpServFecFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 7), TmnxLdpFECFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecFlags.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecFlags.setDescription('The bit flags of vRtrLdpServFecFlags specify the characteristics\n         of the FEC.')
vRtrLdpServFecNumInLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecNumInLabels.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecNumInLabels.setDescription('The value of vRtrLdpServFecNumInLabels gives the number of \n         labels that have been sent to the peer associated with this \n         FEC. This value also indicates which of the following \n         vRtrLdpServFecInLabel1 thru vRtrLdpServFecInLabel5  \n         entries contain valid information i.e. if the value of \n         vRtrLdpServFecNumInLabels is 3 then vRtrLdpServFecInLabel1,\n         vRtrLdpServFecInLabel2 and vRtrLdpServFecInLabel3 will\n         contain valid label information.')
vRtrLdpServFecNumOutLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecNumOutLabels.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecNumOutLabels.setDescription('The value of vRtrLdpServFecNumOutLabels gives the number of\n         labels that have been received from the peer associated with this\n         FEC. This value also indicates which of the following \n         vRtrLdpServFecOutLabel1 thru vRtrLdpServFecOutLabel5  \n         entries contain valid information i.e. if the value of \n         vRtrLdpServFecNumOutLabels is 3, then vRtrLdpServFecOutLabel1,\n         vRtrLdpServFecOutLabel2 and vRtrLdpServFecOutLabel3 will\n         contain valid label information.')
vRtrLdpServFecInLabel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabel1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabel1.setDescription('The value of vRtrLdpServFecInLabel1 specifies the first \n         ingress label exchanged')
vRtrLdpServFecInLabelStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 11), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus1.setDescription('The value of vRtrLdpServFecInLabelStatus1 specifies the \n         status of the ingress label 1')
vRtrLdpServFecInLabel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabel2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabel2.setDescription('The value of vRtrLdpServFecInLabel2 specifies the second\n         ingress label (if at all) exchanged.')
vRtrLdpServFecInLabelStatus2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 13), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus2.setDescription('The value of vRtrLdpServFecInLabelStatus2 specifies the \n         status of the ingress label 2')
vRtrLdpServFecInLabel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabel3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabel3.setDescription('The value of vRtrLdpServFecInLabel3 specifies the third\n         ingress label (if at all) exchanged.')
vRtrLdpServFecInLabelStatus3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 15), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus3.setDescription('The value of vRtrLdpServFecInLabelStatus3 specifies the \n         status of the ingress label 3')
vRtrLdpServFecInLabel4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabel4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabel4.setDescription('The value of vRtrLdpServFecInLabel4 specifies the fourth\n         ingress label (if at all) exchanged.')
vRtrLdpServFecInLabelStatus4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 17), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus4.setDescription('The value of vRtrLdpServFecInLabelStatus4 specifies the \n         status of the ingress label 4')
vRtrLdpServFecInLabel5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabel5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabel5.setDescription('The value of vRtrLdpServFecInLabel5 specifies the fifth\n         ingress label (if at all) exchanged.')
vRtrLdpServFecInLabelStatus5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 19), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelStatus5.setDescription('The value of vRtrLdpServFecInLabelStatus5 specifies the \n         status of the ingress label 5')
vRtrLdpServFecOutLabel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel1.setDescription('The value of vRtrLdpServFecOutLabel1 specifies the first\n         egress label exchanged.')
vRtrLdpServFecOutLabelStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 21), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus1.setDescription('The value of vRtrLdpServFecOutLabelStatus1 specifies the \n         status of the egress label 1')
vRtrLdpServFecOutLabel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel2.setDescription('The value of vRtrLdpServFecOutLabel2 specifies the second\n         egress label (if at all) exchanged.')
vRtrLdpServFecOutLabelStatus2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 23), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus2.setDescription('The value of vRtrLdpServFecOutLabelStatus2 specifies the \n         status of the egress label 2')
vRtrLdpServFecOutLabel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel3.setDescription('The value of vRtrLdpServFecOutLabel3 specifies the third\n         egress label (if at all) exchanged.')
vRtrLdpServFecOutLabelStatus3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 25), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus3.setDescription('The value of vRtrLdpServFecOutLabelStatus3 specifies the \n         status of the egress label 3')
vRtrLdpServFecOutLabel4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel4.setDescription('The value of vRtrLdpServFecOutLabel4 specifies the fourth\n         egress label (if at all) exchanged.')
vRtrLdpServFecOutLabelStatus4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 27), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus4.setDescription('The value of vRtrLdpServFecOutLabelStatus4 specifies the \n         status of the egress label 4')
vRtrLdpServFecOutLabel5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabel5.setDescription('The value of vRtrLdpServFecOutLabel5 specifies the fifth\n         egress label (if at all) exchanged.')
vRtrLdpServFecOutLabelStatus5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 29), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelStatus5.setDescription('The value of vRtrLdpServFecOutLabelStatus5 specifies the \n         status of the egress label 5')
vRtrLdpServFecSdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 30), SdpId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecSdpId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecSdpId.setDescription('The value of vRtrLdpServFecSdpId identifies the SDP associated\n         with this peer.')
vRtrLdpServFecLocalMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecLocalMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecLocalMTU.setDescription('The value of vRtrLdpServFecLocalMTU specifies the largest \n         service frame size (in octets) that can be handled by the \n         local ESR.')
vRtrLdpServFecRemoteMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 32), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecRemoteMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecRemoteMTU.setDescription('The value of vRtrLdpServFecRemoteMTU specifies the largest \n         service frame size (in octets) that can be handled by the \n         remote ESR.')
vRtrLdpServFecLocalVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 33), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecLocalVlanTag.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecLocalVlanTag.setDescription('The value of vRtrLdpServFecLocalVlanTag specifies the local \n         tag on a VLAN VC type SDP binding.')
vRtrLdpServFecRemoteVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 34), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecRemoteVlanTag.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecRemoteVlanTag.setDescription('The value of vRtrLdpServFecRemoteVlanTag specifies the remote\n         tag on a VLAN VC type SDP binding.')
vRtrLdpServFecLocalMaxCellConcat = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 35), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecLocalMaxCellConcat.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecLocalMaxCellConcat.setDescription('The value of vRtrLdpServFecLocalMaxCellConcat specifies the local \n         maximum number of ATM cells to concatenate on a ATM cell-mode VC \n         type SDP binding.')
vRtrLdpServFecRemoteMaxCellConcat = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 36), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecRemoteMaxCellConcat.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecRemoteMaxCellConcat.setDescription('The value of vRtrLdpServFecRemoteMaxCellConcat specifies the remote\n         maximum number of ATM cells to concatenate on a ATM cell-mode VC \n         type SDP binding.')
vRtrLdpServFecInLabelSigStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 37), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus1.setDescription('The value of vRtrLdpServFecInLabelSigStatus1 indicates the signaling\n         status for vRtrLdpServFecInLabel1.')
vRtrLdpServFecInLabelSigStatus2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 38), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus2.setDescription('The value of vRtrLdpServFecInLabelSigStatus2 indicates the signaling\n         status for vRtrLdpServFecInLabel2.')
vRtrLdpServFecInLabelSigStatus3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 39), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus3.setDescription('The value of vRtrLdpServFecInLabelSigStatus3 indicates the signaling\n         status for vRtrLdpServFecInLabel3.')
vRtrLdpServFecInLabelSigStatus4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 40), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus4.setDescription('The value of vRtrLdpServFecInLabelSigStatus4 indicates the signaling\n         status for vRtrLdpServFecInLabel4.')
vRtrLdpServFecInLabelSigStatus5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 41), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecInLabelSigStatus5.setDescription('The value of vRtrLdpServFecInLabelSigStatus5 indicates the signaling\n         status for vRtrLdpServFecInLabel5.')
vRtrLdpServFecOutLabelSigStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 42), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus1.setDescription('The value of vRtrLdpServFecOutLabelSigStatus1 indicates the signaling\n         status for vRtrLdpServFecOutLabel1.')
vRtrLdpServFecOutLabelSigStatus2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 43), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus2.setDescription('The value of vRtrLdpServFecOutLabelSigStatus2 indicates the signaling\n         status for vRtrLdpServFecOutLabel2.')
vRtrLdpServFecOutLabelSigStatus3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 44), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus3.setDescription('The value of vRtrLdpServFecOutLabelSigStatus3 indicates the signaling\n         status for vRtrLdpServFecOutLabel3.')
vRtrLdpServFecOutLabelSigStatus4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 45), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus4.setDescription('The value of vRtrLdpServFecOutLabelSigStatus4 indicates the signaling\n         status for vRtrLdpServFecOutLabel4.')
vRtrLdpServFecOutLabelSigStatus5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 46), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecOutLabelSigStatus5.setDescription('The value of vRtrLdpServFecOutLabelSigStatus5 indicates the signaling\n         status for vRtrLdpServFecOutLabel5.')
vRtrLdpServFecMateEndpointVcId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 47), TmnxVcId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecMateEndpointVcId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecMateEndpointVcId.setDescription('The value of vRtrLdpServFecMateEndpointVcId specifies the VC identifier \n         associated with this service FEC mate endpoint for vc-switching.')
vRtrLdpServFecMateEndpointSdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 11, 1, 48), SdpId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecMateEndpointSdpId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpServFecMateEndpointSdpId.setDescription('The value of vRtrLdpServFecMateEndpointSdpId identifies the SDP\n         associated with this service FEC mate endpoint for vc-switching.')
vRtrLdpServFecMapTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 12), )
if mibBuilder.loadTexts: vRtrLdpServFecMapTable.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpServFecMapTable.setDescription('vRtrLdpServFecMapTable is a read-only table which maps to the \n         vRtrLdpServFecTable. This table has the same indexes as the \n         vRtrLdpServFecTable but the order in which these indexes are \n         specified is different for the two tables.')
vRtrLdpServFecMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 12, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapFecType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcId"))
if mibBuilder.loadTexts: vRtrLdpServFecMapEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpServFecMapEntry.setDescription('Each row entry represents an instance of a service FEC sent to \n         or received from an LDP peer.')
vRtrLdpServFecMapFecType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 12, 1, 1), TmnxLdpFECType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecMapFecType.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpServFecMapFecType.setDescription('The value of vRtrLdpServFecMapFecType specifies the FEC type.')
vRtrLdpServFecMapVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 12, 1, 2), TmnxVcType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecMapVcType.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpServFecMapVcType.setDescription('The value of vRtrLdpServFecMapVcType specifies the VC type  \n         associated with this service FEC.')
vRtrLdpServFecMapVcId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 12, 1, 3), TmnxVcId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpServFecMapVcId.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpServFecMapVcId.setDescription('The value of vRtrLdpServFecMapVcId specifies the VC identifier \n         associated with this service FEC.')
vRtrLdpAddrFecTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13), )
if mibBuilder.loadTexts: vRtrLdpAddrFecTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecTable.setDescription('vRtrLdpAddrFecTable is a read-only table that represents all \n         address FECs either sent to or received from an LDP peer known \n         to the Virtual Router.')
vRtrLdpAddrFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecFecType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecIpPrefix"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecIpMask"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"))
if mibBuilder.loadTexts: vRtrLdpAddrFecEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecEntry.setDescription('Each row entry represents an instance of an address FEC sent\n         to or received from an LDP peer.')
vRtrLdpAddrFecFecType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 1), TmnxLdpFECType())
if mibBuilder.loadTexts: vRtrLdpAddrFecFecType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecFecType.setDescription('The value of vRtrLdpAddrFecFecType specifies the FEC type.')
vRtrLdpAddrFecIpPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 2), IpAddress())
if mibBuilder.loadTexts: vRtrLdpAddrFecIpPrefix.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecIpPrefix.setDescription('The value of vRtrLdpAddrFecIpPrefix specifies the IP Address  \n         Prefix for this address FEC.')
vRtrLdpAddrFecIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 3), IpAddress())
if mibBuilder.loadTexts: vRtrLdpAddrFecIpMask.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecIpMask.setDescription('The value of vRtrLdpAddrFecIpMask specifies the IP Address \n         Mask for this address FEC.')
vRtrLdpAddrFecFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 4), TmnxLdpFECFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecFlags.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecFlags.setDescription('The bit flags of vRtrLdpAddrFecFlags specify the characteristics\n         of the FEC.')
vRtrLdpAddrFecNumInLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecNumInLabels.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecNumInLabels.setDescription('The value of vRtrLdpAddrFecNumInLabels gives the number of\n         labels that have been sent to the peer associated with this \n         FEC. This value also indicates which of the following \n         vRtrLdpAddrFecInLabel1 thru vRtrLdpAddrFecInLabel5  \n         entries contain valid information i.e. if the value of \n         vRtrLdpAddrFecNumInLabels is 3 then vRtrLdpAddrFecInLabel1,\n         vRtrLdpAddrFecInLabel2 and vRtrLdpAddrFecInLabel3 will\n         contain valid label information.')
vRtrLdpAddrFecNumOutLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecNumOutLabels.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecNumOutLabels.setDescription('The value of vRtrLdpAddrFecNumOutLabels gives the number of\n         labels that have been received from the peer associated with this\n         FEC. This value also indicates which of the following \n         vRtrLdpAddrFecOutLabel1 thru vRtrLdpAddrFecOutLabel5  \n         entries contain valid information i.e. if the value of \n         vRtrLdpAddrFecNumOutLabels is 3, then vRtrLdpAddrFecOutLabel1,\n         vRtrLdpAddrFecOutLabel2 and vRtrLdpAddrFecOutLabel3 will\n         contain valid label information.')
vRtrLdpAddrFecInLabel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel1.setDescription('The value of vRtrLdpAddrFecInLabel1 specifies the first \n         ingress label exchanged')
vRtrLdpAddrFecInLabelStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 8), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus1.setDescription('The value of vRtrLdpAddrFecInLabelStatus1 specifies the \n         status of the ingress label 1')
vRtrLdpAddrFecInLabelIfIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 9), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex1.setDescription('The value of vRtrLdpAddrFecInLabelIfIndex1 specifies the \n         interface index for ingress label 1')
vRtrLdpAddrFecInLabel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel2.setDescription('The value of vRtrLdpAddrFecInLabel2 specifies the second\n         ingress label (if at all) exchanged.')
vRtrLdpAddrFecInLabelStatus2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 11), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus2.setDescription('The value of vRtrLdpAddrFecInLabelStatus2 specifies the \n         status of the ingress label ')
vRtrLdpAddrFecInLabelIfIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 12), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex2.setDescription('The value of vRtrLdpAddrFecInLabelIfIndex2 specifies the \n         interface index for ingress label 2')
vRtrLdpAddrFecInLabel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel3.setDescription('The value of vRtrLdpAddrFecInLabel3 specifies the third\n         ingress label (if at all) exchanged.')
vRtrLdpAddrFecInLabelStatus3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 14), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus3.setDescription('The value of vRtrLdpAddrFecInLabelStatus3 specifies the \n         status of the ingress label 3')
vRtrLdpAddrFecInLabelIfIndex3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 15), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex3.setDescription('The value of vRtrLdpAddrFecInLabelIfIndex3 specifies the \n         interface index for ingress label 3')
vRtrLdpAddrFecInLabel4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel4.setDescription('The value of vRtrLdpAddrFecInLabel4 specifies the fourth\n         ingress label (if at all) exchanged.')
vRtrLdpAddrFecInLabelStatus4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 17), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus4.setDescription('The value of vRtrLdpAddrFecInLabelStatus4 specifies the \n         status of the ingress label 4')
vRtrLdpAddrFecInLabelIfIndex4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 18), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex4.setDescription('The value of vRtrLdpAddrFecInLabelIfIndex4 specifies the \n         interface index for ingress label 4')
vRtrLdpAddrFecInLabel5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabel5.setDescription('The value of vRtrLdpAddrFecInLabel5 specifies the fifth\n         ingress label (if at all) exchanged.')
vRtrLdpAddrFecInLabelStatus5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 20), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelStatus5.setDescription('The value of vRtrLdpAddrFecInLabelStatus5 specifies the \n         status of the ingress label 5')
vRtrLdpAddrFecInLabelIfIndex5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 21), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecInLabelIfIndex5.setDescription('The value of vRtrLdpAddrFecInLabelIfIndex5 specifies the \n         interface index for ingress label 5')
vRtrLdpAddrFecOutLabel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel1.setDescription('The value of vRtrLdpAddrFecOutLabel1 specifies the first \n         egress label exchanged')
vRtrLdpAddrFecOutLabelStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 23), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus1.setDescription('The value of vRtrLdpAddrFecOutLabelStatus1 specifies the \n         status of the egress label 1')
vRtrLdpAddrFecOutLabelIfIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 24), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex1.setDescription('The value of vRtrLdpAddrFecOutLabelIfIndex1 specifies the \n         interface index for egress label 1')
vRtrLdpAddrFecOutLabelNextHop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 25), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop1.setDescription('The value of vRtrLdpAddrFecOutLabelNextHop1 specifies the \n         IP address of the next hop for egress label 1')
vRtrLdpAddrFecOutLabel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel2.setDescription('The value of vRtrLdpAddrFecOutLabel2 specifies the second\n         egress label (if at all) exchanged.')
vRtrLdpAddrFecOutLabelStatus2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 27), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus2.setDescription('The value of vRtrLdpAddrFecOutLabelStatus2 specifies the \n         status of the egress label 2')
vRtrLdpAddrFecOutLabelIfIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 28), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex2.setDescription('The value of vRtrLdpAddrFecOutLabelIfIndex2 specifies the \n         interface index for egress label 2')
vRtrLdpAddrFecOutLabelNextHop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 29), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop2.setDescription('The value of vRtrLdpAddrFecOutLabelNextHop2 specifies the \n         IP address of the next hop for egress label 2')
vRtrLdpAddrFecOutLabel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 30), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel3.setDescription('The value of vRtrLdpAddrFecOutLabel3 specifies the third\n         egress label (if at all) exchanged.')
vRtrLdpAddrFecOutLabelStatus3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 31), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus3.setDescription('The value of vRtrLdpAddrFecOutLabelStatus3 specifies the \n         status of the egress label 3')
vRtrLdpAddrFecOutLabelIfIndex3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 32), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex3.setDescription('The value of vRtrLdpAddrFecOutLabelIfIndex3 specifies the \n         interface index for egress label 3')
vRtrLdpAddrFecOutLabelNextHop3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 33), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop3.setDescription('The value of vRtrLdpAddrFecOutLabelNextHop3 specifies the \n         IP address of the next hop for egress label 3')
vRtrLdpAddrFecOutLabel4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 34), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel4.setDescription('The value of vRtrLdpAddrFecOutLabel4 specifies the fourth\n         egress label (if at all) exchanged.')
vRtrLdpAddrFecOutLabelStatus4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 35), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus4.setDescription('The value of vRtrLdpAddrFecOutLabelStatus4 specifies the \n         status of the egress label 4')
vRtrLdpAddrFecOutLabelIfIndex4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 36), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex4.setDescription('The value of vRtrLdpAddrFecOutLabelIfIndex4 specifies the \n         interface index for egress label 4')
vRtrLdpAddrFecOutLabelNextHop4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 37), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop4.setDescription('The value of vRtrLdpAddrFecOutLabelNextHop4 specifies the \n         IP address of the next hop for egress label 4')
vRtrLdpAddrFecOutLabel5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 38), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabel5.setDescription('The value of vRtrLdpAddrFecOutLabel5 specifies the fifth\n         egress label (if at all) exchanged.')
vRtrLdpAddrFecOutLabelStatus5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 39), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelStatus5.setDescription('The value of vRtrLdpAddrFecOutLabelStatus5 specifies the \n         status of the egress label 5')
vRtrLdpAddrFecOutLabelIfIndex5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 40), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelIfIndex5.setDescription('The value of vRtrLdpAddrFecOutLabelIfIndex5 specifies the \n         interface index for egress label 5')
vRtrLdpAddrFecOutLabelNextHop5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 41), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecOutLabelNextHop5.setDescription('The value of vRtrLdpAddrFecOutLabelNextHop5 specifies the \n         IP address of the next hop for egress label 5')
vRtrLdpAddrFecLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 13, 1, 42), TmnxVRtrMplsLspID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecLspId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecLspId.setDescription('The value of vRtrLdpAddrFecLspId indicates the LSP id of the LSP\n         associated with the specified service FEC.')
vRtrLdpAddrFecMapTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 14), )
if mibBuilder.loadTexts: vRtrLdpAddrFecMapTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecMapTable.setDescription('vRtrLdpAddrFecMapTable is a read-only table which maps to the\n         vRtrLdpAddrFecTable. This table has the same indexes as the \n         vRtrLdpAddrFecTable but the order in which these indexes are \n         specified is different for the two tables.')
vRtrLdpAddrFecMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 14, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapFecType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapIpPrefix"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapIpMask"))
if mibBuilder.loadTexts: vRtrLdpAddrFecMapEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecMapEntry.setDescription('Each row entry represents an instance of an address FEC sent\n         to or received from an LDP peer.')
vRtrLdpAddrFecMapFecType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 14, 1, 1), TmnxLdpFECType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecMapFecType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecMapFecType.setDescription('The value of vRtrLdpAddrFecMapFecType specifies the FEC type.')
vRtrLdpAddrFecMapIpPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 14, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecMapIpPrefix.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecMapIpPrefix.setDescription('The value of vRtrLdpAddrFecMapIpPrefix specifies the IP Address  \n         Prefix for this address FEC.')
vRtrLdpAddrFecMapIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 14, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAddrFecMapIpMask.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAddrFecMapIpMask.setDescription('The value of vRtrLdpAddrFecMapIpMask specifies the IP Address \n         Mask for this address FEC.')
vRtrLdpAdjBackoffTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 15), )
if mibBuilder.loadTexts: vRtrLdpAdjBackoffTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAdjBackoffTable.setDescription('vRtrLdpAdjBackoffTable is a read-only table which augments\n         the vRtrLdpHelloAdjTable. The purpose of this table is to\n         keep backoff information about the LDP Hello Adjacencies on\n         the virtual router.\n\n         Use of AUGMENTS clause implies a one-to-one dependent \n         relationship between the base table, vRtrLdpHelloAdjTable,\n         and the augmenting table vRtrLdpAdjBackoffTable. This in \n         effect extends the vRtrLdpHelloAdjTable with additional \n         columns.  Creation or deletion of a row in the \n         vRtrLdpHelloAdjTable results in the same fate for the row \n         in the vRtrLdpAdjBackoffTable.')
vRtrLdpAdjBackoffEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 15, 1), )
vRtrLdpHelloAdjEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAdjBackoffEntry"))
vRtrLdpAdjBackoffEntry.setIndexNames(*vRtrLdpHelloAdjEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrLdpAdjBackoffEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAdjBackoffEntry.setDescription('A row in this table contains backoff information about an \n         LDP adjacency. \n\n         When an LDP session startup fails for the first time, the \n         LDP entity waits for a certain time interval before it tries\n         to setup the session again. This interval is the backoff \n         interval. The initial value for the backoff interval is set\n         to the value of vRtrLdpAdjInitBackoff. After waiting for the \n         backoff interval, LDP retries to setup the LDP session. If \n         it fails again the backoff interval increases exponentially\n         and this repeats for each successive LDP session startup \n         failure. If the backoff interval exceeds vRtrLdpAdjMaxBackoff,\n         LDP will not backoff anymore and will give up trying to \n         establish the LDP session.')
vRtrLdpAdjInitBackoff = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2592000))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAdjInitBackoff.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAdjInitBackoff.setDescription('The value of vRtrLdpAdjInitBackoff specifies the initial\n         backoff time. After a LDP session setup has failed, the \n         value of vRtrLdpAdjInitBackoff is the time interval, in \n         seconds, that the LDP entity waits before attempting to \n         setup the session again. This interval is the backoff \n         interval. This variable indicates the initial value for \n         backoff interval when the LDP session startup first fails. \n         Thereafter, if session startup fails again the backoff \n         interval increases exponentially.')
vRtrLdpAdjMaxBackoff = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 15, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2592000))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAdjMaxBackoff.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAdjMaxBackoff.setDescription('The value of vRtrLdpAdjMaxBackoff specifies the maximum \n         backoff time. For each successive failure of the LDP \n         session startup, the backoff interval (the time for which \n         the router waits before retrying) increases exponentially. \n         If the backoff interval exceeds vRtrLdpAdjMaxBackoff, the \n         router will not backoff anymore and will give up trying \n         to establish the LDP session. A value of 0 for \n         vRtrLdpAdjMaxBackoff indicates that the backoff interval \n         remains constant and will not increase exponentially. In \n         effect the router will try to establish an LDP session \n         till it succeeds')
vRtrLdpAdjCurrentBackoff = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 15, 1, 3), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAdjCurrentBackoff.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAdjCurrentBackoff.setDescription('This value of vRtrLdpAdjCurrentBackoff specifies the current\n         value of the backoff interval.')
vRtrLdpAdjWaitingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 15, 1, 4), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAdjWaitingTime.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAdjWaitingTime.setDescription('The value of vRtrLdpAdjWaitingTime specifies the time for \n         which the entity has been waiting in backoff state.')
vRtrLdpAdjBackoffStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 15, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpAdjBackoffStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpAdjBackoffStatus.setDescription("The value of vRtrLdpAdjBackoffStatus indicates whether or \n         not the entity is in backoff state. If this value is 'true',\n         then the entity is in a backoff state and if the value is \n         'false' then the entity is not in a backoff state")
vRtrLdpPeerParamsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16), )
if mibBuilder.loadTexts: vRtrLdpPeerParamsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerParamsTable.setDescription('vRtrLdpPeerParamsTable has an entry for an LDP peer. This table\n         is used to configure parmaters specific to the peer whether it \n         is an interface or a targeted peer.')
vRtrLdpPeerParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAddress"))
if mibBuilder.loadTexts: vRtrLdpPeerParamsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerParamsEntry.setDescription("Each row entry represents a peer that participates in the LDP \n         protocol on this virtual router.  \n\n         Row entries can be created or deleted via SNMP SET requests. \n         A row with default attribute values is created by setting \n         vRtrLdpPeerRowStatus to 'createAndGo'. A row entry can be \n         destroyed by setting vRtrLdpPeerRowStatus to 'destroy'.\n\n         A row entry with vRtrLdpPeerAddress of 0.0.0.0 represents the \n         default LDP parameters used for all peers that do not have a\n         corresponding entry in this table.")
vRtrLdpPeerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPeerRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerRowStatus.setDescription("vRtrLdpPeerRowStatus is used to control the creation and deletion\n         of rows in the vRtrLdpPeerParamsTable. \n\n         A row can be created by setting vRtrLdpPeerRowStatus to 'createAndGo'.\n         The agent should assign the default attribute values and change \n         the row status to 'active'.\n\n         A row entry can be destroyed by setting vRtrLdpPeerRowStatus to\n         'destroy'.")
vRtrLdpPeerAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPeerAuth.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerAuth.setDescription("When the value of vRtrLdpPeerAuth is 'true', authentication\n         using MD5 message based digest protocol is enabled.  When 'false',\n         no authentication is used.")
vRtrLdpPeerAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPeerAuthKey.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerAuthKey.setDescription('The string specified in vRtrLdpPeerAuthKey is the authentication\n         key to be used between LDP neighbors before establishing sessions. \n         Authentication is done using the MD-5 message based digest protocol.\n         The authentication key can be any combination of letters or numbers.\n         Note that the string may contain embedded nulls.\n\n         An SNMP Get request on this object should return an OCTET STRING of\n         length 0.')
vRtrLdpPeerMinTTLValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 255), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPeerMinTTLValue.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerMinTTLValue.setDescription('The value of vRtrLdpPeerMinTTLValue specifies the minimum\n         TTL value for an incoming LDP packet.\n         \n         If vRtrLdpPeerMinTTLValue is set to zero (0), the \n         TTL Security feature is disabled.')
vRtrLdpPeerTTLLogId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16, 1, 5), TFilterLogId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPeerTTLLogId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerTTLLogId.setDescription('The value of vRtrLdpPeerTTLLogId specifies the filter\n         log to use for packets that fail TTL security check.\n         The value zero indicates that logging is disabled.')
vRtrLdpPeerAuthKeyChain = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 16, 1, 6), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpPeerAuthKeyChain.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpPeerAuthKeyChain.setDescription('The value of vRtrLdpPeerAuthKeyChain specifies the \n        keychain which will be used to sign and/or authenticate  the BGP\n        protocol stream.\n\n        The keychain name is defined by tmnxKeyChainName and is the index for\n        TIMETRA-SECURITY-MIB::tmnxKeyChainTable')
vRtrLdpStaticFecTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18), )
if mibBuilder.loadTexts: vRtrLdpStaticFecTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecTable.setDescription('vRtrLdpStaticFecTable has an entry for each static prefix FEC\n         configured on the virtual router.')
vRtrLdpStaticFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecIpPrefix"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecIpMask"))
if mibBuilder.loadTexts: vRtrLdpStaticFecEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecEntry.setDescription("Each row entry represents a static prefix FEC configured \n         on the virtual router. \n         \n         Entries can be created and deleted via SNMP SET operations\n         to vRtrLdpStaticFecRowStatus. \n\n         An entry is created by setting vRtrLdpStaticFecRowStatus \n         to 'createAndWait'. The row status can be set to 'active' \n         only after a next-hop entry corresponding to this prefix \n         has been created in the vRtrLdpStaticFecNHTable.\n\n         An entry is deleted by setting vRtrLdpStaticFecRowStatus \n         to 'destroy'. For deletion to succeed, there must be no \n         next-hop entries corresponding to this prefix in the \n         vRtrLdpStaticFecNHTable i.e. vRtrLdpStaticFecNumNH must have \n         a value of 0.")
vRtrLdpStaticFecIpPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1, 1), IpAddress())
if mibBuilder.loadTexts: vRtrLdpStaticFecIpPrefix.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecIpPrefix.setDescription('The value of vRtrLdpStaticFecIpPrefix specifies the IP Address  \n         Prefix for this static FEC.')
vRtrLdpStaticFecIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1, 2), IpAddress())
if mibBuilder.loadTexts: vRtrLdpStaticFecIpMask.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecIpMask.setDescription('The value of vRtrLdpStaticFecIpMask specifies the IP Address \n         Mask for this static FEC.')
vRtrLdpStaticFecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpStaticFecRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecRowStatus.setDescription("vRtrLdpStaticFecRowStatus is used to create, delete or \n         control entries in the vRtrLdpStaticFecTable.\n\n         To create a row entry, set vRtrLdpStaticFecRowStatus to \n         'createAndWait'. Before the row can be placed in the \n         'active' state, a next-hop entry corresponding to this \n         prefix must exist in the vRtrLdpStaticFecNHTable.\n\n         To delete a row entry, set vRtrLdpStaticFecRowStatus to\n         'destroy'. For deletion to succeed, no next-hop entry \n         corresponding to this prefix must exist in the \n         vRtrLdpStaticFecNHTable i.e. vRtrLdpStaticFecNumNH must \n         have a value of 0.")
vRtrLdpStaticFecNextNHIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStaticFecNextNHIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNextNHIndex.setDescription("The value of vRtrLdpStaticFecNextNHIndex is used to \n         assign values to vRtrLdpStaticFecNHIndex when creating \n         rows in the vRtrLdpStaticFecNHTable. The network manager \n         reads this object and uses it in the SET request that \n         creates a new row entry in the vRtrLdpStaticFecNHTable. \n         If the SET fails with the code 'inconsistentValue', the\n         process must be repeated. If the SET succeeds, then this \n         object will be incremented and the new instance is \n         created according to the manager's directions.")
vRtrLdpStaticFecIngLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(32, 1023), ValueRangeConstraint(4294967295, 4294967295), )).clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpStaticFecIngLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecIngLabel.setDescription('The value of vRtrLdpStaticFecIngLabel specifies the label\n         that is advertised to the upstream peer. If this variable\n         is set to the default value of 4294967295, the ingress\n         label will be dynamically assigned by the label manager.')
vRtrLdpStaticFecNumNH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStaticFecNumNH.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNumNH.setDescription("The value of vRtrLdpStaticFecNumNH specifies the number \n         of next-hops that are associated with the static prefix \n         FEC represented by this row entry. This is also the number \n         of row entries configured in the vRtrLdpStaticFecNHTable \n         for this static prefix FEC.\n\n         If the static FEC has no next-hops associated with it, \n         this value will be 0 and the row entry will be placed in  \n         the 'notReady' state. Deletion of the row entry will be \n         allowed only if vRtrLdpStaticFecNumNH is 0.")
vRtrLdpStaticFecOperIngLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 18, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpStaticFecOperIngLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecOperIngLabel.setDescription('The value of vRtrLdpStaticFecOperIngLabel specifies the \n         actual or operational value of the label that was advertised\n         to the upstream peer.')
vRtrLdpStaticFecNHTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 19), )
if mibBuilder.loadTexts: vRtrLdpStaticFecNHTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNHTable.setDescription('vRtrLdpStaticFecNHTable has an entry for each next-hop \n         configured for a static prefix FEC on the virtual router.')
vRtrLdpStaticFecNHEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 19, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecIpPrefix"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecIpMask"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecNHIndex"))
if mibBuilder.loadTexts: vRtrLdpStaticFecNHEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNHEntry.setDescription("Each row entry represents a next-hop configured for a \n         static prefix FEC on the virtual router. The static prefix\n         FEC corresponding to a next-hop entry must exist as a \n         row entry in the vRtrLdpStaticFecTable.\n         \n         Entries can be created and deleted via SNMP SET operations \n         to vRtrLdpStaticFecNHRowStatus. \n\n         An entry is created by setting vRtrLdpStaticFecNHRowStatus \n         to 'createAndWait' or 'createAndGo'. Before the row can be \n         placed in the 'active' state, vRtrLdpStaticFecNHType must \n         be set to a valid value.\n\n         An entry is deleted by setting vRtrLdpStaticFecNHRowStatus \n         to 'destroy'.")
vRtrLdpStaticFecNHIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 19, 1, 1), Unsigned32())
if mibBuilder.loadTexts: vRtrLdpStaticFecNHIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNHIndex.setDescription('The value of vRtrLdpStaticFecNHIndex is used to identify\n         the next-hop associated with a static prefix FEC. This \n         value is unique amongst next-hop entries for the same \n         static prefix FEC.')
vRtrLdpStaticFecNHRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 19, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpStaticFecNHRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNHRowStatus.setDescription("vRtrLdpStaticFecNHRowStatus is used to create, delete or \n         control entries in the vRtrLdpStaticFecNHTable.\n\n         An entry is created by setting vRtrLdpStaticFecNHRowStatus \n         to 'createAndWait' or 'createAndGo'. Before the row can be \n         placed in the 'active' state, vRtrLdpStaticFecNHType must \n         be set to a valid value.\n\n         An entry is deleted by setting vRtrLdpStaticFecNHRowStatus \n         to 'destroy'.")
vRtrLdpStaticFecNHType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 19, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("ipAddress", 1), ("pop", 2))).clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpStaticFecNHType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNHType.setDescription('The value of vRtrLdpStaticFecNHType specifies the type of\n         next-hop represented by this row entry.\n\n         unknown (0)    - the next-hop type has not been set.\n         ipAddress (1)  - the next-hop is an IP address.\n         pop (2)        - there is no next-hop i.e. pop the label and route\n        ')
vRtrLdpStaticFecNHIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 19, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpStaticFecNHIpAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNHIpAddr.setDescription("If vRtrLdpStaticFecNHType is set to 'ipAddress', the value\n         of vRtrLdpStaticFecNHIpAddr specifies the IP address of \n         the next-hop. In this case, this variable must be set to \n         a valid value before the row be placed in an active state. \n         \n         If vRtrLdpStaticFecNHType is set to 'pop', this value of \n         vRtrLdpStaticFecNHIpAddr will be 0.0.0.0")
vRtrLdpStaticFecNHEgrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 19, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 1048575), ValueRangeConstraint(4294967295, 4294967295), )).clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpStaticFecNHEgrLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStaticFecNHEgrLabel.setDescription('The value of vRtrLdpStaticFecNHEgrLabel specifies the egress\n         label associated with this next-hop entry. The LSR will swap\n         the incoming label with the configured egress label. If this\n         egress label has a value of 4294967295, the LSR will pop the \n         incoming label.')
vRtrLdpTargTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20), )
if mibBuilder.loadTexts: vRtrLdpTargTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargTable.setDescription('vRtrLdpTargTable keeps information about the export and import \n          prefixes for a targeted LDP session.\n\n          Use of AUGMENTS clause implies a one-to-one dependent\n          relationship between the base table, vRtrLdpGeneralTable,\n          and the augmenting table, vRtrLdpTargTable. This in\n          effect extends the vRtrLdpGeneralTable with additional\n          columns.  Creation or deletion of a row in the \n          vRtrLdpGeneralTable results in the same fate for the row \n          in the vRtrLdpTargTable.')
vRtrLdpTargEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1), )
vRtrLdpGeneralEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargEntry"))
vRtrLdpTargEntry.setIndexNames(*vRtrLdpGeneralEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrLdpTargEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargEntry.setDescription('A row in this table represents information about the targeted\n         LDP session.')
vRtrLdpTargImportPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 3), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy1.setDescription('The value of vRtrLdpTargImportPolicy1 specifies the import \n         route policy to determine which routes are accepted from targeted\n         LDP neighbors.  A maximum of 5 policies can be specified.\n         vRtrLdpTargImportPolicy1 specifies the first policy.')
vRtrLdpTargImportPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 4), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy2.setDescription('The value of vRtrLdpTargImportPolicy2 specifies the second \n         import policy used to determine which routes are accepted from targeted\n         LDP neighbors.')
vRtrLdpTargImportPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 5), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy3.setDescription('The value of vRtrLdpTargImportPolicy3 specifies the third \n         import policy used to determine which routes are accepted from targeted\n         LDP neighbors.')
vRtrLdpTargImportPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 6), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy4.setDescription('The value of vRtrLdpTargImportPolicy4 specifies the fourth \n         import policy to determine which routes are accepted from targeted\n         LDP neighbors.')
vRtrLdpTargImportPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 7), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargImportPolicy5.setDescription('The value of vRtrLdpTargImportPolicy5 specifies the fifth \n         import policy used to determine which routes are accepted from targeted\n         LDP neighbors.')
vRtrLdpTargExportPolicy1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 8), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy1.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy1.setDescription('The value of vRtrLdpTargExportPolicy1 specifies the export \n         route policy used to determine which routes are exported to this \n         targeted LDP session.  A maximum of 5 policies can be specified.\n         vRtrLdpTargExportPolicy1 specifies the first policy.')
vRtrLdpTargExportPolicy2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 9), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy2.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy2.setDescription('The value of vRtrLdpTargExportPolicy2 specifies the second \n         export policy used to determine which routes are exported to this \n         targeted LDP session')
vRtrLdpTargExportPolicy3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 10), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy3.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy3.setDescription('The value of vRtrLdpTargExportPolicy3 specifies the third \n         export policy used to determine which routes are exported to this \n         targeted LDP session.')
vRtrLdpTargExportPolicy4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 11), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy4.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy4.setDescription('The value of vRtrLdpTargExportPolicy4 specifies the fourth \n         export policy used to determine which routes are exported to this \n         targeted LDP session.')
vRtrLdpTargExportPolicy5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 12), TPolicyStatementNameOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy5.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargExportPolicy5.setDescription('The value of vRtrLdpTargExportPolicy5 specifies the fifth\n         export policy used to determine which routes are exported to this \n         targeted LDP session.')
vRtrLdpTargTunnelPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 20, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpTargTunnelPreference.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpTargTunnelPreference.setDescription("The value of vRtrLdpTargTunnelPreference indicates whether LDP \n         over tunnel is preferred when link-level LDP bindings are also \n         available. If this value is 'true', then LDP tunnels are \n         preferred and if the value is 'false' then LDP over tunnel is \n         preferred.\n\n         By default LDP tunnels are preferred.")
vRtrLdpIfTunnelingLspTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 21), )
if mibBuilder.loadTexts: vRtrLdpIfTunnelingLspTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfTunnelingLspTable.setDescription('vRtrLdpIfTunnelingLspTable keeps the list of LDP-over-RSVP LSP \n          ids which are currently supported by the application.\n      \n          Each LSP ID in the list corresponds to the vRtrMplsLspIndex of \n          the given MPLS LSP.')
vRtrLdpIfTunnelingLspEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 21, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfIndex"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAddress"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfLspId"))
if mibBuilder.loadTexts: vRtrLdpIfTunnelingLspEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfTunnelingLspEntry.setDescription("A row in this table contains the LSP id information about an LDP\n         interface or targeted peer.\n\n         Row entries can be created or deleted via SNMP SET requests. \n         A row is created by setting vRtrLdpIfLspRowStatus to 'createAndGo'\n         provided the corresponding LSP id exists as an MPLS lsp.\n         A row entry can be destroyed by setting vRtrLdpIfLspRowStatus to \n         'destroy'.")
vRtrLdpIfLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 21, 1, 1), TmnxVRtrMplsLspID())
if mibBuilder.loadTexts: vRtrLdpIfLspId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfLspId.setDescription('The value of vRtrLdpIfLspId specifies the LSP id of the LSP\n         associated with the specified interface or targeted peer.')
vRtrLdpIfLspRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 21, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrLdpIfLspRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfLspRowStatus.setDescription("vRtrLdpIfLspRowStatus is used to create, delete or \n         control entries in the vRtrLdpIfTunnelingLspTable.\n \n         An entry is created by setting vRtrLdpIfLspRowStatus \n         to 'createAndGo'.\n \n         An entry is deleted by setting vRtrLdpIfLspRowStatus \n         to 'destroy'.")
vRtrLdpCepTdmFecTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22), )
if mibBuilder.loadTexts: vRtrLdpCepTdmFecTable.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmFecTable.setDescription('vRtrLdpCepTdmFecTable is a read-only table that represents all \n         CEP/TDM FECs either sent to or received from an LDP peer known\n         to the Virtual Router.\n         The CEP/TDM Sub-TLVs are defined in RFC 4446:\n\n         Parameter Id    Description\n         0x04            CEP/TDM Payload Bytes\n         0x07            CEP/TDM bit-rate\n         0x0B            TDM Options.')
vRtrLdpCepTdmFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1), )
vRtrLdpServFecEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmFecEntry"))
vRtrLdpCepTdmFecEntry.setIndexNames(*vRtrLdpServFecEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrLdpCepTdmFecEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmFecEntry.setDescription('Each row entry represents an instance of a service FEC sent to \n         or received from an LDP peer.\n         \n         Use of AUGMENTS clause implies a one-to-one dependent relationship\n         between the base table, vRtrLdpServFecTable, and the augmenting\n         table, vRtrLdpCepTdmFecTable.  This in effect extends the\n         vRtrLdpServFecTable with additional columns.\n         \n          Creation or deletion of a row in the vRtrLdpServFecTable results\n          in the same fate for the row in the VRtrLdpCepTdmFecEntry.')
vRtrLdpCepTdmLocalPayloadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 4), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalPayloadSize.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalPayloadSize.setDescription('The value of vRtrLdpCepTdmLocalPayloadSize indicates the local\n         payload size.')
vRtrLdpCepTdmRemotePayloadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 5), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemotePayloadSize.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemotePayloadSize.setDescription('The value of vRtrLdpCepTdmRemotePayloadSize indicates the remote\n         payload size.')
vRtrLdpCepTdmLocalBitrate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 6), Unsigned32()).setUnits('64 Kbits/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalBitrate.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalBitrate.setDescription('The value of vRtrLdpCepTdmLocalBitrate indicates the local\n         bitrate.')
vRtrLdpCepTdmRemoteBitrate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 7), Unsigned32()).setUnits('64 Kbits/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteBitrate.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteBitrate.setDescription('The value of vRtrLdpCepTdmRemoteBitrate indicates the remote\n         bitrate.')
vRtrLdpCepTdmLocalRtpHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalRtpHeader.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalRtpHeader.setDescription('The value of vRtrLdpCepTdmLocalRtpHeader indicates the local\n         RTP header usage bit.')
vRtrLdpCepTdmRemoteRtpHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteRtpHeader.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteRtpHeader.setDescription('The value of vRtrLdpCepTdmRemoteRtpHeader indicates the remote\n         RTP header usage bit.')
vRtrLdpCepTdmLocalDiffTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalDiffTimestamp.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalDiffTimestamp.setDescription('The value of vRtrLdpCepTdmLocalDiffTimestamp indicates the local\n         differential (or dynamic) timestamping mode bit.')
vRtrLdpCepTdmRemoteDiffTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteDiffTimestamp.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteDiffTimestamp.setDescription('The value of vRtrLdpCepTdmRemoteDiffTimestamp indicates the remote\n         differential (or dynamic) timestamping mode bit.')
vRtrLdpCepTdmLocalSigPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 12), TdmOptionsSigPkts()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalSigPkts.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalSigPkts.setDescription('The value of vRtrLdpCepTdmLocalSigPkts indicates the local\n         CE application signalling packets mode.')
vRtrLdpCepTdmRemoteSigPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 13), TdmOptionsSigPkts()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteSigPkts.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteSigPkts.setDescription('The value of vRtrLdpCepTdmRemoteSigPkts indicates the remote\n         CE application signalling packets mode.')
vRtrLdpCepTdmLocalCasTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 14), TdmOptionsCasTrunkFraming()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalCasTrunk.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalCasTrunk.setDescription('The value of vRtrLdpCepTdmLocalCasTrunk indicates the local\n         CE application signalling packets mode.')
vRtrLdpCepTdmRemoteCasTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 15), TdmOptionsCasTrunkFraming()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteCasTrunk.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteCasTrunk.setDescription('The value of vRtrLdpCepTdmRemoteCasTrunk indicates the remote\n         CE application signalling packets mode.')
vRtrLdpCepTdmLocalTimestampFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 16), Unsigned32()).setUnits('8 KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalTimestampFreq.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalTimestampFreq.setDescription('The value of vRtrLdpCepTdmLocalTimestampFreq indicates the local\n         CE application signalling packets mode.')
vRtrLdpCepTdmRemoteTimestampFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 17), Unsigned32()).setUnits('8 KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteTimestampFreq.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteTimestampFreq.setDescription('The value of vRtrLdpCepTdmRemoteTimestampFreq indicates the remote\n         CE application signalling packets mode.')
vRtrLdpCepTdmLocalPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalPayloadType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalPayloadType.setDescription('The value of vRtrLdpCepTdmLocalPayloadType indicates the local\n         payload type.')
vRtrLdpCepTdmRemotePayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemotePayloadType.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemotePayloadType.setDescription('The value of vRtrLdpCepTdmRemotePayloadType indicates the remote\n         payload type.')
vRtrLdpCepTdmLocalSsrcId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalSsrcId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmLocalSsrcId.setDescription('The value of vRtrLdpCepTdmLocalSsrcId indicates the local\n         value of SSRC ID.')
vRtrLdpCepTdmRemoteSsrcId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 22, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteSsrcId.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpCepTdmRemoteSsrcId.setDescription('The value of vRtrLdpCepTdmRemoteSsrcId indicates the remote\n         value of SSRC ID.')
vLdpServFec129Table = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23), )
if mibBuilder.loadTexts: vLdpServFec129Table.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129Table.setDescription('vLdpServFec129Table is a read-only table that represents all\n         service FEC-129s either sent to or received from an LDP peer known\n         to the Virtual Router.')
vLdpServFec129Entry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecVcType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129AgiTlv"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129SrcAiiTlv"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129TgtAiiTlv"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"))
if mibBuilder.loadTexts: vLdpServFec129Entry.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129Entry.setDescription('Each row entry represents an instance of a service FEC-129 sent to \n         or received from an LDP peer.')
vLdpServFec129AgiTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 1), TmnxLdpFec129Tlv())
if mibBuilder.loadTexts: vLdpServFec129AgiTlv.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129AgiTlv.setDescription('The value of vLdpServFec129AgiTlv specifies the Attachment Group\n         Identifier TLV associated with this service FEC.')
vLdpServFec129SrcAiiTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 2), TmnxLdpFec129Tlv())
if mibBuilder.loadTexts: vLdpServFec129SrcAiiTlv.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129SrcAiiTlv.setDescription('The value of vLdpServFec129SrcAiiTlv specifies the Source Attachment\n         Individual Identifier TLV associated with this service FEC.')
vLdpServFec129TgtAiiTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 3), TmnxLdpFec129Tlv())
if mibBuilder.loadTexts: vLdpServFec129TgtAiiTlv.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129TgtAiiTlv.setDescription('The value of vLdpServFec129TgtAiiTlv specifies the Target Attachment\n         Individual Identifier TLV associated with this service FEC.')
vLdpServFec129ServType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 4), ServType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129ServType.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129ServType.setDescription('The value of vLdpServFec129ServType specifies the Service type\n         associated with this service FEC.')
vLdpServFec129ServId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 5), TmnxServId().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129ServId.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129ServId.setDescription('The value of vLdpServFec129ServId specifies the Service identifier\n         associated with this service FEC.')
vLdpServFec129VpnId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 6), TmnxVpnId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129VpnId.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129VpnId.setDescription('The value of vLdpServFec129VpnId identifies the VPN associated \n         with the FEC.')
vLdpServFec129Flags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 7), TmnxLdpFECFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129Flags.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129Flags.setDescription('The bit flags of vLdpServFec129Flags specify the characteristics\n         of the FEC.')
vLdpServFec129NumInLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129NumInLabels.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129NumInLabels.setDescription('The value of vLdpServFec129NumInLabels gives the number of \n         labels that have been sent to the peer associated with this \n         FEC. This value also indicates whether vLdpServFec129InLabel1 entry\n         contain valid information i.e. if the value of \n         vLdpServFec129NumInLabels is 1 then vLdpServFec129InLabel1\n         will contain valid label information.')
vLdpServFec129NumOutLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129NumOutLabels.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129NumOutLabels.setDescription('The value of vLdpServFec129NumOutLabels gives the number of\n         labels that have been received from the peer associated with this\n         FEC. This value also indicates whether vLdpServFec129OutLabel1 \n         entry contain valid information i.e. if the value of \n         vLdpServFec129NumOutLabels is 1, then vLdpServFec129OutLabel1\n         will contain valid label information.')
vLdpServFec129InLabel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129InLabel1.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129InLabel1.setDescription('The value of vLdpServFec129InLabel1 specifies the first \n         ingress label exchanged')
vLdpServFec129InLabelStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 11), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129InLabelStatus1.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129InLabelStatus1.setDescription('The value of vLdpServFec129InLabelStatus1 specifies the \n         status of the ingress label 1')
vLdpServFec129OutLabel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129OutLabel1.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129OutLabel1.setDescription('The value of vLdpServFec129OutLabel1 specifies the first\n         egress label exchanged.')
vLdpServFec129OutLabelStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 21), TmnxLabelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129OutLabelStatus1.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129OutLabelStatus1.setDescription('The value of vLdpServFec129OutLabelStatus1 specifies the \n         status of the egress label 1')
vLdpServFec129SdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 22), SdpId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129SdpId.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129SdpId.setDescription('The value of vLdpServFec129SdpId identifies the SDP associated\n         with this peer.')
vLdpServFec129LocalMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129LocalMTU.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129LocalMTU.setDescription('The value of vLdpServFec129LocalMTU specifies the largest \n         service frame size (in octets) that can be handled by the \n         local ESR.')
vLdpServFec129RemoteMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129RemoteMTU.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129RemoteMTU.setDescription('The value of vLdpServFec129RemoteMTU specifies the largest \n         service frame size (in octets) that can be handled by the \n         remote ESR.')
vLdpServFec129LocalVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129LocalVlanTag.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129LocalVlanTag.setDescription('The value of vLdpServFec129LocalVlanTag specifies the local \n         tag on a VLAN VC type SDP binding.')
vLdpServFec129RemoteVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129RemoteVlanTag.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129RemoteVlanTag.setDescription('The value of vLdpServFec129RemoteVlanTag specifies the remote\n         tag on a VLAN VC type SDP binding.')
vLdpServFec129LocalMaxCellConcat = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129LocalMaxCellConcat.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129LocalMaxCellConcat.setDescription('The value of vLdpServFec129LocalMaxCellConcat specifies the local \n         maximum number of ATM cells to concatenate on a ATM cell-mode VC \n         type SDP binding.')
vLdpServFec129RemoteMaxCellConcat = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129RemoteMaxCellConcat.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129RemoteMaxCellConcat.setDescription('The value of vLdpServFec129RemoteMaxCellConcat specifies the remote\n         maximum number of ATM cells to concatenate on a ATM cell-mode VC \n         type SDP binding.')
vLdpServFec129InLabelSigStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 29), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129InLabelSigStatus1.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129InLabelSigStatus1.setDescription('The value of vLdpServFec129InLabelSigStatus1 indicates the signaling\n         status for vLdpServFec129InLabel1.')
vLdpServFec129OutLabelSigStatus1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 23, 1, 30), TmnxLabelSigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129OutLabelSigStatus1.setStatus('current')
if mibBuilder.loadTexts: vLdpServFec129OutLabelSigStatus1.setDescription('The value of vLdpServFec129OutLabelSigStatus1 indicates the signaling\n         status for vLdpServFec129OutLabel1.')
vLdpServFec129MapTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 24), )
if mibBuilder.loadTexts: vLdpServFec129MapTable.setStatus('obsolete')
if mibBuilder.loadTexts: vLdpServFec129MapTable.setDescription('vLdpServFec129MapTable is a read-only table which maps to the \n         vLdpServFec129Table. This table has the same indexes as the \n         vLdpServFec129Table but the order in which these indexes are \n         specified is different for the two tables.')
vLdpServFec129MapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 24, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerLdpId"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapVcType"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapAgiTlv"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapSrcAiiTlv"), (0, "ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapTgtAiiTlv"))
if mibBuilder.loadTexts: vLdpServFec129MapEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vLdpServFec129MapEntry.setDescription('Each row entry represents an instance of a service FEC sent to \n         or received from an LDP peer.')
vLdpServFec129MapVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 24, 1, 1), TmnxVcType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129MapVcType.setStatus('obsolete')
if mibBuilder.loadTexts: vLdpServFec129MapVcType.setDescription('The value of vLdpServFec129MapVcType specifies the VC type  \n         associated with this service FEC.')
vLdpServFec129MapAgiTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 24, 1, 2), TmnxLdpFec129Tlv()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129MapAgiTlv.setStatus('obsolete')
if mibBuilder.loadTexts: vLdpServFec129MapAgiTlv.setDescription('The value of vLdpServFec129MapAgiTlv specifies the Attachment Group\n         Identifier TLV associated with this service FEC.')
vLdpServFec129MapSrcAiiTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 24, 1, 3), TmnxLdpFec129Tlv()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129MapSrcAiiTlv.setStatus('obsolete')
if mibBuilder.loadTexts: vLdpServFec129MapSrcAiiTlv.setDescription('The value of vLdpServFec129MapSrcAiiTlv specifies the Source\n         Attachment Individual Identifier TLV associated with this service FEC.')
vLdpServFec129MapTgtAiiTlv = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 24, 1, 4), TmnxLdpFec129Tlv()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpServFec129MapTgtAiiTlv.setStatus('obsolete')
if mibBuilder.loadTexts: vLdpServFec129MapTgtAiiTlv.setDescription('The value of vLdpServFec129MapTgtAiiTlv specifies the Target\n         Attachment Individual Identifier TLV associated with this service FEC.')
vLdpCepTdmFec129Table = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25), )
if mibBuilder.loadTexts: vLdpCepTdmFec129Table.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129Table.setDescription('vLdpCepTdmFec129Table is a read-only table that represents all \n         CEP/TDM FECs either sent to or received from an LDP peer known\n         to the Virtual Router.\n         The CEP/TDM Sub-TLVs are defined in RFC 4446:\n\n         Parameter Id    Description\n         0x04            CEP/TDM Payload Bytes\n         0x07            CEP/TDM bit-rate\n         0x0B            TDM Options.')
vLdpCepTdmFec129Entry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1), )
vLdpServFec129Entry.registerAugmentions(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129Entry"))
vLdpCepTdmFec129Entry.setIndexNames(*vLdpServFec129Entry.getIndexNames())
if mibBuilder.loadTexts: vLdpCepTdmFec129Entry.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129Entry.setDescription('Each row entry represents an instance of a service FEC sent to \n         or received from an LDP peer.\n         \n         Use of AUGMENTS clause implies a one-to-one dependent relationship\n         between the base table, vRtrLdpServFecTable, and the augmenting\n         table, vLdpCepTdmFec129Table.  This in effect extends the\n         vRtrLdpServFecTable with additional columns.\n         \n          Creation or deletion of a row in the vRtrLdpServFecTable results\n          in the same fate for the row in the VLdpCepTdmFec129Entry.')
vLdpCepTdmFec129LocalPayloadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 4), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalPayloadSize.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalPayloadSize.setDescription('The value of vLdpCepTdmFec129LocalPayloadSize indicates the local\n         payload size.')
vLdpCepTdmFec129RemotePayloadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 5), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemotePayloadSize.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemotePayloadSize.setDescription('The value of vLdpCepTdmFec129RemotePayloadSize indicates the remote\n         payload size.')
vLdpCepTdmFec129LocalBitrate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 6), Unsigned32()).setUnits('64 Kbits/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalBitrate.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalBitrate.setDescription('The value of vLdpCepTdmFec129LocalBitrate indicates the local\n         bitrate.')
vLdpCepTdmFec129RemoteBitrate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 7), Unsigned32()).setUnits('64 Kbits/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteBitrate.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteBitrate.setDescription('The value of vLdpCepTdmFec129RemoteBitrate indicates the remote\n         bitrate.')
vLdpCepTdmFec129LocalRtpHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalRtpHeader.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalRtpHeader.setDescription('The value of vLdpCepTdmFec129LocalRtpHeader indicates the local\n         RTP header usage bit.')
vLdpCepTdmFec129RemoteRtpHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteRtpHeader.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteRtpHeader.setDescription('The value of vLdpCepTdmFec129RemoteRtpHeader indicates the remote\n         RTP header usage bit.')
vLdpCepTdmFec129LocalDiffTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalDiffTimestamp.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalDiffTimestamp.setDescription('The value of vLdpCepTdmFec129LocalDiffTimestamp indicates the local\n         differential (or dynamic) timestamping mode bit.')
vLdpCepTdmFec129RemoteDiffTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteDiffTimestamp.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteDiffTimestamp.setDescription('The value of vLdpCepTdmFec129RemoteDiffTimestamp indicates the remote\n         differential (or dynamic) timestamping mode bit.')
vLdpCepTdmFec129LocalSigPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 12), TdmOptionsSigPkts()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalSigPkts.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalSigPkts.setDescription('The value of vLdpCepTdmFec129LocalSigPkts indicates the local\n         CE application signalling packets mode.')
vLdpCepTdmFec129RemoteSigPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 13), TdmOptionsSigPkts()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteSigPkts.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteSigPkts.setDescription('The value of vLdpCepTdmFec129RemoteSigPkts indicates the remote\n         CE application signalling packets mode.')
vLdpCepTdmFec129LocalCasTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 14), TdmOptionsCasTrunkFraming()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalCasTrunk.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalCasTrunk.setDescription('The value of vLdpCepTdmFec129LocalCasTrunk indicates the local\n         CE application signalling packets mode.')
vLdpCepTdmFec129RemoteCasTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 15), TdmOptionsCasTrunkFraming()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteCasTrunk.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteCasTrunk.setDescription('The value of vLdpCepTdmFec129RemoteCasTrunk indicates the remote\n         CE application signalling packets mode.')
vLdpCepTdmFec129LocalTimestampFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 16), Unsigned32()).setUnits('8 KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalTimestampFreq.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalTimestampFreq.setDescription('The value of vLdpCepTdmFec129LocalTimestampFreq indicates the local\n         CE application signalling packets mode.')
vLdpCepTdmFec129RemoteTimestampFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 17), Unsigned32()).setUnits('8 KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteTimestampFreq.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteTimestampFreq.setDescription('The value of vLdpCepTdmFec129RemoteCasTrunk indicates the remote\n         CE application signalling packets mode.')
vLdpCepTdmFec129LocalPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalPayloadType.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalPayloadType.setDescription('The value of vLdpCepTdmFec129LocalPayloadType indicates the local\n         payload type.')
vLdpCepTdmFec129RemotePayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemotePayloadType.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemotePayloadType.setDescription('The value of vLdpCepTdmFec129RemotePayloadType indicates the remote\n         payload type.')
vLdpCepTdmFec129LocalSsrcId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalSsrcId.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129LocalSsrcId.setDescription('The value of vLdpCepTdmFec129LocalSsrcId indicates the local\n         value of SSRC ID.')
vLdpCepTdmFec129RemoteSsrcId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 25, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteSsrcId.setStatus('current')
if mibBuilder.loadTexts: vLdpCepTdmFec129RemoteSsrcId.setDescription('The value of vLdpCepTdmFec129RemoteSsrcId indicates the remote\n         value of SSRC ID.')
tmnxLdpNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 17))
vRtrLdpInstanceNotifyReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 17, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("adminUp", 1), ("adminDown", 2), ("operUp", 3), ("operDown", 4)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrLdpInstanceNotifyReasonCode.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpInstanceNotifyReasonCode.setDescription('Used by vRtrLdpInstanceStateChange, the value indicates the reason \n         for the LDP instance state change.')
vRtrLdpIfNotifyReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 17, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("adminUp", 1), ("adminDown", 2), ("operUp", 3), ("operDown", 4), ("sysIpUp", 5), ("sysIpDown", 6)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrLdpIfNotifyReasonCode.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfNotifyReasonCode.setDescription('Used by vRtrLdpIfStateChange, the value indicates the reason for the \n         LSP interface state change.')
vRtrLdpNotifyLocalServiceID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 17, 3), TmnxServId().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrLdpNotifyLocalServiceID.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpNotifyLocalServiceID.setDescription('Used by vRtrLdpSvcIdMismatch, the value indicates the local\n         Service ID.')
vRtrLdpNotifyRemoteServiceID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 17, 4), TmnxServId().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrLdpNotifyRemoteServiceID.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpNotifyRemoteServiceID.setDescription('Used by vRtrLdpSvcIdMismatch, the value indicates the remote\n         Service ID.')
vRtrLdpNotifyLocalGroupID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 17, 5), TmnxVcId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrLdpNotifyLocalGroupID.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpNotifyLocalGroupID.setDescription('Used by vRtrLdpGroupIdMismatch, the value indicates the local\n         Group ID.')
vRtrLdpNotifyRemoteGroupID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 8, 17, 6), TmnxVcId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrLdpNotifyRemoteGroupID.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpNotifyRemoteGroupID.setDescription('Used by vRtrLdpGroupIdMismatch, the value indicates the remote\n         Group ID.')
vRtrLdpStateChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 8, 0, 1)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrLdpStatus"))
if mibBuilder.loadTexts: vRtrLdpStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpStateChange.setDescription('The vRtrLdpStateChange notification is generated when the LDP\n         protocol is created or deleted in the router.')
vRtrLdpInstanceStateChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 8, 0, 2)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenAdminState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenOperState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpInstanceNotifyReasonCode"))
if mibBuilder.loadTexts: vRtrLdpInstanceStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpInstanceStateChange.setDescription('The vRtrLdpInstanceStateChange notification is generated when the LDP\n        module changes state either administratively or operationally.')
vRtrLdpIfStateChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 8, 0, 3)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfAdminState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfOperState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfNotifyReasonCode"))
if mibBuilder.loadTexts: vRtrLdpIfStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpIfStateChange.setDescription('The vRtrLdpIfStateChange notification is generated when the LDP\n        interface changes state either administratively or operationally.')
vRtrLdpSvcIdMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 8, 0, 4)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyLocalServiceID"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyRemoteServiceID"))
if mibBuilder.loadTexts: vRtrLdpSvcIdMismatch.setStatus('obsolete')
if mibBuilder.loadTexts: vRtrLdpSvcIdMismatch.setDescription('The vRtrLdpSvcIdMismatch notification is generated when there is\n         a mismatch of local and remote service IDs.')
vRtrLdpGroupIdMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 8, 0, 5)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyLocalGroupID"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyRemoteGroupID"))
if mibBuilder.loadTexts: vRtrLdpGroupIdMismatch.setStatus('current')
if mibBuilder.loadTexts: vRtrLdpGroupIdMismatch.setDescription('The vRtrLdpGroupIdMismatch notification is generated when there is\n         a mismatch of local and remote group IDs.')
tmnxLdpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 1))
tmnxLdpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2))
tmnxLdpV4v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 1, 4)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpGlobalV3v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpIfV3v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpAdjR2r1Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpSessionR2r1Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpServFecV4v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpAddrFecGroup"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpNotificationGroup"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpStaticFecV3v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpV4v0Compliance = tmnxLdpV4v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpV4v0Compliance.setDescription('The compliance statement for management of extended LDP\n             on Alcatel 7x50 SR series systems 4.0 release.')
tmnxLdpV5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 1, 5)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpGlobalV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpIfV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpAdjR2r1Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpSessionV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpServFecV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpAddrFecV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpNotificationGroup"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpStaticFecV3v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpV5v0Compliance = tmnxLdpV5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpV5v0Compliance.setDescription('The compliance statement for management of extended LDP\n             on Alcatel 7x50 SR series systems 5.0 release.')
tmnxLdpV6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 1, 6)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpGlobalV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpIfV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpAdjR2r1Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpSessionV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpServFecV6v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpServFec129V6v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpAddrFecV5v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpNotificationGroup"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpStaticFecV3v0Group"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "tmnxLdpCepTdmFecV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpV6v0Compliance = tmnxLdpV6v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpV6v0Compliance.setDescription('The compliance statement for management of extended LDP\n             on Alcatel 7x50 SR series systems 6.0 release.')
tmnxLdpAddrFecGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 6)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecFlags"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecNumInLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecNumOutLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapFecType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapIpPrefix"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapIpMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpAddrFecGroup = tmnxLdpAddrFecGroup.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpAddrFecGroup.setDescription('The group of objects supporting management of extended LDP \n         address FECs sent to or received from an LDP peer\n         on Alcatel 7x50 SR series systems.')
tmnxLdpNotifyObjsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 7)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpInstanceNotifyReasonCode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfNotifyReasonCode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyLocalGroupID"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyRemoteGroupID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpNotifyObjsGroup = tmnxLdpNotifyObjsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpNotifyObjsGroup.setDescription('The group of objects supporting extended LDP notifications \n         on Alcatel 7x50 SR series systems.')
tmnxLdpNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 8)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStateChange"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpInstanceStateChange"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfStateChange"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGroupIdMismatch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpNotificationGroup = tmnxLdpNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpNotificationGroup.setDescription('The group of notifications supporting the extended LDP feature\n         on Alcatel 7x50 SR series systems.')
tmnxLdpAdjBackoffGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 10)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAdjInitBackoff"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAdjMaxBackoff"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAdjCurrentBackoff"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAdjWaitingTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAdjBackoffStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpAdjBackoffGroup = tmnxLdpAdjBackoffGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpAdjBackoffGroup.setDescription('The group of objects supporting general management of extended LDP\n         adjacency backoff on Alcatel 7x50 SR series systems.  \n         The vRtrLdpAdjBackoffTable is not yet supported by a TiMOS release.')
tmnxLdpObsoleteObjsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 11)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyLocalServiceID"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpNotifyRemoteServiceID"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPolicyRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPolicyName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpObsoleteObjsGroup = tmnxLdpObsoleteObjsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpObsoleteObjsGroup.setDescription('The group of obsolete objects for the extended LDP feature\n         on Alcatel 7x50 SR series \n         systems.')
tmnxLdpObsoleteNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 12)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSvcIdMismatch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpObsoleteNotificationGroup = tmnxLdpObsoleteNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpObsoleteNotificationGroup.setDescription('The group of obsolete notifications for the extended LDP feature\n         on Alcatel 7x50 SR series systems.')
tmnxLdpAdjR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 15)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjMapLdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjLocalLdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjEntityIndex"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjIndex"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjHoldTimeRemaining"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjRemoteConfSeqNum"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjRemoteIpAddress"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjUpTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjLocalConfSeqNum"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjLocalIpAddress"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjInHelloMsgCount"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjOutHelloMsgCount"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjLocalHelloTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpHelloAdjRemoteHelloTimeout"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpAdjR2r1Group = tmnxLdpAdjR2r1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpAdjR2r1Group.setDescription('The group of objects supporting management of extended LDP \n         Adjacencies for LDP sessions on Alcatel 7x50 SR series systems\n         2.1 Release.')
tmnxLdpSessionR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 16)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalLdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessEntityIndex"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLabelDistMethod"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLoopDetectForPV"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPathVectorLimit"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessAdjacencyType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessProtocolVersion"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalUdpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerUdpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalTcpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerTcpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalAddress"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerAddress"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessKAHoldTimeRemaining"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessMaxPduLength"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessUpTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalKATimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerKATimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsTargAdj"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLinkAdj"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsFECRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsFECSent"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsHelloIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsHelloOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsKeepaliveIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsKeepaliveOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsInitIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsInitOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelMappingIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelMappingOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelRequestIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelRequestOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelReleaseIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelReleaseOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelWithdrawIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelWithdrawOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelAbortIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelAbortOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrWithdrawIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrWithdrawOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsNotificationIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsNotificationOut"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpSessionR2r1Group = tmnxLdpSessionR2r1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpSessionR2r1Group.setDescription('The group of objects supporting management of extended LDP \n         Sessions on Alcatel 7x50 SR series systems 2.1 Release.')
tmnxLdpStaticFecV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 17)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecNextNHIndex"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecIngLabel"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecNumNH"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecOperIngLabel"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecNHRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecNHType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecNHIpAddr"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStaticFecNHEgrLabel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpStaticFecV3v0Group = tmnxLdpStaticFecV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpStaticFecV3v0Group.setDescription('The group of objects supporting management of LDP Static\n         FECs on Alcatel 7x50 SR series systems 3.0 release.')
tmnxLdpIfV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 19)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfTableSpinlock"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfLastChange"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfAdminState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfOperState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfInheritance"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfKeepAliveFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfKeepAliveTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfHelloFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfHelloTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfMaxBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfTransportAddrType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfPassiveMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfAutoCreate"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfOperDownReason"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfExistingAdjacencies"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAuth"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAuthKey"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerMinTTLValue"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerTTLLogId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpIfV3v0Group = tmnxLdpIfV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpIfV3v0Group.setDescription('The group of objects supporting management of extended LDP \n         interfaces and targeted peers on Alcatel 7x50 SR series systems\n         3.0 release.')
tmnxLdpGlobalV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 20)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenLastChange"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenAdminState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenOperState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenLdpLsrId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenProtocolVersion"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenDeaggregateFec"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenKeepAliveFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenKeepAliveTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenHelloFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenHelloTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenRoutePreference"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenControlMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenDistMethod"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenRetentionMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTransportAddrType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenPropagatePolicy"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenLoopDetectCapable"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenHopLimit"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenPathVectorLimit"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenMaxBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargKeepAliveFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargKeepAliveTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargHelloFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargHelloTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargPassiveMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargetedSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenCreateTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenUpTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTunnelDownDampTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenOperDownReason"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTrustList"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsOperDownEvents"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveAdjacencies"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveInterfaces"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsInactiveInterfaces"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveTargSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsInactiveTargSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsAddrFECRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsAddrFECSent"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSvcFECRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSvcFECSent"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsAttemptedSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejNoHelloErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejAdvErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejMaxPduErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejLabelRangeErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadLdpIdentifierErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadPduLengthErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadMessageLengthErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadTlvLengthErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsMalformedTlvValueErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsKeepAliveExpiredErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsShutdownNotifRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsShutdownNotifSent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpGlobalV3v0Group = tmnxLdpGlobalV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpGlobalV3v0Group.setDescription('The group of objects supporting general management of extended LDP \n         on Alcatel 7x50 SR series systems 3.0 release.')
tmnxLdpServFecV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 21)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecServType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecServId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecVpnId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecFlags"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecNumInLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecNumOutLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecSdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapFecType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus5"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpServFecV4v0Group = tmnxLdpServFecV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpServFecV4v0Group.setDescription('The group of objects supporting management of extended LDP \n         service FECs sent to or received from an LDP peer\n         on Alcatel 7x50 SR series systems release 4.0.')
tmnxLdpGlobalV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 22)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenLastChange"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenAdminState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenOperState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenLdpLsrId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenProtocolVersion"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenDeaggregateFec"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenKeepAliveFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenKeepAliveTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenHelloFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenHelloTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenRoutePreference"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenControlMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenDistMethod"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenRetentionMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTransportAddrType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenPropagatePolicy"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenLoopDetectCapable"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenHopLimit"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenPathVectorLimit"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenMaxBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargKeepAliveFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargKeepAliveTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargHelloFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargHelloTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargPassiveMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTargetedSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenCreateTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenUpTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenImportPolicy5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenExportPolicy5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTunnelDownDampTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenOperDownReason"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenGracefulRestart"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenGRNbrLiveTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenGRMaxRecoveryTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargImportPolicy1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargImportPolicy2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargImportPolicy3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargImportPolicy4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargImportPolicy5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargExportPolicy1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargExportPolicy2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargExportPolicy3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargExportPolicy4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargExportPolicy5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpTargTunnelPreference"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsOperDownEvents"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveAdjacencies"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveInterfaces"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsInactiveInterfaces"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsActiveTargSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsInactiveTargSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsAddrFECRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsAddrFECSent"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSvcFECRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSvcFECSent"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsAttemptedSessions"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejNoHelloErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejAdvErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejMaxPduErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsSessRejLabelRangeErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadLdpIdentifierErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadPduLengthErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadMessageLengthErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsBadTlvLengthErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsMalformedTlvValueErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsKeepAliveExpiredErrors"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsShutdownNotifRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpStatsShutdownNotifSent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpGlobalV5v0Group = tmnxLdpGlobalV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpGlobalV5v0Group.setDescription('The group of objects supporting general management of extended LDP \n         on Alcatel 7x50 SR series systems 5.0 release.')
tmnxLdpIfV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 23)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfTableSpinlock"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfLastChange"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfAdminState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfOperState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfInheritance"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfKeepAliveFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfKeepAliveTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfHelloFactor"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfHelloTimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfMaxBackoffTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfTransportAddrType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfPassiveMode"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfAutoCreate"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfOperDownReason"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfExistingAdjacencies"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfTunneling"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpIfLspRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerRowStatus"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAuth"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAuthKey"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerMinTTLValue"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerTTLLogId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpPeerAuthKeyChain"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpIfV5v0Group = tmnxLdpIfV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpIfV5v0Group.setDescription('The group of objects supporting management of extended LDP \n         interfaces and targeted peers on Alcatel 7x50 SR series systems\n         5.0 release.')
tmnxLdpServFecV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 24)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecServType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecServId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecVpnId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecFlags"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecNumInLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecNumOutLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecSdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapFecType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMateEndpointVcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMateEndpointSdpId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpServFecV5v0Group = tmnxLdpServFecV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLdpServFecV5v0Group.setDescription('The group of objects supporting management of extended LDP \n         service FECs sent to or received from an LDP peer\n         on Alcatel 7x50 SR series systems release 5.0.')
tmnxLdpAddrFecV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 25)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecFlags"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecNumInLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecNumOutLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecInLabelIfIndex5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelIfIndex5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecOutLabelNextHop5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecLspId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapFecType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapIpPrefix"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpAddrFecMapIpMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpAddrFecV5v0Group = tmnxLdpAddrFecV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpAddrFecV5v0Group.setDescription('The group of objects supporting management of extended LDP \n         address FECs sent to or received from an LDP peer\n         on Alcatel 7x50 SR series systems for release 5.0.')
tmnxLdpSessionV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 26)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalLdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessEntityIndex"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLabelDistMethod"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLoopDetectForPV"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPathVectorLimit"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessAdjacencyType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessProtocolVersion"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalUdpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerUdpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalTcpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerTcpPort"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalAddress"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerAddress"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessKAHoldTimeRemaining"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessMaxPduLength"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessUpTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLocalKATimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerKATimeout"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessAdvertise"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessRestartHelperState"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessPeerNumRestart"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessLastRestartTime"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessFtReconnectTimeNego"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessFtRecoveryTimeNego"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessFtReconTimeRemaining"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessFtRecovTimeRemaining"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsTargAdj"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLinkAdj"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsFECRecv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsFECSent"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsHelloIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsHelloOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsKeepaliveIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsKeepaliveOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsInitIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsInitOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelMappingIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelMappingOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelRequestIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelRequestOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelReleaseIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelReleaseOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelWithdrawIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelWithdrawOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelAbortIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsLabelAbortOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrWithdrawIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsAddrWithdrawOut"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsNotificationIn"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpSessStatsNotificationOut"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpSessionV5v0Group = tmnxLdpSessionV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpSessionV5v0Group.setDescription('The group of objects supporting management of extended LDP \n         Sessions on Alcatel 7x50 SR series systems 5.0 Release.')
tmnxLdpObsoletedV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 27)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpGenTrustList"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpObsoletedV5v0Group = tmnxLdpObsoletedV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpObsoletedV5v0Group.setDescription('The group of objects obsoleted on Alcatel 7x50 SR series \n         systems 5.0 Release.')
tmnxLdpCepTdmFecV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 28)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalPayloadSize"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemotePayloadSize"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalBitrate"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemoteBitrate"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalRtpHeader"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemoteRtpHeader"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalDiffTimestamp"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemoteDiffTimestamp"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalSigPkts"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemoteSigPkts"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalCasTrunk"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemoteCasTrunk"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalTimestampFreq"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemoteTimestampFreq"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalPayloadType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemotePayloadType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmLocalSsrcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpCepTdmRemoteSsrcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalPayloadSize"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemotePayloadSize"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalBitrate"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemoteBitrate"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalRtpHeader"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemoteRtpHeader"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalDiffTimestamp"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemoteDiffTimestamp"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalSigPkts"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemoteSigPkts"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalCasTrunk"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemoteCasTrunk"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalTimestampFreq"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemoteTimestampFreq"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalPayloadType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemotePayloadType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129LocalSsrcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpCepTdmFec129RemoteSsrcId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpCepTdmFecV6v0Group = tmnxLdpCepTdmFecV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpCepTdmFecV6v0Group.setDescription('The group of objects supporting management of extended LDP \n         CEP/TDM FECs sent to or received from an LDP peer\n         on Alcatel 7x50 SR series systems release 6.0.')
tmnxLdpServFecV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 29)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecServType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecServId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecVpnId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecFlags"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecNumInLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecNumOutLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabel5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecSdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecLocalMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecRemoteMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecInLabelSigStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus2"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus3"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus4"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecOutLabelSigStatus5"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMateEndpointVcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMateEndpointSdpId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpServFecV6v0Group = tmnxLdpServFecV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpServFecV6v0Group.setDescription('The group of objects supporting management of extended LDP \n         service FECs sent to or received from an LDP peer\n         on Alcatel 7x50 SR series systems release 6.0.')
tmnxLdpServFec129V6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 30)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129ServType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129ServId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129VpnId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129Flags"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129NumInLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129NumOutLabels"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129InLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129InLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129OutLabel1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129OutLabelStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129SdpId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129LocalMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129RemoteMTU"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129LocalVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129RemoteVlanTag"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129LocalMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129RemoteMaxCellConcat"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129InLabelSigStatus1"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129OutLabelSigStatus1"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpServFec129V6v0Group = tmnxLdpServFec129V6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpServFec129V6v0Group.setDescription('The group of objects supporting management of LDP \n         FEC-129s sent to or received from an LDP peer\n         on Alcatel 7x50 SR series systems release 6.0.')
tmnxLdpServFecObsoletedV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 8, 2, 31)).setObjects(("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapFecType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vRtrLdpServFecMapVcId"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapVcType"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapAgiTlv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapSrcAiiTlv"), ("ALCATEL-IND1-TIMETRA-LDP-MIB", "vLdpServFec129MapTgtAiiTlv"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLdpServFecObsoletedV6v0Group = tmnxLdpServFecObsoletedV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLdpServFecObsoletedV6v0Group.setDescription('The group of objects supporting management of obsoleted LDP \n         FEC objects on Alcatel 7x50 SR series systems release 6.0.')
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-LDP-MIB", vLdpServFec129InLabelSigStatus1=vLdpServFec129InLabelSigStatus1, vRtrLdpSvcIdMismatch=vRtrLdpSvcIdMismatch, vRtrLdpStatsActiveSessions=vRtrLdpStatsActiveSessions, vLdpServFec129MapTgtAiiTlv=vLdpServFec129MapTgtAiiTlv, vRtrLdpGenAdminState=vRtrLdpGenAdminState, vRtrLdpAddrFecMapIpPrefix=vRtrLdpAddrFecMapIpPrefix, vRtrLdpGenImportPolicy2=vRtrLdpGenImportPolicy2, vRtrLdpHelloAdjEntry=vRtrLdpHelloAdjEntry, vRtrLdpAddrFecOutLabel3=vRtrLdpAddrFecOutLabel3, vRtrLdpSessStatsLabelReleaseIn=vRtrLdpSessStatsLabelReleaseIn, vRtrLdpSessStatsHelloOut=vRtrLdpSessStatsHelloOut, vRtrLdpServFecMapFecType=vRtrLdpServFecMapFecType, vRtrLdpServFecOutLabel3=vRtrLdpServFecOutLabel3, vRtrLdpServFecOutLabelSigStatus5=vRtrLdpServFecOutLabelSigStatus5, vRtrLdpTargExportPolicy3=vRtrLdpTargExportPolicy3, vLdpServFec129MapAgiTlv=vLdpServFec129MapAgiTlv, vRtrLdpPolicyName=vRtrLdpPolicyName, vRtrLdpServFecNumInLabels=vRtrLdpServFecNumInLabels, tmnxLdpObsoleteObjsGroup=tmnxLdpObsoleteObjsGroup, vRtrLdpAddrFecOutLabelNextHop2=vRtrLdpAddrFecOutLabelNextHop2, vRtrLdpServFecServId=vRtrLdpServFecServId, TmnxLdpGenOperDownReasonCode=TmnxLdpGenOperDownReasonCode, vRtrLdpStaticFecNHIpAddr=vRtrLdpStaticFecNHIpAddr, vRtrLdpHelloAdjEntityIndex=vRtrLdpHelloAdjEntityIndex, vRtrLdpSessFtReconTimeRemaining=vRtrLdpSessFtReconTimeRemaining, vLdpServFec129ServType=vLdpServFec129ServType, vLdpCepTdmFec129LocalSigPkts=vLdpCepTdmFec129LocalSigPkts, vRtrLdpGenPathVectorLimit=vRtrLdpGenPathVectorLimit, tmnxLdpStaticFecV3v0Group=tmnxLdpStaticFecV3v0Group, vRtrLdpGenOperState=vRtrLdpGenOperState, vRtrLdpStaticFecIpMask=vRtrLdpStaticFecIpMask, vRtrLdpAddrFecInLabelStatus1=vRtrLdpAddrFecInLabelStatus1, vRtrLdpStateChange=vRtrLdpStateChange, vLdpCepTdmFec129LocalRtpHeader=vLdpCepTdmFec129LocalRtpHeader, vRtrLdpServFecInLabelSigStatus5=vRtrLdpServFecInLabelSigStatus5, vRtrLdpAddrFecMapFecType=vRtrLdpAddrFecMapFecType, vRtrLdpAddrFecInLabel5=vRtrLdpAddrFecInLabel5, vRtrLdpSessLocalTcpPort=vRtrLdpSessLocalTcpPort, vRtrLdpServFecInLabelStatus5=vRtrLdpServFecInLabelStatus5, vRtrLdpSessStatsKeepaliveIn=vRtrLdpSessStatsKeepaliveIn, vRtrLdpIfAutoCreate=vRtrLdpIfAutoCreate, vRtrLdpSessPeerNumRestart=vRtrLdpSessPeerNumRestart, vRtrLdpGeneralEntry=vRtrLdpGeneralEntry, vRtrLdpSessLocalKATimeout=vRtrLdpSessLocalKATimeout, vRtrLdpIfStatsEntry=vRtrLdpIfStatsEntry, vRtrLdpServFecOutLabelSigStatus1=vRtrLdpServFecOutLabelSigStatus1, vLdpCepTdmFec129RemoteCasTrunk=vLdpCepTdmFec129RemoteCasTrunk, vRtrLdpServFecOutLabelStatus1=vRtrLdpServFecOutLabelStatus1, vRtrLdpServFecVpnId=vRtrLdpServFecVpnId, vRtrLdpServFecInLabelStatus2=vRtrLdpServFecInLabelStatus2, vRtrLdpAddrFecIpMask=vRtrLdpAddrFecIpMask, vRtrLdpStatsKeepAliveExpiredErrors=vRtrLdpStatsKeepAliveExpiredErrors, vRtrLdpSessLoopDetectForPV=vRtrLdpSessLoopDetectForPV, vLdpServFec129MapEntry=vLdpServFec129MapEntry, vRtrLdpServFecEntry=vRtrLdpServFecEntry, vRtrLdpHelloAdjRemoteConfSeqNum=vRtrLdpHelloAdjRemoteConfSeqNum, vRtrLdpAdjBackoffStatus=vRtrLdpAdjBackoffStatus, vRtrLdpGenTrustList=vRtrLdpGenTrustList, vRtrLdpAddrFecInLabelIfIndex5=vRtrLdpAddrFecInLabelIfIndex5, vRtrLdpGenTargHelloTimeout=vRtrLdpGenTargHelloTimeout, vRtrLdpSessUpTime=vRtrLdpSessUpTime, vRtrLdpAddrFecOutLabelStatus4=vRtrLdpAddrFecOutLabelStatus4, vRtrLdpHelloAdjUpTime=vRtrLdpHelloAdjUpTime, tmnxLdpGlobalV3v0Group=tmnxLdpGlobalV3v0Group, vLdpCepTdmFec129Table=vLdpCepTdmFec129Table, vRtrLdpStatsInactiveTargSessions=vRtrLdpStatsInactiveTargSessions, vRtrLdpSessStatsLabelRequestOut=vRtrLdpSessStatsLabelRequestOut, vLdpServFec129SrcAiiTlv=vLdpServFec129SrcAiiTlv, vRtrLdpTargImportPolicy2=vRtrLdpTargImportPolicy2, TmnxLdpFECType=TmnxLdpFECType, vRtrLdpStatsActiveTargSessions=vRtrLdpStatsActiveTargSessions, vLdpServFec129Entry=vLdpServFec129Entry, vRtrLdpSessFtRecovTimeRemaining=vRtrLdpSessFtRecovTimeRemaining, tmnxLdpServFec129V6v0Group=tmnxLdpServFec129V6v0Group, vRtrLdpServFecInLabelSigStatus4=vRtrLdpServFecInLabelSigStatus4, vRtrLdpServFecInLabelSigStatus2=vRtrLdpServFecInLabelSigStatus2, vRtrLdpStatsBadTlvLengthErrors=vRtrLdpStatsBadTlvLengthErrors, vRtrLdpServFecInLabelSigStatus1=vRtrLdpServFecInLabelSigStatus1, vRtrLdpServFecMapVcType=vRtrLdpServFecMapVcType, vLdpServFec129LocalVlanTag=vLdpServFec129LocalVlanTag, vLdpCepTdmFec129RemoteTimestampFreq=vLdpCepTdmFec129RemoteTimestampFreq, vRtrLdpCepTdmLocalPayloadType=vRtrLdpCepTdmLocalPayloadType, vRtrLdpHelloAdjLocalIpAddress=vRtrLdpHelloAdjLocalIpAddress, vRtrLdpSessLastRestartTime=vRtrLdpSessLastRestartTime, vRtrLdpStatsActiveInterfaces=vRtrLdpStatsActiveInterfaces, vRtrLdpAddrFecInLabel4=vRtrLdpAddrFecInLabel4, vRtrLdpPeerAuth=vRtrLdpPeerAuth, tmnxLdpV6v0Compliance=tmnxLdpV6v0Compliance, vRtrLdpSessPeerUdpPort=vRtrLdpSessPeerUdpPort, vRtrLdpCepTdmRemoteSigPkts=vRtrLdpCepTdmRemoteSigPkts, vRtrLdpTargExportPolicy4=vRtrLdpTargExportPolicy4, vRtrLdpGenTransportAddrType=vRtrLdpGenTransportAddrType, vRtrLdpIfOperDownReason=vRtrLdpIfOperDownReason, vRtrLdpPeerParamsTable=vRtrLdpPeerParamsTable, vRtrLdpGroupIdMismatch=vRtrLdpGroupIdMismatch, vLdpServFec129OutLabelSigStatus1=vLdpServFec129OutLabelSigStatus1, vRtrLdpServFecInLabel3=vRtrLdpServFecInLabel3, vRtrLdpServFecRemoteVlanTag=vRtrLdpServFecRemoteVlanTag, vRtrLdpIfTable=vRtrLdpIfTable, vRtrLdpCepTdmLocalBitrate=vRtrLdpCepTdmLocalBitrate, vRtrLdpStatsSessRejNoHelloErrors=vRtrLdpStatsSessRejNoHelloErrors, vRtrLdpSessProtocolVersion=vRtrLdpSessProtocolVersion, vRtrLdpCepTdmLocalSsrcId=vRtrLdpCepTdmLocalSsrcId, vRtrLdpAdjCurrentBackoff=vRtrLdpAdjCurrentBackoff, vRtrLdpServFecVcId=vRtrLdpServFecVcId, vRtrLdpPeerRowStatus=vRtrLdpPeerRowStatus, vRtrLdpNotifyRemoteGroupID=vRtrLdpNotifyRemoteGroupID, vRtrLdpAddrFecOutLabelStatus2=vRtrLdpAddrFecOutLabelStatus2, vRtrLdpServFecOutLabelStatus2=vRtrLdpServFecOutLabelStatus2, vLdpCepTdmFec129LocalTimestampFreq=vLdpCepTdmFec129LocalTimestampFreq, vRtrLdpAddrFecTable=vRtrLdpAddrFecTable, vRtrLdpGenImportPolicy4=vRtrLdpGenImportPolicy4, vRtrLdpServFecInLabelStatus3=vRtrLdpServFecInLabelStatus3, TmnxLabelStatus=TmnxLabelStatus, vRtrLdpSessionStatsTable=vRtrLdpSessionStatsTable, vRtrLdpTargImportPolicy4=vRtrLdpTargImportPolicy4, vLdpServFec129AgiTlv=vLdpServFec129AgiTlv, vRtrLdpServFecInLabel5=vRtrLdpServFecInLabel5, vRtrLdpServFecInLabel2=vRtrLdpServFecInLabel2, tmnxLdpServFecV5v0Group=tmnxLdpServFecV5v0Group, vRtrLdpStaticFecIpPrefix=vRtrLdpStaticFecIpPrefix, vRtrLdpTargImportPolicy5=vRtrLdpTargImportPolicy5, vLdpServFec129MapSrcAiiTlv=vLdpServFec129MapSrcAiiTlv, vRtrLdpPeerLdpId=vRtrLdpPeerLdpId, vRtrLdpSessionTable=vRtrLdpSessionTable, vRtrLdpSessStatsLabelRequestIn=vRtrLdpSessStatsLabelRequestIn, vRtrLdpHelloAdjRemoteIpAddress=vRtrLdpHelloAdjRemoteIpAddress, vRtrLdpGenTargKeepAliveTimeout=vRtrLdpGenTargKeepAliveTimeout, vLdpServFec129NumOutLabels=vLdpServFec129NumOutLabels, vRtrLdpCepTdmFecEntry=vRtrLdpCepTdmFecEntry, vRtrLdpIfTunnelingLspTable=vRtrLdpIfTunnelingLspTable, vRtrLdpGenPropagatePolicy=vRtrLdpGenPropagatePolicy, vRtrLdpServFecMapVcId=vRtrLdpServFecMapVcId, vRtrLdpIfLastChange=vRtrLdpIfLastChange, vLdpCepTdmFec129RemoteBitrate=vLdpCepTdmFec129RemoteBitrate, tmnxLdpIfV3v0Group=tmnxLdpIfV3v0Group, vRtrLdpIfHelloFactor=vRtrLdpIfHelloFactor, vRtrLdpGenImportPolicy5=vRtrLdpGenImportPolicy5, vRtrLdpIfPassiveMode=vRtrLdpIfPassiveMode, vRtrLdpIfStatsTable=vRtrLdpIfStatsTable, vRtrLdpAddrFecOutLabelStatus3=vRtrLdpAddrFecOutLabelStatus3, vRtrLdpCepTdmLocalPayloadSize=vRtrLdpCepTdmLocalPayloadSize, vRtrLdpSessKAHoldTimeRemaining=vRtrLdpSessKAHoldTimeRemaining, vLdpServFec129Table=vLdpServFec129Table, vRtrLdpCepTdmRemoteCasTrunk=vRtrLdpCepTdmRemoteCasTrunk, vRtrLdpCepTdmRemotePayloadType=vRtrLdpCepTdmRemotePayloadType, tmnxLdpIfV5v0Group=tmnxLdpIfV5v0Group, vRtrLdpNotifyLocalServiceID=vRtrLdpNotifyLocalServiceID, vRtrLdpPolicyRowStatus=vRtrLdpPolicyRowStatus, vLdpServFec129MapVcType=vLdpServFec129MapVcType, vRtrLdpStatsAddrFECRecv=vRtrLdpStatsAddrFECRecv, vRtrLdpIfKeepAliveFactor=vRtrLdpIfKeepAliveFactor, vLdpServFec129InLabelStatus1=vLdpServFec129InLabelStatus1, vRtrLdpCepTdmLocalTimestampFreq=vRtrLdpCepTdmLocalTimestampFreq, tmnxLdpV4v0Compliance=tmnxLdpV4v0Compliance, tmnxLdpServFecV4v0Group=tmnxLdpServFecV4v0Group, vRtrLdpAddrFecOutLabelNextHop4=vRtrLdpAddrFecOutLabelNextHop4, vRtrLdpIfTunnelingLspEntry=vRtrLdpIfTunnelingLspEntry, vRtrLdpGenGRMaxRecoveryTime=vRtrLdpGenGRMaxRecoveryTime, vRtrLdpHelloAdjType=vRtrLdpHelloAdjType, vLdpCepTdmFec129LocalDiffTimestamp=vLdpCepTdmFec129LocalDiffTimestamp, vLdpCepTdmFec129RemotePayloadSize=vLdpCepTdmFec129RemotePayloadSize, tmnxLdpSessionR2r1Group=tmnxLdpSessionR2r1Group, vLdpServFec129ServId=vLdpServFec129ServId, vRtrLdpStatsInactiveInterfaces=vRtrLdpStatsInactiveInterfaces, vLdpServFec129TgtAiiTlv=vLdpServFec129TgtAiiTlv, vRtrLdpGenImportPolicy3=vRtrLdpGenImportPolicy3, vRtrLdpAddrFecInLabelIfIndex1=vRtrLdpAddrFecInLabelIfIndex1, vRtrLdpIfTunneling=vRtrLdpIfTunneling, vRtrLdpInstanceStateChange=vRtrLdpInstanceStateChange, vRtrLdpAddrFecOutLabelIfIndex5=vRtrLdpAddrFecOutLabelIfIndex5, vRtrLdpServFecOutLabelStatus5=vRtrLdpServFecOutLabelStatus5, vRtrLdpCepTdmLocalDiffTimestamp=vRtrLdpCepTdmLocalDiffTimestamp, vRtrLdpGenKeepAliveFactor=vRtrLdpGenKeepAliveFactor, vRtrLdpHelloAdjMapTable=vRtrLdpHelloAdjMapTable, vRtrLdpHelloAdjInHelloMsgCount=vRtrLdpHelloAdjInHelloMsgCount, vRtrLdpSessMaxPduLength=vRtrLdpSessMaxPduLength, vRtrLdpPolicyEntry=vRtrLdpPolicyEntry, vRtrLdpStatsSessRejMaxPduErrors=vRtrLdpStatsSessRejMaxPduErrors, vRtrLdpNotifyLocalGroupID=vRtrLdpNotifyLocalGroupID, vRtrLdpAddrFecOutLabelStatus5=vRtrLdpAddrFecOutLabelStatus5, vRtrLdpSessPathVectorLimit=vRtrLdpSessPathVectorLimit, vRtrLdpStatsShutdownNotifRecv=vRtrLdpStatsShutdownNotifRecv, vLdpCepTdmFec129LocalCasTrunk=vLdpCepTdmFec129LocalCasTrunk, vRtrLdpTargExportPolicy5=vRtrLdpTargExportPolicy5, tmnxLdpAddrFecV5v0Group=tmnxLdpAddrFecV5v0Group, vRtrLdpSessAdjacencyType=vRtrLdpSessAdjacencyType, tmnxLdpNotifyPrefix=tmnxLdpNotifyPrefix, vRtrLdpGenRoutePreference=vRtrLdpGenRoutePreference, vRtrLdpHelloAdjMapEntry=vRtrLdpHelloAdjMapEntry, vRtrLdpSessLocalAddress=vRtrLdpSessLocalAddress, vRtrLdpStatsSvcFECSent=vRtrLdpStatsSvcFECSent, vLdpCepTdmFec129LocalBitrate=vLdpCepTdmFec129LocalBitrate, tmnxLdpAdjR2r1Group=tmnxLdpAdjR2r1Group, vRtrLdpAddrFecOutLabelNextHop1=vRtrLdpAddrFecOutLabelNextHop1, vRtrLdpGenCreateTime=vRtrLdpGenCreateTime, vRtrLdpStatsTable=vRtrLdpStatsTable, vRtrLdpServFecMateEndpointSdpId=vRtrLdpServFecMateEndpointSdpId, vRtrLdpStaticFecNHTable=vRtrLdpStaticFecNHTable, vRtrLdpSessStatsAddrWithdrawOut=vRtrLdpSessStatsAddrWithdrawOut, vRtrLdpStatsAddrFECSent=vRtrLdpStatsAddrFECSent, vRtrLdpServFecTable=vRtrLdpServFecTable, TmnxLdpHelloTimeout=TmnxLdpHelloTimeout, vRtrLdpAddrFecInLabel2=vRtrLdpAddrFecInLabel2, vRtrLdpAddrFecOutLabelIfIndex3=vRtrLdpAddrFecOutLabelIfIndex3, vRtrLdpSessLocalLdpId=vRtrLdpSessLocalLdpId, vRtrLdpServFecOutLabelSigStatus2=vRtrLdpServFecOutLabelSigStatus2, vRtrLdpHelloAdjMapLdpId=vRtrLdpHelloAdjMapLdpId, vRtrLdpStaticFecIngLabel=vRtrLdpStaticFecIngLabel, vRtrLdpGenTargPassiveMode=vRtrLdpGenTargPassiveMode, timetraLdpMIBModule=timetraLdpMIBModule, vRtrLdpSessStatsAddrIn=vRtrLdpSessStatsAddrIn, tmnxLdpObsoleteNotificationGroup=tmnxLdpObsoleteNotificationGroup, tmnxLdpNotificationGroup=tmnxLdpNotificationGroup, vRtrLdpServFecInLabelSigStatus3=vRtrLdpServFecInLabelSigStatus3, vRtrLdpStatsShutdownNotifSent=vRtrLdpStatsShutdownNotifSent, vRtrLdpAddrFecIpPrefix=vRtrLdpAddrFecIpPrefix, vRtrLdpIfStateChange=vRtrLdpIfStateChange, vRtrLdpServFecMapTable=vRtrLdpServFecMapTable, vLdpCepTdmFec129RemoteRtpHeader=vLdpCepTdmFec129RemoteRtpHeader, vRtrLdpSessFtReconnectTimeNego=vRtrLdpSessFtReconnectTimeNego, vLdpServFec129NumInLabels=vLdpServFec129NumInLabels, vRtrLdpServFecLocalMTU=vRtrLdpServFecLocalMTU, vRtrLdpServFecOutLabel1=vRtrLdpServFecOutLabel1, TmnxLdpHelloFactor=TmnxLdpHelloFactor, vLdpCepTdmFec129LocalPayloadType=vLdpCepTdmFec129LocalPayloadType, vRtrLdpStaticFecNHRowStatus=vRtrLdpStaticFecNHRowStatus, vLdpServFec129RemoteMTU=vLdpServFec129RemoteMTU, vRtrLdpGenExportPolicy4=vRtrLdpGenExportPolicy4, vRtrLdpServFecLocalVlanTag=vRtrLdpServFecLocalVlanTag, vRtrLdpIfInheritance=vRtrLdpIfInheritance, vRtrLdpGenDistMethod=vRtrLdpGenDistMethod, vRtrLdpStatsBadMessageLengthErrors=vRtrLdpStatsBadMessageLengthErrors, tmnxLdpGroups=tmnxLdpGroups, tmnxLdpServFecV6v0Group=tmnxLdpServFecV6v0Group, vLdpServFec129InLabel1=vLdpServFec129InLabel1, TmnxLdpIntTargOperDownReasonCode=TmnxLdpIntTargOperDownReasonCode, vRtrLdpPeerAuthKey=vRtrLdpPeerAuthKey, vRtrLdpSessStatsLabelMappingOut=vRtrLdpSessStatsLabelMappingOut, vRtrLdpServFecOutLabelSigStatus3=vRtrLdpServFecOutLabelSigStatus3, vRtrLdpGenDeaggregateFec=vRtrLdpGenDeaggregateFec, vRtrLdpHelloAdjHoldTimeRemaining=vRtrLdpHelloAdjHoldTimeRemaining, vRtrLdpStaticFecNHEntry=vRtrLdpStaticFecNHEntry, vRtrLdpServFecInLabelStatus4=vRtrLdpServFecInLabelStatus4, vRtrLdpAddrFecInLabel3=vRtrLdpAddrFecInLabel3, vRtrLdpAddrFecInLabelStatus2=vRtrLdpAddrFecInLabelStatus2, vRtrLdpAddrFecOutLabel2=vRtrLdpAddrFecOutLabel2, vRtrLdpIfLspRowStatus=vRtrLdpIfLspRowStatus, vRtrLdpSessStatsLabelMappingIn=vRtrLdpSessStatsLabelMappingIn, vLdpCepTdmFec129RemoteSigPkts=vLdpCepTdmFec129RemoteSigPkts, vLdpServFec129OutLabelStatus1=vLdpServFec129OutLabelStatus1, vRtrLdpSessStatsLabelAbortOut=vRtrLdpSessStatsLabelAbortOut, vLdpCepTdmFec129RemoteSsrcId=vLdpCepTdmFec129RemoteSsrcId, TmnxLdpKeepAliveTimeout=TmnxLdpKeepAliveTimeout)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-LDP-MIB", vRtrLdpHelloAdjOutHelloMsgCount=vRtrLdpHelloAdjOutHelloMsgCount, vRtrLdpHelloAdjIndex=vRtrLdpHelloAdjIndex, vRtrLdpAddrFecNumInLabels=vRtrLdpAddrFecNumInLabels, vRtrLdpStatsAttemptedSessions=vRtrLdpStatsAttemptedSessions, vRtrLdpIfHelloTimeout=vRtrLdpIfHelloTimeout, vRtrLdpCepTdmRemotePayloadSize=vRtrLdpCepTdmRemotePayloadSize, PYSNMP_MODULE_ID=timetraLdpMIBModule, vRtrLdpCepTdmRemoteDiffTimestamp=vRtrLdpCepTdmRemoteDiffTimestamp, vRtrLdpAdjMaxBackoff=vRtrLdpAdjMaxBackoff, TmnxLdpKeepAliveFactor=TmnxLdpKeepAliveFactor, vRtrLdpSessStatsLabelWithdrawOut=vRtrLdpSessStatsLabelWithdrawOut, vRtrLdpNotifyRemoteServiceID=vRtrLdpNotifyRemoteServiceID, vRtrLdpSessFtRecoveryTimeNego=vRtrLdpSessFtRecoveryTimeNego, vRtrLdpServFecVcType=vRtrLdpServFecVcType, vLdpCepTdmFec129LocalSsrcId=vLdpCepTdmFec129LocalSsrcId, vRtrLdpAddrFecOutLabelIfIndex4=vRtrLdpAddrFecOutLabelIfIndex4, vRtrLdpServFecInLabel4=vRtrLdpServFecInLabel4, TmnxLdpFec129Tlv=TmnxLdpFec129Tlv, vLdpServFec129OutLabel1=vLdpServFec129OutLabel1, vRtrLdpIfNotifyReasonCode=vRtrLdpIfNotifyReasonCode, vLdpServFec129RemoteVlanTag=vLdpServFec129RemoteVlanTag, vRtrLdpSessLabelDistMethod=vRtrLdpSessLabelDistMethod, vLdpServFec129LocalMaxCellConcat=vLdpServFec129LocalMaxCellConcat, vLdpServFec129LocalMTU=vLdpServFec129LocalMTU, vRtrLdpSessStatsTargAdj=vRtrLdpSessStatsTargAdj, vRtrLdpStaticFecNumNH=vRtrLdpStaticFecNumNH, vRtrLdpIfTableSpinlock=vRtrLdpIfTableSpinlock, vRtrLdpCepTdmRemoteBitrate=vRtrLdpCepTdmRemoteBitrate, vRtrLdpGenMaxBackoffTime=vRtrLdpGenMaxBackoffTime, vRtrLdpAddrFecOutLabel5=vRtrLdpAddrFecOutLabel5, vRtrLdpAddrFecInLabelIfIndex3=vRtrLdpAddrFecInLabelIfIndex3, vRtrLdpGenLastChange=vRtrLdpGenLastChange, vRtrLdpIfTransportAddrType=vRtrLdpIfTransportAddrType, vRtrLdpSessAdvertise=vRtrLdpSessAdvertise, vRtrLdpTargImportPolicy1=vRtrLdpTargImportPolicy1, vRtrLdpAdjWaitingTime=vRtrLdpAdjWaitingTime, vRtrLdpServFecFecType=vRtrLdpServFecFecType, vRtrLdpSessState=vRtrLdpSessState, vRtrLdpSessStatsAddrOut=vRtrLdpSessStatsAddrOut, vRtrLdpSessionEntry=vRtrLdpSessionEntry, vRtrLdpHelloAdjLocalLdpId=vRtrLdpHelloAdjLocalLdpId, vRtrLdpGenLdpLsrId=vRtrLdpGenLdpLsrId, vRtrLdpIfEntry=vRtrLdpIfEntry, vRtrLdpAddrFecMapTable=vRtrLdpAddrFecMapTable, vRtrLdpGenExportPolicy1=vRtrLdpGenExportPolicy1, vRtrLdpStaticFecEntry=vRtrLdpStaticFecEntry, vRtrLdpGenBackoffTime=vRtrLdpGenBackoffTime, vRtrLdpGenTargKeepAliveFactor=vRtrLdpGenTargKeepAliveFactor, vRtrLdpTargTunnelPreference=vRtrLdpTargTunnelPreference, vRtrLdpServFecFlags=vRtrLdpServFecFlags, vRtrLdpAddrFecOutLabelIfIndex1=vRtrLdpAddrFecOutLabelIfIndex1, vRtrLdpSessStatsFECRecv=vRtrLdpSessStatsFECRecv, TmnxVpnId=TmnxVpnId, vRtrLdpIfRowStatus=vRtrLdpIfRowStatus, vRtrLdpSessEntityIndex=vRtrLdpSessEntityIndex, vRtrLdpCepTdmLocalRtpHeader=vRtrLdpCepTdmLocalRtpHeader, vRtrLdpServFecRemoteMTU=vRtrLdpServFecRemoteMTU, vRtrLdpPolicyType=vRtrLdpPolicyType, vRtrLdpGenExportPolicy5=vRtrLdpGenExportPolicy5, vRtrLdpSessStatsAddrWithdrawIn=vRtrLdpSessStatsAddrWithdrawIn, vRtrLdpSessStatsLabelReleaseOut=vRtrLdpSessStatsLabelReleaseOut, vRtrLdpGenLoopDetectCapable=vRtrLdpGenLoopDetectCapable, vRtrLdpStaticFecNHIndex=vRtrLdpStaticFecNHIndex, vRtrLdpServFecSdpId=vRtrLdpServFecSdpId, vRtrLdpIfAdminState=vRtrLdpIfAdminState, vRtrLdpSessStatsKeepaliveOut=vRtrLdpSessStatsKeepaliveOut, vRtrLdpAddrFecOutLabelIfIndex2=vRtrLdpAddrFecOutLabelIfIndex2, vRtrLdpStatsEntry=vRtrLdpStatsEntry, vRtrLdpGenHelloTimeout=vRtrLdpGenHelloTimeout, vRtrLdpAddrFecOutLabelStatus1=vRtrLdpAddrFecOutLabelStatus1, vRtrLdpServFecMateEndpointVcId=vRtrLdpServFecMateEndpointVcId, vRtrLdpServFecMapEntry=vRtrLdpServFecMapEntry, vLdpCepTdmFec129RemotePayloadType=vLdpCepTdmFec129RemotePayloadType, vLdpServFec129MapTable=vLdpServFec129MapTable, vRtrLdpCepTdmLocalSigPkts=vRtrLdpCepTdmLocalSigPkts, vRtrLdpSessStatsLabelWithdrawIn=vRtrLdpSessStatsLabelWithdrawIn, vRtrLdpPolicyTable=vRtrLdpPolicyTable, vRtrLdpAddrFecFlags=vRtrLdpAddrFecFlags, vRtrLdpAddrFecMapEntry=vRtrLdpAddrFecMapEntry, tmnxLdpSessionV5v0Group=tmnxLdpSessionV5v0Group, vRtrLdpHelloAdjLocalHelloTimeout=vRtrLdpHelloAdjLocalHelloTimeout, vRtrLdpStaticFecNHEgrLabel=vRtrLdpStaticFecNHEgrLabel, vRtrLdpAddrFecOutLabelNextHop5=vRtrLdpAddrFecOutLabelNextHop5, vRtrLdpIfExistingAdjacencies=vRtrLdpIfExistingAdjacencies, vLdpServFec129RemoteMaxCellConcat=vLdpServFec129RemoteMaxCellConcat, tmnxLdpNotificationObjects=tmnxLdpNotificationObjects, vRtrLdpAddrFecOutLabel4=vRtrLdpAddrFecOutLabel4, vRtrLdpStatsActiveAdjacencies=vRtrLdpStatsActiveAdjacencies, tmnxLdpConformance=tmnxLdpConformance, vRtrLdpServFecInLabelStatus1=vRtrLdpServFecInLabelStatus1, vRtrLdpHelloAdjRemoteHelloTimeout=vRtrLdpHelloAdjRemoteHelloTimeout, vRtrLdpTargEntry=vRtrLdpTargEntry, vRtrLdpGenUpTime=vRtrLdpGenUpTime, vRtrLdpAddrFecInLabelStatus3=vRtrLdpAddrFecInLabelStatus3, vRtrLdpAddrFecLspId=vRtrLdpAddrFecLspId, vRtrLdpSessStatsInitIn=vRtrLdpSessStatsInitIn, vRtrLdpSessionStatsEntry=vRtrLdpSessionStatsEntry, TmnxLdpFECFlags=TmnxLdpFECFlags, vRtrLdpGenTunnelDownDampTime=vRtrLdpGenTunnelDownDampTime, vLdpCepTdmFec129LocalPayloadSize=vLdpCepTdmFec129LocalPayloadSize, vRtrLdpStatsSessRejLabelRangeErrors=vRtrLdpStatsSessRejLabelRangeErrors, vLdpCepTdmFec129RemoteDiffTimestamp=vLdpCepTdmFec129RemoteDiffTimestamp, tmnxLdpServFecObsoletedV6v0Group=tmnxLdpServFecObsoletedV6v0Group, vRtrLdpGenControlMode=vRtrLdpGenControlMode, vRtrLdpStaticFecNextNHIndex=vRtrLdpStaticFecNextNHIndex, vRtrLdpTargImportPolicy3=vRtrLdpTargImportPolicy3, vRtrLdpSessStatsNotificationOut=vRtrLdpSessStatsNotificationOut, vRtrLdpSessPeerKATimeout=vRtrLdpSessPeerKATimeout, tmnxLdpGlobalV5v0Group=tmnxLdpGlobalV5v0Group, TmnxLdpAdjacencyType=TmnxLdpAdjacencyType, vRtrLdpIfLspId=vRtrLdpIfLspId, vRtrLdpAddrFecEntry=vRtrLdpAddrFecEntry, vRtrLdpIfIndex=vRtrLdpIfIndex, tmnxLdpObjs=tmnxLdpObjs, vRtrLdpTargExportPolicy2=vRtrLdpTargExportPolicy2, vRtrLdpPeerAddress=vRtrLdpPeerAddress, vRtrLdpStatsSessRejAdvErrors=vRtrLdpStatsSessRejAdvErrors, vRtrLdpServFecOutLabelSigStatus4=vRtrLdpServFecOutLabelSigStatus4, tmnxLdpCepTdmFecV6v0Group=tmnxLdpCepTdmFecV6v0Group, vRtrLdpGenHelloFactor=vRtrLdpGenHelloFactor, vRtrLdpGenTargHelloFactor=vRtrLdpGenTargHelloFactor, vLdpServFec129Flags=vLdpServFec129Flags, vLdpCepTdmFec129Entry=vLdpCepTdmFec129Entry, vRtrLdpAddrFecMapIpMask=vRtrLdpAddrFecMapIpMask, vRtrLdpGenGracefulRestart=vRtrLdpGenGracefulRestart, vRtrLdpHelloAdjLocalConfSeqNum=vRtrLdpHelloAdjLocalConfSeqNum, vRtrLdpAddrFecInLabelIfIndex2=vRtrLdpAddrFecInLabelIfIndex2, vRtrLdpStatsSvcFECRecv=vRtrLdpStatsSvcFECRecv, vRtrLdpAddrFecInLabelIfIndex4=vRtrLdpAddrFecInLabelIfIndex4, vRtrLdpSessPeerTcpPort=vRtrLdpSessPeerTcpPort, vRtrLdpAddrFecInLabel1=vRtrLdpAddrFecInLabel1, vRtrLdpServFecLocalMaxCellConcat=vRtrLdpServFecLocalMaxCellConcat, vRtrLdpServFecNumOutLabels=vRtrLdpServFecNumOutLabels, vRtrLdpCepTdmRemoteSsrcId=vRtrLdpCepTdmRemoteSsrcId, vRtrLdpStaticFecTable=vRtrLdpStaticFecTable, vRtrLdpServFecServType=vRtrLdpServFecServType, vRtrLdpAddrFecInLabelStatus4=vRtrLdpAddrFecInLabelStatus4, vRtrLdpSessStatsFECSent=vRtrLdpSessStatsFECSent, vRtrLdpAdjBackoffTable=vRtrLdpAdjBackoffTable, vRtrLdpGenHopLimit=vRtrLdpGenHopLimit, vRtrLdpGenGRNbrLiveTime=vRtrLdpGenGRNbrLiveTime, vRtrLdpStatsOperDownEvents=vRtrLdpStatsOperDownEvents, tmnxLdpNotifyObjsGroup=tmnxLdpNotifyObjsGroup, vRtrLdpAddrFecInLabelStatus5=vRtrLdpAddrFecInLabelStatus5, vRtrLdpIfBackoffTime=vRtrLdpIfBackoffTime, vRtrLdpServFecOutLabel2=vRtrLdpServFecOutLabel2, TmnxLdpFECPolicy=TmnxLdpFECPolicy, vRtrLdpCepTdmRemoteRtpHeader=vRtrLdpCepTdmRemoteRtpHeader, vRtrLdpStaticFecRowStatus=vRtrLdpStaticFecRowStatus, vRtrLdpSessLocalUdpPort=vRtrLdpSessLocalUdpPort, vRtrLdpGenImportPolicy1=vRtrLdpGenImportPolicy1, vRtrLdpServFecOutLabelStatus3=vRtrLdpServFecOutLabelStatus3, TmnxLdpLabelDistMethod=TmnxLdpLabelDistMethod, vRtrLdpPeerTTLLogId=vRtrLdpPeerTTLLogId, vRtrLdpStatsMalformedTlvValueErrors=vRtrLdpStatsMalformedTlvValueErrors, vRtrLdpServFecOutLabelStatus4=vRtrLdpServFecOutLabelStatus4, vRtrLdpGenOperDownReason=vRtrLdpGenOperDownReason, vRtrLdpGeneralTable=vRtrLdpGeneralTable, vRtrLdpGenRetentionMode=vRtrLdpGenRetentionMode, vRtrLdpIfMaxBackoffTime=vRtrLdpIfMaxBackoffTime, tmnxLdpObsoletedV5v0Group=tmnxLdpObsoletedV5v0Group, vRtrLdpGenTargetedSessions=vRtrLdpGenTargetedSessions, vRtrLdpAddrFecOutLabelNextHop3=vRtrLdpAddrFecOutLabelNextHop3, vRtrLdpSessStatsLinkAdj=vRtrLdpSessStatsLinkAdj, tmnxLdpNotifications=tmnxLdpNotifications, vLdpServFec129VpnId=vLdpServFec129VpnId, vRtrLdpGenProtocolVersion=vRtrLdpGenProtocolVersion, tmnxLdpV5v0Compliance=tmnxLdpV5v0Compliance, vRtrLdpStatsBadLdpIdentifierErrors=vRtrLdpStatsBadLdpIdentifierErrors, vRtrLdpSessPeerAddress=vRtrLdpSessPeerAddress, vRtrLdpServFecRemoteMaxCellConcat=vRtrLdpServFecRemoteMaxCellConcat, TmnxLabelSigStatus=TmnxLabelSigStatus, vRtrLdpServFecInLabel1=vRtrLdpServFecInLabel1, vRtrLdpServFecOutLabel4=vRtrLdpServFecOutLabel4, vRtrLdpInstanceNotifyReasonCode=vRtrLdpInstanceNotifyReasonCode, vRtrLdpIfKeepAliveTimeout=vRtrLdpIfKeepAliveTimeout, vRtrLdpPeerMinTTLValue=vRtrLdpPeerMinTTLValue, vRtrLdpAddrFecNumOutLabels=vRtrLdpAddrFecNumOutLabels, vRtrLdpAddrFecFecType=vRtrLdpAddrFecFecType, vRtrLdpSessStatsLabelAbortIn=vRtrLdpSessStatsLabelAbortIn, vRtrLdpAddrFecOutLabel1=vRtrLdpAddrFecOutLabel1, vRtrLdpHelloAdjTable=vRtrLdpHelloAdjTable, vRtrLdpPeerParamsEntry=vRtrLdpPeerParamsEntry, vRtrLdpGenExportPolicy3=vRtrLdpGenExportPolicy3, TmnxLdpBackoffTime=TmnxLdpBackoffTime, vLdpServFec129SdpId=vLdpServFec129SdpId, vRtrLdpTargTable=vRtrLdpTargTable, vRtrLdpTargExportPolicy1=vRtrLdpTargExportPolicy1, vRtrLdpAdjInitBackoff=vRtrLdpAdjInitBackoff, vRtrLdpSessRestartHelperState=vRtrLdpSessRestartHelperState, vRtrLdpCepTdmLocalCasTrunk=vRtrLdpCepTdmLocalCasTrunk, vRtrLdpGenExportPolicy2=vRtrLdpGenExportPolicy2, vRtrLdpServFecOutLabel5=vRtrLdpServFecOutLabel5, vRtrLdpCepTdmRemoteTimestampFreq=vRtrLdpCepTdmRemoteTimestampFreq, vRtrLdpCepTdmFecTable=vRtrLdpCepTdmFecTable, vRtrLdpSessStatsInitOut=vRtrLdpSessStatsInitOut, vRtrLdpPeerAuthKeyChain=vRtrLdpPeerAuthKeyChain, vRtrLdpSessStatsHelloIn=vRtrLdpSessStatsHelloIn, vRtrLdpAdjBackoffEntry=vRtrLdpAdjBackoffEntry, vRtrLdpStatsBadPduLengthErrors=vRtrLdpStatsBadPduLengthErrors, vRtrLdpSessStatsNotificationIn=vRtrLdpSessStatsNotificationIn, tmnxLdpAdjBackoffGroup=tmnxLdpAdjBackoffGroup, vRtrLdpGenKeepAliveTimeout=vRtrLdpGenKeepAliveTimeout, vRtrLdpStaticFecNHType=vRtrLdpStaticFecNHType, tmnxLdpCompliances=tmnxLdpCompliances, vRtrLdpIfOperState=vRtrLdpIfOperState, vRtrLdpStaticFecOperIngLabel=vRtrLdpStaticFecOperIngLabel, tmnxLdpAddrFecGroup=tmnxLdpAddrFecGroup, vRtrLdpPolicyIndex=vRtrLdpPolicyIndex)
