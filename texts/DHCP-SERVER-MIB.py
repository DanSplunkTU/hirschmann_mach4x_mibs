#
# PySNMP MIB module DHCP-SERVER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/DHCP-SERVER-MIB
# Produced by pysmi-1.1.8 at Thu Jan 13 23:32:54 2022
# On host fv-az83-250 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
iso, Counter64, Gauge32, IpAddress, Integer32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, NotificationType, ModuleIdentity, enterprises, Unsigned32, Bits, MibIdentifier, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter64", "Gauge32", "IpAddress", "Integer32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "NotificationType", "ModuleIdentity", "enterprises", "Unsigned32", "Bits", "MibIdentifier", "Counter32")
TruthValue, TextualConvention, DateAndTime, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DateAndTime", "RowStatus", "DisplayString")
lucent = MibIdentifier((1, 3, 6, 1, 4, 1, 1751))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 1))
mibs = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 2))
ipspg = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 1, 48))
ipspgServices = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1))
ipspgDHCP = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1))
ipspgDNS = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 2))
ipspgTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2))
dhcpServMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1))
if mibBuilder.loadTexts: dhcpServMib.setLastUpdated('0606220830Z')
if mibBuilder.loadTexts: dhcpServMib.setOrganization('Lucent Technologies')
if mibBuilder.loadTexts: dhcpServMib.setContactInfo('        James Offutt\n          Postal:  Lucent Technologies\n                   400 Lapp Road\n                   Malvern, PA 19355\n                   USA\n          Tel:     +1 610-722-7900\n          Fax:     +1 610-725-8559')
if mibBuilder.loadTexts: dhcpServMib.setDescription('The Vendor Specific MIB module for entities implementing the server\n          side of the Bootstrap Protocol (BOOTP) and the Dynamic Host\n          Configuration protocol (DHCP) for Internet Protocol version 4\n          (IPv4).')
dhcpServMibTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0))
if mibBuilder.loadTexts: dhcpServMibTraps.setStatus('current')
if mibBuilder.loadTexts: dhcpServMibTraps.setDescription('DHCP Server MIB traps.')
dhcpServMibObjects = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1))
if mibBuilder.loadTexts: dhcpServMibObjects.setStatus('current')
if mibBuilder.loadTexts: dhcpServMibObjects.setDescription('DHCP Server MIB objects are all defined in this branch.')
dhcpServSystem = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 1))
if mibBuilder.loadTexts: dhcpServSystem.setStatus('current')
if mibBuilder.loadTexts: dhcpServSystem.setDescription('Group of objects that are related to the overall system.')
dhcpServSubnetCounters = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 2))
if mibBuilder.loadTexts: dhcpServSubnetCounters.setStatus('current')
if mibBuilder.loadTexts: dhcpServSubnetCounters.setDescription('Group of objects that count various subnet data values')
dhcpServBootpCounters = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 3))
if mibBuilder.loadTexts: dhcpServBootpCounters.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpCounters.setDescription('Group of objects that count various BOOTP events.')
dhcpServDhcpCounters = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4))
if mibBuilder.loadTexts: dhcpServDhcpCounters.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCounters.setDescription('Group of objects that count various DHCP Statistics.')
dhcpServBootpStatistics = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 5))
if mibBuilder.loadTexts: dhcpServBootpStatistics.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpStatistics.setDescription('Group of objects that measure various BOOTP statistics.')
dhcpServDhcpStatistics = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 6))
if mibBuilder.loadTexts: dhcpServDhcpStatistics.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpStatistics.setDescription('Group of objects that measure various DHCP statistics.')
dhcpServConfiguration = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7))
if mibBuilder.loadTexts: dhcpServConfiguration.setStatus('current')
if mibBuilder.loadTexts: dhcpServConfiguration.setDescription('Objects that contain pre-configured and Dynamic Config. Info.')
dhcpServFailover = ObjectIdentity((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 8))
if mibBuilder.loadTexts: dhcpServFailover.setStatus('current')
if mibBuilder.loadTexts: dhcpServFailover.setDescription('Objects that contain partner server info.')
class DhcpServTimeInterval(TextualConvention, Gauge32):
    description = 'The number of milli-seconds that has elapsed since some epoch.\n          Systems that cannot measure events to the milli-second\n          resolution SHOULD round this value to the next available\n          resolution that the system supports.'
    status = 'current'

dhcpServSystemDescr = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServSystemDescr.setStatus('current')
if mibBuilder.loadTexts: dhcpServSystemDescr.setDescription('A textual description of the server.  This value should\n          include the full name and version identification of the server.\n          This string MUST contain only printable NVT ASCII characters.')
dhcpServSystemStatus = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("starting", 0), ("running", 1), ("stopping", 2), ("stopped", 3), ("reload", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServSystemStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpServSystemStatus.setDescription(' Dhcp System Server Status ')
dhcpServSystemUpTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServSystemUpTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServSystemUpTime.setDescription('If the server has a persistent state (e.g., a process),\n               this value will be the seconds elapsed since it started.\n               For software without persistant state, this value will\n               be zero.')
dhcpServSystemResetTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServSystemResetTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServSystemResetTime.setDescription("If the server has a persistent state (e.g., a process)\n               and supports a `reset' operation (e.g., can be told to\n               re-read configuration files), this value will be the\n               seconds elapsed since the last time the name server was\n               `reset.'  For software that does not have persistence or\n               does not support a `reset' operation, this value will be\n               zero.")
dhcpServCountUsedSubnets = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServCountUsedSubnets.setStatus('current')
if mibBuilder.loadTexts: dhcpServCountUsedSubnets.setDescription('The number subnets managed by the server (i.e. configured), from\n          which the server has issued at least one lease.')
dhcpServCountUnusedSubnets = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServCountUnusedSubnets.setStatus('current')
if mibBuilder.loadTexts: dhcpServCountUnusedSubnets.setDescription('The number subnets managed by the server (i.e. configured), from\n          which the server has issued no leases.')
dhcpServCountFullSubnets = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServCountFullSubnets.setStatus('current')
if mibBuilder.loadTexts: dhcpServCountFullSubnets.setDescription('The number subnets managed by the server (i.e. configured), in\n          which the address pools have been exhausted.')
dhcpServBootpCountRequests = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpCountRequests.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpCountRequests.setDescription('The number of packets received that contain a Message Type of\n          1 (BOOTREQUEST) in the first octet and do not contain option\n          number 53 (DHCP Message Type) in the options.')
dhcpServBootpCountInvalids = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpCountInvalids.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpCountInvalids.setDescription('The number of packets received that do not contain a Message\n          Type of 1 (BOOTREQUEST) in the first octet or are not valid\n          BOOTP packets (e.g.: too short, invalid field in packet\n          header).')
dhcpServBootpCountReplies = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpCountReplies.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpCountReplies.setDescription('The number of packets sent that contain a Message Type of 1\n          (BOOTREQUEST) in the first octet and do not contain option\n          number 53 (DHCP Message Type) in the options.')
dhcpServBootpCountDroppedUnknownClients = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpCountDroppedUnknownClients.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpCountDroppedUnknownClients.setDescription('The number of BOOTP packets dropped due to the server not\n          recognizing or not providing service to the hardware address\n          received in the incoming packet.')
dhcpServBootpCountDroppedNotServingSubnet = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpCountDroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpCountDroppedNotServingSubnet.setDescription('The number of BOOTP packets dropped due to the server not\n          being configured or not otherwise able to serve addresses on\n          the subnet from which this message was received.')
dhcpServDhcpCountDiscovers = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountDiscovers.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountDiscovers.setDescription('The number of DHCPDISCOVER (option 53 with value 1) packets\n          received.')
dhcpServDhcpCountRequests = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountRequests.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountRequests.setDescription('The number of DHCPREQUEST (option 53 with value 3) packets\n          received.')
dhcpServDhcpCountReleases = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountReleases.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountReleases.setDescription('The number of DHCPRELEASE (option 53 with value 7) packets\n          received.')
dhcpServDhcpCountDeclines = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountDeclines.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountDeclines.setDescription('The number of DHCPDECLINE (option 53 with value 4) packets\n          received.')
dhcpServDhcpCountInforms = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountInforms.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountInforms.setDescription('The number of DHCPINFORM (option 53 with value 8) packets\n          received.')
dhcpServDhcpCountInvalids = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountInvalids.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountInvalids.setDescription('The number of DHCP packets received whose DHCP message type\n          (i.e.: option number 53) is not understood or handled by the\n          server.')
dhcpServDhcpCountOffers = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountOffers.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountOffers.setDescription('The number of DHCPOFFER (option 53 with value 2) packets\n          sent.')
dhcpServDhcpCountAcks = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountAcks.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountAcks.setDescription('The number of DHCPACK (option 53 with value 5) packets sent.')
dhcpServDhcpCountNacks = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountNacks.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountNacks.setDescription('The number of DHCPNACK (option 53 with value 6) packets sent.')
dhcpServDhcpCountDroppedUnknownClient = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountDroppedUnknownClient.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountDroppedUnknownClient.setDescription('The number of DHCP packets dropped due to the server not\n          recognizing or not providing service to the client-id and/or\n          hardware address received in the incoming packet.')
dhcpServDhcpCountDroppedNotServingSubnet = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 4, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpCountDroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpCountDroppedNotServingSubnet.setDescription('The number of DHCP packets dropped due to the server not being\n          configured or not otherwise able to serve addresses on the\n          subnet from which this message was received.')
dhcpServBootpStatMinArrivalInterval = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 5, 1), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpStatMinArrivalInterval.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpStatMinArrivalInterval.setDescription('The minimum amount of time between receiving two BOOTP\n          messages.  A message is received at the server when the server\n          is able to begin processing the message.  This typically occurs\n          immediately after the message is read into server memory.  If\n          no messages have been received, then this object contains a\n          zero value.')
dhcpServBootpStatMaxArrivalInterval = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 5, 2), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpStatMaxArrivalInterval.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpStatMaxArrivalInterval.setDescription('The maximum amount of time between receiving two BOOTP\n          messages.  A message is received at the server when the server\n          is able to begin processing the message.  This typically occurs\n          immediately after the message is read into server memory.  If\n          no messages have been received, then this object contains a\n          zero value.')
dhcpServBootpStatLastArrivalTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 5, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpStatLastArrivalTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpStatLastArrivalTime.setDescription('The number of seconds since the last valid BOOTP\n          message was received by the server.  Invalid messages do not\n          cause this value to change.  If valid no messages have been\n          received, then this object contains a zero value.')
dhcpServBootpStatMinResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 5, 4), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpStatMinResponseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpStatMinResponseTime.setDescription('The smallest time interval measured as the difference between\n          the arrival of a BOOTP message at the server and the successful\n          transmission of the response to that message.  A message is\n          received at the server when the server is able to begin\n          processing the message.  A message is transmitted after the\n          server has no further use for the message.  Note that the\n          operating system may still have the message queued internally.\n          The operating system queue time is not to be considered as part\n          of the response time.  Invalid messages do not cause this value\n          to change.  If no valid messages have been received, then this\n          object contains a zero value.')
dhcpServBootpStatMaxResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 5, 5), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpStatMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpStatMaxResponseTime.setDescription('The largest time interval measured as the difference between\n          the arrival of a BOOTP message at the server and the successful\n          transmission of the response to that message.  A message is\n          received at the server when the server is able to begin\n          processing the message.  A message is transmitted after the\n          server has no further use for the message.  Note that the\n          operating system may still have the message queued internally.\n          The operating system queue time is not to be considered as part\n          of the response time.  Invalid messages do not cause this value\n          to change.  If no valid messages have been received, then this\n          object contains a zero value.')
dhcpServBootpStatSumResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 5, 6), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServBootpStatSumResponseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServBootpStatSumResponseTime.setDescription('The sum of the response time intervals in milli-seconds where\n          a response time interval is measured as the difference between\n          the arrival of a BOOTP message at the server and the successful\n          transmission of the response to that message.  A message is\n          received at the server when the server is able to begin\n          processing the message.  A message is transmitted after the\n          server has no further use for the message.  Note that the\n          operating system may still have the message queued internally.\n          The operating system queue time is not to be considered as part\n          of the response time.  Invalid messages do not cause this value\n          to change.  If no valid messages have been received, then this\n          object contains a zero value.')
dhcpServDhcpStatMinArrivalInterval = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 6, 1), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpStatMinArrivalInterval.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpStatMinArrivalInterval.setDescription('The minimum amount of time between receiving two DHCP\n          messages.  A message is received at the server when the server\n          is able to begin processing the message.  This typically occurs\n          immediately after the message is read into server memory.  If\n          no messages have been received, then this object contains a\n          zero value.')
dhcpServDhcpStatMaxArrivalInterval = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 6, 2), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpStatMaxArrivalInterval.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpStatMaxArrivalInterval.setDescription('The maximum amount of time between receiving two DHCP\n          messages.  A message is received at the server when the server\n          is able to begin processing the message.  This typically occurs\n          immediately after the message is read into server memory.  If\n          no messages have been received, then this object contains a\n          zero value.')
dhcpServDhcpStatLastArrivalTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 6, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpStatLastArrivalTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpStatLastArrivalTime.setDescription('The number of seconds since the last valid DHCP message\n          was received by the server.  Invalid messages do not cause this\n          value to change.  If no valid messages have been received, then\n          this object contains a zero value.')
dhcpServDhcpStatMinResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 6, 4), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpStatMinResponseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpStatMinResponseTime.setDescription('The smallest time interval measured as the difference between\n          the arrival of a DHCP message at the server and the successful\n          transmission of the response to that message.  A message is\n          received at the server when the server is able to begin\n          processing the message.  A message is transmitted after the\n          server has no further use for the message.  Note that the\n          operating system may still have the message queued internally.\n          The operating system queue time is not to be considered as part\n          of the response time.  Invalid messages do not cause this value\n          to change.  If no valid messages have been received, then this\n          object contains a zero value.')
dhcpServDhcpStatMaxResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 6, 5), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpStatMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpStatMaxResponseTime.setDescription('The largest time interval measured as the difference between\n          the arrival of a DHCP message at the server and the successful\n          transmission of the response to that message.  A message is\n          received at the server when the server is able to begin\n          processing the message.  A message is transmitted after the\n          server has no further use for the message.  Note that the\n          operating system may still have the message queued internally.\n          The operating system queue time is not to be considered as part\n          of the response time.  Invalid messages do not cause this value\n          to change.  If no valid messages have been received, then this\n          object contains a zero value.')
dhcpServDhcpStatSumResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 6, 6), DhcpServTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServDhcpStatSumResponseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServDhcpStatSumResponseTime.setDescription('The sum of the response time intervals in milli-seconds where\n          a response time interval is measured as the difference between\n          the arrival of a DHCP message at the server and the successful\n          transmission of the response to that message.  A message is\n          received at the server when the server is able to begin\n          processing the message.  A message is transmitted after the\n          server has no further use for the message.  Note that the\n          operating system may still have the message queued internally.\n          The operating system queue time is not to be considered as part\n          of the response time.  Invalid messages do not cause this value\n          to change.  If no valid messages have been received, then this\n          object contains a zero value.')
dhcpServRangeTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2), )
if mibBuilder.loadTexts: dhcpServRangeTable.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeTable.setDescription('A list of ranges that are configured on this server.')
dhcpServRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1), ).setIndexNames((0, "DHCP-SERVER-MIB", "dhcpServRangeSubnetAddr"), (0, "DHCP-SERVER-MIB", "dhcpServRangeStart"))
if mibBuilder.loadTexts: dhcpServRangeEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeEntry.setDescription('A logical row in the serverRangeTable.')
dhcpServRangeSubnetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeSubnetAddr.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeSubnetAddr.setDescription('The IP address defining a subnet')
dhcpServRangeSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeSubnetMask.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeSubnetMask.setDescription('The subnet mask (DHCP option 1) provided to any client offered\n          an address from this range.')
dhcpServRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeStart.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeStart.setDescription('Start of Subnet Address, Index for Conceptual Tabl, Type IP address ')
dhcpServRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeEnd.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeEnd.setDescription('The IP address of the last address in the range. The value of\n          range end must be greater than or equal to the value of range\n          start.')
dhcpServRangeInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeInUse.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeInUse.setDescription('The number of addresses in this range that are currently in\n          use.  This number includes those addresses whose lease has not\n          expired and addresses which have been reserved (either by the\n          server or through configuration).')
dhcpServRangeOutstandingOffers = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeOutstandingOffers.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeOutstandingOffers.setDescription('The number of outstanding DHCPOFFER messages for this range is\n         reported with this value.  An offer is outstanding if the\n         server has sent a DHCPOFFER message to a client, but has not\n         yet received a DHCPREQUEST message from the client nor has the\n         server-specific timeout (limiting the time in which a client\n         can respond to the offer message) for the offer message\n         expired.')
dhcpServRangeUnavailable = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeUnavailable.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeUnavailable.setDescription(' Dhcp Server IP Addresses unavailable in a Subnet ')
dhcpServRangeType = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("manBootp", 1), ("autoBootp", 2), ("manDhcp", 3), ("autoDhcp", 4), ("dynamicDhcp", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeType.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeType.setDescription('Dhcp Server Client Lease Type ')
dhcpServRangeUnused = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 7, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServRangeUnused.setStatus('current')
if mibBuilder.loadTexts: dhcpServRangeUnused.setDescription('The number of addresses in this range that are currently\n          unused.  This number includes those addresses whose lease has not\n          expired and addresses which have been reserved (either by the\n          server or through configuration).')
dhcpServFailoverTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 8, 1), )
if mibBuilder.loadTexts: dhcpServFailoverTable.setStatus('current')
if mibBuilder.loadTexts: dhcpServFailoverTable.setDescription('A list of partner server.')
dhcpServFailoverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 8, 1, 1), ).setIndexNames((0, "DHCP-SERVER-MIB", "dhcpServFailoverPartnerAddr"))
if mibBuilder.loadTexts: dhcpServFailoverEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpServFailoverEntry.setDescription('A logical row in the serverFailoverTable.')
dhcpServFailoverPartnerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 8, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServFailoverPartnerAddr.setStatus('current')
if mibBuilder.loadTexts: dhcpServFailoverPartnerAddr.setDescription('The IP address defining a partner server')
dhcpServFailoverPartnerType = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("failover", 2), ("unconfigured", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServFailoverPartnerType.setStatus('current')
if mibBuilder.loadTexts: dhcpServFailoverPartnerType.setDescription('Dhcp Server Failover server type ')
dhcpServFailoverPartnerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("syncing", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServFailoverPartnerStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpServFailoverPartnerStatus.setDescription('Dhcp Server Partner status ')
dhcpServFailoverPartnerPolltime = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 1, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServFailoverPartnerPolltime.setStatus('current')
if mibBuilder.loadTexts: dhcpServFailoverPartnerPolltime.setDescription('The last time there was a successfull communication with the\npartner server. This value is local time in seconds since some epoch.')
ipspgDhcpTrapTable = MibTable((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1), )
if mibBuilder.loadTexts: ipspgDhcpTrapTable.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrapTable.setDescription("The agent's table of IPSPG alarm information.")
ipspgDhcpTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1), ).setIndexNames((0, "DHCP-SERVER-MIB", "ipspgDhcpTrIndex"))
if mibBuilder.loadTexts: ipspgDhcpTrapEntry.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrapEntry.setDescription('Information about the last alarm trap generated by the agent.')
ipspgDhcpTrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrIndex.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrIndex.setDescription('Index into the IPSPG Alarm traps')
ipspgDhcpTrSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrSequence.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrSequence.setDescription('Counter of the number of IPSPG alarm traps since the agent was last initialized')
ipspgDhcpTrId = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("monitor", 1), ("analyzer", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrId.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrId.setDescription('The application which generated this IPSPG alarm.')
ipspgDhcpTrText = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrText.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrText.setDescription('An ASCII string describing the IPSPG alarm condition/cause.')
ipspgDhcpTrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inform", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrPriority.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrPriority.setDescription('The priority level as set on the agent for this Calss and Type of trap.')
ipspgDhcpTrClass = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrClass.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrClass.setDescription('The Class number of the described IPSPG alarm.')
ipspgDhcpTrType = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrType.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrType.setDescription('The type number of the described IPSPG alarm.')
ipspgDhcpTrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrTime.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrTime.setDescription('The time that the condition or event occurred which caused generation of this alarm.  This value is given in seconds since 00:00:00 Greenwich mean time (GMT) January 1, 1970.')
ipspgDhcpTrSuspect = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrSuspect.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrSuspect.setDescription('An ASCII string describing the host which caused the IPSPG alarm.')
ipspgDhcpTrDiagId = MibTableColumn((1, 3, 6, 1, 4, 1, 1751, 1, 48, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipspgDhcpTrDiagId.setStatus('current')
if mibBuilder.loadTexts: ipspgDhcpTrDiagId.setDescription('An integer describing the diagnosis which triggered this IPSPG alarm.')
dhcpServerStarted = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 1)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerStarted.setStatus('current')
if mibBuilder.loadTexts: dhcpServerStarted.setDescription('The monitor has determined that the DHCP server has been started.')
dhcpServerStopped = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 2)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerStopped.setStatus('current')
if mibBuilder.loadTexts: dhcpServerStopped.setDescription('The monitor has determined that the DHCP server has been stopped.')
dhcpServerReload = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 3)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerReload.setStatus('current')
if mibBuilder.loadTexts: dhcpServerReload.setDescription('The monitor has determined that the DHCP server has been reloaded.')
dhcpServerSubnetDepleted = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 4)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerSubnetDepleted.setStatus('current')
if mibBuilder.loadTexts: dhcpServerSubnetDepleted.setDescription('The monitor has determined that the DHCP server has run out of addresses in a subnet.')
dhcpServerBadPacket = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 5)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerBadPacket.setStatus('current')
if mibBuilder.loadTexts: dhcpServerBadPacket.setDescription('The monitor has determined that the DHCP server has received a bad DHCP or Bootp packet.')
dhcpServerFailoverActive = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 6)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerFailoverActive.setStatus('current')
if mibBuilder.loadTexts: dhcpServerFailoverActive.setDescription('This trap is issued by the secondary server. It indicates\n    a primary partner server is down and its scopes are now being served by\n    this failover server.')
dhcpServerFailoverReturnedControl = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 7)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerFailoverReturnedControl.setStatus('current')
if mibBuilder.loadTexts: dhcpServerFailoverReturnedControl.setDescription('This trap is issued by the secondary server. It indicates\n    that the failover server has returned control to its primary partner.')
dhcpServerSubnetThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 8)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerSubnetThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: dhcpServerSubnetThresholdExceeded.setDescription('This trap is issued when subnet threshold is exceeded.')
dhcpServerSubnetThresholdDescent = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 9)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerSubnetThresholdDescent.setStatus('current')
if mibBuilder.loadTexts: dhcpServerSubnetThresholdDescent.setDescription('This trap is issued when subnet unavailable lease percentage falls below the descent threshold value.')
dhcpServerDropUnknownClient = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 10)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerDropUnknownClient.setStatus('current')
if mibBuilder.loadTexts: dhcpServerDropUnknownClient.setDescription('This trap is issued when the server drops a client message because the client MAC address is either in a MAC exclusion pool or is not in an inclusion pool.')
dhcpServerPingResponseReceived = NotificationType((1, 3, 6, 1, 4, 1, 1751, 1, 48, 1, 1, 1, 0, 11)).setObjects(("DHCP-SERVER-MIB", "ipspgDhcpTrSequence"), ("DHCP-SERVER-MIB", "ipspgDhcpTrId"), ("DHCP-SERVER-MIB", "ipspgDhcpTrText"), ("DHCP-SERVER-MIB", "ipspgDhcpTrPriority"), ("DHCP-SERVER-MIB", "ipspgDhcpTrClass"), ("DHCP-SERVER-MIB", "ipspgDhcpTrType"), ("DHCP-SERVER-MIB", "ipspgDhcpTrTime"), ("DHCP-SERVER-MIB", "ipspgDhcpTrSuspect"), ("DHCP-SERVER-MIB", "ipspgDhcpTrDiagId"))
if mibBuilder.loadTexts: dhcpServerPingResponseReceived.setStatus('current')
if mibBuilder.loadTexts: dhcpServerPingResponseReceived.setDescription('This trap is issued when the server receives a ping response.')
mibBuilder.exportSymbols("DHCP-SERVER-MIB", ipspgDhcpTrTime=ipspgDhcpTrTime, dhcpServDhcpStatMaxArrivalInterval=dhcpServDhcpStatMaxArrivalInterval, dhcpServRangeOutstandingOffers=dhcpServRangeOutstandingOffers, dhcpServDhcpCountDroppedNotServingSubnet=dhcpServDhcpCountDroppedNotServingSubnet, dhcpServDhcpCountNacks=dhcpServDhcpCountNacks, ipspgDhcpTrText=ipspgDhcpTrText, dhcpServDhcpCountDeclines=dhcpServDhcpCountDeclines, dhcpServRangeType=dhcpServRangeType, ipspgDhcpTrIndex=ipspgDhcpTrIndex, dhcpServMibTraps=dhcpServMibTraps, dhcpServSystemDescr=dhcpServSystemDescr, dhcpServDhcpCountDroppedUnknownClient=dhcpServDhcpCountDroppedUnknownClient, PYSNMP_MODULE_ID=dhcpServMib, dhcpServRangeSubnetMask=dhcpServRangeSubnetMask, dhcpServerPingResponseReceived=dhcpServerPingResponseReceived, ipspgDHCP=ipspgDHCP, dhcpServMib=dhcpServMib, ipspgDhcpTrSuspect=ipspgDhcpTrSuspect, ipspgDNS=ipspgDNS, dhcpServFailover=dhcpServFailover, dhcpServDhcpStatMinArrivalInterval=dhcpServDhcpStatMinArrivalInterval, dhcpServRangeEnd=dhcpServRangeEnd, dhcpServerFailoverActive=dhcpServerFailoverActive, dhcpServBootpStatMinResponseTime=dhcpServBootpStatMinResponseTime, ipspgDhcpTrSequence=ipspgDhcpTrSequence, dhcpServDhcpCountAcks=dhcpServDhcpCountAcks, dhcpServMibObjects=dhcpServMibObjects, dhcpServDhcpStatistics=dhcpServDhcpStatistics, dhcpServDhcpCountReleases=dhcpServDhcpCountReleases, dhcpServerSubnetDepleted=dhcpServerSubnetDepleted, dhcpServBootpCountInvalids=dhcpServBootpCountInvalids, dhcpServSystemResetTime=dhcpServSystemResetTime, dhcpServBootpCountRequests=dhcpServBootpCountRequests, dhcpServDhcpStatSumResponseTime=dhcpServDhcpStatSumResponseTime, DhcpServTimeInterval=DhcpServTimeInterval, dhcpServRangeInUse=dhcpServRangeInUse, dhcpServBootpStatistics=dhcpServBootpStatistics, dhcpServerFailoverReturnedControl=dhcpServerFailoverReturnedControl, ipspgDhcpTrPriority=ipspgDhcpTrPriority, dhcpServDhcpCountInvalids=dhcpServDhcpCountInvalids, dhcpServDhcpCountOffers=dhcpServDhcpCountOffers, dhcpServSubnetCounters=dhcpServSubnetCounters, dhcpServBootpStatMaxArrivalInterval=dhcpServBootpStatMaxArrivalInterval, dhcpServerSubnetThresholdExceeded=dhcpServerSubnetThresholdExceeded, dhcpServConfiguration=dhcpServConfiguration, dhcpServDhcpCountInforms=dhcpServDhcpCountInforms, ipspgDhcpTrClass=ipspgDhcpTrClass, dhcpServerStarted=dhcpServerStarted, dhcpServDhcpStatMaxResponseTime=dhcpServDhcpStatMaxResponseTime, ipspgDhcpTrapEntry=ipspgDhcpTrapEntry, lucent=lucent, dhcpServCountUsedSubnets=dhcpServCountUsedSubnets, dhcpServFailoverTable=dhcpServFailoverTable, dhcpServRangeUnavailable=dhcpServRangeUnavailable, dhcpServerSubnetThresholdDescent=dhcpServerSubnetThresholdDescent, products=products, dhcpServBootpCounters=dhcpServBootpCounters, dhcpServCountFullSubnets=dhcpServCountFullSubnets, dhcpServBootpCountDroppedUnknownClients=dhcpServBootpCountDroppedUnknownClients, dhcpServBootpStatSumResponseTime=dhcpServBootpStatSumResponseTime, dhcpServFailoverPartnerStatus=dhcpServFailoverPartnerStatus, dhcpServDhcpStatMinResponseTime=dhcpServDhcpStatMinResponseTime, dhcpServFailoverPartnerAddr=dhcpServFailoverPartnerAddr, dhcpServRangeStart=dhcpServRangeStart, dhcpServDhcpStatLastArrivalTime=dhcpServDhcpStatLastArrivalTime, dhcpServRangeSubnetAddr=dhcpServRangeSubnetAddr, dhcpServBootpCountReplies=dhcpServBootpCountReplies, dhcpServBootpStatLastArrivalTime=dhcpServBootpStatLastArrivalTime, ipspgDhcpTrId=ipspgDhcpTrId, dhcpServerBadPacket=dhcpServerBadPacket, dhcpServSystem=dhcpServSystem, dhcpServFailoverPartnerPolltime=dhcpServFailoverPartnerPolltime, dhcpServSystemStatus=dhcpServSystemStatus, dhcpServDhcpCountRequests=dhcpServDhcpCountRequests, ipspgServices=ipspgServices, dhcpServDhcpCountDiscovers=dhcpServDhcpCountDiscovers, dhcpServBootpStatMaxResponseTime=dhcpServBootpStatMaxResponseTime, dhcpServerStopped=dhcpServerStopped, ipspgTrap=ipspgTrap, ipspgDhcpTrType=ipspgDhcpTrType, dhcpServFailoverPartnerType=dhcpServFailoverPartnerType, dhcpServDhcpCounters=dhcpServDhcpCounters, dhcpServRangeEntry=dhcpServRangeEntry, ipspgDhcpTrapTable=ipspgDhcpTrapTable, dhcpServFailoverEntry=dhcpServFailoverEntry, dhcpServRangeUnused=dhcpServRangeUnused, dhcpServerDropUnknownClient=dhcpServerDropUnknownClient, dhcpServerReload=dhcpServerReload, dhcpServSystemUpTime=dhcpServSystemUpTime, ipspgDhcpTrDiagId=ipspgDhcpTrDiagId, dhcpServCountUnusedSubnets=dhcpServCountUnusedSubnets, dhcpServRangeTable=dhcpServRangeTable, dhcpServBootpCountDroppedNotServingSubnet=dhcpServBootpCountDroppedNotServingSubnet, ipspg=ipspg, dhcpServBootpStatMinArrivalInterval=dhcpServBootpStatMinArrivalInterval, mibs=mibs)
