#
# PySNMP MIB module DIFF-SERV-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/DIFF-SERV-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 04:09:13 2022
# On host fv-az77-149 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
rlExperience, = mibBuilder.importSymbols("CISCOSB-MIB", "rlExperience")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
TimeTicks, NotificationType, MibIdentifier, Gauge32, iso, ObjectIdentity, Counter64, Bits, mib_2, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ModuleIdentity, Counter32, zeroDotZero, Integer32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "NotificationType", "MibIdentifier", "Gauge32", "iso", "ObjectIdentity", "Counter64", "Bits", "mib-2", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ModuleIdentity", "Counter32", "zeroDotZero", "Integer32", "IpAddress")
TestAndIncr, DisplayString, RowStatus, TextualConvention, RowPointer = mibBuilder.importSymbols("SNMPv2-TC", "TestAndIncr", "DisplayString", "RowStatus", "TextualConvention", "RowPointer")
diffServMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1))
diffServMib.setRevisions(('1999-07-19 01:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: diffServMib.setRevisionsDescriptions(('Initial version, published as  RFC xxxx.',))
if mibBuilder.loadTexts: diffServMib.setLastUpdated('9907190100Z')
if mibBuilder.loadTexts: diffServMib.setOrganization('Cisco Systems')
if mibBuilder.loadTexts: diffServMib.setContactInfo('    Fred Baker\n        Postal: 519 Lado Drive\n                Santa Barbara,  California 93111\n           Tel: +1 (408)526-4257\n           FAX: +1 (805)681-0115\n        E-mail: fred@cisco.com\n             Kwok Ho Chan\n        Postal: 600 Technology  Park Drive\n                Billerica, Massachusetts 01821, USA\n           Tel: +1 (978)288-8175\n        E-mail: khchan@nortelnetworks.com\n             Andrew Smith\n        Postal: 3585 Monroe St.\n                Santa Clara, California 95051\n           Tel: +1 (408) 579 2821\n           FAX: +1 (408) 579 3000\n        E-mail: andrew@extremenetworks.com')
if mibBuilder.loadTexts: diffServMib.setDescription('This MIB defines the objects necessary to manage a\n         device that uses the Differentiated Services\n         Architecture described in RFC 2475.')
diffServObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 1))
diffServTables = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2))
diffServMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 3))
class Dscp(TextualConvention, Integer32):
    description = 'The code point used for discriminating a traffic\n         stream.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 63)

diffServAggregateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 1), )
if mibBuilder.loadTexts: diffServAggregateTable.setStatus('current')
if mibBuilder.loadTexts: diffServAggregateTable.setDescription("The 'Aggregate' Table  enumerates Behavior Aggregate\n         classifiers (DSCPs) that a system may identify traffic\n         using.")
diffServAggregateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 1, 1), ).setIndexNames((0, "DIFF-SERV-MIB", "diffServAggregateDSCP"))
if mibBuilder.loadTexts: diffServAggregateEntry.setStatus('current')
if mibBuilder.loadTexts: diffServAggregateEntry.setDescription("An 'aggregate' entry describes a single BA\n         classifier.")
diffServAggregateDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 1, 1, 1), Dscp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServAggregateDSCP.setStatus('current')
if mibBuilder.loadTexts: diffServAggregateDSCP.setDescription('This is the Differentiated Services Code Point (DSCP)\n         for the classifier. This object is only meant to be\n         pointed to by a RowPointer from other tables, such as\n         the diffServClassifierMatchObject, and is not actually\n         configured or changed.')
class MFClassifierL4Port(TextualConvention, Integer32):
    description = 'A value indicating a Layer-4 protocol  port number.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

diffServMFClassifierUnique = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 1, 1), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServMFClassifierUnique.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierUnique.setDescription('The diffServMFClassifierUnique object  yields a\n         unique new value for diffServMFClassifierIndex when read and\n         subsequently set. This value must be tested for\n         uniqueness.')
diffServMFClassifierTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2), )
if mibBuilder.loadTexts: diffServMFClassifierTable.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierTable.setDescription('A table of MF  (IP 6-tuple multi-field) classifier\n         entries that a system may use to identify traffic.')
diffServMFClassifierEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1), ).setIndexNames((0, "DIFF-SERV-MIB", "diffServMFClassifierIndex"))
if mibBuilder.loadTexts: diffServMFClassifierEntry.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierEntry.setDescription('A multi-field  classifier entry describes a single MF\n         classifier.')
diffServMFClassifierIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServMFClassifierIndex.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierIndex.setDescription('This is a unique index for the classifier. This object\n         is meant to be pointed to by a RowPointer from other\n         tables, such as the diffServClassifierMatchObject.')
diffServMFClassifierAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierAddrType.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierAddrType.setDescription('The type of IP address used by this classifier entry.')
diffServMFClassifierDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 3), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierDstAddr.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierDstAddr.setDescription("The IP address to match against the packet's\n         destination IP address.")
diffServMFClassifierDstAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierDstAddrMask.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierDstAddrMask.setDescription('A mask for the matching of the destination IP  address.\n         A zero bit in the mask means that the corresponding bit\n         in the address always matches.')
diffServMFClassifierSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierSrcAddr.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierSrcAddr.setDescription('The IP address to match against the source IP  address\n         of each packet.')
diffServMFClassifierSrcAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierSrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierSrcAddrMask.setDescription('A mask for the matching of the source  IP address.')
diffServMFClassifierDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 63), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierDscp.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierDscp.setDescription('The value that the DSCP in the packet  must have to\n         match this entry. A value of -1 indicates that a\n         specific DSCP value has not been defined and thus all\n         DSCP values are considered a match.')
diffServMFClassifierProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierProtocol.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierProtocol.setDescription('The IP protocol to match against the IPv4 protocol\n         number in the packet. A value of zero means match all.')
diffServMFClassifierDstL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 9), MFClassifierL4Port()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierDstL4PortMin.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierDstL4PortMin.setDescription('The minimum value that the layer-4 destination port\n         number in the packet must have in order to match this\n         classifier entry.')
diffServMFClassifierDstL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 10), MFClassifierL4Port()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierDstL4PortMax.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierDstL4PortMax.setDescription('The maximum value that the layer-4 destination port\n         number in the packet must have in order to match this\n         classifier entry. This value must be equal to or\n         greater that the value specified for this entry in\n         diffServMFClassifierDstL4PortMin.')
diffServMFClassifierSrcL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 11), MFClassifierL4Port()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierSrcL4PortMin.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierSrcL4PortMin.setDescription('The minimum value that the layer-4 source port number\n         in the packet must have in order to match this\n         classifier entry.')
diffServMFClassifierSrcL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 12), MFClassifierL4Port()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierSrcL4PortMax.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierSrcL4PortMax.setDescription('The maximum value that the layer-4 source port number\n         in the packet must have in oder to match this\n         classifier entry. This value must be equal to or\n         greater that the value specified for this entry in\n         dsSixTupleIpSrcL4PortMin.')
diffServMFClassifierStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMFClassifierStatus.setStatus('current')
if mibBuilder.loadTexts: diffServMFClassifierStatus.setDescription('This indicates the status of this classifier entry.')
diffServClassifierUnique = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 1, 2), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServClassifierUnique.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierUnique.setDescription('The diffServClassifierUnique object yields a unique\n         new value for diffServClassifierNumber when read and\n         subsequently set. This value must be tested for\n         uniqueness.')
diffServClassifierTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3), )
if mibBuilder.loadTexts: diffServClassifierTable.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierTable.setDescription('The classifier table enumerates specific classifiers\n         that a system may apply, including Differentiated\n         Services Code Points (DSCPs) and Multi-field\n         discriminators such as {Source IP Address, Destination\n         IP Address, IP Protocol, Source TCP/UDP Port,\n         Destination TCP/UDP Port).')
diffServClassifierEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServInterfaceDirection"), (0, "DIFF-SERV-MIB", "diffServClassifierNumber"))
if mibBuilder.loadTexts: diffServClassifierEntry.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierEntry.setDescription('An entry in the classifier table describes a single\n         classifier.')
diffServInterfaceDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServInterfaceDirection.setStatus('current')
if mibBuilder.loadTexts: diffServInterfaceDirection.setDescription("Specifies the  direction for this entry on the\n         interface. 'inbound' traffic is operated on during\n         receipt, while 'outbound' traffic is operated on prior\n         to transmission.")
diffServClassifierNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServClassifierNumber.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierNumber.setDescription('diffServClassifierNumber enumerates the classifier\n         entry.')
diffServClassifierMatchObject = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 3), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierMatchObject.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierMatchObject.setDescription('A pointer to the row that describes the applicable\n         classifier. An obvious choice would be the\n         diffServAggregateEntry for a given DSCP, but other\n         choices include tables describing any classifier that\n         may be of interest. If the row pointed to does not\n         exist, the classifier is ignored.\n         The NULL OID zeroDotZero is interpreted to match\n         anything not matched by another classifier.')
diffServClassifierNext = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 4), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierNext.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierNext.setDescription("The 'next' variable selects the appropriate meter or\n         action to apply to this class of traffic.")
diffServClassifierSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierSequence.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierSequence.setDescription('The sequence in which  classifiers are applied, in\n         ascending order. Classifiers with the same sequence\n         number must be unambiguous.  Classifiers with different\n         sequence numbers may overlap in their ranges, with the\n         understanding that the first applied classifier to\n         match a packet is taken.')
diffServClassifierConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("other", 0), ("mib", 1), ("pib", 2), ("bgp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServClassifierConfigType.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierConfigType.setDescription('Used to indicate how the classifer is  configured.')
diffServClassifierConfigTypeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServClassifierConfigTypeInfo.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierConfigTypeInfo.setDescription('Additional information associated with how the\n         classifier is configured.')
diffServClassifierStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierStatus.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierStatus.setDescription('The RowStatus  variable controls the activation,\n         deactivation, or deletion of a classifier. Any writable\n         variable may be modified whether the row is active or\n         notInService.')
diffServTBMeterUnique = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 1, 3), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServTBMeterUnique.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterUnique.setDescription('The diffServTBMeterUnique object yieldiffServ  a unique\n         new value for diffServTBMeterNumber when read and\n         subsequently set. This value must be tested for\n         uniqueness.')
diffServTBMeterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4), )
if mibBuilder.loadTexts: diffServTBMeterTable.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterTable.setDescription('The Meter Table enumerates specific token bucket\n         meters that a system may use to police a stream of\n         classified traffic. Such a stream may include a single\n         micro-flow, all traffic from a given source to a given\n         destination, all traffic conforming to a single\n         classifier, or any other cut of the traffic, including\n         all of it.\n         Note that the conceptual model requires all traffic to\n         pass through one or more meters, and that the last\n         meter configured in such a sequence must always\n         conform.\n         Counters in this table start counting on creation of\n         the meter that specifies their existence.')
diffServTBMeterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServInterfaceDirection"), (0, "DIFF-SERV-MIB", "diffServTBMeterNumber"))
if mibBuilder.loadTexts: diffServTBMeterEntry.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterEntry.setDescription('An entry in the meter  table describes a single token\n         bucket meter. Note that a meter has exactly one rate,\n         defined as the burst size each time interval. Multiple\n         meters may be cascaded should a multi-rate token bucket\n         be needed in a given Per-Hop Behavior. An example of\n         such a PHB is AF.')
diffServTBMeterNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: diffServTBMeterNumber.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterNumber.setDescription('The number of  the meter, for reference from the\n         classifier or in cascade from another meter.')
diffServTBMeterInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4, 1, 2), Unsigned32()).setUnits('microseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterInterval.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterInterval.setDescription('The number of  microseconds in the token bucket\n         interval for this meter. Note that implementations\n         frequently do not keep time in microseconds internally,\n         so in implementation the effect of this value must be\n         approximated.')
diffServTBMeterBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4, 1, 3), Unsigned32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterBurstSize.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterBurstSize.setDescription('The number of  bytes in a single transmission burst.\n         The rate at which the metered traffic may run is one\n         burst per interval. Note that if multiple meters are\n         cascaded onto one PHB, such as in AF, their intervals\n         must be equal, and the peak rate of the data stream is\n         the sum of their intervals per interval.')
diffServTBMeterFailNext = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4, 1, 4), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterFailNext.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterFailNext.setDescription('If the traffic does not conform to the meter,  the next\n         meter or action to enquire of.')
diffServTBMeterSucceedNext = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4, 1, 5), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterSucceedNext.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterSucceedNext.setDescription("The 'Succeed Next' pointer selects which action or\n         queue on the interface that to be used with the\n         message. Incoming traffic may use the value zeroDotZero\n         in this variable to indicate that no queuing on receipt\n         occurs. Incoming interfaces generally use queuing\n         either to divert routing traffic for speedier\n         processing during a flap, or for shaping purposes.")
diffServTBMeterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterStatus.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterStatus.setDescription('The RowStatus  variable controls the activation,\n         deactivation, or deletion of a meter. Any writable\n         variable may be modified whether the row is active or\n         notInService.')
diffServActionUnique = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 1, 4), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServActionUnique.setStatus('current')
if mibBuilder.loadTexts: diffServActionUnique.setDescription('The diffServActionUnique object yields a unique new\n         value for diffServActionNumber when read and\n         subsequently set. This value must be tested for\n         uniqueness.')
diffServActionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5), )
if mibBuilder.loadTexts: diffServActionTable.setStatus('current')
if mibBuilder.loadTexts: diffServActionTable.setDescription('The Action Table enumerates specific apply to  a stream\n         of classified traffic. Such a stream may include a\n         single micro-flow, all traffic from a given source to a\n         given destination, all traffic conforming to a single\n         classifier, or any other cut of the traffic, including\n         all of it.\n         Counters in this table start counting on creation of\n         the action that specifies their existence.')
diffServActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServInterfaceDirection"), (0, "DIFF-SERV-MIB", "diffServActionNumber"))
if mibBuilder.loadTexts: diffServActionEntry.setStatus('current')
if mibBuilder.loadTexts: diffServActionEntry.setDescription('An entry in the action table describes the actions\n         applied to traffic conforming to a given meter.')
diffServActionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServActionNumber.setStatus('current')
if mibBuilder.loadTexts: diffServActionNumber.setDescription('The number of  the meter, for reference from the\n         classifier or in cascade from another meter.')
diffServActionNext = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 2), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionNext.setStatus('current')
if mibBuilder.loadTexts: diffServActionNext.setDescription("The 'Next' pointer selects which queue or Traffic\n         Control Block on the interface. Incoming traffic may\n         use the value zeroDotZero in this variable to indicate\n         that no queuing on receipt occurs. Incoming interfaces\n         generally use queuing either to divert routing traffic\n         for speedier processing during a flap, or for shaping\n         purposes.")
diffServActionDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 3), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionDSCP.setStatus('current')
if mibBuilder.loadTexts: diffServActionDSCP.setDescription('The DSCP that  traffic conforming to this classifier\n         and this meter is remarked with. Note that if the\n         classifier is working from the same DSCP value, no\n         effective change in the DSCP results.\n         Differentiated Services may result in packet remarking\n         both on ingress to a network and on egress, and it is\n         quite possible that ingress and egress would occur in\n         the same router.')
diffServActionMinThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 4), Unsigned32()).setUnits('packets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionMinThreshold.setStatus('current')
if mibBuilder.loadTexts: diffServActionMinThreshold.setDescription("The min-threshold is the queue depth that a random\n         drop process will seek to manage the queue's depth to.\n         This object is in the action table rather than the\n         queue table because Differentiated Services PHBs, such\n         as the Assured Service, permit differently classified\n         traffic to have different drop parameters even though\n         they occupy the same queue.")
diffServActionMaxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 5), Unsigned32()).setUnits('packets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionMaxThreshold.setStatus('current')
if mibBuilder.loadTexts: diffServActionMaxThreshold.setDescription('The max-threshold is the maximum permissible queue\n         depth. In tail drop scenarios, the queue will drop if a\n         packet is presented to it and it is instantaneously\n         full by this measure. In random drop scenarios, the\n         queue will drop if a packet is presented to it and the\n         average queue depth exceeds the max-threshold.\n         This object is in the action table rather than the\n         queue table because Differentiated Services PHBs, such\n         as the Assured Service, permit differently classified\n         traffic to have different drop parameters even though\n         they occupy the same queue.')
diffServActionDropPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("alwaysDrop", 2), ("tailDrop", 3), ("randomDrop", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionDropPolicy.setStatus('current')
if mibBuilder.loadTexts: diffServActionDropPolicy.setDescription('The drop policy applied to traffic.')
diffServActionHCConformingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 7), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionHCConformingPackets.setStatus('current')
if mibBuilder.loadTexts: diffServActionHCConformingPackets.setDescription('The number of  Packets conforming to this meter. This\n         object is used on high speed interfaces.\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.')
diffServActionConformingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 8), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionConformingPackets.setStatus('current')
if mibBuilder.loadTexts: diffServActionConformingPackets.setDescription('The number of  Packets conforming to this meter.  This\n         object may be used on low speed interfaces, and\n         represents the least significant 32 bits of\n         diffServActionHCConformingPackets.\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.')
diffServActionHCConformingOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 9), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionHCConformingOctets.setStatus('current')
if mibBuilder.loadTexts: diffServActionHCConformingOctets.setDescription('The number of  octets conforming to this meter. This\n         object is used on high speed interfaces.\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.')
diffServActionConformingOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 10), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionConformingOctets.setStatus('current')
if mibBuilder.loadTexts: diffServActionConformingOctets.setDescription('The number of  octets conforming to this meter.  This\n         object may be used on low speed interfaces, and\n         represents the least significant 32 bits of\n         diffServActionHCConformingOctets.\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.')
diffServActionTailDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionTailDrops.setStatus('current')
if mibBuilder.loadTexts: diffServActionTailDrops.setDescription("The number of  packets conforming to this classifier\n         and meter that have been dropped because either the\n         meter always drops, or the queue's depth exceeds the\n         max-threshold value.  On high speed devices, this\n         object implements the least significant 32 bits of\n         diffServActionHCTailDrops .\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.")
diffServActionHCTailDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionHCTailDrops.setStatus('current')
if mibBuilder.loadTexts: diffServActionHCTailDrops.setDescription("The number of  packets conforming to this classifier\n         and meter that have been dropped because either the\n         meter always drops, or the queue's depth exceeds the\n         max-threshold value.  This object should be used on\n         high speed interfaces.\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.")
diffServActionRandomDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionRandomDrops.setStatus('current')
if mibBuilder.loadTexts: diffServActionRandomDrops.setDescription('The number of  packets conforming to this classifier\n         and meter that have been dropped by a random drop\n         process because the queue is over-full.  On high speed\n         lines, this object reflects the least significant 32\n         bits of diffServActionHCRandomDrops.\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.')
diffServActionHCRandomDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionHCRandomDrops.setStatus('current')
if mibBuilder.loadTexts: diffServActionHCRandomDrops.setDescription('The number of  packets conforming to this classifier\n         and meter that have been dropped by a random drop\n         process because the queue is over-full.  This object is\n         used on high speed lines.\n         Discontinuities in the value of this counter can occur\n         at re-initialization of the management system, and at\n         other times as indicated by the value of\n         ifCounterDiscontinuityTime.')
diffServActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 5, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionStatus.setStatus('current')
if mibBuilder.loadTexts: diffServActionStatus.setDescription('The RowStatus  variable controls the activation,\n         deactivation, or deletion of a meter. Any writable\n         variable may be modified whether the row is active or\n         notInService.')
diffServQueueUnique = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 1, 5), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServQueueUnique.setStatus('current')
if mibBuilder.loadTexts: diffServQueueUnique.setDescription('The diffServQueueUnique object yields  a unique new\n         value for diffServQueueNumber when read and\n         subsequently set. This value must be tested for\n         uniqueness.')
diffServQueueTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6), )
if mibBuilder.loadTexts: diffServQueueTable.setStatus('current')
if mibBuilder.loadTexts: diffServQueueTable.setDescription('The Queue Table enumerates the queues  on an interface.\n         Queues are used to store traffic during intervals when\n         the arrival rate exceeds the departure rate for a class\n         of traffic. Because some PHBs indicate that the use of\n         a priority queue may be advisable, each queue in this\n         system is seen as having a priority. Those queues that\n         share the same priority operate in what may externally\n         appear to be a Weighted Round Robin manner, and preempt\n         the traffic belonging to any lower priority. For this\n         reason, it is strongly urged that traffic placed into\n         prioritized queues be strongly policed to avoid traffic\n         lockout.\n         Queues in this table also have a minimum and a maximum\n         rate.  When a maximum rate is specified, the queue acts\n         as a shaper if it has sufficient traffic and capacity\n         is available.  If it is a minimum rate, then the weight\n         in the WRR is effectively set to this rate divided by\n         the sum of the rates of queues on the interface,\n         guaranteeing it at least that throughput rate. If it is\n         a maximum rate, the queue operates as a shaper. A\n         shaper potentially reduces the rate of traffic through\n         it to the indicated rate, and minimizes variations in\n         rate.')
diffServQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServInterfaceDirection"), (0, "DIFF-SERV-MIB", "diffServQueueNumber"))
if mibBuilder.loadTexts: diffServQueueEntry.setStatus('current')
if mibBuilder.loadTexts: diffServQueueEntry.setDescription('An entry in the Queue  Table describes a single FIFO\n         queue.')
diffServQueueNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diffServQueueNumber.setStatus('current')
if mibBuilder.loadTexts: diffServQueueNumber.setDescription('The number of  the queue.')
diffServQueueMinimumRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1, 2), Unsigned32()).setUnits('KBPS').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQueueMinimumRate.setStatus('current')
if mibBuilder.loadTexts: diffServQueueMinimumRate.setDescription('The rate of the queue, in kilobits per second  (KBPS).\n         This unit is chosen because interfaces exist at the\n         time of this writing which exceed the number of bits\n         per second which may be represented in a 32 bit number.\n         If the value is zero, then there is effectively no\n         minimum rate. If the value is non-zero, the queue set\n         will seek to assure this class of traffic at least this\n         rate.')
diffServQueueMaximumRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1, 3), Unsigned32()).setUnits('KBPS').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQueueMaximumRate.setStatus('current')
if mibBuilder.loadTexts: diffServQueueMaximumRate.setDescription('The rate of the queue, in kilobits per second  (KBPS).\n         This unit is chosen because interfaces exist at the\n         time of this writing which exceed the number of bits\n         per second which may be represented in a 32 bit number.\n         If the value is zero, then there is effectively no\n         maximum rate. If the value is non-zero, the queue set\n         will seek to assure this class of traffic at most this\n         rate.')
diffServQueuePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQueuePriority.setStatus('current')
if mibBuilder.loadTexts: diffServQueuePriority.setDescription('The priority of the queue. If  multiple queues exist on\n         the same interface at the same priority, they are\n         effectively given Weighted Round Robin service. If\n         multiple priorities are configured on an interface,\n         traffic with a numerically higher priority number is\n         deemed to have higher priority than other traffic, and\n         is preemptively serviced.')
diffServQueueNextTCB = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1, 5), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQueueNextTCB.setStatus('current')
if mibBuilder.loadTexts: diffServQueueNextTCB.setDescription("The 'Next' pointer selects the successor TCB on the\n         interface.  Incoming traffic may use the value\n         zeroDotZero in this variable to indicate that the\n         packet is now to be routed; outbound traffic may use\n         the same value to indicate that no subsequent queuing\n         applies.  Ingress interfaces generally use queuing\n         either to divert routing traffic for speedier\n         processing during a flap, or for shaping purposes.")
diffServQueueOccupancyWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQueueOccupancyWeight.setStatus('current')
if mibBuilder.loadTexts: diffServQueueOccupancyWeight.setDescription('The amount, in the form of a factor, that the  current,\n         actual queue occupancy should influence the averaged\n         queue occupancy.  The averaged queue occupancy can be\n         used for comparison to configured drop thresholds in\n         RED or RED-like dropper implementations.  Larger the\n         weight, the greater the instantaneous queue occupancy\n         influences the averaged queue occupancy.  Usually,\n         dramatic changes in the instantaneous queue occupancy\n         is the result of bursty input streams.  Notice this\n         numeric attribute is divided by 10,000 to get the\n         effective fractional factor used in the actual\n         calculations.')
diffServQueueStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 51, 1, 2, 6, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQueueStatus.setStatus('current')
if mibBuilder.loadTexts: diffServQueueStatus.setDescription('The RowStatus  variable controls the activation,\n         deactivation, or deletion of a queue. Any writable\n         variable may be modified whether the row is active or\n         notInService.')
mibBuilder.exportSymbols("DIFF-SERV-MIB", diffServAggregateTable=diffServAggregateTable, diffServActionEntry=diffServActionEntry, diffServClassifierTable=diffServClassifierTable, diffServMFClassifierSrcAddrMask=diffServMFClassifierSrcAddrMask, diffServActionConformingOctets=diffServActionConformingOctets, diffServMFClassifierDstL4PortMax=diffServMFClassifierDstL4PortMax, diffServMIBConformance=diffServMIBConformance, diffServMFClassifierDstAddr=diffServMFClassifierDstAddr, diffServTBMeterBurstSize=diffServTBMeterBurstSize, diffServQueueNextTCB=diffServQueueNextTCB, diffServActionMinThreshold=diffServActionMinThreshold, diffServTBMeterStatus=diffServTBMeterStatus, diffServQueueEntry=diffServQueueEntry, diffServActionTable=diffServActionTable, diffServActionMaxThreshold=diffServActionMaxThreshold, diffServInterfaceDirection=diffServInterfaceDirection, diffServQueuePriority=diffServQueuePriority, diffServMFClassifierTable=diffServMFClassifierTable, diffServClassifierConfigType=diffServClassifierConfigType, diffServClassifierStatus=diffServClassifierStatus, diffServTBMeterInterval=diffServTBMeterInterval, diffServActionDSCP=diffServActionDSCP, diffServQueueMaximumRate=diffServQueueMaximumRate, diffServQueueOccupancyWeight=diffServQueueOccupancyWeight, diffServMFClassifierDstL4PortMin=diffServMFClassifierDstL4PortMin, Dscp=Dscp, diffServMib=diffServMib, PYSNMP_MODULE_ID=diffServMib, diffServActionTailDrops=diffServActionTailDrops, diffServActionRandomDrops=diffServActionRandomDrops, diffServTBMeterSucceedNext=diffServTBMeterSucceedNext, diffServActionDropPolicy=diffServActionDropPolicy, diffServQueueUnique=diffServQueueUnique, diffServMFClassifierUnique=diffServMFClassifierUnique, diffServQueueTable=diffServQueueTable, diffServActionHCConformingOctets=diffServActionHCConformingOctets, diffServTBMeterUnique=diffServTBMeterUnique, diffServMFClassifierProtocol=diffServMFClassifierProtocol, diffServClassifierUnique=diffServClassifierUnique, diffServActionNumber=diffServActionNumber, diffServClassifierNext=diffServClassifierNext, diffServTBMeterFailNext=diffServTBMeterFailNext, diffServActionHCTailDrops=diffServActionHCTailDrops, diffServMFClassifierDstAddrMask=diffServMFClassifierDstAddrMask, diffServActionStatus=diffServActionStatus, diffServQueueStatus=diffServQueueStatus, diffServQueueNumber=diffServQueueNumber, diffServMFClassifierSrcAddr=diffServMFClassifierSrcAddr, diffServActionHCConformingPackets=diffServActionHCConformingPackets, diffServActionConformingPackets=diffServActionConformingPackets, diffServMFClassifierAddrType=diffServMFClassifierAddrType, diffServMFClassifierStatus=diffServMFClassifierStatus, diffServMFClassifierIndex=diffServMFClassifierIndex, diffServClassifierMatchObject=diffServClassifierMatchObject, diffServAggregateEntry=diffServAggregateEntry, diffServClassifierConfigTypeInfo=diffServClassifierConfigTypeInfo, diffServMFClassifierSrcL4PortMin=diffServMFClassifierSrcL4PortMin, diffServAggregateDSCP=diffServAggregateDSCP, diffServMFClassifierSrcL4PortMax=diffServMFClassifierSrcL4PortMax, MFClassifierL4Port=MFClassifierL4Port, diffServTables=diffServTables, diffServObjects=diffServObjects, diffServClassifierNumber=diffServClassifierNumber, diffServActionUnique=diffServActionUnique, diffServActionNext=diffServActionNext, diffServClassifierSequence=diffServClassifierSequence, diffServActionHCRandomDrops=diffServActionHCRandomDrops, diffServMFClassifierDscp=diffServMFClassifierDscp, diffServQueueMinimumRate=diffServQueueMinimumRate, diffServTBMeterTable=diffServTBMeterTable, diffServMFClassifierEntry=diffServMFClassifierEntry, diffServTBMeterNumber=diffServTBMeterNumber, diffServTBMeterEntry=diffServTBMeterEntry, diffServClassifierEntry=diffServClassifierEntry)
