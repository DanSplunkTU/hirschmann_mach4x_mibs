#
# PySNMP MIB module RTCPXR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/RTCP-XR-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 14:59:54 2022
# On host fv-az36-128 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
InetAddressType, InetAddress, InetPortNumber = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress", "InetPortNumber")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Unsigned32, MibIdentifier, Bits, mib_2, iso, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, NotificationType, ObjectIdentity, Counter32, TimeTicks, IpAddress, Counter64, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "MibIdentifier", "Bits", "mib-2", "iso", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "NotificationType", "ObjectIdentity", "Counter32", "TimeTicks", "IpAddress", "Counter64", "Integer32")
TimeStamp, TextualConvention, DisplayString, RowPointer = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TextualConvention", "DisplayString", "RowPointer")
rtcpXrMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 255))
rtcpXrMIB.setRevisions(('2005-02-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rtcpXrMIB.setRevisionsDescriptions(('Initial version, published as RFC nnnn',))
if mibBuilder.loadTexts: rtcpXrMIB.setLastUpdated('200502200000Z')
if mibBuilder.loadTexts: rtcpXrMIB.setOrganization('IETF AVT Working Group')
if mibBuilder.loadTexts: rtcpXrMIB.setContactInfo('IETF AVT Working Group\n         Chairs: Colin Perkins, Magnus Westerlund\n         Working Group Email:  avt@ietf.org\n\n         Editors: Alan Clark\n                  Telchemy\n                  Email: alan@telchemy.com\n\n                  Amy Pendleton\n                  Nortel Networks\n                  Email: aspen@nortelnetworks.com')
if mibBuilder.loadTexts: rtcpXrMIB.setDescription('RTCP Extended Reports MIB\n                 Copyright (c) The Internet Society (2005)\n                 This version of the MIB module is part of\n                 RFC nnnn and is based on RFC3611.')
class LeveldB(TextualConvention, Integer32):
    description = 'Represents a signal level in decibels (dB).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-120, 120), ValueRangeConstraint(127, 127), )
class Rfactor(TextualConvention, Unsigned32):
    reference = 'ITU-T G.107'
    description = 'Call or transmission quality expressed as an \n       R factor in the range 0 to 120. A value of\n       127 shall be interpreted as NULL or unsupported.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 120), ValueRangeConstraint(127, 127), )
class ScaledMOSscore(TextualConvention, Integer32):
    reference = 'ITU-T P.800'
    description = 'Call or transmission quality expressed as a \n       MOS score scaled by 10.  MOS is typically represented\n       as a 1.0 to 5.0 score with a single decimal place and\n       hence in this representation as 10 to 50. A value of\n       127 shall be interpreted as NULL or unsupported.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(10, 50), ValueRangeConstraint(127, 127), )
class Percentage(TextualConvention, Unsigned32):
    description = 'Percentage expressed as a rounded integer.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 100)

rtcpXrMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 255, 1))
rtcpXrConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 255, 2))
rtcpXrEvents = MibIdentifier((1, 3, 6, 1, 2, 1, 255, 3))
rtcpXrSessionIDTable = MibTable((1, 3, 6, 1, 2, 1, 255, 1, 1), )
if mibBuilder.loadTexts: rtcpXrSessionIDTable.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDTable.setDescription('Table of information about RTP Sessions for which RTCP XR\n     parameters and metrics are available. ')
rtcpXrSessionIDEntry = MibTableRow((1, 3, 6, 1, 2, 1, 255, 1, 1, 1), ).setIndexNames((0, "RTCPXR-MIB", "rtcpXrSessionIDIndex"))
if mibBuilder.loadTexts: rtcpXrSessionIDEntry.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDEntry.setDescription('An entry in the table of call records.  A row in this table \n         is created for each RTP session endpoint participating.')
rtcpXrSessionIDIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: rtcpXrSessionIDIndex.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDIndex.setDescription('Index for this session within the Session ID table.')
rtcpXrSessionIDSessionIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDSessionIdentifier.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDSessionIdentifier.setDescription('Unique identifier for this session.  Where a billing record\n         correlation identifer is not available for a particular call, \n         another identifier such as SSRC can be used.')
rtcpXrSessionIDCallStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDCallStartTime.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDCallStartTime.setDescription('Call start time for this call. If the start time is not\n         known then this represents the earliest known time associated\n         with the call.')
rtcpXrSessionIDCallStopTime = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDCallStopTime.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDCallStopTime.setDescription('Call stop time for this call. If the call is still active \n         then this shall have the value 0.  If the call is complete\n         but the time is unknown then this shall have the value of the \n         latest time associated with the call.')
rtcpXrSessionIDSourceIPtype = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDSourceIPtype.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDSourceIPtype.setDescription('Source IP address type for this session.')
rtcpXrSessionIDSourceIPaddress = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDSourceIPaddress.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDSourceIPaddress.setDescription('Source IP address for this session.')
rtcpXrSessionIDSourceRTPport = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 7), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDSourceRTPport.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDSourceRTPport.setDescription('Source UDP port for RTP. A value of 0 indicates\n         an unknown port number.')
rtcpXrSessionIDSourceRTCPport = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 8), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDSourceRTCPport.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDSourceRTCPport.setDescription('Source UDP port for RTCP.A value of 0 indicates\n         an unknown port number.')
rtcpXrSessionIDDestIPtype = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 9), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDDestIPtype.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDDestIPtype.setDescription('Destination IP address type for this session.')
rtcpXrSessionIDDestIPaddress = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 10), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDDestIPaddress.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDDestIPaddress.setDescription('Destination IP address for this session.')
rtcpXrSessionIDDestRTPport = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 11), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDDestRTPport.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDDestRTPport.setDescription('Destination UDP port for RTP. A value of 0 indicates\n         an unknown port number.')
rtcpXrSessionIDDestRTCPport = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 12), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDDestRTCPport.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDDestRTCPport.setDescription('Destination UDP port for RTCP.A value of 0 indicates\n         an unknown port number.')
rtcpXrSessionIDSrceIdenType = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dialedNumber", 1), ("urlID", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDSrceIdenType.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDSrceIdenType.setDescription('Defines the type of address in parameter\n        rtcpXrSessionIDSourceIdentifier')
rtcpXrSessionIDSrceIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDSrceIdentifier.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDSrceIdentifier.setDescription('Alternate identifier to the IP address.  This can be E.164, \n         DN, or URL.')
rtcpXrSessionIDDestIdenType = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dialedNumber", 1), ("urlID", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDDestIdenType.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDDestIdenType.setDescription('Defines the type of address in parameter\n         rtcpXrSessionIDDestIdentifier.')
rtcpXrSessionIDDestIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDDestIdentifier.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDDestIdentifier.setDescription('Alternate identifier to the IP address.  This can be E.164, \n         DN, or URL.')
rtcpXrSessionIDMeasurePt = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("localEndpoint", 1), ("remoteEndpoint", 2), ("midStream", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDMeasurePt.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDMeasurePt.setDescription("Place that these metrics were measured - this endpoint,\n         remote endpoint (i.e. reported through XR), or midstream.\n         If this MIB is supported in a midstream device (e.g. probe)\n         then data from the IP endpoint reported to this device \n         using RFC3611 would be described as 'remoteEndpoint' and\n         data measured locally would be described as 'midStream'.\n         If this MIB is supported in an IP endpoint then the metrics\n         obtained from measurement of the incoming stream would be\n         'localEndpoint' and those reported via RFC3611 from the\n         remote end would be 'remoteEndpoint'. \n         This MIB could therefor report both remote and local\n         data if located in an IP endpoint or both remote and \n         midstream data if located in a probe, router or other\n         mid-network device.")
rtcpXrSessionIDMeasurePtID = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDMeasurePtID.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDMeasurePtID.setDescription('Information describing the identity of the endpoint that\n         measured the data in this row. If the data was measured\n         locally then this would be the identity of this system,\n         if measured remotely and reported via RFC3611 then this\n         would be the identity of the remote measurement point,\n         if known.')
rtcpXrSessionIDReverseSession = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 19), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDReverseSession.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDReverseSession.setDescription('A pointer to the corresponding entry in this table for\n        the reverse direction of transmission. For example, if\n        this row contained locally measured metrics for the A->B\n        direction of transmission then the reverse session would\n        be the row containing locally measured metrics for the\n        B->A direction of transmission.')
rtcpXrSessionIDAltMeasurePt = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 1, 1, 20), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrSessionIDAltMeasurePt.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDAltMeasurePt.setDescription('A pointer to the corresponding entry in this table for\n        alternate measurement point data. For example, if this\n        MIB was located in a midstream devices and this row \n        contained metrics measured midstream then the alternate\n        measurement point would refer to the metrics reported\n        by the remote endpoint, and vice versa.')
rtcpXrBaseParamTable = MibTable((1, 3, 6, 1, 2, 1, 255, 1, 2), )
if mibBuilder.loadTexts: rtcpXrBaseParamTable.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamTable.setDescription('Table of basic parameters related to RTP sessions in\n      the Session table. ')
rtcpXrBaseParamEntry = MibTableRow((1, 3, 6, 1, 2, 1, 255, 1, 2, 1), ).setIndexNames((0, "RTCPXR-MIB", "rtcpXrSessionIDIndex"))
if mibBuilder.loadTexts: rtcpXrBaseParamEntry.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamEntry.setDescription('An entry in the table of basic parameters. A row in this table \n         is created for each RTP session endpoint participating.')
rtcpXrBaseParamVocoderType = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamVocoderType.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamVocoderType.setDescription("Vocoder type used on this call. The format used shall be\n         ITU-T G.7xx, GSM FR, GSM EFR, GSM HR, AMR, AMR WB, iLBC \n         or similar.  For example 'ITU G.729A'. ")
rtcpXrBaseParamVocoderRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamVocoderRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamVocoderRate.setDescription('Vocoder rate in use at the time this data was captured \n         expressed in bits per second.  For example G.711 would\n         have the rate 64000 and G.729 would have the rate 8000.')
rtcpXrBaseParamFrameDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setUnits('sample clock ticks').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamFrameDuration.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamFrameDuration.setDescription('Companion information to vocoder type.  This represents the\n         duration of the time interval represented by a frame, which\n         is generally equivalent to the nominal spacing of frames.\n         This is expressed in sample clock ticks as defined under\n         rtxpXrSampleRate.\n         This parameter may be equated to the SDP ptime parameter\n         which is expressed in milliseconds (however which cannot\n         represent certain vocoder types, e.g. those with 2.5mS\n         frames).')
rtcpXrBaseParamSampleRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setUnits('samples per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamSampleRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamSampleRate.setDescription('Companion information to vocoder type.  This represents the\n         rate at which media was sampled (e.g. 8000 for narrowband\n         voice, 16000 for wideband voice).')
rtcpXrBaseParamDurationMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 5), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamDurationMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamDurationMs.setDescription('Current duration of call in milliseconds if still active,\n         duration of call in milliseconds if complete.')
rtcpXrBaseParamNetworkLossRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 6), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamNetworkLossRate.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamNetworkLossRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamNetworkLossRate.setDescription('Average rate of network packet loss.')
rtcpXrBaseParamAvgDiscardRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 7), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamAvgDiscardRate.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamAvgDiscardRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamAvgDiscardRate.setDescription('Average rate of discards due to jitter.')
rtcpXrBaseParamBurstLossDensity = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 8), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamBurstLossDensity.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamBurstLossDensity.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamBurstLossDensity.setDescription('Density of loss and discarded packets during burst periods.')
rtcpXrBaseParamBurstLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 9), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamBurstLenMs.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamBurstLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamBurstLenMs.setDescription('Average length of bursts in milliseconds.')
rtcpXrBaseParamGapLossDensity = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 10), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamGapLossDensity.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamGapLossDensity.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamGapLossDensity.setDescription('Density of loss and discarded packets during gap periods.')
rtcpXrBaseParamGapLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 11), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamGapLenMs.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamGapLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamGapLenMs.setDescription('Average length of gaps in milliseconds.')
rtcpXrBaseParamAvgOWDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 12), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamAvgOWDelay.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamAvgOWDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamAvgOWDelay.setDescription('Average (symmetric) one way RTCP delay on call. A value of \n         zero may indicate that this value has not yet been determined.')
rtcpXrBaseParamAvgEndSysDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 13), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamAvgEndSysDelay.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamAvgEndSysDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamAvgEndSysDelay.setDescription('Average end system delay on call. A value of zero may \n         indicate that this value has not yet been determined.')
rtcpXrBaseParamPlcType = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("enhanced", 2), ("standard", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamPlcType.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamPlcType.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamPlcType.setDescription('Defines type of packet loss concealment used on this call.')
rtcpXrBaseParamJBuffAdaptMode = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reserved", 1), ("nonAdaptive", 2), ("adaptive", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAdaptMode.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAdaptMode.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAdaptMode.setDescription('Defines if jitter buffer is in fixed or adaptive mode.')
rtcpXrBaseParamJBuffAdaptRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAdaptRate.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAdaptRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAdaptRate.setDescription('Estimated adaptation rate of jitter buffer.')
rtcpXrBaseParamJBuffAverageDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 17), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAverageDelay.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAverageDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAverageDelay.setDescription('Average size of jitter buffer in mS.')
rtcpXrBaseParamJBuffMaximumDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 18), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffMaximumDelay.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffMaximumDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffMaximumDelay.setDescription('Maximum delay through jitter buffer at current size in mS.')
rtcpXrBaseParamJBuffAbsMaxDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 19), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAbsMaxDelay.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAbsMaxDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamJBuffAbsMaxDelay.setDescription('Absolute maximum size jitter buffer can reach in mS.')
rtcpXrBaseParamJitterLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 2, 1, 20), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrBaseParamJitterLevel.setReference('See RFC3550 Section 6.4.')
if mibBuilder.loadTexts: rtcpXrBaseParamJitterLevel.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamJitterLevel.setDescription('Average jitter level measured according to RFC3550 and\n         represented in terms of milliseconds.')
rtcpXrCallQualityTable = MibTable((1, 3, 6, 1, 2, 1, 255, 1, 3), )
if mibBuilder.loadTexts: rtcpXrCallQualityTable.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityTable.setDescription('Table of voice quality metrics. A row is created\n      in this table for each row in the Session table.')
rtcpXrCallQualityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 255, 1, 3, 1), ).setIndexNames((0, "RTCPXR-MIB", "rtcpXrSessionIDIndex"))
if mibBuilder.loadTexts: rtcpXrCallQualityEntry.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityEntry.setDescription('An entry in the table of voice quality metrics.  A row in \n         this table is created for each row in the Session\n         table.')
rtcpXrCallQualityNoiseLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 1), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityNoiseLeveldBm.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrCallQualityNoiseLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityNoiseLeveldBm.setDescription('Measured received silent period noise level in dBm.\n         A value of 127 indicates that this parameter is not\n         available.\n         In midpoint applications this parameter may not be\n         available.  If this is a midstream device and call\n         quality metrics were calculated using the value of\n         this parameter reported from the endpoint in an\n         RTCP XR payload then the value used in this\n         calculation MAY be reported.')
rtcpXrCallQualitySignalLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 2), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualitySignalLeveldBm.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrCallQualitySignalLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualitySignalLeveldBm.setDescription('Measured received signal level during talkspurts in dBm.\n         A value of 127 indicates that this parameter is not\n         available.\n         In midpoint applications this parameter may not be\n         available. If this is a midstream device and call\n         quality metrics were calculated using the value of\n         this parameter reported from the endpoint in an\n         RTCP XR payload then the value used in this\n         calculation MAY be reported.')
rtcpXrCallQualityLocalRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 3), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityLocalRERLdB.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrCallQualityLocalRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityLocalRERLdB.setDescription('Residual Echo Return Loss measured at this endpoint,\n         or at the terminating endpoint of this RTP session.\n         This relates to the echo level from the network beyond\n         the terminating endpoint and may be interpreted as either\n         line echo in the case of a gateway or acoustic echo in the\n         case of a handset.  \n         Note that this echo affects conversational quality as\n         perceived by the user at the originating end of this\n         RTP session.\n         A value of 127 indicates that this parameter is not\n         available.\n         In midpoint applications this parameter may not be\n         available.  If this is a midstream device and call\n         quality metrics were calculated using the value of\n         this parameter reported from the endpoint in an\n         RTCP XR payload then the value used in this\n         calculation MAY be reported.')
rtcpXrCallQualityRemoteRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 4), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityRemoteRERLdB.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrCallQualityRemoteRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityRemoteRERLdB.setDescription('Residual Echo Return Loss measured at originating endpoint\n         of this RTP session (i.e. the remote endpoint if this MIB\n         is implemented in an endpoint).\n\n\n         Note that this affects the conversational quality \n         metrics reported by the terminating (this) endpoint, hence\n         is useful in understanding what has affected the reported\n         call quality mertrics\n         A value of 127 indicates that this parameter is not\n         available.\n         In midpoint applications this parameter may not be\n         available.  If this is a midstream device and call\n         quality metrics were calculated using the value of\n         this parameter reported from the endpoint in an\n         RTCP XR payload then the value used in this\n         calculation MAY be reported.')
rtcpXrCallQualityRCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 5), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityRCQ.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrCallQualityRCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityRCQ.setDescription('Conversational quality R factor for this call. This value\n         SHOULD be calculated using ITU G.107 (The E Model) or \n         extended versions thereof.')
rtcpXrCallQualityRLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 6), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityRLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityRLQ.setDescription('Listening quality R factor for this call. This value\n         SHOULD be calculated using ITU G.107 (The E Model) or \n         extended versions thereof.')
rtcpXrCallQualityExternalRCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 7), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityExternalRCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityExternalRCQ.setDescription('External R factor for this call. This value\n         SHOULD be calculated using ITU G.107 (The E Model) or \n         extended versions thereof.\n         The External R factor relates to the quality of an\n         incoming voice from another network segment.  For example\n         if a conference bridge terminates and re-creates voice\n         streams then an R factor would be calculated at the bridge\n         for the endpoint A to bridge segment and relayed to the\n\n\n         subsequent bridge to endpoint B as an External R factor. \n         This allows endpoint B to estimate the end-to-end call\n         quality.')
rtcpXrCallQualityMOSCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 8), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityMOSCQ.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrCallQualityMOSCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityMOSCQ.setDescription('Estimated conversational quality MOS for this call\n        expressed in MOS x 10 (e.g. 41 = MOS of 4.1). This value\n        MAY be calculated by converting the R-CQ value to a MOS.')
rtcpXrCallQualityMOSLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 9), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityMOSLQ.setReference('See RFC3611 Section 4.7.')
if mibBuilder.loadTexts: rtcpXrCallQualityMOSLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityMOSLQ.setDescription('Estimated listening quality MOS for this call\n       expressed in MOS x 10 (e.g. 41 = MOS of 4.1). This value\n        MAY be calculated by converting the R-CQ value to a MOS.')
rtcpXrCallQualityAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 3, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrCallQualityAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityAlgorithm.setDescription("Call quality algorithm used to determine R factors\n        and MOS scores. For example, 'ITU-T G.107' for the \n        E model. If any localized parameter scaling is used\n        (for example Japan's TTC MOS scaling) then this \n        MUST also be reported.")
rtcpXrHistoryTable = MibTable((1, 3, 6, 1, 2, 1, 255, 1, 4), )
if mibBuilder.loadTexts: rtcpXrHistoryTable.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryTable.setDescription('Table of aggregate measurement data for groups\n      of RTP sessions.  A group may be a flow or any\n      other logical association of streams.')
rtcpXrHistoryEntry = MibTableRow((1, 3, 6, 1, 2, 1, 255, 1, 4, 1), ).setIndexNames((0, "RTCPXR-MIB", "rtcpXrHistoryIndex"))
if mibBuilder.loadTexts: rtcpXrHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryEntry.setDescription('An entry in the table of call history records.')
rtcpXrHistoryIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: rtcpXrHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryIndex.setDescription('Index for this set of aggregate data.')
rtcpXrHistoryGroupName = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryGroupName.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryGroupName.setDescription('Name of this set of aggregate data. Examples may include\n         a flow, an interface or some other logical grouping of\n         RTP sessions.')
rtcpXrHistoryStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryStartTime.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryStartTime.setDescription('Time at which this history was reset or started.')
rtcpXrHistoryStopTime = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryStopTime.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryStopTime.setDescription('Time at which this history was stopped.')
rtcpXrHistoryNumOfSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryNumOfSessions.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryNumOfSessions.setDescription('Number of calls included in this history.')
rtcpXrHistoryMinDurationMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 6), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinDurationMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinDurationMs.setDescription('Minimum duration of calls.')
rtcpXrHistoryMaxDurationMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 7), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxDurationMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxDurationMs.setDescription('Maximum duration of calls.')
rtcpXrHistoryAvgDurationMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 8), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgDurationMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgDurationMs.setDescription('Average duration of calls.')
rtcpXrHistoryMaxNetworkLossRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 9), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxNetworkLossRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxNetworkLossRate.setDescription('Maximum loss rate per call.')
rtcpXrHistoryAvgNetworkLossRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 10), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgNetworkLossRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgNetworkLossRate.setDescription('Average loss rate across calls.')
rtcpXrHistoryMaxDiscardRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 11), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxDiscardRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxDiscardRate.setDescription('Maximum discard rate per call.')
rtcpXrHistoryAvgDiscardRate = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 12), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgDiscardRate.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgDiscardRate.setDescription('Average discard rate across calls.')
rtcpXrHistoryMaxBurstLossDensity = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 13), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxBurstLossDensity.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxBurstLossDensity.setDescription('Maximum density of bursts if loss/discard.')
rtcpXrHistoryAvgBurstLossDensity = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 14), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgBurstLossDensity.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgBurstLossDensity.setDescription('Average density of bursts of loss/discard.')
rtcpXrHistoryMinBurstLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 15), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinBurstLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinBurstLenMs.setDescription('Minimum length of bursts.')
rtcpXrHistoryMaxBurstLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 16), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxBurstLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxBurstLenMs.setDescription('Maximum length of bursts.')
rtcpXrHistoryAvgBurstLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 17), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgBurstLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgBurstLenMs.setDescription('Average length of bursts.')
rtcpXrHistoryMaxGapLossDensity = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 18), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxGapLossDensity.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxGapLossDensity.setDescription('Maximum loss/discard density in gaps.')
rtcpXrHistoryAvgGapLossDensity = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 19), Percentage()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgGapLossDensity.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgGapLossDensity.setDescription('Average loss/discard density in gaps.')
rtcpXrHistoryMinGapLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 20), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinGapLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinGapLenMs.setDescription('Minimum average per-call gap length.')
rtcpXrHistoryMaxGapLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 21), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxGapLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxGapLenMs.setDescription('Maximum average per-call gap length.')
rtcpXrHistoryAvgGapLenMs = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 22), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgGapLenMs.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgGapLenMs.setDescription('Average per-call gap length.')
rtcpXrHistoryMinOneWayDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 23), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinOneWayDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinOneWayDelay.setDescription('Minimum one way delay.')
rtcpXrHistoryMaxOneWayDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 24), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxOneWayDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxOneWayDelay.setDescription('Maximum one way delay.')
rtcpXrHistoryAvgOneWayDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 25), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgOneWayDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgOneWayDelay.setDescription('Average one way delay.')
rtcpXrHistoryMinEndSystemDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 26), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinEndSystemDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinEndSystemDelay.setDescription('Minimum end system delay.')
rtcpXrHistoryMaxEndSystemDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 27), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxEndSystemDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxEndSystemDelay.setDescription('Maximum end system delay.')
rtcpXrHistoryAvgEndSystemDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 28), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgEndSystemDelay.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgEndSystemDelay.setDescription('Average end system delay.')
rtcpXrHistoryMinJitterLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 29), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinJitterLevel.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinJitterLevel.setDescription('Minimum jitter level.')
rtcpXrHistoryMaxJitterLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 30), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxJitterLevel.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxJitterLevel.setDescription('Maximum jitter level.')
rtcpXrHistoryAvgJitterLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 31), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgJitterLevel.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgJitterLevel.setDescription('Average jitter level.')
rtcpXrHistoryMinNoiseLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 32), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinNoiseLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinNoiseLeveldBm.setDescription('Minimum noise level.')
rtcpXrHistoryMaxNoiseLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 33), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxNoiseLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxNoiseLeveldBm.setDescription('Maximum noise level.')
rtcpXrHistoryAvgNoiseLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 34), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgNoiseLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgNoiseLeveldBm.setDescription('Average noise level.')
rtcpXrHistoryNoiseLevelCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryNoiseLevelCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryNoiseLevelCount.setDescription('Number of sessions included in the Noise Level\n       history values (as Noise Level is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryMinSignalLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 36), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinSignalLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinSignalLeveldBm.setDescription('Minimum signal level.')
rtcpXrHistoryMaxSignalLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 37), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxSignalLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxSignalLeveldBm.setDescription('Maximum signal level.')
rtcpXrHistoryAvgSignalLeveldBm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 38), LeveldB()).setUnits('dBm0').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgSignalLeveldBm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgSignalLeveldBm.setDescription('Average signal level.')
rtcpXrHistorySignalLevelCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistorySignalLevelCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistorySignalLevelCount.setDescription('Number of sessions included in the Signal Level\n       history values (as Signal Level is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryMinLocalRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 40), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinLocalRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinLocalRERLdB.setDescription('Minimum local Residual Echo Return Loss.')
rtcpXrHistoryMaxLocalRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 41), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxLocalRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxLocalRERLdB.setDescription('Maximum local Residual Echo Return Loss.')
rtcpXrHistoryAvgLocalRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 42), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgLocalRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgLocalRERLdB.setDescription('Average local Residual Echo Return Loss.')
rtcpXrHistoryLocalRERLCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryLocalRERLCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryLocalRERLCount.setDescription('Number of sessions included in the Local RERL\n       history values (as Local RERL is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryMinRemoteRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 44), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinRemoteRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinRemoteRERLdB.setDescription('Minimum remote Residual Echo Return Loss.')
rtcpXrHistoryMaxRemoteRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 45), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxRemoteRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxRemoteRERLdB.setDescription('Minimum remote Residual Echo Return Loss.')
rtcpXrHistoryAvgRemoteRERLdB = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 46), LeveldB()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgRemoteRERLdB.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgRemoteRERLdB.setDescription('Minimum remote Residual Echo Return Loss.')
rtcpXrHistoryRemoteRERLCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryRemoteRERLCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryRemoteRERLCount.setDescription('Number of sessions included in the Remote RERL\n       history values (as Remote RERL is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryMinRCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 48), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinRCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinRCQ.setDescription('Minimum conversational R factor.')
rtcpXrHistoryMaxRCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 49), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxRCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxRCQ.setDescription('Maximum conversational R factor')
rtcpXrHistoryAvgRCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 50), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgRCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgRCQ.setDescription('Average conversational R factor')
rtcpXrHistoryRCQCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryRCQCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryRCQCount.setDescription('Number of sessions included in the R CQ\n       history values (as R CQ is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryMinRLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 52), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinRLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinRLQ.setDescription('Minimum listening quality R factor.')
rtcpXrHistoryMaxRLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 53), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxRLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxRLQ.setDescription('Maximum listening quality R factor.')
rtcpXrHistoryAvgRLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 54), Rfactor()).setUnits('R factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgRLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgRLQ.setDescription('Average listening quality R factor.')
rtcpXrHistoryRLQCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryRLQCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryRLQCount.setDescription('Number of sessions included in the R LQ\n       history values (as R LQ is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryMinMOSCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 56), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinMOSCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinMOSCQ.setDescription('Minimum conversational quality MOS.')
rtcpXrHistoryMaxMOSCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 57), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxMOSCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxMOSCQ.setDescription('Maximum conversational quality MOS.')
rtcpXrHistoryAvgMOSCQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 58), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgMOSCQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgMOSCQ.setDescription('Average conversational quality MOS.')
rtcpXrHistoryMOSCQCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMOSCQCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMOSCQCount.setDescription('Number of sessions included in the MOS CQ\n       history values (as MOS CQ is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryMinMOSLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 60), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMinMOSLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMinMOSLQ.setDescription('Minimum listening quality MOS.')
rtcpXrHistoryMaxMOSLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 61), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMaxMOSLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMaxMOSLQ.setDescription('Maximum listening quality MOS.')
rtcpXrHistoryAvgMOSLQ = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 62), ScaledMOSscore()).setUnits('MOS x 10').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryAvgMOSLQ.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryAvgMOSLQ.setDescription('Average listening quality MOS.')
rtcpXrHistoryMOSLQCount = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryMOSLQCount.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryMOSLQCount.setDescription('Number of sessions included in the MOS LQ\n       history values (as MOS LQ is an optional\n       parameter and may not be present on all calls.')
rtcpXrHistoryCQAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 64), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrHistoryCQAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryCQAlgorithm.setDescription('Call quality algorithm used - must be consistent\n       for all calls in this history.')
rtcpXrHistoryReset = MibTableColumn((1, 3, 6, 1, 2, 1, 255, 1, 4, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("running", 1), ("stop", 2), ("reset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtcpXrHistoryReset.setStatus('current')
if mibBuilder.loadTexts: rtcpXrHistoryReset.setDescription('Status of this row in the history table.\n       Writing a value of 2 to this object MUST cause \n       history updates to be stopped for this row. Writing \n       a value of 3 to this object MUST cause the history \n       row to be reset. \n       Reads MUST return a value of 1 if the row is still\n       being updated or 2 if the row update has stopped.')
rtcpXrVoipThresholdViolation = NotificationType((1, 3, 6, 1, 2, 1, 255, 3, 1)).setObjects(("RTCPXR-MIB", "rtcpXrVoipAlertSeverity"), ("RTCPXR-MIB", "rtcpXrVoipAlertType"), ("RTCPXR-MIB", "rtcpXrVoipAlertInfoType"), ("RTCPXR-MIB", "rtcpXrVoipAlertPointer"))
if mibBuilder.loadTexts: rtcpXrVoipThresholdViolation.setStatus('current')
if mibBuilder.loadTexts: rtcpXrVoipThresholdViolation.setDescription('Notification that voice quality has changed\n         Sent immediately when the condition is detected.')
rtcpXrEventParam = MibIdentifier((1, 3, 6, 1, 2, 1, 255, 3, 2))
rtcpXrVoipAlertType = MibScalar((1, 3, 6, 1, 2, 1, 255, 3, 2, 1), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrVoipAlertType.setStatus('current')
if mibBuilder.loadTexts: rtcpXrVoipAlertType.setDescription('Text description of the type of alert.  Where possible,\n        this parameter should be populated with the correct\n        rtcpXrVoipEntry or rtcpXrVoipHistory description.')
rtcpXrVoipAlertInfoType = MibScalar((1, 3, 6, 1, 2, 1, 255, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("adminStringOnly", 1), ("sessionPointer", 2), ("historyPointer", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrVoipAlertInfoType.setStatus('current')
if mibBuilder.loadTexts: rtcpXrVoipAlertInfoType.setDescription('Indicates the type of information returned in the\n          rtcpXrVoipAlertInfo parameter.')
rtcpXrVoipAlertPointer = MibScalar((1, 3, 6, 1, 2, 1, 255, 3, 2, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrVoipAlertPointer.setStatus('current')
if mibBuilder.loadTexts: rtcpXrVoipAlertPointer.setDescription('Pointer to the table of call session information to \n         identify the specific call that triggered the alert.')
rtcpXrVoipAlertSeverity = MibScalar((1, 3, 6, 1, 2, 1, 255, 3, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtcpXrVoipAlertSeverity.setReference('See Alarm MIB - RFC3877.')
if mibBuilder.loadTexts: rtcpXrVoipAlertSeverity.setStatus('current')
if mibBuilder.loadTexts: rtcpXrVoipAlertSeverity.setDescription('The severity of the alert as defined in ITU-T X.733 and\n        RFC3877.')
rtcpXrCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 255, 2, 1))
rtcpXrGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 255, 2, 2))
rtcpXrFullMetricsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 255, 2, 1, 1)).setObjects(("RTCPXR-MIB", "rtcpXrSessionIDGroup"), ("RTCPXR-MIB", "rtcpXrBaseParamGroup"), ("RTCPXR-MIB", "rtcpXrCallQualityGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrFullMetricsCompliance = rtcpXrFullMetricsCompliance.setStatus('current')
if mibBuilder.loadTexts: rtcpXrFullMetricsCompliance.setDescription('Describes the requirements for conformance to the\n                rtcpXr MIB for VoIP devices that support basic\n                reporting.')
rtcpXrMetricsAlertsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 255, 2, 1, 2)).setObjects(("RTCPXR-MIB", "rtcpXrSessionIDGroup"), ("RTCPXR-MIB", "rtcpXrBaseParamGroup"), ("RTCPXR-MIB", "rtcpXrCallQualityGroup"), ("RTCPXR-MIB", "rtcpXrNotificationParmsGroup"), ("RTCPXR-MIB", "rtcpXrNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrMetricsAlertsCompliance = rtcpXrMetricsAlertsCompliance.setStatus('current')
if mibBuilder.loadTexts: rtcpXrMetricsAlertsCompliance.setDescription('Describes the requirements for conformance to the\n                rtcpXr MIB for VoIP devices that support reporting\n                and alerts.')
rtcpXrMetricsHistoryCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 255, 2, 1, 3)).setObjects(("RTCPXR-MIB", "rtcpXrSessionIDGroup"), ("RTCPXR-MIB", "rtcpXrBaseParamGroup"), ("RTCPXR-MIB", "rtcpXrCallQualityGroup"), ("RTCPXR-MIB", "rtcpXrMIBHistoryGroup"), ("RTCPXR-MIB", "rtcpXrNotificationParmsGroup"), ("RTCPXR-MIB", "rtcpXrNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrMetricsHistoryCompliance = rtcpXrMetricsHistoryCompliance.setStatus('current')
if mibBuilder.loadTexts: rtcpXrMetricsHistoryCompliance.setDescription('Describes the requirements for conformance to the\n                rtcpXr MIB for VoIP devices that support reporting,\n                call history and alerts.')
rtcpXrMinimalCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 255, 2, 1, 4)).setObjects(("RTCPXR-MIB", "rtcpXrSessionIDGroup"), ("RTCPXR-MIB", "rtcpXrBaseParamGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrMinimalCompliance = rtcpXrMinimalCompliance.setStatus('current')
if mibBuilder.loadTexts: rtcpXrMinimalCompliance.setDescription('Describes the minimal requirements for conformance to \n                the rtcpXr MIB - NOT RECOMMENDED.')
rtcpXrSessionIDGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 255, 2, 2, 1)).setObjects(("RTCPXR-MIB", "rtcpXrSessionIDSessionIdentifier"), ("RTCPXR-MIB", "rtcpXrSessionIDCallStartTime"), ("RTCPXR-MIB", "rtcpXrSessionIDCallStopTime"), ("RTCPXR-MIB", "rtcpXrSessionIDSourceIPtype"), ("RTCPXR-MIB", "rtcpXrSessionIDSourceIPaddress"), ("RTCPXR-MIB", "rtcpXrSessionIDSourceRTPport"), ("RTCPXR-MIB", "rtcpXrSessionIDSourceRTCPport"), ("RTCPXR-MIB", "rtcpXrSessionIDDestIPtype"), ("RTCPXR-MIB", "rtcpXrSessionIDDestIPaddress"), ("RTCPXR-MIB", "rtcpXrSessionIDDestRTPport"), ("RTCPXR-MIB", "rtcpXrSessionIDDestRTCPport"), ("RTCPXR-MIB", "rtcpXrSessionIDDestIdentifier"), ("RTCPXR-MIB", "rtcpXrSessionIDDestIdenType"), ("RTCPXR-MIB", "rtcpXrSessionIDSrceIdentifier"), ("RTCPXR-MIB", "rtcpXrSessionIDSrceIdenType"), ("RTCPXR-MIB", "rtcpXrSessionIDMeasurePt"), ("RTCPXR-MIB", "rtcpXrSessionIDMeasurePtID"), ("RTCPXR-MIB", "rtcpXrSessionIDReverseSession"), ("RTCPXR-MIB", "rtcpXrSessionIDAltMeasurePt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrSessionIDGroup = rtcpXrSessionIDGroup.setStatus('current')
if mibBuilder.loadTexts: rtcpXrSessionIDGroup.setDescription('Session ID objects used in rtcpXr VoIP Metrics MIB')
rtcpXrBaseParamGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 255, 2, 2, 2)).setObjects(("RTCPXR-MIB", "rtcpXrBaseParamVocoderType"), ("RTCPXR-MIB", "rtcpXrBaseParamVocoderRate"), ("RTCPXR-MIB", "rtcpXrBaseParamFrameDuration"), ("RTCPXR-MIB", "rtcpXrBaseParamSampleRate"), ("RTCPXR-MIB", "rtcpXrBaseParamDurationMs"), ("RTCPXR-MIB", "rtcpXrBaseParamNetworkLossRate"), ("RTCPXR-MIB", "rtcpXrBaseParamAvgDiscardRate"), ("RTCPXR-MIB", "rtcpXrBaseParamBurstLossDensity"), ("RTCPXR-MIB", "rtcpXrBaseParamBurstLenMs"), ("RTCPXR-MIB", "rtcpXrBaseParamGapLossDensity"), ("RTCPXR-MIB", "rtcpXrBaseParamGapLenMs"), ("RTCPXR-MIB", "rtcpXrBaseParamAvgOWDelay"), ("RTCPXR-MIB", "rtcpXrBaseParamAvgEndSysDelay"), ("RTCPXR-MIB", "rtcpXrBaseParamPlcType"), ("RTCPXR-MIB", "rtcpXrBaseParamJBuffAdaptMode"), ("RTCPXR-MIB", "rtcpXrBaseParamJBuffAdaptRate"), ("RTCPXR-MIB", "rtcpXrBaseParamJBuffAverageDelay"), ("RTCPXR-MIB", "rtcpXrBaseParamJBuffMaximumDelay"), ("RTCPXR-MIB", "rtcpXrBaseParamJBuffAbsMaxDelay"), ("RTCPXR-MIB", "rtcpXrBaseParamJitterLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrBaseParamGroup = rtcpXrBaseParamGroup.setStatus('current')
if mibBuilder.loadTexts: rtcpXrBaseParamGroup.setDescription('Objects used in rtcpXr VoIP Metrics MIB')
rtcpXrCallQualityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 255, 2, 2, 3)).setObjects(("RTCPXR-MIB", "rtcpXrCallQualityNoiseLeveldBm"), ("RTCPXR-MIB", "rtcpXrCallQualitySignalLeveldBm"), ("RTCPXR-MIB", "rtcpXrCallQualityLocalRERLdB"), ("RTCPXR-MIB", "rtcpXrCallQualityRemoteRERLdB"), ("RTCPXR-MIB", "rtcpXrCallQualityRCQ"), ("RTCPXR-MIB", "rtcpXrCallQualityRLQ"), ("RTCPXR-MIB", "rtcpXrCallQualityExternalRCQ"), ("RTCPXR-MIB", "rtcpXrCallQualityMOSCQ"), ("RTCPXR-MIB", "rtcpXrCallQualityMOSLQ"), ("RTCPXR-MIB", "rtcpXrCallQualityAlgorithm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrCallQualityGroup = rtcpXrCallQualityGroup.setStatus('current')
if mibBuilder.loadTexts: rtcpXrCallQualityGroup.setDescription('Call quality objects used in rtcpXr VoIP Metrics MIB')
rtcpXrMIBHistoryGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 255, 2, 2, 4)).setObjects(("RTCPXR-MIB", "rtcpXrHistoryGroupName"), ("RTCPXR-MIB", "rtcpXrHistoryStartTime"), ("RTCPXR-MIB", "rtcpXrHistoryStopTime"), ("RTCPXR-MIB", "rtcpXrHistoryNumOfSessions"), ("RTCPXR-MIB", "rtcpXrHistoryMinDurationMs"), ("RTCPXR-MIB", "rtcpXrHistoryMaxDurationMs"), ("RTCPXR-MIB", "rtcpXrHistoryAvgDurationMs"), ("RTCPXR-MIB", "rtcpXrHistoryMaxNetworkLossRate"), ("RTCPXR-MIB", "rtcpXrHistoryAvgNetworkLossRate"), ("RTCPXR-MIB", "rtcpXrHistoryMaxDiscardRate"), ("RTCPXR-MIB", "rtcpXrHistoryAvgDiscardRate"), ("RTCPXR-MIB", "rtcpXrHistoryMaxBurstLossDensity"), ("RTCPXR-MIB", "rtcpXrHistoryAvgBurstLossDensity"), ("RTCPXR-MIB", "rtcpXrHistoryMinBurstLenMs"), ("RTCPXR-MIB", "rtcpXrHistoryMaxBurstLenMs"), ("RTCPXR-MIB", "rtcpXrHistoryAvgBurstLenMs"), ("RTCPXR-MIB", "rtcpXrHistoryMaxGapLossDensity"), ("RTCPXR-MIB", "rtcpXrHistoryAvgGapLossDensity"), ("RTCPXR-MIB", "rtcpXrHistoryMinGapLenMs"), ("RTCPXR-MIB", "rtcpXrHistoryMaxGapLenMs"), ("RTCPXR-MIB", "rtcpXrHistoryAvgGapLenMs"), ("RTCPXR-MIB", "rtcpXrHistoryMinOneWayDelay"), ("RTCPXR-MIB", "rtcpXrHistoryMaxOneWayDelay"), ("RTCPXR-MIB", "rtcpXrHistoryAvgOneWayDelay"), ("RTCPXR-MIB", "rtcpXrHistoryMinEndSystemDelay"), ("RTCPXR-MIB", "rtcpXrHistoryMaxEndSystemDelay"), ("RTCPXR-MIB", "rtcpXrHistoryAvgEndSystemDelay"), ("RTCPXR-MIB", "rtcpXrHistoryAvgJitterLevel"), ("RTCPXR-MIB", "rtcpXrHistoryMinJitterLevel"), ("RTCPXR-MIB", "rtcpXrHistoryMaxJitterLevel"), ("RTCPXR-MIB", "rtcpXrHistoryMinNoiseLeveldBm"), ("RTCPXR-MIB", "rtcpXrHistoryMaxNoiseLeveldBm"), ("RTCPXR-MIB", "rtcpXrHistoryAvgNoiseLeveldBm"), ("RTCPXR-MIB", "rtcpXrHistoryNoiseLevelCount"), ("RTCPXR-MIB", "rtcpXrHistoryMinSignalLeveldBm"), ("RTCPXR-MIB", "rtcpXrHistoryMaxSignalLeveldBm"), ("RTCPXR-MIB", "rtcpXrHistoryAvgSignalLeveldBm"), ("RTCPXR-MIB", "rtcpXrHistorySignalLevelCount"), ("RTCPXR-MIB", "rtcpXrHistoryMinLocalRERLdB"), ("RTCPXR-MIB", "rtcpXrHistoryMaxLocalRERLdB"), ("RTCPXR-MIB", "rtcpXrHistoryAvgLocalRERLdB"), ("RTCPXR-MIB", "rtcpXrHistoryLocalRERLCount"), ("RTCPXR-MIB", "rtcpXrHistoryMinRemoteRERLdB"), ("RTCPXR-MIB", "rtcpXrHistoryMaxRemoteRERLdB"), ("RTCPXR-MIB", "rtcpXrHistoryAvgRemoteRERLdB"), ("RTCPXR-MIB", "rtcpXrHistoryRemoteRERLCount"), ("RTCPXR-MIB", "rtcpXrHistoryMinRCQ"), ("RTCPXR-MIB", "rtcpXrHistoryMaxRCQ"), ("RTCPXR-MIB", "rtcpXrHistoryAvgRCQ"), ("RTCPXR-MIB", "rtcpXrHistoryRCQCount"), ("RTCPXR-MIB", "rtcpXrHistoryMinRLQ"), ("RTCPXR-MIB", "rtcpXrHistoryMaxRLQ"), ("RTCPXR-MIB", "rtcpXrHistoryAvgRLQ"), ("RTCPXR-MIB", "rtcpXrHistoryRLQCount"), ("RTCPXR-MIB", "rtcpXrHistoryMinMOSCQ"), ("RTCPXR-MIB", "rtcpXrHistoryMaxMOSCQ"), ("RTCPXR-MIB", "rtcpXrHistoryAvgMOSCQ"), ("RTCPXR-MIB", "rtcpXrHistoryMOSCQCount"), ("RTCPXR-MIB", "rtcpXrHistoryMinMOSLQ"), ("RTCPXR-MIB", "rtcpXrHistoryMaxMOSLQ"), ("RTCPXR-MIB", "rtcpXrHistoryAvgMOSLQ"), ("RTCPXR-MIB", "rtcpXrHistoryMOSLQCount"), ("RTCPXR-MIB", "rtcpXrHistoryCQAlgorithm"), ("RTCPXR-MIB", "rtcpXrHistoryReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrMIBHistoryGroup = rtcpXrMIBHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: rtcpXrMIBHistoryGroup.setDescription('Objects used in rtcpXr VoIP History MIB')
rtcpXrNotificationParmsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 255, 2, 2, 5)).setObjects(("RTCPXR-MIB", "rtcpXrVoipAlertSeverity"), ("RTCPXR-MIB", "rtcpXrVoipAlertType"), ("RTCPXR-MIB", "rtcpXrVoipAlertInfoType"), ("RTCPXR-MIB", "rtcpXrVoipAlertPointer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrNotificationParmsGroup = rtcpXrNotificationParmsGroup.setStatus('current')
if mibBuilder.loadTexts: rtcpXrNotificationParmsGroup.setDescription('Notification parameters emitted by a rtcpXr endpoint.')
rtcpXrNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 255, 2, 2, 6)).setObjects(("RTCPXR-MIB", "rtcpXrVoipThresholdViolation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtcpXrNotificationsGroup = rtcpXrNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: rtcpXrNotificationsGroup.setDescription('Notifications emitted by a rtcpXr endpoint.')
mibBuilder.exportSymbols("RTCPXR-MIB", rtcpXrHistoryMinRCQ=rtcpXrHistoryMinRCQ, rtcpXrHistoryMaxOneWayDelay=rtcpXrHistoryMaxOneWayDelay, rtcpXrBaseParamVocoderRate=rtcpXrBaseParamVocoderRate, rtcpXrSessionIDDestIPaddress=rtcpXrSessionIDDestIPaddress, rtcpXrCallQualityAlgorithm=rtcpXrCallQualityAlgorithm, rtcpXrHistoryMaxBurstLenMs=rtcpXrHistoryMaxBurstLenMs, rtcpXrSessionIDSourceRTCPport=rtcpXrSessionIDSourceRTCPport, rtcpXrHistoryAvgNetworkLossRate=rtcpXrHistoryAvgNetworkLossRate, rtcpXrHistoryIndex=rtcpXrHistoryIndex, rtcpXrSessionIDSrceIdentifier=rtcpXrSessionIDSrceIdentifier, rtcpXrBaseParamAvgDiscardRate=rtcpXrBaseParamAvgDiscardRate, rtcpXrCallQualityRLQ=rtcpXrCallQualityRLQ, rtcpXrHistoryMinMOSLQ=rtcpXrHistoryMinMOSLQ, rtcpXrHistoryMinBurstLenMs=rtcpXrHistoryMinBurstLenMs, rtcpXrHistoryAvgNoiseLeveldBm=rtcpXrHistoryAvgNoiseLeveldBm, rtcpXrBaseParamGroup=rtcpXrBaseParamGroup, rtcpXrBaseParamFrameDuration=rtcpXrBaseParamFrameDuration, rtcpXrHistoryMaxRLQ=rtcpXrHistoryMaxRLQ, rtcpXrBaseParamJBuffAdaptMode=rtcpXrBaseParamJBuffAdaptMode, rtcpXrBaseParamJitterLevel=rtcpXrBaseParamJitterLevel, rtcpXrHistoryMaxDiscardRate=rtcpXrHistoryMaxDiscardRate, rtcpXrMIB=rtcpXrMIB, rtcpXrHistoryMinNoiseLeveldBm=rtcpXrHistoryMinNoiseLeveldBm, rtcpXrSessionIDAltMeasurePt=rtcpXrSessionIDAltMeasurePt, rtcpXrFullMetricsCompliance=rtcpXrFullMetricsCompliance, rtcpXrBaseParamGapLossDensity=rtcpXrBaseParamGapLossDensity, rtcpXrHistoryMinSignalLeveldBm=rtcpXrHistoryMinSignalLeveldBm, rtcpXrHistoryRCQCount=rtcpXrHistoryRCQCount, rtcpXrBaseParamJBuffMaximumDelay=rtcpXrBaseParamJBuffMaximumDelay, rtcpXrBaseParamNetworkLossRate=rtcpXrBaseParamNetworkLossRate, rtcpXrHistoryAvgJitterLevel=rtcpXrHistoryAvgJitterLevel, rtcpXrHistoryAvgDurationMs=rtcpXrHistoryAvgDurationMs, rtcpXrHistoryLocalRERLCount=rtcpXrHistoryLocalRERLCount, rtcpXrNotificationsGroup=rtcpXrNotificationsGroup, rtcpXrSessionIDSrceIdenType=rtcpXrSessionIDSrceIdenType, rtcpXrSessionIDDestIPtype=rtcpXrSessionIDDestIPtype, rtcpXrHistoryMinOneWayDelay=rtcpXrHistoryMinOneWayDelay, rtcpXrHistoryMaxEndSystemDelay=rtcpXrHistoryMaxEndSystemDelay, rtcpXrHistoryMOSCQCount=rtcpXrHistoryMOSCQCount, rtcpXrHistoryAvgDiscardRate=rtcpXrHistoryAvgDiscardRate, rtcpXrBaseParamJBuffAverageDelay=rtcpXrBaseParamJBuffAverageDelay, rtcpXrSessionIDEntry=rtcpXrSessionIDEntry, rtcpXrSessionIDDestIdentifier=rtcpXrSessionIDDestIdentifier, rtcpXrCallQualityRemoteRERLdB=rtcpXrCallQualityRemoteRERLdB, rtcpXrHistoryAvgBurstLossDensity=rtcpXrHistoryAvgBurstLossDensity, rtcpXrBaseParamBurstLenMs=rtcpXrBaseParamBurstLenMs, rtcpXrHistoryStopTime=rtcpXrHistoryStopTime, rtcpXrHistoryAvgSignalLeveldBm=rtcpXrHistoryAvgSignalLeveldBm, rtcpXrHistoryMaxSignalLeveldBm=rtcpXrHistoryMaxSignalLeveldBm, rtcpXrBaseParamAvgEndSysDelay=rtcpXrBaseParamAvgEndSysDelay, rtcpXrSessionIDSourceIPtype=rtcpXrSessionIDSourceIPtype, rtcpXrBaseParamVocoderType=rtcpXrBaseParamVocoderType, rtcpXrSessionIDReverseSession=rtcpXrSessionIDReverseSession, rtcpXrHistoryMaxDurationMs=rtcpXrHistoryMaxDurationMs, rtcpXrHistoryMaxNoiseLeveldBm=rtcpXrHistoryMaxNoiseLeveldBm, rtcpXrEventParam=rtcpXrEventParam, rtcpXrHistoryAvgGapLenMs=rtcpXrHistoryAvgGapLenMs, rtcpXrVoipAlertPointer=rtcpXrVoipAlertPointer, rtcpXrHistoryTable=rtcpXrHistoryTable, rtcpXrSessionIDCallStartTime=rtcpXrSessionIDCallStartTime, rtcpXrCallQualityEntry=rtcpXrCallQualityEntry, rtcpXrHistoryAvgLocalRERLdB=rtcpXrHistoryAvgLocalRERLdB, rtcpXrHistoryMaxGapLenMs=rtcpXrHistoryMaxGapLenMs, rtcpXrVoipAlertSeverity=rtcpXrVoipAlertSeverity, rtcpXrHistoryMaxRCQ=rtcpXrHistoryMaxRCQ, rtcpXrHistoryAvgRemoteRERLdB=rtcpXrHistoryAvgRemoteRERLdB, rtcpXrHistoryMaxNetworkLossRate=rtcpXrHistoryMaxNetworkLossRate, rtcpXrSessionIDSourceIPaddress=rtcpXrSessionIDSourceIPaddress, rtcpXrHistoryMinMOSCQ=rtcpXrHistoryMinMOSCQ, rtcpXrBaseParamTable=rtcpXrBaseParamTable, rtcpXrCallQualityMOSLQ=rtcpXrCallQualityMOSLQ, rtcpXrBaseParamSampleRate=rtcpXrBaseParamSampleRate, Rfactor=Rfactor, rtcpXrCompliances=rtcpXrCompliances, rtcpXrSessionIDMeasurePtID=rtcpXrSessionIDMeasurePtID, rtcpXrHistoryRemoteRERLCount=rtcpXrHistoryRemoteRERLCount, rtcpXrSessionIDDestIdenType=rtcpXrSessionIDDestIdenType, rtcpXrCallQualityNoiseLeveldBm=rtcpXrCallQualityNoiseLeveldBm, rtcpXrHistoryAvgGapLossDensity=rtcpXrHistoryAvgGapLossDensity, rtcpXrMetricsHistoryCompliance=rtcpXrMetricsHistoryCompliance, rtcpXrSessionIDMeasurePt=rtcpXrSessionIDMeasurePt, rtcpXrCallQualitySignalLeveldBm=rtcpXrCallQualitySignalLeveldBm, rtcpXrHistoryMaxRemoteRERLdB=rtcpXrHistoryMaxRemoteRERLdB, rtcpXrVoipThresholdViolation=rtcpXrVoipThresholdViolation, rtcpXrCallQualityRCQ=rtcpXrCallQualityRCQ, rtcpXrMIBHistoryGroup=rtcpXrMIBHistoryGroup, rtcpXrBaseParamPlcType=rtcpXrBaseParamPlcType, rtcpXrHistoryMinLocalRERLdB=rtcpXrHistoryMinLocalRERLdB, rtcpXrCallQualityTable=rtcpXrCallQualityTable, PYSNMP_MODULE_ID=rtcpXrMIB, rtcpXrEvents=rtcpXrEvents, rtcpXrBaseParamJBuffAbsMaxDelay=rtcpXrBaseParamJBuffAbsMaxDelay, rtcpXrSessionIDSourceRTPport=rtcpXrSessionIDSourceRTPport, rtcpXrHistoryAvgRCQ=rtcpXrHistoryAvgRCQ, rtcpXrHistoryMOSLQCount=rtcpXrHistoryMOSLQCount, ScaledMOSscore=ScaledMOSscore, rtcpXrMetricsAlertsCompliance=rtcpXrMetricsAlertsCompliance, rtcpXrHistoryMinRemoteRERLdB=rtcpXrHistoryMinRemoteRERLdB, rtcpXrHistoryMaxMOSCQ=rtcpXrHistoryMaxMOSCQ, rtcpXrHistoryReset=rtcpXrHistoryReset, rtcpXrHistoryEntry=rtcpXrHistoryEntry, rtcpXrHistoryMaxBurstLossDensity=rtcpXrHistoryMaxBurstLossDensity, rtcpXrCallQualityLocalRERLdB=rtcpXrCallQualityLocalRERLdB, rtcpXrHistorySignalLevelCount=rtcpXrHistorySignalLevelCount, rtcpXrHistoryAvgBurstLenMs=rtcpXrHistoryAvgBurstLenMs, rtcpXrBaseParamAvgOWDelay=rtcpXrBaseParamAvgOWDelay, Percentage=Percentage, rtcpXrSessionIDDestRTCPport=rtcpXrSessionIDDestRTCPport, rtcpXrBaseParamJBuffAdaptRate=rtcpXrBaseParamJBuffAdaptRate, rtcpXrHistoryAvgEndSystemDelay=rtcpXrHistoryAvgEndSystemDelay, rtcpXrHistoryNumOfSessions=rtcpXrHistoryNumOfSessions, rtcpXrNotificationParmsGroup=rtcpXrNotificationParmsGroup, rtcpXrSessionIDIndex=rtcpXrSessionIDIndex, rtcpXrHistoryMinEndSystemDelay=rtcpXrHistoryMinEndSystemDelay, rtcpXrHistoryCQAlgorithm=rtcpXrHistoryCQAlgorithm, rtcpXrHistoryMinDurationMs=rtcpXrHistoryMinDurationMs, rtcpXrBaseParamGapLenMs=rtcpXrBaseParamGapLenMs, rtcpXrHistoryStartTime=rtcpXrHistoryStartTime, rtcpXrHistoryRLQCount=rtcpXrHistoryRLQCount, rtcpXrVoipAlertInfoType=rtcpXrVoipAlertInfoType, rtcpXrSessionIDTable=rtcpXrSessionIDTable, rtcpXrHistoryGroupName=rtcpXrHistoryGroupName, rtcpXrHistoryNoiseLevelCount=rtcpXrHistoryNoiseLevelCount, rtcpXrHistoryAvgMOSLQ=rtcpXrHistoryAvgMOSLQ, rtcpXrHistoryMinGapLenMs=rtcpXrHistoryMinGapLenMs, rtcpXrHistoryMinRLQ=rtcpXrHistoryMinRLQ, rtcpXrConformance=rtcpXrConformance, rtcpXrSessionIDCallStopTime=rtcpXrSessionIDCallStopTime, rtcpXrMinimalCompliance=rtcpXrMinimalCompliance, rtcpXrGroups=rtcpXrGroups, rtcpXrHistoryMaxGapLossDensity=rtcpXrHistoryMaxGapLossDensity, rtcpXrSessionIDGroup=rtcpXrSessionIDGroup, rtcpXrCallQualityExternalRCQ=rtcpXrCallQualityExternalRCQ, rtcpXrHistoryMaxJitterLevel=rtcpXrHistoryMaxJitterLevel, rtcpXrVoipAlertType=rtcpXrVoipAlertType, rtcpXrHistoryAvgOneWayDelay=rtcpXrHistoryAvgOneWayDelay, rtcpXrCallQualityGroup=rtcpXrCallQualityGroup, rtcpXrHistoryMaxLocalRERLdB=rtcpXrHistoryMaxLocalRERLdB, LeveldB=LeveldB, rtcpXrCallQualityMOSCQ=rtcpXrCallQualityMOSCQ, rtcpXrBaseParamBurstLossDensity=rtcpXrBaseParamBurstLossDensity, rtcpXrBaseParamEntry=rtcpXrBaseParamEntry, rtcpXrHistoryAvgRLQ=rtcpXrHistoryAvgRLQ, rtcpXrSessionIDSessionIdentifier=rtcpXrSessionIDSessionIdentifier, rtcpXrSessionIDDestRTPport=rtcpXrSessionIDDestRTPport, rtcpXrHistoryAvgMOSCQ=rtcpXrHistoryAvgMOSCQ, rtcpXrMIBObjects=rtcpXrMIBObjects, rtcpXrHistoryMaxMOSLQ=rtcpXrHistoryMaxMOSLQ, rtcpXrBaseParamDurationMs=rtcpXrBaseParamDurationMs, rtcpXrHistoryMinJitterLevel=rtcpXrHistoryMinJitterLevel)
