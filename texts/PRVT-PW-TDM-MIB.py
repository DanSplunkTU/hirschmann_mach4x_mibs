#
# PySNMP MIB module PRVT-PW-TDM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-PW-TDM-MIB
# Produced by pysmi-1.1.3 at Wed Dec  8 18:20:56 2021
# On host fv-az74-115 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
switch, = mibBuilder.importSymbols("PRVT-SWITCH-MIB", "switch")
PerfCurrentCount, PerfIntervalCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfCurrentCount", "PerfIntervalCount")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
NotificationType, IpAddress, Counter32, Integer32, transmission, ModuleIdentity, Gauge32, TimeTicks, Bits, iso, ObjectIdentity, MibIdentifier, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "IpAddress", "Counter32", "Integer32", "transmission", "ModuleIdentity", "Gauge32", "TimeTicks", "Bits", "iso", "ObjectIdentity", "MibIdentifier", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64")
StorageType, RowStatus, DisplayString, TruthValue, TextualConvention, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "RowStatus", "DisplayString", "TruthValue", "TextualConvention", "TimeStamp")
prvtPwVcTDMMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2))
prvtPwVcTDMMIB.setRevisions(('2019-02-27 00:00', '2009-07-07 00:00', '2009-07-01 00:00', '2009-03-06 00:00', '2009-03-05 00:00', '2009-02-18 00:00', '2009-01-15 00:00', '2008-06-19 00:00', '2006-07-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtPwVcTDMMIB.setRevisionsDescriptions(('Update interval values for :\n prvtPwVcTDMCfgPeerPort\n prvtPwVcTDMCfgLocalPort\n prvtPwVcTDMCfgOosPort\n prvtPwVcTDMCfgPeerOosPort', 'Change the range for prvtPwVcTDMCfgChannelGroup in order \nto support all configurable channels group  for OC3 module', 'Added prvtPwVcTDMCfgRtpOosPayload and prvtPwVcTDMCfgRtpPayload objects.', 'Added MPLS objects.', 'Added Destination Oos Port ', 'Added prvtPwVcTDMCfgIpTos, prvtPwVcTDMCfgIpOosTos', 'Added prvtPwVcTDMCfgInterface, prvtTDMChannelGrpOC3TimeSlots', 'Added prvtPwVcTDMClearCircuitStatistics, prvtPwVcTDMCfgRtp,\nprvtPwVcTDMCfgOosPort, prvtPwVcTDMCfgPayloadSuppression', 'Added Oos Ecid and Vlan priotity objects.',))
if mibBuilder.loadTexts: prvtPwVcTDMMIB.setLastUpdated('200907070000Z')
if mibBuilder.loadTexts: prvtPwVcTDMMIB.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtPwVcTDMMIB.setContactInfo('BATM/Telco Systems Support team\nEmail: \nFor North America: techsupport@telco.com\nFor North Europe: support@batm.de, info@batm.de\nFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtPwVcTDMMIB.setDescription('This MIB contains managed object definitions for\nencapsulating TDM (T1,E1, T3, E3, NxDS0) as\npseudo-wires over packet-switching networks (PSN).')
prvtPwVc = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 200))
class PrvtPwVcTDMCfgIndex(TextualConvention, Unsigned32):
    description = 'Index into any of the relevant prvtPwVcXXXCfgTable.'
    status = 'current'

class TimeSlotList(TextualConvention, OctetString):
    description = 'Each octet within this value specifies a time slot included\nin the give channel group. There should be 32 bits of 4 octets for each \nport of the CES module. Note that if the line type is set to T1 only\nthe first 24 bits of each 4 octests can be set. The most significant bit \nof the list indicates timeslot 1 of port 1, the 33th bit - timeslot 1 of port 2, etc.\nIf the bit is set, the port is included in the given channel group.'
    status = 'current'

class PrvtPwVcTDMCfgInterface(TextualConvention, IpAddress):
    description = 'Interface of the given circuit used in TDM config for OC3 modules '
    status = 'current'

class InterfaceTimeSlot(TextualConvention, OctetString):
    description = 'The first 4 octets of this value represent the interface of \nthe given channel group P.K.L.M.The last 32 bits of the\n4 octets represent a bitmask of the time slots'
    status = 'current'

prvtPwVcTDMObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1))
prvtPwVcTDMTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 2))
prvtPwVcTDMConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3))
prvtPwVcTDMTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1), )
if mibBuilder.loadTexts: prvtPwVcTDMTable.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMTable.setDescription('This table contains basic information including ifIndex,\nand pointers to entries in the relevant TDM config\ntables for this TDM PW.')
prvtPwVcTDMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1), ).setIndexNames((0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMModuleId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMCircuitId"))
if mibBuilder.loadTexts: prvtPwVcTDMEntry.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMEntry.setDescription("This table is indexed by the same index that was\ncreated for the associated entry in the PW Table\n(in the PW-STD-MIB).\nAn entry is created in this table by the agent for every\nentry in the prvtPwVcTable with a prvtPwVcType of 'TDM'.")
prvtPwVcTDMModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMModuleId.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMModuleId.setDescription('The ID of the CES Module where the crcuit is configured. ')
prvtPwVcTDMCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMCircuitId.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCircuitId.setDescription('The ID of the CES Circuit that this PW represents. ')
prvtPwVcTDMType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("ds1", 2), ("e1", 3), ("ds3", 4), ("e3", 5), ("octetAlignedT1", 6), ("nXds0", 7), ("nXds0WithCASe1", 8), ("nXds0WithCASds1Esf", 9), ("nXds0WithCASds1Sf", 10))).clone('e1')).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMType.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMType.setDescription('Specifies the type of TDM PW. The connection assumed to be\nsymmetrical having the same value at both ends. To identify\nstructured vs. unstructured type for DS1 and E1, dsx1LineType\nand dsx1SignalMode [DS1MIB] should be referenced. DS3 and E3\nare always unstructured. ')
prvtPwVcRelTDMCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 4), PrvtPwVcTDMCfgIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcRelTDMCfgIndex.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcRelTDMCfgIndex.setDescription('Index to the relevant TDM configuration table entry\nthat appears in one of the related MIB modules\nsuch as SAToP,TDMoIP or CESoPSN. It is likely that\nmultiple TDM PWs of the same characteristic will share\na single configuration entry of the relevant type.')
prvtPwVcTDMTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 900))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMTimeElapsed.setDescription("The number of seconds, including partial seconds,\nthat have elapsed since the beginning of the current\nmeasurement period. If, for some reason, such as an\nadjustment in the system's time-of-day clock, the\ncurrent interval exceeds the maximum value, the\nagent will return the maximum value.")
prvtPwVcTDMValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMValidIntervals.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMValidIntervals.setDescription('The number of previous 15-minute intervals for which data\nwas collected.\nAn agent with TDM capability must be capable of supporting\nat least n intervals. The minimum value of n is 4, The\ndefault of n is 32 and the maximum value of n is 96.\nThe value will be <n> unless the measurement was (re-)\nstarted within the last (<n>*15) minutes, in which case\nthe value will be the number of complete 15 minute\nintervals for which the agent has at least some data.\nIn certain cases(e.g., in the case where the agent is\na proxy) it is possible that some intervals are unavailable.\nIn this case, this interval is the maximum interval number\nfor which data is available. ')
prvtPwVcTDMCurrentIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 7), Bits().clone(namedValues=NamedValues(("other", 0), ("strayPacket", 1), ("malformedPacket", 2), ("excessivePktLossRate", 3), ("bufferOverrun", 4), ("bufferUnderrun", 5), ("remotePktLoss", 6), ("packetLoss", 7), ("tdmFault", 8), ("packetsLbitCounter", 9), ("packetsRbitCounter", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMCurrentIndications.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCurrentIndications.setDescription("The following defects should be detected and reported\nupon request:\n\n-Stray packets MAY be detected by the PSN and multiplexing\nlayers. Stray packets MUST be discarded by the CE-bound IWF\nand their detection MUST NOT affect mechanisms for detection\nof packet loss.\n\n-Malformed packets are detected by mismatch between the\nexpected packet size (taking the value of the L bit into\naccount) and the actual packet size inferred from the PSN and\nmultiplexing layers. Malformed in-order packets MUST be\ndiscarded by the CE-bound IWF and replacement data generated\nas for lost packets.\n\n-Excessive packet loss rate is detected by computing the\naverage packet loss rate over the value of\nprvtPwVcTDMAvePktLossTimeWindow and comparing it with a\npreconfigured threshold [SATOP].\n\n-Buffer overrun is detected in the normal operation state\nwhen the CE bound IWF's jitter buffer cannot accommodate\nnewly arrived packets.\n\n-Remote packet loss is indicated by reception of packets with\ntheir R bit set.\n\n-Packet misorder is detected by looking at the Sequence\nnumber provided by the control word.\n\n-TDM Fault, if L bit in the control word is set, it indicates\nthat TDM data carried in the payload is invalid due an\nattachment circuit fault. When the L bit is set the payload\nMAY be omitted in order to conserve bandwidth.\n\nNote: the algorithm used to capture these indications\nis implementation specific.")
prvtPwVcTDMLatchedIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 8), Bits().clone(namedValues=NamedValues(("other", 0), ("staryPacket", 1), ("malformedPacket", 2), ("excessivePktLossRate", 3), ("bufferOverrun", 4), ("bufferUnderrun", 5), ("remotePktLoss", 6), ("packetLoss", 7), ("tdmFault", 8), ("packetsLbitCounter", 9), ("packetsRbitCounter", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMLatchedIndications.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMLatchedIndications.setDescription('The state of TDM indicators when the TDM PW last declared\nan error second (either as ES, SES or a second with\nerrors inside a UAS) condition. At this time, only LOPS\ncan create a failure. Since indicators other than LOPS are\nuseful, all are latched here. For bit definitions, see\nprvtPwVcTDMCurrentIndications above.\n\nNote: the algorithm used to latch these indications when\nentering an defect state is implementation specific.')
prvtPwVcTDMLastEsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMLastEsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMLastEsTimeStamp.setDescription('The value of sysUpTime on the most recent occasion at\nwhich the TDM PW entered the ES or SES state.')
prvtPwVcTDMEmulationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("undefined", 0), ("structured", 1), ("unstuctured", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMEmulationMode.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMEmulationMode.setDescription('The circuit emulation mode.')
prvtPwVcTDMOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMOperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMOperStatus.setDescription('The operational status of the circuit.')
prvtPwVcTDMClearCircuitStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prvtPwVcTDMClearCircuitStatistics.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMClearCircuitStatistics.setDescription('Clear circuit statistics.')
prvtPwVcTDMCfgTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3), )
if mibBuilder.loadTexts: prvtPwVcTDMCfgTable.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgTable.setDescription('This table contains a set of parameters that may be\nreferenced by one or more TDM PWs in prvtPwVcTDMTable.')
prvtPwVcTDMCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1), ).setIndexNames((0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMModuleId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMCircuitId"))
if mibBuilder.loadTexts: prvtPwVcTDMCfgEntry.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgEntry.setDescription('These parameters define the characteristics of a\nTDM PW. They are grouped here to ease NMS burden.\nOnce an entry is created here it may be re-used\nby many PWs.')
prvtPwVcTDMCfgPayloadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 1), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPayloadSize.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPayloadSize.setDescription('The value of this object indicates the PayLoad Size to\nbe defined during the PW setUp. Upon TX, implementation\nmust be capable of carrying that amount of data.\nUpon RX, When the LEN field is set to 0, the payload of\npacket MUST assume this size, and if the actual\npacket size is inconsistent with this length,\nthe packet MUST be considered to be malformed. ')
prvtPwVcTDMCfgPktReorder = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 2), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPktReorder.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPktReorder.setDescription('If set True: as CE bound packets are queued in the\njitter buffer, out of order packets are re-ordered. The\nmaximum sequence number differential (i.e., the range in\nwhich re-sequencing can occur) is dependant on the depth\nof the jitter buffer. See prvtPwVcTDMCfgJtrBfrDepth.\n\nNOTE: Some implementations may not support this feature.\nThe agent is then required to set this False.')
prvtPwVcTDMCfgRtpHdrUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtpHdrUsed.setReference('See [SATOP]')
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtpHdrUsed.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtpHdrUsed.setDescription('If set False: an RTP header is not pre-pended to the\nTDM packet.')
prvtPwVcTDMCfgJtrBfrDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)).clone(3)).setUnits('millisecond').setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgJtrBfrDepth.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgJtrBfrDepth.setDescription("The size of the Jitter buffer SHOULD be defined to\na value that is capable to allow accommodation to the\nPSN-specific packet delay variation.\n\nIf configured to a value not supported by the\nimplementation, the agent MUST return an error code\n'jtrBfrDepth' in 'prvtPwVcTDMConfigError '\n\nNOTE: jitter buffers are a limited resource to\nbe managed.")
prvtPwVcTDMCfgChannelGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgChannelGroup.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgChannelGroup.setDescription("The circuit's channel group. This object is only valid if structured emulation mode is used.\nIf a group is not set the value of the object is 0.")
prvtPwVcTDMCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 6), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPorts.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPorts.setDescription("A bitmap of themodule's TDM ports belongng to the circuit. ")
prvtPwVcTDMCfgPeerIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 6, 16))).clone(namedValues=NamedValues(("ipv4", 4), ("ipv6", 6), ("dns", 16)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerIpType.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerIpType.setDescription("The type of the peer's IP address. ")
prvtPwVcTDMCfgPeerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerIpAddress.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerIpAddress.setDescription("The peer's IP address. ")
prvtPwVcTDMCfgPeerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerPort.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerPort.setDescription('The connection port. ')
prvtPwVcTDMCfgPeerMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 10), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerMAC.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerMAC.setDescription('The Peer MAC address. This object is only valid for Metro-Ethernet and Mpls circuits.\nIf an IP address is configured for the circuit, this object will display\nthe resolved MAC address.')
prvtPwVcTDMCfgPeerEcid = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerEcid.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerEcid.setDescription('The peer circuit identifier. This object is only valid if the Circuit protocol is metro-ethernet. ')
prvtPwVcTDMCfgPeerOosEcid = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerOosEcid.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerOosEcid.setDescription('The peer circuit identifier for the out-of-band signaling. This value is valid only when the object\nprvtPwVcTDMCfgEcid is set and when the current protocol is metro-ethernet')
prvtPwVcTDMCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4094))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgVlanId.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgVlanId.setDescription('The circuit Vlan ID. ')
prvtPwVcTDMCfgVlanPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgVlanPrio.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgVlanPrio.setDescription('The prioirty for the VLAN set here, when the protocol for the circuit is metro-ethernet')
prvtPwVcTDMCfgLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgLocalPort.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgLocalPort.setDescription('Local UDP port. ')
prvtPwVcTDMCfgEcid = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgEcid.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgEcid.setDescription('The local circuit identifier. This object is only valid if the Circuit protocol is metro-ethernet. ')
prvtPwVcTDMCfgOosEcid = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgOosEcid.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgOosEcid.setDescription('The local circuit identifier for the out-of-band signaling. This value is valid only when the object\nprvtPwVcTDMCfgEcid is set and when the current protocol is metro-ethernet')
prvtPwVcTDMCfgProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 0), ("satop", 1), ("cesopsn", 2), ("metro-ethernet", 3), ("mpls", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgProtocol.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgProtocol.setDescription('The emulation protocol.')
prvtPwVcTDMCfgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgAdminStatus.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgAdminStatus.setDescription('The administrative status of the circuit.')
prvtPwVcTDMCfgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgRowStatus.setDescription('This field is used to create and destroy TDM circuits.')
prvtPwVcTDMCfgRtp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtp.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtp.setDescription('TRTP header.')
prvtPwVcTDMCfgOosPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgOosPort.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgOosPort.setDescription('Oos port.')
prvtPwVcTDMCfgPayloadSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPayloadSuppression.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPayloadSuppression.setDescription('Controls payload suppression. Object does not require module to be restarted.')
prvtPwVcTDMCfgInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 24), PrvtPwVcTDMCfgInterface()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgInterface.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgInterface.setDescription('Interface used for configuring OC3 TDM circuits \nP - Port Number, K,L,M standard numbering of SONET/SDH.')
prvtPwVcTDMCfgIpTos = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgIpTos.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgIpTos.setDescription('Set/Show IP TOS information')
prvtPwVcTDMCfgIpOosTos = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgIpOosTos.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgIpOosTos.setDescription('Set/Show IP Out Of Stream information')
prvtPwVcTDMCfgPeerOosPort = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerOosPort.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgPeerOosPort.setDescription('This field is used to SET Destination Oos Port')
prvtPwVcTDMCfgMplsLocalLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)).clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsLocalLabel.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsLocalLabel.setDescription('The local circuit identifier. This object is only valid if the Circuit protocol is MPLS ')
prvtPwVcTDMCfgMplsPeerLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)).clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsPeerLabel.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsPeerLabel.setDescription('The peer circuit identifier. This object is only valid if the Circuit protocol is MPLS ')
prvtPwVcTDMCfgMplsTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsTTL.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsTTL.setDescription('MPLS TTL ')
prvtPwVcTDMCfgMplsExp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsExp.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsExp.setDescription('MPLS EXP ')
prvtPwVcTDMCfgMplsOosLocalLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosLocalLabel.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosLocalLabel.setDescription('The local circuit identifier  for the out-of-band signaling. This object is only valid if the Circuit protocol is MPLS ')
prvtPwVcTDMCfgMplsOosPeerLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosPeerLabel.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosPeerLabel.setDescription('The peer circuit identifier  for the out-of-band signaling. This object is only valid if the Circuit protocol is MPLS ')
prvtPwVcTDMCfgMplsOosTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosTTL.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosTTL.setDescription('MPLS TTL for the out-of-band signaling.')
prvtPwVcTDMCfgMplsOosExp = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosExp.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgMplsOosExp.setDescription('MPLS EXP for the out-of-band signaling.')
prvtPwVcTDMCfgRtpOosPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtpOosPayload.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtpOosPayload.setDescription('This field is used to SET RTP Oos payload type.')
prvtPwVcTDMCfgRtpPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 3, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtpPayload.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMCfgRtpPayload.setDescription('This field is used to SET RTP payload type.')
prvtTDMChannelGrpTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 4), )
if mibBuilder.loadTexts: prvtTDMChannelGrpTable.setStatus('current')
if mibBuilder.loadTexts: prvtTDMChannelGrpTable.setDescription('This table contains the set of available channel groups.')
prvtTDMChannelGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 4, 1), ).setIndexNames((0, "PRVT-PW-TDM-MIB", "prvtTDMChannelGrpModuleID"), (0, "PRVT-PW-TDM-MIB", "prvtTDMChannelGrpID"))
if mibBuilder.loadTexts: prvtTDMChannelGrpEntry.setStatus('current')
if mibBuilder.loadTexts: prvtTDMChannelGrpEntry.setDescription('These parameters are used to configure a CES channel group.')
prvtTDMChannelGrpModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 4, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtTDMChannelGrpModuleID.setStatus('current')
if mibBuilder.loadTexts: prvtTDMChannelGrpModuleID.setDescription('The index of the module to which this channel group belongs. ')
prvtTDMChannelGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 4, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtTDMChannelGrpID.setStatus('current')
if mibBuilder.loadTexts: prvtTDMChannelGrpID.setDescription('The channel group ID.')
prvtTDMChannelGrpCfgError = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("channelGroupAtached", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtTDMChannelGrpCfgError.setStatus('current')
if mibBuilder.loadTexts: prvtTDMChannelGrpCfgError.setDescription('This object displays the correctness of the configuration. If it has a value of \nchannelGroupAtached(1) this channel group has been attached to a circuit and the \nnew configuration cannot be applied.')
prvtTDMChannelGrpTimeSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 4, 1, 4), TimeSlotList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prvtTDMChannelGrpTimeSlots.setStatus('current')
if mibBuilder.loadTexts: prvtTDMChannelGrpTimeSlots.setDescription('This object is used to configure  which time slots are members of the given\nchannel group.')
prvtTDMChannelGrpOC3TimeSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 4, 1, 5), InterfaceTimeSlot()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prvtTDMChannelGrpOC3TimeSlots.setStatus('current')
if mibBuilder.loadTexts: prvtTDMChannelGrpOC3TimeSlots.setDescription('This object is used to configure  interface and time slots  for the given channel\ngroup in OC3 module.')
prvtPwVcTDMPerfCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5), )
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentTable.setDescription('The current 15 minute interval counts are in\nthis table.\n\nThis table provides per TDM PW performance information.')
prvtPwVcTDMPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5, 1), ).setIndexNames((0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMModuleId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMCircuitId"))
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentEntry.setDescription('An entry in this table is created by the agent for every\nprvtPwVcTDM entry. After 15 minutes, the contents of this table\nentry are copied to a new entry in the prvtPwVcTDMPerfInterval\ntable and the counts in this entry are reset to zero.')
prvtPwVcTDMPerfCurrentPktsOoseq = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentPktsOoseq.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentPktsOoseq.setDescription('Number of packets detected out of sequence (via TDM\nheader sequence numbers), but successfully re-ordered.\nNote: some implementations may not support this\nFeature.')
prvtPwVcTDMPerfCurrentJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentJtrBfrUnderruns.setDescription('Number of times a packet needed to be played\nout and the jitter buffer was empty.')
prvtPwVcTDMPerfCurrentJtrBfrOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentJtrBfrOverruns.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentJtrBfrOverruns.setDescription('Number of packets detected out of range (via TDM\nheader sequence numbers), and could not be re-\nordered, or could not fit in the jitter buffer.')
prvtPwVcTDMPerfCurrentMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentMalformedPkt.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentMalformedPkt.setDescription("Number of packets detected with unexpected size, or\nbad headers' stack")
prvtPwVcTDMPerfCurrentNearEndFC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentNearEndFC.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentNearEndFC.setDescription('Number of local packet failures.')
prvtPwVcTDMPerfCurrentFarEndFC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentFarEndFC.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentFarEndFC.setDescription('Number of remote packet failures.')
prvtPwVcTDMPerfIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6), )
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalTable.setDescription('This table provides performance information per TDM PW\nsimilar to the prvtPwVcTDMPerfCurrentTable above. However,\nthese counts represent historical 15 minute intervals.\nTypically, this table will have a maximum of 96 entries\nfor a 24 hour period, but is not limited to this. ')
prvtPwVcTDMPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1), ).setIndexNames((0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMModuleId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMCircuitId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalNumber"))
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalEntry.setDescription('An entry in this table is created by the agent for\nevery prvtPwVcTDMPerfCurrentEntry that is 15 minutes old.\nThe contents of the Current entry are copied to the new\nentry here. The Current entry, then resets its counts\nto zero for the next current 15 minute interval. ')
prvtPwVcTDMPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 1), Unsigned32())
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalNumber.setDescription('A number (normally between 1 and 96 to cover a 24 hour\nperiod) which identifies the interval for which the set\nof statistics is available. The interval identified by 1\nis the most recently completed 15 minute interval, and\nthe interval identified by N is the interval immediately\npreceding the one identified by N-1. The minimum range of\nN is 1 through 4. The default range is 1 through 32. The\nmaximum value of N is 1 through 96.')
prvtPwVcTDMPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalValidData.setDescription('This variable indicates if the data for this interval\nis valid.')
prvtPwVcTDMPerfIntervalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalDuration.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalDuration.setDescription("The duration of a particular interval in seconds,\nAdjustments in the system's time-of-day clock, may\ncause the interval to be greater or less than, the\nnormal value. Therefore this actual interval value\nis provided.")
prvtPwVcTDMPerfIntervalPktsOoseq = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalPktsOoseq.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalPktsOoseq.setDescription('Number of packets detected out of sequence (via TDM\nheader sequence numbers), but successfully re-ordered.\nNote: some implementations mat not support this\nfeature.')
prvtPwVcTDMPerfIntervalJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalJtrBfrUnderruns.setDescription('Number of times a packet needed to be played\nout and the jitter buffer was empty.')
prvtPwVcTDMPerfIntervalJtrBfrOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalJtrBfrOverruns.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalJtrBfrOverruns.setDescription('Number of packets detected out of range (via TDM\nheader sequence numbers), and could not be re-\nordered, or could not fit in the jitter buffer.')
prvtPwVcTDMPerfIntervalMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalMalformedPkt.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalMalformedPkt.setDescription("Number of packets detected with unexpected size, or\nbad headers' stack")
prvtPwVcTDMPerfIntervalNearEndFC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalNearEndFC.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalNearEndFC.setDescription('Number of local packet failures.')
prvtPwVcTDMPerfIntervalFarEndFC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalFarEndFC.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalFarEndFC.setDescription('Number of remote packet failures.')
prvtPwVcTDMPerfTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7), )
if mibBuilder.loadTexts: prvtPwVcTDMPerfTable.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfTable.setDescription('This table provides performance information per TDM PW\nsimilar to the prvtPwVcTDMPerfIntervalTable above. However,\nthese counters represent complete historical information. ')
prvtPwVcTDMPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1), ).setIndexNames((0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMModuleId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMCircuitId"))
if mibBuilder.loadTexts: prvtPwVcTDMPerfEntry.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfEntry.setDescription('An entry is created in this table by the agent for\nevery entry in the prvtPwVcTDM table.')
prvtPwVcTDMPerfPktsOoseq = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfPktsOoseq.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfPktsOoseq.setDescription('Number of packets detected out of sequence (via TDM\nheader sequence numbers), but successfully re-ordered.\nNote: some implementations may not support this\nfeature.')
prvtPwVcTDMPerfJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfJtrBfrUnderruns.setDescription('Number of times a packet needed to be played\nout and the jitter buffer was empty.')
prvtPwVcTDMPerfJtrBfrOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfJtrBfrOverruns.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfJtrBfrOverruns.setDescription('Number of packets detected out of range (via TDM\nheader sequence numbers), and could not be re-\nordered, or could not fit in the jitter buffer.')
prvtPwVcTDMPerfMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfMalformedPkt.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfMalformedPkt.setDescription("Number of packets detected with unexpected size, or\nbad headers' stack.")
prvtPwVcTDMPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\nwhich any one or more of this segment's Counter32\nsuffered a discontinuity. If no such\ndiscontinuities have occurred since the last re-\ninitialization of the local management subsystem, then\nthis object contains a zero value.")
prvtPwVcTDMPerfNearEndFC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfNearEndFC.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfNearEndFC.setDescription('Number of local packet failures.')
prvtPwVcTDMPerfFarEndFC = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMPerfFarEndFC.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfFarEndFC.setDescription('Number of remote packet failures.')
prvtPwVcTDMAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 8), )
if mibBuilder.loadTexts: prvtPwVcTDMAlarmTable.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMAlarmTable.setDescription('This table contains object for configuring and displaying CES Circuits TCA thresholds.')
prvtPwVcTDMAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 8, 1), ).setIndexNames((0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMModuleId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMCircuitId"), (0, "PRVT-PW-TDM-MIB", "prvtPwVcTDMAlarmIndex"))
if mibBuilder.loadTexts: prvtPwVcTDMAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMAlarmEntry.setDescription('')
prvtPwVcTDMAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 8, 1, 1), Gauge32())
if mibBuilder.loadTexts: prvtPwVcTDMAlarmIndex.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMAlarmIndex.setDescription(' An integer uniquely identifying an alarm entry.')
prvtPwVcTDMAlarmVariable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 8, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtPwVcTDMAlarmVariable.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMAlarmVariable.setDescription('The OID of the variable whose value is being monitored. Depending on the time interval, \nthe error condition and the modue and circuit ID, this points to an object from an entry in \nprvtPwVcTDMPerfCurrentTable or prvtPwVcTDMPerfTable.')
prvtPwVcTDMAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 8, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prvtPwVcTDMAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMAlarmThreshold.setDescription('The alarm condition threshold for this alarm entry. The alarm is triggered if the value of the\nobject pointed by prvtPwVcTDMAlarmVariable remains above this threshold for more than 3 seconds.')
prvtPwVcTDMAlarmValue = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 1, 8, 1, 4), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: prvtPwVcTDMAlarmValue.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMAlarmValue.setDescription('The value of the object pointed to by prvtPwVcTDMAlarmVariable, present for notification purposes.')
prvtPwVcTDMAlarm = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 2, 1)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMAlarmVariable"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMAlarmThreshold"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMAlarmValue"))
if mibBuilder.loadTexts: prvtPwVcTDMAlarm.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMAlarm.setDescription('This notification is sent when the value of a TDM port error condition statistic has exceeded the \nconfigured threshold, or the value has dropped back below the threshold.')
prvtPwVcTDMStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 2, 2)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMOperStatus"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMCfgAdminStatus"))
if mibBuilder.loadTexts: prvtPwVcTDMStatusChange.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMStatusChange.setDescription('This notification is sent when the operational or administrative status of circuit changes.')
prvtPwVcTDMGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 1))
prvtPwVcTDMCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 2))
prvtPwTDMModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 2, 1)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMGroup"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfCurrentGroup"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalGroup"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfGroup"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtPwTDMModuleCompliance = prvtPwTDMModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: prvtPwTDMModuleCompliance.setDescription('The compliance statement for agent that support PW\nover TDM PSN operation.')
prvtPwVcTDMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 1, 1)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMType"), ("PRVT-PW-TDM-MIB", "prvtPwVcRelTDMCfgIndex"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMTimeElapsed"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMValidIntervals"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMCurrentIndications"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMLatchedIndications"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMLastEsTimeStamp"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMCfgPayloadSize"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMCfgPktReorder"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMCfgRtpHdrUsed"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMCfgJtrBfrDepth"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtPwVcTDMGroup = prvtPwVcTDMGroup.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMGroup.setDescription('Collection of objects for basic TDM PW config and\nstatus.')
prvtPwVcTDMPerfCurrentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 1, 2)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfCurrentPktsOoseq"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfCurrentJtrBfrUnderruns"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfCurrentJtrBfrOverruns"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfCurrentMalformedPkt"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfNearEndFC"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfFarEndFC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtPwVcTDMPerfCurrentGroup = prvtPwVcTDMPerfCurrentGroup.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfCurrentGroup.setDescription('Collection of current statistics objects for TDM PWs.')
prvtPwVcTDMPerfIntervalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 1, 3)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalPktsOoseq"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalJtrBfrUnderruns"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalJtrBfrOverruns"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalMalformedPkt"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfNearEndFC"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfFarEndFC"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalValidData"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfIntervalDuration"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtPwVcTDMPerfIntervalGroup = prvtPwVcTDMPerfIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfIntervalGroup.setDescription('Collection of Interval statistics objects for TDM PWs.')
prvtPwVcTDMPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 1, 4)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfPktsOoseq"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfJtrBfrUnderruns"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfJtrBfrOverruns"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfMalformedPkt"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfNearEndFC"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfFarEndFC"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMPerfDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtPwVcTDMPerfGroup = prvtPwVcTDMPerfGroup.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMPerfGroup.setDescription('Collection of running statistics objects for TDM PWs.')
prvtPwVcTDMNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 738, 1, 5, 200, 2, 3, 1, 5)).setObjects(("PRVT-PW-TDM-MIB", "prvtPwVcTDMAlarm"), ("PRVT-PW-TDM-MIB", "prvtPwVcTDMStatusChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prvtPwVcTDMNotificationsGroup = prvtPwVcTDMNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: prvtPwVcTDMNotificationsGroup.setDescription('The group of supported notifications.')
mibBuilder.exportSymbols("PRVT-PW-TDM-MIB", prvtPwVcTDMCfgChannelGroup=prvtPwVcTDMCfgChannelGroup, prvtPwVcTDMPerfIntervalTable=prvtPwVcTDMPerfIntervalTable, prvtPwVcTDMPerfIntervalFarEndFC=prvtPwVcTDMPerfIntervalFarEndFC, prvtPwVcTDMPerfIntervalJtrBfrUnderruns=prvtPwVcTDMPerfIntervalJtrBfrUnderruns, prvtTDMChannelGrpCfgError=prvtTDMChannelGrpCfgError, prvtPwVcTDMTraps=prvtPwVcTDMTraps, prvtPwVcTDMCurrentIndications=prvtPwVcTDMCurrentIndications, prvtTDMChannelGrpTable=prvtTDMChannelGrpTable, prvtPwVcTDMLatchedIndications=prvtPwVcTDMLatchedIndications, prvtPwVcTDMGroups=prvtPwVcTDMGroups, prvtPwVcTDMPerfIntervalEntry=prvtPwVcTDMPerfIntervalEntry, prvtPwVcTDMCfgEntry=prvtPwVcTDMCfgEntry, prvtPwVcTDMCfgVlanPrio=prvtPwVcTDMCfgVlanPrio, prvtPwVcTDMLastEsTimeStamp=prvtPwVcTDMLastEsTimeStamp, prvtPwVcTDMCfgMplsOosTTL=prvtPwVcTDMCfgMplsOosTTL, prvtPwVcTDMCfgMplsOosPeerLabel=prvtPwVcTDMCfgMplsOosPeerLabel, prvtPwVcTDMAlarmIndex=prvtPwVcTDMAlarmIndex, prvtPwVcTDMPerfJtrBfrOverruns=prvtPwVcTDMPerfJtrBfrOverruns, prvtPwVcTDMEntry=prvtPwVcTDMEntry, prvtPwVcTDMObjects=prvtPwVcTDMObjects, prvtPwVcTDMCfgInterface=prvtPwVcTDMCfgInterface, PYSNMP_MODULE_ID=prvtPwVcTDMMIB, prvtPwVcTDMPerfGroup=prvtPwVcTDMPerfGroup, prvtTDMChannelGrpTimeSlots=prvtTDMChannelGrpTimeSlots, prvtPwVcTDMPerfPktsOoseq=prvtPwVcTDMPerfPktsOoseq, prvtPwVcTDMCfgLocalPort=prvtPwVcTDMCfgLocalPort, prvtPwVcTDMCfgProtocol=prvtPwVcTDMCfgProtocol, prvtPwVcTDMPerfFarEndFC=prvtPwVcTDMPerfFarEndFC, prvtPwVcTDMPerfCurrentEntry=prvtPwVcTDMPerfCurrentEntry, prvtPwVcTDMCfgRtp=prvtPwVcTDMCfgRtp, prvtPwVcTDMOperStatus=prvtPwVcTDMOperStatus, prvtPwVcTDMPerfIntervalDuration=prvtPwVcTDMPerfIntervalDuration, prvtPwVcTDMCfgPeerEcid=prvtPwVcTDMCfgPeerEcid, prvtPwVc=prvtPwVc, prvtTDMChannelGrpEntry=prvtTDMChannelGrpEntry, prvtPwVcTDMAlarmTable=prvtPwVcTDMAlarmTable, prvtPwVcTDMCfgPeerIpType=prvtPwVcTDMCfgPeerIpType, prvtPwVcTDMMIB=prvtPwVcTDMMIB, prvtPwVcTDMPerfCurrentJtrBfrUnderruns=prvtPwVcTDMPerfCurrentJtrBfrUnderruns, prvtPwVcTDMCfgPeerMAC=prvtPwVcTDMCfgPeerMAC, prvtPwVcTDMCfgVlanId=prvtPwVcTDMCfgVlanId, prvtPwVcTDMTimeElapsed=prvtPwVcTDMTimeElapsed, prvtPwVcTDMGroup=prvtPwVcTDMGroup, prvtPwVcTDMCfgOosPort=prvtPwVcTDMCfgOosPort, prvtPwVcTDMPerfEntry=prvtPwVcTDMPerfEntry, prvtPwVcTDMPerfCurrentTable=prvtPwVcTDMPerfCurrentTable, prvtTDMChannelGrpOC3TimeSlots=prvtTDMChannelGrpOC3TimeSlots, prvtPwVcTDMPerfCurrentJtrBfrOverruns=prvtPwVcTDMPerfCurrentJtrBfrOverruns, prvtPwVcTDMCfgOosEcid=prvtPwVcTDMCfgOosEcid, prvtPwVcTDMCfgPeerPort=prvtPwVcTDMCfgPeerPort, prvtPwVcTDMPerfCurrentPktsOoseq=prvtPwVcTDMPerfCurrentPktsOoseq, prvtPwVcTDMCfgIpTos=prvtPwVcTDMCfgIpTos, prvtPwVcTDMCfgPeerOosEcid=prvtPwVcTDMCfgPeerOosEcid, prvtTDMChannelGrpID=prvtTDMChannelGrpID, PrvtPwVcTDMCfgInterface=PrvtPwVcTDMCfgInterface, prvtPwVcTDMPerfJtrBfrUnderruns=prvtPwVcTDMPerfJtrBfrUnderruns, prvtPwVcTDMPerfIntervalPktsOoseq=prvtPwVcTDMPerfIntervalPktsOoseq, prvtPwVcTDMPerfIntervalNumber=prvtPwVcTDMPerfIntervalNumber, TimeSlotList=TimeSlotList, prvtPwVcTDMCfgMplsLocalLabel=prvtPwVcTDMCfgMplsLocalLabel, prvtTDMChannelGrpModuleID=prvtTDMChannelGrpModuleID, prvtPwVcTDMPerfCurrentNearEndFC=prvtPwVcTDMPerfCurrentNearEndFC, prvtPwVcTDMCfgPeerIpAddress=prvtPwVcTDMCfgPeerIpAddress, InterfaceTimeSlot=InterfaceTimeSlot, prvtPwVcTDMEmulationMode=prvtPwVcTDMEmulationMode, prvtPwVcTDMCfgRtpPayload=prvtPwVcTDMCfgRtpPayload, prvtPwVcTDMPerfCurrentMalformedPkt=prvtPwVcTDMPerfCurrentMalformedPkt, prvtPwVcTDMAlarmThreshold=prvtPwVcTDMAlarmThreshold, prvtPwVcTDMStatusChange=prvtPwVcTDMStatusChange, prvtPwVcTDMCfgTable=prvtPwVcTDMCfgTable, prvtPwVcTDMAlarmEntry=prvtPwVcTDMAlarmEntry, prvtPwVcTDMPerfNearEndFC=prvtPwVcTDMPerfNearEndFC, prvtPwVcTDMCfgPorts=prvtPwVcTDMCfgPorts, prvtPwVcTDMConformance=prvtPwVcTDMConformance, prvtPwVcTDMCfgPeerOosPort=prvtPwVcTDMCfgPeerOosPort, prvtPwVcTDMCfgEcid=prvtPwVcTDMCfgEcid, prvtPwVcTDMType=prvtPwVcTDMType, prvtPwVcTDMCfgIpOosTos=prvtPwVcTDMCfgIpOosTos, prvtPwTDMModuleCompliance=prvtPwTDMModuleCompliance, prvtPwVcTDMCfgPayloadSuppression=prvtPwVcTDMCfgPayloadSuppression, prvtPwVcTDMCfgMplsExp=prvtPwVcTDMCfgMplsExp, prvtPwVcTDMCircuitId=prvtPwVcTDMCircuitId, prvtPwVcTDMCfgRtpOosPayload=prvtPwVcTDMCfgRtpOosPayload, prvtPwVcTDMPerfIntervalGroup=prvtPwVcTDMPerfIntervalGroup, prvtPwVcTDMCfgMplsPeerLabel=prvtPwVcTDMCfgMplsPeerLabel, prvtPwVcTDMCfgPktReorder=prvtPwVcTDMCfgPktReorder, prvtPwVcTDMNotificationsGroup=prvtPwVcTDMNotificationsGroup, prvtPwVcTDMPerfDiscontinuityTime=prvtPwVcTDMPerfDiscontinuityTime, prvtPwVcTDMTable=prvtPwVcTDMTable, prvtPwVcTDMPerfIntervalNearEndFC=prvtPwVcTDMPerfIntervalNearEndFC, prvtPwVcTDMCfgAdminStatus=prvtPwVcTDMCfgAdminStatus, prvtPwVcTDMCfgMplsOosExp=prvtPwVcTDMCfgMplsOosExp, prvtPwVcTDMCfgPayloadSize=prvtPwVcTDMCfgPayloadSize, prvtPwVcRelTDMCfgIndex=prvtPwVcRelTDMCfgIndex, prvtPwVcTDMCfgRtpHdrUsed=prvtPwVcTDMCfgRtpHdrUsed, prvtPwVcTDMClearCircuitStatistics=prvtPwVcTDMClearCircuitStatistics, prvtPwVcTDMPerfIntervalJtrBfrOverruns=prvtPwVcTDMPerfIntervalJtrBfrOverruns, prvtPwVcTDMPerfMalformedPkt=prvtPwVcTDMPerfMalformedPkt, prvtPwVcTDMCfgRowStatus=prvtPwVcTDMCfgRowStatus, prvtPwVcTDMValidIntervals=prvtPwVcTDMValidIntervals, prvtPwVcTDMPerfIntervalValidData=prvtPwVcTDMPerfIntervalValidData, prvtPwVcTDMCfgMplsOosLocalLabel=prvtPwVcTDMCfgMplsOosLocalLabel, prvtPwVcTDMPerfCurrentFarEndFC=prvtPwVcTDMPerfCurrentFarEndFC, prvtPwVcTDMPerfTable=prvtPwVcTDMPerfTable, prvtPwVcTDMAlarmVariable=prvtPwVcTDMAlarmVariable, prvtPwVcTDMModuleId=prvtPwVcTDMModuleId, prvtPwVcTDMPerfCurrentGroup=prvtPwVcTDMPerfCurrentGroup, prvtPwVcTDMCompliances=prvtPwVcTDMCompliances, prvtPwVcTDMCfgJtrBfrDepth=prvtPwVcTDMCfgJtrBfrDepth, PrvtPwVcTDMCfgIndex=PrvtPwVcTDMCfgIndex, prvtPwVcTDMAlarm=prvtPwVcTDMAlarm, prvtPwVcTDMPerfIntervalMalformedPkt=prvtPwVcTDMPerfIntervalMalformedPkt, prvtPwVcTDMAlarmValue=prvtPwVcTDMAlarmValue, prvtPwVcTDMCfgMplsTTL=prvtPwVcTDMCfgMplsTTL)
