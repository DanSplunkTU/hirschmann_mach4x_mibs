#
# PySNMP MIB module Job-Monitoring-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/Job-Monitoring-MIB
# Produced by pysmi-1.1.8 at Thu Jan 13 23:32:41 2022
# On host fv-az74-435 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
enterprises, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, ObjectIdentity, iso, IpAddress, Unsigned32, ModuleIdentity, Counter32, Counter64, Gauge32, TimeTicks, Integer32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "ObjectIdentity", "iso", "IpAddress", "Unsigned32", "ModuleIdentity", "Counter32", "Counter64", "Gauge32", "TimeTicks", "Integer32", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
jobmonMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2699, 1, 1))
jobmonMIB.setRevisions(('1999-02-19 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jobmonMIB.setRevisionsDescriptions((' This version published as RFC 2707',))
if mibBuilder.loadTexts: jobmonMIB.setLastUpdated('9902190000Z')
if mibBuilder.loadTexts: jobmonMIB.setOrganization('Printer Working Group (PWG)')
if mibBuilder.loadTexts: jobmonMIB.setContactInfo("Tom Hastings\n        Postal:  Xerox Corp.\n                 Mail stop ESAE-231\n                 701 S. Aviation Blvd.\n                 El Segundo, CA 90245\n\n        Tel:     (301)333-6413\n        Fax:     (301)333-5514\n        E-mail:  hastings@cp10.es.xerox.com\n\n        Send questions and comments to the Printer Working Group (PWG)\n        using the Job Monitoring Project (JMP) Mailing List:\n        jmp@pwg.org\n\n        For further information, including how to subscribe to the\n        jmp mailing list, access the PWG web page under 'JMP':\n\n            http://www.pwg.org/\n\n        Implementers of this specification are encouraged to join the\n        jmp mailing list in order to participate in discussions on any\n        clarifications needed and registration proposals being reviewed\n\n        in order to achieve consensus.")
if mibBuilder.loadTexts: jobmonMIB.setDescription('The MIB module for monitoring job in servers, printers, and\n        other devices.\n\n        Version: 1.0')
class JmUTF8StringTC(TextualConvention, OctetString):
    description = "To facilitate internationalization, this TC represents\n        information taken from the ISO/IEC IS 10646-1 character set,\n        encoded as an octet string using the UTF-8 character encoding\n        scheme.\n\n        See section 3.6.1, entitled: 'Text generated by the server or\n        device'."
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 63)

class JmJobStringTC(TextualConvention, OctetString):
    description = "To facilitate internationalization, this TC represents\n        information using any coded character set registered by IANA as\n        specified in section 3.7.  While it is recommended that the\n        coded character set be UTF-8 [UTF-8], the actual coded\n        character set SHALL be indicated by the value of the\n        jobCodedCharSet(8) attribute for the job.\n\n        See section 3.6.2, entitled: 'Text supplied by the job\n        submitter'."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 63)

class JmNaturalLanguageTagTC(TextualConvention, OctetString):
    description = "An IETF RFC 1766-compliant 'language tag', with zero or more\n        sub-tags that identify a natural language.  While RFC 1766\n        specifies that the US-ASCII values are case-insensitive, this\n        MIB specification requires that all characters SHALL be lower\n        case in order to simplify comparing by management applications.\n\n        See section 3.6.1, entitled: 'Text generated by the server or\n        device' and section 3.6.2, entitled: 'Text supplied by the job\n        submitter'."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 63)

class JmTimeStampTC(TextualConvention, Integer32):
    description = 'The simple time at which an event took place.  The units are\n        in seconds since the system was booted.\n\n        NOTE - JmTimeStampTC is defined in units of seconds, rather\n        than 100ths of seconds, so as to be simpler for agents to\n        implement (even if they have to implement the 100ths of a\n        second to comply with implementing sysUpTime in MIB-II[mib-\n        II].)\n\n        NOTE - JmTimeStampTC is defined as an Integer32 so that it can\n        be used as a value of an attribute, i.e., as a value of the\n        jmAttributeValueAsInteger object.  The TimeStamp textual-\n        convention defined in SNMPv2-TC [SMIv2-TC] is defined as an\n        APPLICATION 3 IMPLICIT INTEGER tag, not an Integer32 which is\n        defined in SNMPv2-SMI [SMIv2-TC] as UNIVERSAL 2 IMPLICIT\n        INTEGER, so cannot be used in this MIB as one of the values of\n        jmAttributeValueAsInteger.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class JmJobSourcePlatformTypeTC(TextualConvention, Integer32):
    description = 'The source platform type that can submit jobs to servers or\n        devices in any of the 3 configurations.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2.  See also\n\n        IANA operating-system-names registry.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("sptUNIX", 3), ("sptOS2", 4), ("sptPCDOS", 5), ("sptNT", 6), ("sptMVS", 7), ("sptVM", 8), ("sptOS400", 9), ("sptVMS", 10), ("sptWindows", 11), ("sptNetWare", 12))

class JmFinishingTC(TextualConvention, Integer32):
    description = "The type of finishing operation.\n\n        These values are the same as the enum values of the IPP\n        'finishings' attribute.  See Section 3.7.1.2.\n\n        other(1),\n            Some other finishing operation besides one of the specified\n            or registered values.\n\n        unknown(2),\n            The finishing is unknown.\n\n        none(3),\n            Perform no finishing.\n\n        staple(4),\n            Bind the document(s) with one or more staples. The exact\n            number and placement of the staples is site-defined.\n\n        punch(5),\n            Holes are required in the finished document. The exact\n            number and placement of the holes is site-defined.  The\n            punch specification MAY be satisfied (in a site- and\n            implementation-specific manner) either by\n            drilling/punching, or by substituting pre-drilled media.\n\n        cover(6),\n\n            Select a non-printed (or pre-printed) cover for the\n            document. This does not supplant the specification of a\n            printed cover (on cover stock medium) by the document\n            itself.\n\n        bind(7)\n            Binding is to be applied to the document; the type and\n            placement of the binding is product-specific.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("none", 3), ("staple", 4), ("punch", 5), ("cover", 6), ("bind", 7))

class JmPrintQualityTC(TextualConvention, Integer32):
    description = "Print quality settings.\n\n        These values are the same as the enum values of the IPP 'print-\n        quality' attribute.  See Section 3.7.1.2.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("draft", 3), ("normal", 4), ("high", 5))

class JmPrinterResolutionTC(TextualConvention, OctetString):
    description = "Printer resolutions.\n\n        Nine octets consisting of two 4-octet SIGNED-INTEGERs followed\n\n        by a SIGNED-BYTE.  The values are the same as those specified\n        in the Printer MIB [printmib]. The first SIGNED-INTEGER\n        contains the value of prtMarkerAddressabilityXFeedDir.  The\n        second SIGNED-INTEGER contains the value of\n        prtMarkerAddressabilityFeedDir.  The SIGNED-BYTE contains the\n        value of prtMarkerAddressabilityUnit.\n\n        Note: the latter value is either 3 (tenThousandsOfInches) or 4\n        (micrometers) and the addressability is in 10,000 units of\n        measure. Thus the SIGNED-INTEGERs represent integral values in\n        either dots-per-inch or dots-per-centimeter.\n\n        The syntax is the same as the IPP 'printer-resolution'\n        attribute.  See Section 3.7.1.2."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(9, 9)
    fixedLength = 9

class JmTonerEconomyTC(TextualConvention, Integer32):
    description = 'Toner economy settings.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4))
    namedValues = NamedValues(("unknown", 2), ("off", 3), ("on", 4))

class JmBooleanTC(TextualConvention, Integer32):
    description = 'Boolean true or false value.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4))
    namedValues = NamedValues(("unknown", 2), ("false", 3), ("true", 4))

class JmMediumTypeTC(TextualConvention, Integer32):
    description = 'Identifies the type of medium.\n\n        other(1),\n            The type is neither one of the values listed in this\n            specification nor a registered value.\n\n        unknown(2),\n            The type is not known.\n\n        stationery(3),\n            Separately cut sheets of an opaque material.\n\n        transparency(4),\n            Separately cut sheets of a transparent material.\n\n        envelope(5),\n            Envelopes that can be used for conventional mailing\n            purposes.\n\n        envelopePlain(6),\n            Envelopes that are not preprinted and have no windows.\n\n        envelopeWindow(7),\n            Envelopes that have windows for addressing purposes.\n\n        continuousLong(8),\n            Continuously connected sheets of an opaque material\n            connected along the long edge.\n\n        continuousShort(9),\n            Continuously connected sheets of an opaque material\n            connected along the short edge.\n\n        tabStock(10),\n            Media with tabs.\n\n        multiPartForm(11),\n            Form medium composed of multiple layers not pre-attached to\n            one another;  each sheet MAY be drawn separately from an\n            input source.\n\n        labels(12),\n            Label-stock.\n\n        multiLayer(13)\n            Form medium composed of multiple layers which are pre-\n            attached to one another, e.g. for use with impact printers.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2.  These enum\n        values correspond to the keyword name strings of the\n        prtInputMediaType object in the Printer MIB [print-mib].  There\n        is no printer description attribute in IPP/1.0 that represents\n        these values.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("stationery", 3), ("transparency", 4), ("envelope", 5), ("envelopePlain", 6), ("envelopeWindow", 7), ("continuousLong", 8), ("continuousShort", 9), ("tabStock", 10), ("multiPartForm", 11), ("labels", 12), ("multiLayer", 13))

class JmJobCollationTypeTC(TextualConvention, Integer32):
    description = "This value is the type of job collation.  Implementations that\n        don't support multiple documents or don't support multiple\n        copies SHALL NOT support the uncollatedDocuments(5) value.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2. See also\n        Section 3.4, entitled 'Monitoring Job Progress'."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("uncollatedSheets", 3), ("collatedDocuments", 4), ("uncollatedDocuments", 5))

class JmJobSubmissionIDTypeTC(TextualConvention, OctetString):
    description = 'Identifies the format type of a job submission ID.\n\n        Each job submission ID is a fixed-length, 48-octet printable\n        US-ASCII [US-ASCII] coded character string containing no\n        control characters, consisting of the fields defined in section\n        3.5.1.\n\n        This is like a type 2 enumeration.  See section 3.7.3.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 1)
    fixedLength = 1

class JmJobStateTC(TextualConvention, Integer32):
    description = "The current state of the job (pending, processing, completed,\n        etc.).  The following figure shows the normal job state\n        transitions:\n\n                                                    +----> canceled(7)\n                                                   /\n    +---> pending(3) -------> processing(5) ------+------> completed(9)\n    |         ^                      ^             \\\n--->+         |                      |              +----> aborted(8)\n    |         v                      v             /\n    +---> pendingHeld(4)  processingStopped(6) ---+\n\n                Figure 4 - Normal Job State Transitions\n\n        Normally a job progresses from left to right.  Other state\n        transitions are unlikely, but are not forbidden.  Not shown are\n        the transitions to the canceled state from the pending,\n        pendingHeld, and processingStopped states.\n\n        Jobs in the pending, processing, and processingStopped states\n        are called 'active', while jobs in the pendingHeld, canceled,\n        aborted, and completed states are called 'inactive'.  Jobs\n        reach one of the three terminal states: completed, canceled, or\n        aborted, after the jobs have completed all activity, and all\n        MIB objects and attributes have reached their final values for\n        the job.\n\n        These values are the same as the enum values of the IPP 'job-\n        state' job attribute.  See Section 3.7.1.2.\n\n        unknown(2),\n            The job state is not known, or its state is indeterminate.\n\n        pending(3),\n            The job is a candidate to start processing, but is not yet\n            processing.\n\n        pendingHeld(4),\n            The job is not a candidate for processing for any number of\n            reasons but will return to the pending state as soon as the\n            reasons are no longer present.  The job's\n            jmJobStateReasons1 object and/or jobStateReasonsN (N=2..4)\n            attributes SHALL indicate why the job is no longer a\n            candidate for processing.  The reasons are represented as\n            bits in the jmJobStateReasons1 object and/or\n            jobStateReasonsN (N=2..4) attributes.  See the\n            JmJobStateReasonsNTC (N=1..4) textual convention for the\n            specification of each reason.\n\n        processing(5),\n            One or more of:\n\n            1.  the job is using, or is attempting to use, one or\n            more purely software processes that are analyzing,\n            creating, or interpreting a PDL, etc.,\n\n            2.  the job is using, or is attempting to use, one or\n            more hardware devices that are interpreting a PDL,\n            making mark on a medium, and/or performing finishing,\n            such as stapling, etc.,  OR\n\n            3. (configuration 2) the server has made the job ready\n            for printing, but the output device is not yet printing\n            it, either because the job hasn't reached the output\n            device or because the job is queued in the output\n            device or some other spooler, awaiting the output\n            device to print it.\n\n            When the job is in the processing state, the entire job\n            state includes the detailed status represented in the\n            device MIB indicated by the hrDeviceIndex value of the\n            job's physicalDevice attribute, if the agent implements\n            such a device MIB.\n\n            Implementations MAY, though they NEED NOT, include\n\n            additional values in the job's jmJobStateReasons1 object\n            to indicate the progress of the job, such as adding the\n            jobPrinting value to indicate when the device is actually\n            making marks on a medium and/or the processingToStopPoint\n            value to indicate that the server or device is in the\n            process of canceling or aborting the job.\n\n        processingStopped(6),\n            The job has stopped while processing for any number of\n            reasons and will return to the processing state as soon\n            as the reasons are no longer present.\n\n            The job's jmJobStateReasons1 object and/or the job's\n            jobStateReasonsN (N=2..4) attributes MAY indicate why the\n            job has stopped processing.  For example, if the output\n            device is stopped, the deviceStopped value MAY be\n            included in the job's jmJobStateReasons1 object.\n\n            NOTE - When an output device is stopped, the device\n            usually indicates its condition in human readable form\n            at the device.  The management application can obtain\n             more complete device status remotely by querying the\n            appropriate device MIB using the job's deviceIndex\n            attribute(s), if the agent implements such a device MIB\n\n        canceled(7),\n            A client has canceled the job and the server or device\n            has completed canceling the job AND all MIB objects and\n            attributes have reached their final values for the job.\n            While the server or device is canceling the job, the\n            job's jmJobStateReasons1 object SHOULD contain the\n            processingToStopPoint value and one of the\n            canceledByUser, canceledByOperator, or canceledAtDevice\n            values.  The canceledByUser, canceledByOperator, or\n            canceledAtDevice values remain while the job is in the\n            canceled state.\n\n        aborted(8),\n            The job has been aborted by the system, usually while the\n            job was in the processing or processingStopped state and\n            the server or device has completed aborting the job AND\n            all MIB objects and attributes have reached their final\n            values for the job.  While the server or device is\n            aborting the job, the job's jmJobStateReasons1 object MAY\n            contain the processingToStopPoint and abortedBySystem\n            values.  If implemented, the abortedBySystem value SHALL\n            remain while the job is in the aborted state.\n\n        completed(9)\n            The job has completed successfully or with warnings or\n            errors after processing and all of the media have been\n            successfully stacked in the appropriate output bin(s) AND\n            all MIB objects and attributes have reached their final\n            values for the job.  The job's jmJobStateReasons1 object\n            SHOULD contain one of: completedSuccessfully,\n            completedWithWarnings, or completedWithErrors values.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("unknown", 2), ("pending", 3), ("pendingHeld", 4), ("processing", 5), ("processingStopped", 6), ("canceled", 7), ("aborted", 8), ("completed", 9))

class JmAttributeTypeTC(TextualConvention, Integer32):
    description = "The type of the attribute which identifies the attribute.\n\n        NOTE - The enum assignments are grouped logically with values\n        assigned in groups of 20, so that additional values may be\n        registered in the future and assigned a value that is part of\n        their logical grouping.\n\n        Values in the range 2**30 to 2**31-1 are reserved for private\n        or experimental usage.  This range corresponds to the same\n        range reserved in IPP.  Implementers are warned that use of\n        such values may conflict with other implementations.\n        Implementers are encouraged to request registration of enum\n        values following the procedures in Section 3.7.1.\n\n        See Section 3.2 entitled 'The Attribute Mechanism' for a\n        description of this textual-convention and its use in the\n        jmAttributeTable.  See Section 3.3.8 for the specification of\n        each attribute.  The comment(s) after each enum assignment\n        specifies the data type(s) of the attribute.\n\n        This is a type 2 enumeration.  See Section 3.7.1.2."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7, 8, 9, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 50, 51, 52, 53, 54, 55, 56, 70, 71, 72, 73, 74, 75, 76, 77, 90, 91, 92, 93, 94, 95, 96, 97, 110, 111, 112, 113, 114, 115, 130, 131, 132, 150, 151, 152, 170, 171, 172, 173, 174, 175, 190, 191, 192, 193, 194, 195))
    namedValues = NamedValues(("other", 1), ("jobStateReasons2", 3), ("jobStateReasons3", 4), ("jobStateReasons4", 5), ("processingMessage", 6), ("processingMessageNaturalLangTag", 7), ("jobCodedCharSet", 8), ("jobNaturalLanguageTag", 9), ("jobURI", 20), ("jobAccountName", 21), ("serverAssignedJobName", 22), ("jobName", 23), ("jobServiceTypes", 24), ("jobSourceChannelIndex", 25), ("jobSourcePlatformType", 26), ("submittingServerName", 27), ("submittingApplicationName", 28), ("jobOriginatingHost", 29), ("deviceNameRequested", 30), ("queueNameRequested", 31), ("physicalDevice", 32), ("numberOfDocuments", 33), ("fileName", 34), ("documentName", 35), ("jobComment", 36), ("documentFormatIndex", 37), ("documentFormat", 38), ("jobPriority", 50), ("jobProcessAfterDateAndTime", 51), ("jobHold", 52), ("jobHoldUntil", 53), ("outputBin", 54), ("sides", 55), ("finishing", 56), ("printQualityRequested", 70), ("printQualityUsed", 71), ("printerResolutionRequested", 72), ("printerResolutionUsed", 73), ("tonerEcomonyRequested", 74), ("tonerEcomonyUsed", 75), ("tonerDensityRequested", 76), ("tonerDensityUsed", 77), ("jobCopiesRequested", 90), ("jobCopiesCompleted", 91), ("documentCopiesRequested", 92), ("documentCopiesCompleted", 93), ("jobKOctetsTransferred", 94), ("sheetCompletedCopyNumber", 95), ("sheetCompletedDocumentNumber", 96), ("jobCollationType", 97), ("impressionsSpooled", 110), ("impressionsSentToDevice", 111), ("impressionsInterpreted", 112), ("impressionsCompletedCurrentCopy", 113), ("fullColorImpressionsCompleted", 114), ("highlightColorImpressionsCompleted", 115), ("pagesRequested", 130), ("pagesCompleted", 131), ("pagesCompletedCurrentCopy", 132), ("sheetsRequested", 150), ("sheetsCompleted", 151), ("sheetsCompletedCurrentCopy", 152), ("mediumRequested", 170), ("mediumConsumed", 171), ("colorantRequested", 172), ("colorantConsumed", 173), ("mediumTypeConsumed", 174), ("mediumSizeConsumed", 175), ("jobSubmissionToServerTime", 190), ("jobSubmissionTime", 191), ("jobStartedBeingHeldTime", 192), ("jobStartedProcessingTime", 193), ("jobCompletionTime", 194), ("jobProcessingCPUTime", 195))

class JmJobServiceTypesTC(TextualConvention, Integer32):
    description = 'Specifies the type(s) of service to which the job has been\n        submitted (print, fax, scan, etc.).  The service type is\n        represented as an enum that is bit encoded with each job\n        service type so that more general and arbitrary services can be\n        created, such as services with more than one destination type,\n\n        or ones with only a source or only a destination.  For example,\n        a job service might scan, faxOut, and print a single job.  In\n        this case, three bits would be set in the jobServiceTypes\n        attribute, corresponding to the hexadecimal values: 0x8 + 0x20\n        + 0x4, respectively, yielding: 0x2C.\n\n        Whether this attribute is set from a job attribute supplied by\n        the job submission client or is set by the recipient job\n        submission server or device depends on the job submission\n        protocol.  With either implementation, the agent SHALL return a\n        non-zero value for this attribute indicating the type of the\n        job.\n\n        One of the purposes of this attribute is to permit a requester\n        to filter out jobs that are not of interest.  For example, a\n        printer operator MAY only be interested in jobs that include\n        printing.  That is why the attribute is in the job\n        identification category.\n\n        The following service component types are defined (in\n        hexadecimal) and are assigned a separate bit value for use with\n        the jobServiceTypes attribute:\n\n        other                             0x1\n            The job contains some instructions that are not one of the\n            identified types.\n\n        unknown                           0x2\n            The job contains some instructions whose type is unknown to\n            the agent.\n\n        print                             0x4\n            The job contains some instructions that specify printing\n\n        scan                              0x8\n            The job contains some instructions that specify scanning\n\n        faxIn                             0x10\n            The job contains some instructions that specify receive fax\n\n        faxOut                            0x20\n            The job contains some instructions that specify sending fax\n\n        getFile                           0x40\n            The job contains some instructions that specify accessing\n            files or documents\n\n        putFile                           0x80\n\n            The job contains some instructions that specify storing\n            files or documents\n\n        mailList                          0x100\n            The job contains some instructions that specify\n            distribution of documents using an electronic mail system.\n\n        These bit definitions are the equivalent of a type 2 enum\n        except that combinations of them MAY be used together.  See\n        section 3.7.1.2.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class JmJobStateReasons1TC(TextualConvention, Integer32):
    description = 'The JmJobStateReasonsNTC (N=1..4) textual-conventions are used\n        with the jmJobStateReasons1 object and jobStateReasonsN\n        (N=2..4), respectively, to provide additional information\n        regarding the current jmJobState object value.  These values\n        MAY be used with any job state or states for which the reason\n        makes sense.  See section 3.3.9.1 for the specification of each\n        bit value defined for use with the JmJobStateReasons1TC.\n\n        These bit definitions are the equivalent of a type 2 enum\n        except that combinations of bits may be used together.  See\n        section 3.7.1.2.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class JmJobStateReasons2TC(TextualConvention, Integer32):
    description = 'This textual-convention is used with the jobStateReasons2\n        attribute to provides additional information regarding the\n        jmJobState object.  See section 3.3.9.2 for the specification\n        of JmJobStateReasons2TC.  See section 3.3.9.1 for the\n        description under JmJobStateReasons1TC for additional\n        information that applies to all reasons.\n\n        These bit definitions are the equivalent of a type 2 enum\n        except that combinations of them may be used together.  See\n        section 3.7.1.2.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class JmJobStateReasons3TC(TextualConvention, Integer32):
    description = 'This textual-convention is used with the jobStateReasons3\n        attribute to provides additional information regarding the\n        jmJobState object.  See section 3.3.9.3 for the specification\n        of JmJobStateReasons3TC.  See section 3.3.9.1 for the\n        description under JmJobStateReasons1TC for additional\n        information that applies to all reasons.\n\n        These bit definitions are the equivalent of a type 2 enum\n        except that combinations of them may be used together.  See\n        section 3.7.1.2.  '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class JmJobStateReasons4TC(TextualConvention, Integer32):
    description = 'This textual-convention is used in the jobStateReasons4\n        attribute to provides additional information regarding the\n        jmJobState object.  See section 3.3.9.4 for the specification\n        of JmJobStateReasons4TC.  See section 3.3.9.1 for the\n        description under JmJobStateReasons1TC for additional\n        information that applies to all reasons.\n\n        These bit definitions are the equivalent of a type 2 enum\n        except that combinations of them may be used together.  See\n        section 3.7.1.2.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

jobmonMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1))
jmGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1))
jmGeneralTable = MibTable((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1), )
if mibBuilder.loadTexts: jmGeneralTable.setStatus('current')
if mibBuilder.loadTexts: jmGeneralTable.setDescription("The jmGeneralTable consists of information of a general nature\n        that are per-job-set, but are not per-job.  See Section 2\n        entitled 'Terminology and Job Model' for the definition of a\n        job set.\n\n        The MANDATORY-GROUP macro specifies that this group is\n        MANDATORY.")
jmGeneralEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1), ).setIndexNames((0, "Job-Monitoring-MIB", "jmGeneralJobSetIndex"))
if mibBuilder.loadTexts: jmGeneralEntry.setStatus('current')
if mibBuilder.loadTexts: jmGeneralEntry.setDescription('Information about a job set (queue).\n\n        An entry SHALL exist in this table for each job set.')
jmGeneralJobSetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)))
if mibBuilder.loadTexts: jmGeneralJobSetIndex.setStatus('current')
if mibBuilder.loadTexts: jmGeneralJobSetIndex.setDescription("A unique value for each job set in this MIB.  The jmJobTable\n        and jmAttributeTable tables have this same index as their\n        primary index.\n\n        The value(s) of the jmGeneralJobSetIndex SHALL be persistent\n        across power cycles, so that clients that have retained\n        jmGeneralJobSetIndex values will access the same job sets upon\n        subsequent power-up.\n\n        An implementation that has only one job set, such as a printer\n\n        with a single queue, SHALL hard code this object with the value\n        1.\n\n        See Section 2 entitled 'Terminology and Job Model' for the\n        definition of a job set.\n        Corresponds to the first index in jmJobTable and\n        jmAttributeTable.")
jmGeneralNumberOfActiveJobs = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmGeneralNumberOfActiveJobs.setStatus('current')
if mibBuilder.loadTexts: jmGeneralNumberOfActiveJobs.setDescription("The current number of 'active' jobs in the jmJobIDTable,\n        jmJobTable, and jmAttributeTable, i.e., the total number of\n        jobs that are in the pending, processing, or processingStopped\n        states.  See the JmJobStateTC textual-convention for the exact\n        specification of the semantics of the job states.")
jmGeneralOldestActiveJobIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmGeneralOldestActiveJobIndex.setStatus('current')
if mibBuilder.loadTexts: jmGeneralOldestActiveJobIndex.setDescription("The jmJobIndex of the oldest job that is still in one of the\n        'active' states (pending, processing, or processingStopped).\n        In other words, the index of the 'active' job that has been in\n        the job tables the longest.\n\n        If there are no active jobs, the agent SHALL set the value of\n        this object to 0.\n\n        See Section 3.2 entitled 'The Job Tables and the Oldest Active\n        and Newest Active Indexes' for a description of the usage of\n        this object.")
jmGeneralNewestActiveJobIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmGeneralNewestActiveJobIndex.setStatus('current')
if mibBuilder.loadTexts: jmGeneralNewestActiveJobIndex.setDescription("The jmJobIndex of the newest job that is in one of the\n        'active' states (pending, processing, or processingStopped).\n        In other words, the index of the 'active' job that has been\n        most recently added to the job tables.\n\n        When all jobs become 'inactive', i.e., enter the pendingHeld,\n        completed, canceled, or aborted states, the agent SHALL set the\n        value of this object to 0.\n\n        See Section 3.2 entitled 'The Job Tables and the Oldest Active\n        and Newest Active Indexes' for a description of the usage of\n        this object.")
jmGeneralJobPersistence = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 2147483647)).clone(60)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: jmGeneralJobPersistence.setStatus('current')
if mibBuilder.loadTexts: jmGeneralJobPersistence.setDescription('The minimum time in seconds for this instance of the Job Set\n        that an entry SHALL remain in the jmJobIDTable and jmJobTable\n        after processing has completed, i.e., the minimum time in\n        seconds starting when the job enters the completed, canceled,\n        or aborted state.\n\n        Configuring this object is implementation-dependent.\n\n        This value SHALL be equal to or greater than the value of\n        jmGeneralAttributePersistence.  This value SHOULD be at least\n        60 which gives a monitoring or accounting application one\n        minute in which to poll for job data.')
jmGeneralAttributePersistence = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 2147483647)).clone(60)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: jmGeneralAttributePersistence.setStatus('current')
if mibBuilder.loadTexts: jmGeneralAttributePersistence.setDescription('The minimum time in seconds for this instance of the Job Set\n        that an entry SHALL remain in the jmAttributeTable after\n        processing has completed , i.e., the time in seconds starting\n        when the job enters the completed, canceled, or aborted state.\n\n        Configuring this object is implementation-dependent.\n\n        This value SHOULD be at least 60 which gives a monitoring or\n        accounting application one minute in which to poll for job\n        data.')
jmGeneralJobSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 1, 1, 1, 7), JmUTF8StringTC().subtype(subtypeSpec=ValueSizeConstraint(0, 63)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmGeneralJobSetName.setStatus('current')
if mibBuilder.loadTexts: jmGeneralJobSetName.setDescription("The human readable name of this job set assigned by the system\n        administrator (by means outside of this MIB).  Typically, this\n        name SHOULD be the name of the job queue.  If a server or\n        device has only a single job set, this object can be the\n        administratively assigned name of the server or device itself.\n        This name does not need to be unique, though each job set in a\n        single Job Monitoring MIB SHOULD have distinct names.\n\n        NOTE - If the job set corresponds to a single printer and the\n        Printer MIB is implemented, this value SHOULD be the same as\n        the prtGeneralPrinterName object in the draft Printer MIB\n        [print-mib-draft].  If the job set corresponds to an IPP\n        Printer, this value SHOULD be the same as the IPP 'printer-\n        name' Printer attribute.\n\n        NOTE - The purpose of this object is to help the user of the\n        job monitoring application distinguish between several job sets\n        in implementations that support more than one job set.\n\n        See the OBJECT compliance macro for the minimum maximum length\n        required for conformance.")
jmJobID = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 2))
jmJobIDTable = MibTable((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 2, 1), )
if mibBuilder.loadTexts: jmJobIDTable.setStatus('current')
if mibBuilder.loadTexts: jmJobIDTable.setDescription('The jmJobIDTable provides a correspondence map (1) between the\n        job submission ID that a client uses to refer to a job and (2)\n        the jmGeneralJobSetIndex and jmJobIndex that the Job Monitoring\n        MIB agent assigned to the job and that are used to access the\n        job in all of the other tables in the MIB.  If a monitoring\n        application already knows the jmGeneralJobSetIndex and the\n        jmJobIndex of the job it is querying, that application NEED NOT\n        use the jmJobIDTable.\n\n        The MANDATORY-GROUP macro specifies that this group is\n        MANDATORY.')
jmJobIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 2, 1, 1), ).setIndexNames((0, "Job-Monitoring-MIB", "jmJobSubmissionID"))
if mibBuilder.loadTexts: jmJobIDEntry.setStatus('current')
if mibBuilder.loadTexts: jmJobIDEntry.setDescription('The map from (1) the jmJobSubmissionID to (2) the\n        jmGeneralJobSetIndex and jmJobIndex.\n\n        An entry SHALL exist in this table for each job currently known\n        to the agent for all job sets and job states.  There MAY be\n        more than one jmJobIDEntry that maps to a single job.  This\n        many to one mapping can occur when more than one network entity\n        along the job submission path supplies a job submission ID.\n        See Section 3.5.  However, each job SHALL appear once and in\n        one and only one job set.')
jmJobSubmissionID = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(48, 48)).setFixedLength(48))
if mibBuilder.loadTexts: jmJobSubmissionID.setStatus('current')
if mibBuilder.loadTexts: jmJobSubmissionID.setDescription("A quasi-unique 48-octet fixed-length string ID which\n        identifies the job within a particular client-server\n        environment.  There are multiple formats for the\n        jmJobSubmissionID.  Each format SHALL be uniquely identified.\n        See the JmJobSubmissionIDTypeTC textual convention.  Each\n        format SHALL be registered using the procedures of a type 2\n        enum.  See section 3.7.3 entitled: 'PWG Registration of Job\n        Submission Id Formats'.\n\n        If the requester (client or server) does not supply a job\n        submission ID in the job submission protocol, then the\n        recipient (server or device) SHALL assign a job submission ID\n        using any of the standard formats that have been reserved for\n        agents and adding the final 8 octets to distinguish the ID from\n        others submitted from the same requester.\n\n        The monitoring application, whether in the client or running\n        separately, MAY use the job submission ID to help identify\n        which jmJobIndex was assigned by the agent, i.e., in which row\n        the job information is in the other tables.\n\n        NOTE - fixed-length is used so that a management application\n        can use a shortened GetNext varbind (in SNMPv1 and SNMPv2) in\n        order to get the next submission ID, disregarding the remainder\n        of the ID in order to access jobs independent of the trailing\n        identifier part, e.g., to get all jobs submitted by a\n        particular jmJobOwner or submitted from a particular MAC\n        address.\n\n        See the JmJobSubmissionIDTypeTC textual convention.\n        See APPENDIX B - Support of Job Submission Protocols.")
jmJobIDJobSetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobIDJobSetIndex.setStatus('current')
if mibBuilder.loadTexts: jmJobIDJobSetIndex.setDescription('This object contains the value of the jmGeneralJobSetIndex for\n        the job with the jmJobSubmissionID value, i.e., the job set\n        index of the job set in which the job was placed when that\n        server or device accepted the job.  This 16-bit value in\n\n        combination with the jmJobIDJobIndex value permits the\n        management application to access the other tables to obtain the\n        job-specific objects for this job.\n\n        See jmGeneralJobSetIndex in the jmGeneralTable.')
jmJobIDJobIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobIDJobIndex.setStatus('current')
if mibBuilder.loadTexts: jmJobIDJobIndex.setDescription('This object contains the value of the jmJobIndex for the job\n        with the jmJobSubmissionID value, i.e., the job index for the\n        job when the server or device accepted the job.  This value, in\n        combination with the jmJobIDJobSetIndex value, permits the\n        management application to access the other tables to obtain the\n        job-specific objects for this job.\n\n        See jmJobIndex in the jmJobTable.')
jmJob = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3))
jmJobTable = MibTable((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1), )
if mibBuilder.loadTexts: jmJobTable.setStatus('current')
if mibBuilder.loadTexts: jmJobTable.setDescription('The jmJobTable consists of basic job state and status\n        information for each job in a job set that (1) monitoring\n        applications need to be able to access in a single SNMP Get\n        operation, (2) that have a single value per job, and (3) that\n        SHALL always be implemented.\n\n        The MANDATORY-GROUP macro specifies that this group is\n        MANDATORY.')
jmJobEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1), ).setIndexNames((0, "Job-Monitoring-MIB", "jmGeneralJobSetIndex"), (0, "Job-Monitoring-MIB", "jmJobIndex"))
if mibBuilder.loadTexts: jmJobEntry.setStatus('current')
if mibBuilder.loadTexts: jmJobEntry.setDescription("Basic per-job state and status information.\n\n        An entry SHALL exist in this table for each job, no matter what\n        the state of the job is.  Each job SHALL appear in one and only\n        one job set.\n\n        See Section 3.2 entitled 'The Job Tables'.")
jmJobIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: jmJobIndex.setStatus('current')
if mibBuilder.loadTexts: jmJobIndex.setDescription("The sequential, monatonically increasing identifier index for\n        the job generated by the server or device when that server or\n        device accepted the job.  This index value permits the\n        management application to access the other tables to obtain the\n        job-specific row entries.\n\n        See Section 3.2 entitled 'The Job Tables and the Oldest Active\n        and Newest Active Indexes'.\n        See Section 3.5 entitled 'Job Identification'.\n        See also jmGeneralNewestActiveJobIndex for the largest value of\n        jmJobIndex.\n        See JmJobSubmissionIDTypeTC for a limit on the size of this\n        index if the agent represents it as an 8-digit decimal number.")
jmJobState = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 2), JmJobStateTC().clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobState.setStatus('current')
if mibBuilder.loadTexts: jmJobState.setDescription('The current state of the job (pending, processing, completed,\n        etc.).  Agents SHALL implement only those states which are\n        appropriate for the particular implementation.  However,\n        management applications SHALL be prepared to receive all the\n        standard job states.\n\n        The final value for this object SHALL be one of: completed,\n        canceled, or aborted.  The minimum length of time that the\n        agent SHALL maintain MIB data for a job in the completed,\n        canceled, or aborted state before removing the job data from\n        the jmJobIDTable and jmJobTable is specified by the value of\n        the jmGeneralJobPersistence object.')
jmJobStateReasons1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 3), JmJobStateReasons1TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobStateReasons1.setStatus('current')
if mibBuilder.loadTexts: jmJobStateReasons1.setDescription("Additional information about the job's current state, i.e.,\n        information that augments the value of the job's jmJobState\n        object.\n\n        Implementation of any reason values is OPTIONAL, but an agent\n        SHOULD return any reason information available.  These values\n        MAY be used with any job state or states for which the reason\n        makes sense.  Since the Job State Reasons will be more dynamic\n        than the Job State, it is recommended that a job monitoring\n        application read this object every time jmJobState is read.\n        When the agent cannot provide a reason for the current state of\n        the job, the value of the jmJobStateReasons1 object and\n        jobStateReasonsN attributes SHALL be 0.\n\n        The jobStateReasonsN (N=2..4) attributes provide further\n        additional information about the job's current state.")
jmNumberOfInterveningJobs = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmNumberOfInterveningJobs.setStatus('current')
if mibBuilder.loadTexts: jmNumberOfInterveningJobs.setDescription("The number of jobs that are expected to complete processing\n        before this job has completed processing according to the\n        implementation's queuing algorithm, if no other jobs were to be\n        submitted.  In other words, this value is the job's queue\n        position.  The agent SHALL return a value of 0 for this\n        attribute when the job is the next job to complete processing\n        (or has completed processing).")
jmJobKOctetsPerCopyRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 2147483647)).clone(-2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobKOctetsPerCopyRequested.setStatus('current')
if mibBuilder.loadTexts: jmJobKOctetsPerCopyRequested.setDescription("The total size in K (1024) octets of the document(s) being\n        requested to be processed in the job.  The agent SHALL round\n        the actual number of octets up to the next highest K.  Thus 0\n        octets is represented as '0', 1-1024 octets is represented as\n        '1', 1025-2048 is represented as '2', etc.\n\n        In computing this value, the server/device SHALL NOT include\n        the multiplicative factors contributed by (1) the number of\n        document copies, and (2) the number of job copies, independent\n        of whether the device can process multiple copies of the job or\n        document without making multiple passes over the job or\n        document data and independent of whether the output is collated\n        or not.  Thus the server/device computation is independent of\n        the implementation and indicates the size of the document(s)\n        measured in K octets independent of the number of copies.")
jmJobKOctetsProcessed = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobKOctetsProcessed.setStatus('current')
if mibBuilder.loadTexts: jmJobKOctetsProcessed.setDescription("The total number of octets processed by the server or device\n\n        measured in units of K (1024) octets so far.  The agent SHALL\n        round the actual number of octets processed up to the next\n        higher K.  Thus 0 octets is represented as '0', 1-1024 octets\n        is represented as '1', 1025-2048 octets is '2', etc.  For\n        printing devices, this value is the number interpreted by the\n        page description language interpreter rather than what has been\n        marked on media.\n\n        For implementations where multiple copies are produced by the\n        interpreter with only a single pass over the data, the final\n        value SHALL be equal to the value of the\n        jmJobKOctetsPerCopyRequested object.  For implementations where\n        multiple copies are produced by the interpreter by processing\n        the data for each copy, the final value SHALL be a multiple of\n        the value of the jmJobKOctetsPerCopyRequested object.\n\n        NOTE - See the impressionsCompletedCurrentCopy and\n        pagesCompletedCurrentCopy attributes for attributes that are\n        reset on each document copy.\n\n        NOTE - The jmJobKOctetsProcessed object can be used with the\n        jmJobKOctetsPerCopyRequested object to provide an indication of\n        the relative progress of the job, provided that the\n        multiplicative factor is taken into account for some\n        implementations of multiple copies.")
jmJobImpressionsPerCopyRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 2147483647)).clone(-2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobImpressionsPerCopyRequested.setStatus('current')
if mibBuilder.loadTexts: jmJobImpressionsPerCopyRequested.setDescription("The total size in number of impressions of the document(s)\n        submitted.\n\n        In computing this value, the server/device SHALL NOT include\n        the multiplicative factors contributed by (1) the number of\n        document copies, and (2) the number of job copies, independent\n        of whether the device can process multiple copies of the job or\n        document without making multiple passes over the job or\n        document data and independent of whether the output is collated\n        or not.  Thus the server/device computation is independent of\n        the implementation and reflects the size of the document(s)\n        measured in impressions independent of the number of copies.\n\n        See the definition of the term 'impression' in Section 2.")
jmJobImpressionsCompleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobImpressionsCompleted.setStatus('current')
if mibBuilder.loadTexts: jmJobImpressionsCompleted.setDescription("The total number of impressions completed for this job so far.\n        For printing devices, the impressions completed includes\n        interpreting, marking, and stacking the output.  For other\n        types of job services, the number of impressions completed\n        includes the number of impressions processed.\n\n        NOTE - See the impressionsCompletedCurrentCopy and\n        pagesCompletedCurrentCopy attributes for attributes that are\n        reset on each document copy.\n\n        NOTE - The jmJobImpressionsCompleted object can be used with\n        the jmJobImpressionsPerCopyRequested object to provide an\n        indication of the relative progress of the job, provided that\n        the multiplicative factor is taken into account for some\n        implementations of multiple copies.\n\n        See the definition of the term 'impression' in Section 2 and\n        the counting example in Section 3.4 entitled 'Monitoring Job\n        Progress'.")
jmJobOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 3, 1, 1, 9), JmJobStringTC().subtype(subtypeSpec=ValueSizeConstraint(0, 63)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmJobOwner.setStatus('current')
if mibBuilder.loadTexts: jmJobOwner.setDescription('The coded character set name of the user that submitted the\n        job.  The method of assigning this user name will be system\n        and/or site specific but the method MUST ensure that the name\n        is unique to the network that is visible to the client and\n        target device.\n\n        This value SHOULD be the most authenticated name of the user\n        submitting the job.\n\n        See the OBJECT compliance macro for the minimum maximum length\n\n        required for conformance.')
jmAttribute = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 4))
jmAttributeTable = MibTable((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 4, 1), )
if mibBuilder.loadTexts: jmAttributeTable.setStatus('current')
if mibBuilder.loadTexts: jmAttributeTable.setDescription('The jmAttributeTable SHALL contain attributes of the job and\n        document(s) for each job in a job set.  Instead of allocating\n        distinct objects for each attribute, each attribute is\n        represented as a separate row in the jmAttributeTable.\n\n        The MANDATORY-GROUP macro specifies that this group is\n        MANDATORY.  An agent SHALL implement any attribute if (1) the\n        server or device supports the functionality represented by the\n        attribute and (2) the information is available to the agent. ')
jmAttributeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 4, 1, 1), ).setIndexNames((0, "Job-Monitoring-MIB", "jmGeneralJobSetIndex"), (0, "Job-Monitoring-MIB", "jmJobIndex"), (0, "Job-Monitoring-MIB", "jmAttributeTypeIndex"), (0, "Job-Monitoring-MIB", "jmAttributeInstanceIndex"))
if mibBuilder.loadTexts: jmAttributeEntry.setStatus('current')
if mibBuilder.loadTexts: jmAttributeEntry.setDescription("Attributes representing information about the job and\n        document(s) or resources required and/or consumed.\n\n        Each entry in the jmAttributeTable is a per-job entry with an\n        extra index for each type of attribute (jmAttributeTypeIndex)\n        that a job can have and an additional index\n        (jmAttributeInstanceIndex) for those attributes that can have\n\n        multiple instances per job.  The jmAttributeTypeIndex object\n        SHALL contain an enum type that indicates the type of attribute\n        (see the JmAttributeTypeTC textual-convention).  The value of\n        the attribute SHALL be represented in either the\n        jmAttributeValueAsInteger or jmAttributeValueAsOctets objects,\n        and/or both, as specified in the JmAttributeTypeTC textual-\n        convention.\n\n        The agent SHALL create rows in the jmAttributeTable as the\n        server or device is able to discover the attributes either from\n        the job submission protocol itself or from the document PDL.\n        As the documents are interpreted, the interpreter MAY discover\n        additional attributes and so the agent adds additional rows to\n        this table.  As the attributes that represent resources are\n        actually consumed, the usage counter contained in the\n        jmAttributeValueAsInteger object is incremented according to\n        the units indicated in the description of the JmAttributeTypeTC\n        enum.\n\n        The agent SHALL maintain each row in the jmAttributeTable for\n        at least the minimum time after a job completes as specified by\n        the jmGeneralAttributePersistence object.\n\n        Zero or more entries SHALL exist in this table for each job in\n        a job set.\n\n        See Section 3.3 entitled 'The Attribute Mechanism' for a\n        description of the jmAttributeTable.")
jmAttributeTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 4, 1, 1, 1), JmAttributeTypeTC())
if mibBuilder.loadTexts: jmAttributeTypeIndex.setStatus('current')
if mibBuilder.loadTexts: jmAttributeTypeIndex.setDescription('The type of attribute that this row entry represents.\n\n        The type MAY identify information about the job or document(s)\n\n        or MAY identify a resource required to process the job before\n        the job start processing and/or consumed by the job as the job\n        is processed.\n\n        Examples of job attributes (i.e., apply to the job as a whole)\n        that have only one instance per job include:\n        jobCopiesRequested(90), documentCopiesRequested(92),\n        jobCopiesCompleted(91), documentCopiesCompleted(93), while\n        examples of job attributes that may have more than one instance\n        per job include:  documentFormatIndex(37), and\n        documentFormat(38).\n\n        Examples of document attributes (one instance per document)\n        include: fileName(34), and documentName(35).\n\n        Examples of required and consumed resource attributes include:\n        pagesRequested(130), mediumRequested(170), pagesCompleted(131),\n        and mediumConsumed(171), respectively.')
jmAttributeInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)))
if mibBuilder.loadTexts: jmAttributeInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: jmAttributeInstanceIndex.setDescription('A running 16-bit index of the attributes of the same type for\n        each job.  For those attributes with only a single instance per\n        job, this index value SHALL be 1.  For those attributes that\n        are a single value per document, the index value SHALL be the\n        document number, starting with 1 for the first document in the\n        job.  Jobs with only a single document SHALL use the index\n        value of 1.  For those attributes that can have multiple values\n        per job or per document, such as documentFormatIndex(37) or\n        documentFormat(38), the index SHALL be a running index for the\n        job as a whole, starting at 1.')
jmAttributeValueAsInteger = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 2147483647)).clone(-2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmAttributeValueAsInteger.setStatus('current')
if mibBuilder.loadTexts: jmAttributeValueAsInteger.setDescription("The integer value of the attribute.  The value of the\n        attribute SHALL be represented as an integer if the enum\n\n        description in the JmAttributeTypeTC textual-convention\n        definition has the tag: 'INTEGER:'.\n\n        Depending on the enum definition, this object value MAY be an\n        integer, a counter, an index, or an enum, depending on the\n        jmAttributeTypeIndex value.  The units of this value are\n        specified in the enum description.\n\n        For those attributes that are accumulating job consumption as\n        the job is processed as specified in the JmAttributeTypeTC\n        textual-convention, SHALL contain the final value after the job\n        completes processing, i.e., this value SHALL indicate the total\n        usage of this resource made by the job.\n\n        A monitoring application is able to copy this value to a\n        suitable longer term storage for later processing as part of an\n        accounting system.\n\n        Since the agent MAY add attributes representing resources to\n        this table while the job is waiting to be processed or being\n        processed, which can be a long time before any of the resources\n        are actually used, the agent SHALL set the value of the\n        jmAttributeValueAsInteger object to 0 for resources that the\n        job has not yet consumed.\n\n        Attributes for which the concept of an integer value is\n        meaningless, such as fileName(34), jobName, and\n        processingMessage, do not have the 'INTEGER:' tag in the\n        JmAttributeTypeTC definition and so an agent SHALL always\n        return a value of '-1' to indicate 'other' for the value of the\n        jmAttributeValueAsInteger object for these attributes.\n\n        For attributes which do have the 'INTEGER:' tag in the\n        JmAttributeTypeTC definition, if the integer value is not (yet)\n        known, the agent either (1) SHALL not materialize the row in\n        the jmAttributeTable until the value is known or (2) SHALL\n        return a '-2' to represent an 'unknown' counting integer value,\n        a '0' to represent an 'unknown' index value, and a '2' to\n        represent an 'unknown(2)' enum value.")
jmAttributeValueAsOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2699, 1, 1, 1, 4, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: jmAttributeValueAsOctets.setStatus('current')
if mibBuilder.loadTexts: jmAttributeValueAsOctets.setDescription("The octet string value of the attribute.  The value of the\n        attribute SHALL be represented as an OCTET STRING if the enum\n        description in the JmAttributeTypeTC textual-convention\n        definition has the tag: 'OCTETS:'.\n\n        Depending on the enum definition, this object value MAY be a\n        coded character set string (text), such as 'JmUTF8StringTC', or\n        a binary octet string, such as 'DateAndTime'.\n\n        Attributes for which the concept of an octet string value is\n        meaningless, such as pagesCompleted, do not have the tag\n        'OCTETS:' in the JmAttributeTypeTC definition and so the agent\n        SHALL always return a zero length string for the value of the\n        jmAttributeValueAsOctets object.\n\n        For attributes which do have the 'OCTETS:' tag in the\n        JmAttributeTypeTC definition, if the OCTET STRING value is not\n        (yet) known, the agent either SHALL NOT materialize the row in\n        the jmAttributeTable until the value is known or SHALL return a\n        zero-length string.")
jobmonMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 2))
jmMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 3))
jmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2699, 1, 1, 3, 1)).setObjects(("Job-Monitoring-MIB", "jmGeneralGroup"), ("Job-Monitoring-MIB", "jmJobIDGroup"), ("Job-Monitoring-MIB", "jmJobGroup"), ("Job-Monitoring-MIB", "jmAttributeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jmMIBCompliance = jmMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: jmMIBCompliance.setDescription('The compliance statement for agents that implement the\n        job monitoring MIB.')
jmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2699, 1, 1, 3, 2))
jmGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2699, 1, 1, 3, 2, 1)).setObjects(("Job-Monitoring-MIB", "jmGeneralNumberOfActiveJobs"), ("Job-Monitoring-MIB", "jmGeneralOldestActiveJobIndex"), ("Job-Monitoring-MIB", "jmGeneralNewestActiveJobIndex"), ("Job-Monitoring-MIB", "jmGeneralJobPersistence"), ("Job-Monitoring-MIB", "jmGeneralAttributePersistence"), ("Job-Monitoring-MIB", "jmGeneralJobSetName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jmGeneralGroup = jmGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: jmGeneralGroup.setDescription('The general group.')
jmJobIDGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2699, 1, 1, 3, 2, 2)).setObjects(("Job-Monitoring-MIB", "jmJobIDJobSetIndex"), ("Job-Monitoring-MIB", "jmJobIDJobIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jmJobIDGroup = jmJobIDGroup.setStatus('current')
if mibBuilder.loadTexts: jmJobIDGroup.setDescription('The job ID group.')
jmJobGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2699, 1, 1, 3, 2, 3)).setObjects(("Job-Monitoring-MIB", "jmJobState"), ("Job-Monitoring-MIB", "jmJobStateReasons1"), ("Job-Monitoring-MIB", "jmNumberOfInterveningJobs"), ("Job-Monitoring-MIB", "jmJobKOctetsPerCopyRequested"), ("Job-Monitoring-MIB", "jmJobKOctetsProcessed"), ("Job-Monitoring-MIB", "jmJobImpressionsPerCopyRequested"), ("Job-Monitoring-MIB", "jmJobImpressionsCompleted"), ("Job-Monitoring-MIB", "jmJobOwner"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jmJobGroup = jmJobGroup.setStatus('current')
if mibBuilder.loadTexts: jmJobGroup.setDescription('The job group.')
jmAttributeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2699, 1, 1, 3, 2, 4)).setObjects(("Job-Monitoring-MIB", "jmAttributeValueAsInteger"), ("Job-Monitoring-MIB", "jmAttributeValueAsOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jmAttributeGroup = jmAttributeGroup.setStatus('current')
if mibBuilder.loadTexts: jmAttributeGroup.setDescription('The attribute group.')
mibBuilder.exportSymbols("Job-Monitoring-MIB", JmPrintQualityTC=JmPrintQualityTC, JmJobServiceTypesTC=JmJobServiceTypesTC, jmAttribute=jmAttribute, JmJobStateReasons4TC=JmJobStateReasons4TC, jmJob=jmJob, jmAttributeEntry=jmAttributeEntry, jobmonMIBNotifications=jobmonMIBNotifications, JmAttributeTypeTC=JmAttributeTypeTC, jmGeneralJobSetIndex=jmGeneralJobSetIndex, PYSNMP_MODULE_ID=jobmonMIB, jobmonMIBObjects=jobmonMIBObjects, jmGeneralNumberOfActiveJobs=jmGeneralNumberOfActiveJobs, jmGeneralJobSetName=jmGeneralJobSetName, JmJobSourcePlatformTypeTC=JmJobSourcePlatformTypeTC, JmJobStateReasons2TC=JmJobStateReasons2TC, jmJobKOctetsProcessed=jmJobKOctetsProcessed, jmMIBCompliance=jmMIBCompliance, jmJobStateReasons1=jmJobStateReasons1, jmAttributeGroup=jmAttributeGroup, jmJobSubmissionID=jmJobSubmissionID, jmNumberOfInterveningJobs=jmNumberOfInterveningJobs, JmNaturalLanguageTagTC=JmNaturalLanguageTagTC, jmJobKOctetsPerCopyRequested=jmJobKOctetsPerCopyRequested, jmJobImpressionsPerCopyRequested=jmJobImpressionsPerCopyRequested, JmJobStateReasons3TC=JmJobStateReasons3TC, jmGeneralEntry=jmGeneralEntry, jmGeneralJobPersistence=jmGeneralJobPersistence, jmJobTable=jmJobTable, JmFinishingTC=JmFinishingTC, JmUTF8StringTC=JmUTF8StringTC, JmTonerEconomyTC=JmTonerEconomyTC, jmAttributeTypeIndex=jmAttributeTypeIndex, jmAttributeValueAsInteger=jmAttributeValueAsInteger, jmJobIDGroup=jmJobIDGroup, jmJobGroup=jmJobGroup, jmJobID=jmJobID, jmAttributeInstanceIndex=jmAttributeInstanceIndex, jmJobIndex=jmJobIndex, JmJobCollationTypeTC=JmJobCollationTypeTC, jmJobIDEntry=jmJobIDEntry, jmJobEntry=jmJobEntry, JmJobSubmissionIDTypeTC=JmJobSubmissionIDTypeTC, JmMediumTypeTC=JmMediumTypeTC, JmTimeStampTC=JmTimeStampTC, jmGeneralTable=jmGeneralTable, jmJobIDJobIndex=jmJobIDJobIndex, jmJobState=jmJobState, jmJobOwner=jmJobOwner, jmGeneralGroup=jmGeneralGroup, jmJobImpressionsCompleted=jmJobImpressionsCompleted, jmAttributeValueAsOctets=jmAttributeValueAsOctets, jmMIBConformance=jmMIBConformance, jmAttributeTable=jmAttributeTable, JmPrinterResolutionTC=JmPrinterResolutionTC, jmMIBGroups=jmMIBGroups, jobmonMIB=jobmonMIB, jmGeneralNewestActiveJobIndex=jmGeneralNewestActiveJobIndex, JmJobStateTC=JmJobStateTC, jmGeneral=jmGeneral, jmGeneralAttributePersistence=jmGeneralAttributePersistence, JmJobStringTC=JmJobStringTC, jmJobIDJobSetIndex=jmJobIDJobSetIndex, JmJobStateReasons1TC=JmJobStateReasons1TC, jmGeneralOldestActiveJobIndex=jmGeneralOldestActiveJobIndex, jmJobIDTable=jmJobIDTable, JmBooleanTC=JmBooleanTC)
