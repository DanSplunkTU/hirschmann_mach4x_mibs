#
# PySNMP MIB module HC-RMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/HC-RMON-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 05:10:50 2022
# On host fv-az42-839 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
matrixSDDestAddress, rmon, matrixDSDestAddress, hostIndex, etherStatsIndex, hostAddress, hostTopNReport, hostTopNControlEntry, statistics, matrixSDIndex, capture, OwnerString, captureBufferIndex, captureBufferControlIndex, hostTimeCreationOrder, matrix, history, hostTopNIndex, etherHistorySampleIndex, hostTopN, matrixSDSourceAddress, matrixDSIndex, hosts, matrixDSSourceAddress, etherHistoryIndex, hostTimeIndex = mibBuilder.importSymbols("RMON-MIB", "matrixSDDestAddress", "rmon", "matrixDSDestAddress", "hostIndex", "etherStatsIndex", "hostAddress", "hostTopNReport", "hostTopNControlEntry", "statistics", "matrixSDIndex", "capture", "OwnerString", "captureBufferIndex", "captureBufferControlIndex", "hostTimeCreationOrder", "matrix", "history", "hostTopNIndex", "etherHistorySampleIndex", "hostTopN", "matrixSDSourceAddress", "matrixDSIndex", "hosts", "matrixDSSourceAddress", "etherHistoryIndex", "hostTimeIndex")
nlMatrixSDSourceAddress, nlMatrixSDTimeMark, nlMatrix, nlMatrixDSSourceAddress, nlMatrixTopNIndex, alHostTimeMark, nlMatrixTopNControlIndex, ZeroBasedCounter32, protocolDist, nlHostTimeMark, hlMatrixControlIndex, alMatrixTopNControlIndex, rmonConformance, nlHostAddress, alMatrixSDTimeMark, alHost, usrHistory, nlMatrixDSTimeMark, probeConfig, nlMatrixSDDestAddress, protocolDistControlIndex, nlHost, alMatrixTopNControlEntry, usrHistoryObjectIndex, protocolDirLocalIndex, usrHistoryControlIndex, alMatrix, nlMatrixDSDestAddress, alMatrixDSTimeMark, hlHostControlIndex, alMatrixTopNIndex, nlMatrixTopNControlEntry, usrHistorySampleIndex = mibBuilder.importSymbols("RMON2-MIB", "nlMatrixSDSourceAddress", "nlMatrixSDTimeMark", "nlMatrix", "nlMatrixDSSourceAddress", "nlMatrixTopNIndex", "alHostTimeMark", "nlMatrixTopNControlIndex", "ZeroBasedCounter32", "protocolDist", "nlHostTimeMark", "hlMatrixControlIndex", "alMatrixTopNControlIndex", "rmonConformance", "nlHostAddress", "alMatrixSDTimeMark", "alHost", "usrHistory", "nlMatrixDSTimeMark", "probeConfig", "nlMatrixSDDestAddress", "protocolDistControlIndex", "nlHost", "alMatrixTopNControlEntry", "usrHistoryObjectIndex", "protocolDirLocalIndex", "usrHistoryControlIndex", "alMatrix", "nlMatrixDSDestAddress", "alMatrixDSTimeMark", "hlHostControlIndex", "alMatrixTopNIndex", "nlMatrixTopNControlEntry", "usrHistorySampleIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Counter32, NotificationType, iso, IpAddress, TimeTicks, ModuleIdentity, Counter64, Unsigned32, Bits, Gauge32, ObjectIdentity, MibIdentifier, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "iso", "IpAddress", "TimeTicks", "ModuleIdentity", "Counter64", "Unsigned32", "Bits", "Gauge32", "ObjectIdentity", "MibIdentifier", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus")
hcRMON = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 20, 8))
if mibBuilder.loadTexts: hcRMON.setLastUpdated('9702120000Z')
if mibBuilder.loadTexts: hcRMON.setOrganization('IETF RMON MIB Working Group')
if mibBuilder.loadTexts: hcRMON.setContactInfo('Steve Waldbusser \n        Postal: International Network Services \n        1213 Innsbruck Dr. \n        Sunnyvale, CA 94089 \n        Phone:  +1 408 542 0251 \n        Email:  waldbusser@ins.com')
if mibBuilder.loadTexts: hcRMON.setDescription('The MIB module for managing remote monitoring \n        device implementations. This MIB module \n        augments the original RMON MIB as specified in \n        RFC 1757 and RFC 1513 and RMON2 MIB as specified in \n        RFC 2021.')
mediaIndependentStats = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 21))
class ZeroBasedCounter64(TextualConvention, Counter64):
    description = 'This TC describes an object which counts events with the \n        following semantics: objects of this type will be set to \n        zero(0) on creation and will thereafter count appropriate \n        events, wrapping back to zero(0) when the value 2^64 is \n        reached. \n \n        Provided that an application discovers the new object within \n        the minimum time to wrap it can use the initial value as a \n \n \n \n \n \n \n \n \n \n \n \n        delta since it last polled the table of which this object is \n        part.  It is important for a management station to be aware of \n        this minimum time and the actual time between polls, and to \n        discard data if the actual time is too long or there is no \n        defined minimum time. \n \n        Typically this TC is used in tables where the INDEX space is \n        constantly changing and/or the TimeFilter mechanism is in use.'
    status = 'current'

class RmonGauge64(TextualConvention, Counter64):
    description = 'The RmonGauge64 type represents a non-negative integer, which \n        may increase or decrease, but shall never exceed a maximum value. \n        The maximum value can not be greater than 2^64-1. The value of a \n        Gauge has its maximum value whenever the information being modeled \n        is greater or equal to that maximum value; if the information \n        being modeled subsequently decreases below the maximum value, the \n        Gauge also decreases.'
    status = 'current'

mediaIndependentTable = MibTable((1, 3, 6, 1, 2, 1, 16, 21, 1), )
if mibBuilder.loadTexts: mediaIndependentTable.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentTable.setDescription('Media independent statistics for promiscious monitoring of \n        any media. \n \n        The following table defines media independent statistics that \n        provides information for full and/or half-duplex links as well \n        as high capacity links. \n \n        For half-duplex links, the mediaIndependentOut* objects will \n        not be present. \n        For full-duplex links, the mediaIndependentOut* objects will be \n        present. Whenever possible, the probe should count packets \n        moving away from the closest terminating equipment as output \n        packets. Failing that, the probe should count packets moving \n        away from the DTE as output packets.')
mediaIndependentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 21, 1, 1), ).setIndexNames((0, "HC-RMON-MIB", "mediaIndependentIndex"))
if mibBuilder.loadTexts: mediaIndependentEntry.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentEntry.setDescription('Media independent statistics for promiscious monitoring of \n        any media.')
mediaIndependentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentIndex.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentIndex.setDescription('The value of this object uniquely identifies this \n \n \n \n \n \n \n \n \n \n \n \n        mediaIndependent entry.')
mediaIndependentDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mediaIndependentDataSource.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentDataSource.setDescription('This object identifies the source of the data that \n        this mediaIndependent entry is configured to analyze.  This \n        source can be any interface on this device. \n        In order to identify a particular interface, this \n        object shall identify the instance of the ifIndex \n        object, defined in RFC 1213 and RFC 1573 [4,6], for \n        the desired interface.  For example, if an entry \n        were to receive data from interface #1, this object \n        would be set to ifIndex.1. \n \n        The statistics in this group reflect all packets \n        on the local network segment attached to the \n        identified interface. \n \n        An agent may or may not be able to tell if \n        fundamental changes to the media of the interface \n        have occurred and necessitate an invalidation of \n        this entry.  For example, a hot-pluggable ethernet \n        card could be pulled out and replaced by a \n        token-ring card.  In such a case, if the agent has \n        such knowledge of the change, it is recommended that \n        it invalidate this entry. \n \n        This object may not be modified if the associated \n        mediaIndependentStatus object is equal to valid(1).')
mediaIndependentDropEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentDropEvents.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentDropEvents.setDescription('The total number of events in which packets \n        were dropped by the probe due to lack of resources. \n        Note that this number is not necessarily the number of \n        packets dropped; it is just the number of times this \n        condition has been detected.')
mediaIndependentDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentDroppedFrames.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentDroppedFrames.setDescription('The total number of frames which were received by the probe \n        and therefore not accounted for in the \n        mediaIndependentDropEvents, but for which the probe chose not \n        to count for this entry for whatever reason.  Most often, this \n        event occurs when the probe is out of some resources and \n        decides to shed load from this collection. \n \n        This count does not include packets that were not counted \n        because they had MAC-layer errors. \n \n        Note that, unlike the dropEvents counter, this number is the \n        exact number of frames dropped.')
mediaIndependentInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInPkts.setDescription('The total number of packets (including bad packets, \n        broadcast packets, and multicast packets) received \n        on a half-duplex link or on the inbound connection of a \n        full-duplex link.')
mediaIndependentInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInOverflowPkts.setDescription('The number of times the associated \n        mediaIndependentInPkts counter has overflowed.')
mediaIndependentInHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInHighCapacityPkts.setDescription('The total number of packets (including bad packets, \n        broadcast packets, and multicast packets) received \n        on a half-duplex link or on the inbound connection of a \n        full-duplex link.')
mediaIndependentOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutPkts.setDescription('The total number of packets (including bad packets, \n        broadcast packets, and multicast packets) received on a \n        full-duplex link in the direction of the network.')
mediaIndependentOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutOverflowPkts.setDescription('The number of times the associated \n        mediaIndependentOutPkts counter has overflowed.')
mediaIndependentOutHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutHighCapacityPkts.setDescription('The total number of packets (including bad packets, \n        broadcast packets, and multicast packets) received on a \n        full-duplex link in the direction of the network.')
mediaIndependentInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInOctets.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInOctets.setDescription('The total number of octets of data (including those in bad \n        packets) received (excluding framing bits but including FCS \n        octets) on a half-duplex link or on the inbound connection of \n        a full-duplex link.')
mediaIndependentInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInOverflowOctets.setDescription('The number of times the associated \n        mediaIndependentInOctets counter has overflowed.')
mediaIndependentInHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInHighCapacityOctets.setDescription('The total number of octets of data (including those in bad \n        packets) received (excluding framing bits but \n        including FCS octets) on a half-duplex link or on the inbound \n        connection of a full-duplex link.')
mediaIndependentOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutOctets.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutOctets.setDescription('The total number of octets of data (including those in bad \n        packets) received on a full-duplex link in the direction of \n        the network (excluding framing bits but including FCS \n        octets).')
mediaIndependentOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutOverflowOctets.setDescription('The number of times the associated \n        mediaIndependentOutOctets counter has overflowed.')
mediaIndependentOutHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutHighCapacityOctets.setDescription('The total number of packets (including bad packets, \n        broadcast packets, and multicast packets) received on a \n        full-duplex link in the direction of the network (excluding \n        framing bits but including FCS octets).')
mediaIndependentInNUCastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInNUCastPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInNUCastPkts.setDescription('The total number of non-unicast packets (including bad \n        packets) received on a half-duplex link or on the inbound \n        connection of a full-duplex link.')
mediaIndependentInNUCastOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInNUCastOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInNUCastOverflowPkts.setDescription('The number of times the associated \n        mediaIndependentInNUCastPkts counter has overflowed.')
mediaIndependentInNUCastHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInNUCastHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInNUCastHighCapacityPkts.setDescription('The total number of non-unicast packets (including bad \n        packets) received on a half-duplex link or on the inbound \n        connection of a full-duplex link.')
mediaIndependentOutNUCastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutNUCastPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutNUCastPkts.setDescription('The total number of non-unicast packets (including bad \n        packets) received on a full-duplex link in the direction of \n        the network.')
mediaIndependentOutNUCastOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutNUCastOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutNUCastOverflowPkts.setDescription('The number of times the associated \n        mediaIndependentOutNUCastPkts counter has overflowed.')
mediaIndependentOutNUCastHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutNUCastHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutNUCastHighCapacityPkts.setDescription('The total number of packets (including bad packets) \n        received on a full-duplex link in the direction of the \n        network.')
mediaIndependentInErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInErrors.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInErrors.setDescription('The total number of bad packets received on a \n        half-duplex link or on the inbound connection of a \n        full-duplex link.')
mediaIndependentOutErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutErrors.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutErrors.setDescription('The total number of bad packets received on a full-duplex \n        link in the direction of the network.')
mediaIndependentInputSpeed = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInputSpeed.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentInputSpeed.setDescription('The nominal maximum speed in kilobits per second of this \n        half-duplex link or on the inbound connection of this \n        full-duplex link. If the speed is unknown or there is no fixed \n        maximum (e.g. a compressed link), this value shall be zero.')
mediaIndependentOutputSpeed = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutputSpeed.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOutputSpeed.setDescription('The nominal maximum speed in kilobits per second of this \n        full-duplex link in the direction of the network. If the speed \n        is unknown or there is no fixed maximum (e.g. a compressed \n        link), this value shall be zero.')
mediaIndependentOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 27), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mediaIndependentOwner.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentOwner.setDescription('The entity that configured this entry and is \n        therefore using the resources assigned to it.')
mediaIndependentStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 28), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mediaIndependentStatus.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentStatus.setDescription('The status of this media independent statistics entry.')
etherStatsHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 1, 7), )
if mibBuilder.loadTexts: etherStatsHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        etherStatsTable.')
etherStatsHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 1, 7, 1), ).setIndexNames((0, "RMON-MIB", "etherStatsIndex"))
if mibBuilder.loadTexts: etherStatsHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        etherStatsEntry. These objects will be created by the agent \n        for all etherStatsEntries it deems appropriate.')
etherStatsHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts.setDescription('The number of times the associated etherStatsPkts \n        counter has overflowed.')
etherStatsHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityPkts.setDescription('The total number of packets (including bad packets, \n        broadcast packets, and multicast packets) received.')
etherStatsHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowOctets.setDescription('The number of times the associated etherStatsOctets \n        counter has overflowed.')
etherStatsHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOctets.setDescription('The total number of octets of data (including \n        those in bad packets) received on the \n        network (excluding framing bits but including \n        FCS octets). \n \n        If the network is half-duplex Fast Ethernet, this \n        object can be used as a reasonable estimate of \n        utilization. If greater precision is desired, the \n        etherStatsHighCapacityPkts and \n        etherStatsHighCapacityOctets objects should be sampled \n        before and after a common interval.  The differences \n        in the sampled values are Pkts and Octets, \n        respectively, and the number of seconds in the \n        interval is Interval.  These values \n        are used to calculate the Utilization as follows: \n \n                        Pkts * (.96 + .64) + (Octets * .08) \n        Utilization = ------------------------------------- \n                                Interval * 10,000 \n \n        The result of this equation is the value Utilization \n        which is the percent utilization of the ethernet \n        segment on a scale of 0 to 100 percent. \n \n        This table is not appropriate for monitoring full-duplex \n        ethernets. If the network is a full-duplex ethernet and the \n \n \n \n \n \n \n \n \n \n \n \n        mediaIndependentTable is monitoring that network, the \n        utilization can be calculated as follows: \n \n        1) Determine the utilization of the inbound path by using \n           the appropriate equation (for ethernet or fast ethernet) \n           to determine the utilization, substituting \n           mediaIndependentInPkts for etherStatsHighCapacityPkts, and \n           mediaIndependentInOctets for etherStatsHighCapacityOctets. \n           Call the resulting utilization inUtilization. \n \n        2) Determine the utilization of the outbound path by using \n           the same equation to determine the utilization, substituting \n           mediaIndependentOutPkts for etherStatsHighCapacityPkts, and \n           mediaIndependentOutOctetss for etherStatsHighCapacityOctets. \n           Call the resulting utilization outUtilization. \n \n        3) The utilization is the maximum of inUtilization and \n           outUtilization. This metric shows the amount of percentage \n           of bandwidth that is left before congestion will be \n           experienced on the link.')
etherStatsHighCapacityOverflowPkts64Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts64Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts64Octets.setDescription('The number of times the associated etherStatsPkts64Octets \n        counter has overflowed.')
etherStatsHighCapacityPkts64Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts64Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityPkts64Octets.setDescription('The total number of packets (including bad \n        packets) received that were 64 octets in length \n        (excluding framing bits but including FCS octets).')
etherStatsHighCapacityOverflowPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts65to127Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts65to127Octets.setDescription('The number of times the associated etherStatsPkts65to127Octets \n        counter has overflowed.')
etherStatsHighCapacityPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts65to127Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityPkts65to127Octets.setDescription('The total number of packets (including bad \n        packets) received that were between \n        65 and 127 octets in length inclusive \n        (excluding framing bits but including FCS octets).')
etherStatsHighCapacityOverflowPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts128to255Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts128to255Octets.setDescription('The number of times the associated etherStatsPkts128to255Octets \n        counter has overflowed.')
etherStatsHighCapacityPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts128to255Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityPkts128to255Octets.setDescription('The total number of packets (including bad \n        packets) received that were between \n        128 and 255 octets in length inclusive \n        (excluding framing bits but including FCS octets).')
etherStatsHighCapacityOverflowPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts256to511Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts256to511Octets.setDescription('The number of times the associated etherStatsPkts256to511Octets \n        counter has overflowed.')
etherStatsHighCapacityPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts256to511Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityPkts256to511Octets.setDescription('The total number of packets (including bad \n        packets) received that were between \n        256 and 511 octets in length inclusive \n        (excluding framing bits but including FCS octets).')
etherStatsHighCapacityOverflowPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts512to1023Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts512to1023Octets.setDescription('The number of times the associated etherStatsPkts512to1023Octets \n        counter has overflowed.')
etherStatsHighCapacityPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts512to1023Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityPkts512to1023Octets.setDescription('The total number of packets (including bad \n        packets) received that were between \n        512 and 1023 octets in length inclusive \n        (excluding framing bits but including FCS octets).')
etherStatsHighCapacityOverflowPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts1024to1518Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts1024to1518Octets.setDescription('The number of times the associated etherStatsPkts1024to1518Octets \n        counter has overflowed.')
etherStatsHighCapacityPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts1024to1518Octets.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityPkts1024to1518Octets.setDescription('The total number of packets (including bad \n        packets) received that were between \n        1024 and 1518 octets in length inclusive \n        (excluding framing bits but including FCS octets).')
etherHistoryHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 2, 6), )
if mibBuilder.loadTexts: etherHistoryHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: etherHistoryHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        etherHistoryTable.')
etherHistoryHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 2, 6, 1), ).setIndexNames((0, "RMON-MIB", "etherHistoryIndex"), (0, "RMON-MIB", "etherHistorySampleIndex"))
if mibBuilder.loadTexts: etherHistoryHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: etherHistoryHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        etherHistoryEntry. These objects will be created by the agent \n        for all etherHistoryEntries associated with whichever \n        historyControlEntries it deems appropriate. (i.e., either all \n        etherHistoryHighCapacityEntries associated with a particular \n        historyControlEntry will be created, or none of them will \n        be.)')
etherHistoryHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: etherHistoryHighCapacityOverflowPkts.setDescription('The number of times the associated etherHistoryPkts \n \n \n \n \n \n \n \n \n \n \n \n        Gauge overflowed during this sampling interval.')
etherHistoryHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 2), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: etherHistoryHighCapacityPkts.setDescription('The total number of packets (including bad packets, \n        broadcast packets, and multicast packets) received during \n        this sampling interval.')
etherHistoryHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: etherHistoryHighCapacityOverflowOctets.setDescription('The number of times the associated etherHistoryOctets \n        counter has overflowed during this sampling interval.')
etherHistoryHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 4), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: etherHistoryHighCapacityOctets.setDescription('The total number of octets of data (including \n        those in bad packets) received on the \n        network (excluding framing bits but including \n        FCS octets) during this sampling interval.')
hostHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 4, 5), )
if mibBuilder.loadTexts: hostHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        hostTable.')
hostHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 4, 5, 1), ).setIndexNames((0, "RMON-MIB", "hostIndex"), (0, "RMON-MIB", "hostAddress"))
if mibBuilder.loadTexts: hostHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        hostEntry. These objects will be created by the agent \n        for all hostEntries associated with whichever \n        hostControlEntries it deems appropriate. (i.e., either all \n        hostHighCapacityEntries associated with a particular \n        hostControlEntry will be created, or none of them will \n        be.)')
hostHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityInOverflowPkts.setDescription('The number of times the associated hostInPkts \n        counter has overflowed.')
hostHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInPkts.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityInPkts.setDescription('The number of good packets transmitted to \n        this address since it was added to the \n        hostHighCapacityTable.')
hostHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityOutOverflowPkts.setDescription('The number of times the associated hostOutPkts \n        counter has overflowed.')
hostHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutPkts.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityOutPkts.setDescription('The number of packets, including bad packets, transmitted \n        by this address since it was added to the \n        hostHighCapacityTable.')
hostHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityInOverflowOctets.setDescription('The number of times the associated hostInOctets \n        counter has overflowed.')
hostHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInOctets.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityInOctets.setDescription('The number of octets transmitted to this address \n        since it was added to the hostHighCapacityTable (excluding \n        framing bits but including FCS octets), except for \n        those octets in bad packets.')
hostHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityOutOverflowOctets.setDescription('The number of times the associated hostOutOctets \n        counter has overflowed.')
hostHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutOctets.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityOutOctets.setDescription('The number of octets transmitted by this address \n        since it was added to the hostHighCapacityTable (excluding \n        framing bits but including FCS octets), including \n        those octets in bad packets.')
hostTimeHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 4, 6), )
if mibBuilder.loadTexts: hostTimeHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        hostTimeTable.')
hostTimeHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 4, 6, 1), ).setIndexNames((0, "RMON-MIB", "hostTimeIndex"), (0, "RMON-MIB", "hostTimeCreationOrder"))
if mibBuilder.loadTexts: hostTimeHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        hostTimeEntry. These objects will be created by the agent \n        for all hostTimeEntries associated with whichever \n        hostControlEntries it deems appropriate. (i.e., either all \n        hostTimeHighCapacityEntries associated with a particular \n        hostControlEntry will be created, or none of them will \n        be.)')
hostTimeHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityInOverflowPkts.setDescription('The number of times the associated hostTimeInPkts \n        counter has overflowed.')
hostTimeHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInPkts.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityInPkts.setDescription('The number of good packets transmitted to this address \n        since it was added to the hostTimeHighCapacityTable.')
hostTimeHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityOutOverflowPkts.setDescription('The number of times the associated hostTimeOutPkts \n        counter has overflowed.')
hostTimeHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutPkts.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityOutPkts.setDescription('The number of packets, including bad packets, transmitted \n        by this address since it was added to the \n        hostTimeHighCapacityTable.')
hostTimeHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityInOverflowOctets.setDescription('The number of times the associated hostTimeInOctets \n        counter has overflowed.')
hostTimeHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInOctets.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityInOctets.setDescription('The number of octets transmitted to this address \n        since it was added to the hostTimeHighCapacityTable \n        (excluding framing bits but including FCS octets), \n        except for those octets in bad packets.')
hostTimeHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityOutOverflowOctets.setDescription('The number of times the associated hostTimeOutOctets \n        counter has overflowed.')
hostTimeHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutOctets.setStatus('current')
if mibBuilder.loadTexts: hostTimeHighCapacityOutOctets.setDescription('The number of octets transmitted by this address since \n        it was added to the hostTimeTable (excluding framing \n        bits but including FCS octets), including those \n        octets in bad packets.')
hostTopNRateBase = MibScalar((1, 3, 6, 1, 2, 1, 16, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("hostTopNInPkts", 1), ("hostTopNOutPkts", 2), ("hostTopNInOctets", 3), ("hostTopNOutOctets", 4), ("hostTopNOutErrors", 5), ("hostTopNOutBroadcastPkts", 6), ("hostTopNOutMulticastPkts", 7), ("hostTopNHCInPkts", 8), ("hostTopNHCOutPkts", 9), ("hostTopNHCInOctets", 10), ("hostTopNHCOutOctets", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostTopNRateBase.setStatus('current')
if mibBuilder.loadTexts: hostTopNRateBase.setDescription('The variable for each host that the hostTopNRate \n        variable is based upon, as well as a control \n        for the table that the results will be reported in. \n \n        This object may not be modified if the associated \n        hostTopNStatus [RFC 1757] object is equal to valid(1). \n \n        If this value is less than or equal to 7, when the report \n        is prepared, entries are created in the hostTopNTable \n        associated with this object. \n        If this value is greater than or equal to 8, when the report \n        is prepared, entries are created in the \n        hostTopNHighCapacityTable associated with this object.')
hostTopNHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 5, 3), )
if mibBuilder.loadTexts: hostTopNHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: hostTopNHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        hostTopNTable when hostTopNRateBase specifies a High Capacity \n    TopN Report.')
hostTopNHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 5, 3, 1), ).setIndexNames((0, "RMON-MIB", "hostTopNReport"), (0, "RMON-MIB", "hostTopNIndex"))
if mibBuilder.loadTexts: hostTopNHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: hostTopNHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        hostTopNEntry when hostTopNRateBase specifies a High Capacity \n        TopN Report. These objects will be created by the agent \n \n \n \n \n \n \n \n \n \n \n \n        for all hostTopNEntries associated with whichever \n        hostTopNControlEntries have a hostTopNRateBase that specify \n        a high capacity report.')
hostTopNHighCapacityBaseRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 5, 3, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTopNHighCapacityBaseRate.setStatus('current')
if mibBuilder.loadTexts: hostTopNHighCapacityBaseRate.setDescription("The amount of change in the selected variable \n          during this sampling interval, modulo 2^32.  The \n          selected variable is this host's instance of the \n          object selected by hostTopNRateBase.")
hostTopNHighCapacityOverflowRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 5, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTopNHighCapacityOverflowRate.setStatus('current')
if mibBuilder.loadTexts: hostTopNHighCapacityOverflowRate.setDescription("The amount of change in the selected variable \n          during this sampling interval, divided by 2^32, truncating \n          fractions (i.e., X DIV 2^32).  The selected variable is \n          this host's instance of the object selected by \n          hostTopNRateBase.")
hostTopNHighCapacityRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 5, 3, 1, 3), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTopNHighCapacityRate.setStatus('current')
if mibBuilder.loadTexts: hostTopNHighCapacityRate.setDescription("The amount of change in the selected variable \n          during this sampling interval.  The selected \n          variable is this host's instance of the object \n          selected by hostTopNRateBase.")
matrixSDHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 6, 5), )
if mibBuilder.loadTexts: matrixSDHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: matrixSDHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        matrixSDTable.')
matrixSDHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 6, 5, 1), ).setIndexNames((0, "RMON-MIB", "matrixSDIndex"), (0, "RMON-MIB", "matrixSDSourceAddress"), (0, "RMON-MIB", "matrixSDDestAddress"))
if mibBuilder.loadTexts: matrixSDHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: matrixSDHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        matrixSDEntry. These objects will be created by the agent \n        for all matrixSDEntries associated with whichever \n        matrixControlEntries it deems appropriate. (i.e., either all \n        matrixSDHighCapacityEntries associated with a particular \n        matrixControlEntry will be created, or none of them will \n        be.)')
matrixSDHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: matrixSDHighCapacityOverflowPkts.setDescription('The number of times the associated matrixSDPkts \n        counter has overflowed.')
matrixSDHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: matrixSDHighCapacityPkts.setDescription('The number of packets transmitted from the source \n        address to the destination address (this number \n        includes bad packets).')
matrixSDHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: matrixSDHighCapacityOverflowOctets.setDescription('The number of times the associated matrixSDOctets \n        counter has overflowed.')
matrixSDHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: matrixSDHighCapacityOctets.setDescription('The number of octets (excluding framing bits but \n        including FCS octets) contained in all packets \n        transmitted from the source address to the \n        destination address.')
matrixDSHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 6, 6), )
if mibBuilder.loadTexts: matrixDSHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: matrixDSHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n        matrixDSTable.')
matrixDSHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 6, 6, 1), ).setIndexNames((0, "RMON-MIB", "matrixDSIndex"), (0, "RMON-MIB", "matrixDSDestAddress"), (0, "RMON-MIB", "matrixDSSourceAddress"))
if mibBuilder.loadTexts: matrixDSHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: matrixDSHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-1 \n \n \n \n \n \n \n \n \n \n \n \n        matrixDSEntry. These objects will be created by the agent \n        for all matrixDSEntries associated with whichever \n        matrixControlEntries it deems appropriate. (i.e., either all \n        matrixDSHighCapacityEntries associated with a particular \n        matrixControlEntry will be created, or none of them will \n        be.)')
matrixDSHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: matrixDSHighCapacityOverflowPkts.setDescription('The number of times the associated matrixDSPkts \n        counter has overflowed.')
matrixDSHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: matrixDSHighCapacityPkts.setDescription('The number of packets transmitted from the source \n        address to the destination address (this number \n        includes bad packets).')
matrixDSHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: matrixDSHighCapacityOverflowOctets.setDescription('The number of times the associated matrixDSOctets \n        counter has overflowed.')
matrixDSHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: matrixDSHighCapacityOctets.setDescription('The number of octets (excluding framing bits \n        but including FCS octets) contained in all packets \n        transmitted from the source address to the \n        destination address.')
captureBufferHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 8, 3), )
if mibBuilder.loadTexts: captureBufferHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: captureBufferHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON \n        captureBufferTable.')
captureBufferHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 8, 3, 1), ).setIndexNames((0, "RMON-MIB", "captureBufferControlIndex"), (0, "RMON-MIB", "captureBufferIndex"))
if mibBuilder.loadTexts: captureBufferHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: captureBufferHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON \n        captureBufferEntry. These objects will be created by the agent \n        for all captureBufferEntries associated with whichever \n        bufferControlEntries it deems appropriate. (i.e., either all \n        captureBufferHighCapacityEntries associated with a particular \n        bufferControlEntry will be created, or none of them will \n        be.)')
captureBufferPacketHighCapacityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999))).setUnits('nanoseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: captureBufferPacketHighCapacityTime.setStatus('current')
if mibBuilder.loadTexts: captureBufferPacketHighCapacityTime.setDescription('The number of nanoseconds that had passed since this capture \n        buffer was first turned on when this packet was captured, \n        modulo 10^6. \n \n        This object is used in conjunction with existing timestamp \n        object. This object returns the number of nano-seconds to be \n        added to to number of milli-seconds obtained from the \n        captureBufferPacketTime object, to obtain more accurate \n        inter packet arrival time.')
protocolDistStatsHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 12, 3), )
if mibBuilder.loadTexts: protocolDistStatsHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: protocolDistStatsHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        protocolDistStatsTable.')
protocolDistStatsHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 12, 3, 1), ).setIndexNames((0, "RMON2-MIB", "protocolDistControlIndex"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: protocolDistStatsHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: protocolDistStatsHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        protocolDistStatsTable. These objects will be created by the \n        agent for all protocolDistStatsEntries associated with \n        whichever protocolDistControlEntries it deems appropriate. \n        (i.e., either all protocolDistStatsHighCapacityEntries \n        associated with a particular protocolDistControlEntry will be \n        created, or none of them will be.)')
protocolDistStatsHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOverflowPkts.setDescription('The number of times the associated protocolDistStatsPkts \n        counter has overflowed.')
protocolDistStatsHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: protocolDistStatsHighCapacityPkts.setDescription('The number of packets without errors received of this \n        protocol type.  Note that this is the number of link-layer \n        packets, so if a single network-layer packet is fragmented \n        into several link-layer frames, this counter is incremented \n        several times.')
protocolDistStatsHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOverflowOctets.setDescription('The number of times the associated protocolDistStatsOctets \n        counter has overflowed.')
protocolDistStatsHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOctets.setDescription("The number of octets in packets received of this protocol \n        type since it was added to the protocolDistStatsTable \n        (excluding framing bits but including FCS octets), except for \n        those octets in packets that contained errors. \n \n        Note this doesn't count just those octets in the particular \n        protocol frames, but includes the entire packet that contained \n        the protocol.")
nlHostHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 14, 3), )
if mibBuilder.loadTexts: nlHostHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlHostTable.')
nlHostHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 14, 3, 1), ).setIndexNames((0, "RMON2-MIB", "hlHostControlIndex"), (0, "RMON2-MIB", "nlHostTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlHostAddress"))
if mibBuilder.loadTexts: nlHostHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlHostEntry. These objects will be created by the agent \n        for all nlHostEntries associated with whichever \n        hlHostControlEntries it deems appropriate. (i.e., either all \n        nlHostHighCapacityEntries associated with a particular \n        hlHostControlEntry will be created, or none of them will \n        be.)')
nlHostHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityInOverflowPkts.setDescription('The number of times the associated nlHostInPkts \n        counter has overflowed.')
nlHostHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInPkts.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityInPkts.setDescription('The number of packets without errors transmitted to \n        this address since it was added to the nlHostHighCapacityTable. \n        Note that this is the number of link-layer packets, so if a \n        single network-layer packet is fragmented into several \n        link-layer frames, this counter is incremented several times.')
nlHostHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityOutOverflowPkts.setDescription('The number of times the associated nlHostOutPkts \n        counter has overflowed.')
nlHostHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutPkts.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityOutPkts.setDescription('The number of packets without errors transmitted by \n        this address since it was added to the nlHostHighCapacityTable. \n        Note that this is the number of link-layer packets, so if a \n        single network-layer packet is fragmented into several \n        link-layer frames, this counter is incremented several times.')
nlHostHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityInOverflowOctets.setDescription('The number of times the associated nlHostInOctets \n        counter has overflowed.')
nlHostHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 6), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInOctets.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityInOctets.setDescription("The number of octets transmitted to this address \n        since it was added to the nlHostHighCapacityTable \n        (excluding framing bits but including FCS octets), \n        excluding those octets in packets that contained \n        errors. \n \n        Note this doesn't count just those octets in the \n        particular protocol frames, but includes the entire \n        packet that contained the protocol.")
nlHostHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityOutOverflowOctets.setDescription('The number of times the associated nlHostOutOctets \n        counter has overflowed.')
nlHostHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 8), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutOctets.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityOutOctets.setDescription("The number of octets transmitted by this address \n        since it was added to the nlHostHighCapacityTable \n        (excluding framing bits but including FCS octets), \n        excluding those octets in packets that contained \n        errors. \n \n        Note this doesn't count just those octets in the \n        particular protocol frames, but includes the entire \n        packet that contained the protocol.")
nlMatrixSDHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 6), )
if mibBuilder.loadTexts: nlMatrixSDHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: nlMatrixSDHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlMatrixTable.')
nlMatrixSDHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 6, 1), ).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "nlMatrixSDTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixSDSourceAddress"), (0, "RMON2-MIB", "nlMatrixSDDestAddress"))
if mibBuilder.loadTexts: nlMatrixSDHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: nlMatrixSDHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlMatrixEntry. These objects will be created by the agent \n        for all nlMatrixSDEntries associated with whichever \n        hlMatrixControlEntries it deems appropriate. (i.e., either all \n        nlMatrixSDHighCapacityEntries associated with a particular \n        hlMatrixControlEntry will be created, or none of them will \n        be.)')
nlMatrixSDHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOverflowPkts.setDescription('The number of times the associated nlMatrixSDPkts \n        counter has overflowed.')
nlMatrixSDHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: nlMatrixSDHighCapacityPkts.setDescription('The number of packets without errors transmitted from the \n \n \n \n \n \n \n \n \n \n \n \n        source address to the destination address since this entry was \n        added to the nlMatrixSDHighCapacityTable.  Note that this is \n        the number of link-layer packets, so if a single network-layer \n        packet is fragmented into several link-layer frames, this \n        counter is incremented several times.')
nlMatrixSDHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOverflowOctets.setDescription('The number of times the associated nlMatrixSDOctets \n        counter has overflowed.')
nlMatrixSDHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOctets.setDescription("The number of octets transmitted from the source address to \n        the destination address since this entry was added to the \n        nlMatrixSDHighCapacityTable (excluding framing bits but \n        including FCS octets), excluding those octets in packets that \n        contained errors. \n \n        Note this doesn't count just those octets in the particular \n        protocol frames, but includes the entire packet that contained \n        the protocol.")
nlMatrixDSHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 7), )
if mibBuilder.loadTexts: nlMatrixDSHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: nlMatrixDSHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlMatrixDSTable.')
nlMatrixDSHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 7, 1), ).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "nlMatrixDSTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixDSDestAddress"), (0, "RMON2-MIB", "nlMatrixDSSourceAddress"))
if mibBuilder.loadTexts: nlMatrixDSHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: nlMatrixDSHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlMatrixDSEntry. These objects will be created by the agent \n        for all nlMatrixDSEntries associated with whichever \n        hlmatrixControlEntries it deems appropriate. (i.e., either all \n        nlMatrixDSHighCapacityEntries associated with a particular \n        hlMatrixControlEntry will be created, or none of them will \n        be.)')
nlMatrixDSHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOverflowPkts.setDescription('The number of times the associated nlMatrixDSPkts \n        counter has overflowed.')
nlMatrixDSHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: nlMatrixDSHighCapacityPkts.setDescription('The number of packets without errors transmitted from the \n        source address to the destination address since this entry was \n        added to the nlMatrixHighCapacityDSTable.  Note that this is \n        the number of link-layer packets, so if a single network-layer \n        packet is fragmented into several link-layer frames, this \n        counter is incremented several times.')
nlMatrixDSHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOverflowOctets.setDescription('The number of times the associated nlMatrixDSOctets \n        counter has overflowed.')
nlMatrixDSHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOctets.setDescription("The number of octets transmitted from the source address \n        to the destination address since this entry was added to the \n        nlMatrixDSHighCapacityTable (excluding framing bits but \n        including FCS octets), excluding those octets in packets that \n        contained errors. \n \n        Note this doesn't count just those octets in the particular \n        protocol frames, but includes the entire packet that contained \n        the protocol.")
nlMatrixTopNControlRateBase = MibScalar((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nlMatrixTopNPkts", 1), ("nlMatrixTopNOctets", 2), ("nlMatrixTopNHighCapacityPkts", 3), ("nlMatrixTopNHighCapacityOctets", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlMatrixTopNControlRateBase.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNControlRateBase.setDescription('The variable for each nlMatrix[SD/DS] entry that the \n        nlMatrixTopNEntries are sorted by, as well as a control \n        for the table that the results will be reported in. \n \n        This object may not be modified if the associated \n        nlMatrixTopNControlStatus object is equal to active(1). \n \n        If this value is less than or equal to 2, when the report \n \n \n \n \n \n \n \n \n \n \n \n        is prepared, entries are created in the nlMatrixTopNTable \n        associated with this object. \n        If this value is greater than or equal to 3, when the report \n        is prepared, entries are created in the \n        nlMatrixTopNHighCapacityTable associated with this object.')
nlMatrixTopNHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 8), )
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlMatrixTopNTable when nlMatrixTopNControlRateBase specifies \n        a High Capacity TopN Report.')
nlMatrixTopNHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 8, 1), ).setIndexNames((0, "RMON2-MIB", "nlMatrixTopNControlIndex"), (0, "RMON2-MIB", "nlMatrixTopNIndex"))
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        nlMatrixTopNEntry when nlMatrixTopNControlRateBase specifies \n        a High Capacity TopN Report. These objects will be created by \n        the agent for all nlMatrixTopNEntries associated with whichever \n        nlMatrixTopNControlEntries have a nlMatrixTopNControlRateBase \n        that specify a high capacity report.')
nlMatrixTopNHighCapacityBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityBasePktRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityBasePktRate.setDescription('The number of packets seen from the source host \n        to the destination host during this sampling interval, \n        modulo 2^32, counted using the rules for counting the \n        nlMatrixSDPkts object.')
nlMatrixTopNHighCapacityOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOverflowPktRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOverflowPktRate.setDescription('The number of packets seen from the source host \n        to the destination host during this sampling interval, \n        divided by 2^32, truncating fractions (i.e., X DIV 2^32), \n        and counted using the rules for counting the \n        nlMatrixSDPkts object.')
nlMatrixTopNHighCapacityPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 3), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityPktRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityPktRate.setDescription('The number of packets seen from the source host \n        to the destination host during this sampling interval, \n    counted using the rules for counting the \n        nlMatrixSDPkts object. \n        If the value of nlMatrixTopNControlRateBase is \n        nlMatrixTopNHighCapacityPkts, this variable will be used \n        to sort this report.')
nlMatrixTopNHighCapacityReverseBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseBasePktRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseBasePktRate.setDescription('The number of packets seen from the destination host to the \n        source host during this sampling interval, modulo 2^32, counted \n        using the rules for counting the nlMatrixSDPkts object (note \n \n \n \n \n \n \n \n \n \n \n \n        that the corresponding nlMatrixSDPkts object selected is the \n        one whose source address is equal to nlMatrixTopNDestAddress \n        and whose destination address is equal to \n        nlMatrixTopNSourceAddress.) \n \n        Note that if the value of nlMatrixTopNControlRateBase is equal \n        to nlMatrixTopNHighCapacityPkts, the sort of topN entries is \n        based entirely on nlMatrixTopNHighCapacityPktRate, and not on \n        the value of this object.')
nlMatrixTopNHighCapacityReverseOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOverflowPktRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOverflowPktRate.setDescription('The number of packets seen from the destination host to the \n        source host during this sampling interval, divided by 2^32, \n    truncating fractions (i.e., X DIV 2^32), and counted \n        using the rules for counting the nlMatrixSDPkts object (note \n        that the corresponding nlMatrixSDPkts object selected is the \n        one whose source address is equal to nlMatrixTopNDestAddress \n        and whose destination address is equal to \n        nlMatrixTopNSourceAddress.) \n \n        Note that if the value of nlMatrixTopNControlRateBase is equal \n        to nlMatrixTopNHighCapacityPkts, the sort of topN entries is \n        based entirely on nlMatrixTopNHighCapacityPktRate, and not on \n        the value of this object.')
nlMatrixTopNHighCapacityReversePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 6), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReversePktRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReversePktRate.setDescription('The number of packets seen from the destination host to the \n        source host during this sampling interval, counted \n        using the rules for counting the nlMatrixSDPkts object (note \n        that the corresponding nlMatrixSDPkts object selected is the \n        one whose source address is equal to nlMatrixTopNDestAddress \n        and whose destination address is equal to \n        nlMatrixTopNSourceAddress.) \n \n        Note that if the value of nlMatrixTopNControlRateBase is equal \n \n \n \n \n \n \n \n \n \n \n \n        to nlMatrixTopNHighCapacityPkts, the sort of topN entries is \n        based entirely on nlMatrixTopNHighCapacityPktRate, and not on \n        the value of this object.')
nlMatrixTopNHighCapacityBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityBaseOctetRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityBaseOctetRate.setDescription('The number of octets seen from the source host \n        to the destination host during this sampling interval, \n        modulo 2^32, counted using the rules for counting the \n        nlMatrixSDOctets object.')
nlMatrixTopNHighCapacityOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOverflowOctetRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOverflowOctetRate.setDescription('The number of octets seen from the source host \n        to the destination host during this sampling interval, \n        divided by 2^32, truncating fractions (i.e., X DIV 2^32), \n        and counted using the rules for counting the \n        nlMatrixSDOctets object.')
nlMatrixTopNHighCapacityOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 9), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOctetRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOctetRate.setDescription('The number of octets seen from the source host \n        to the destination host during this sampling interval, \n    counted using the rules for counting the \n        nlMatrixSDOctets object. \n        If the value of nlMatrixTopNControlRateBase is \n        nlMatrixTopNHighCapacityOctets, this variable will be used \n        to sort this report.')
nlMatrixTopNHighCapacityReverseBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseBaseOctetRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseBaseOctetRate.setDescription('The number of octets seen from the destination host to the \n        source host during this sampling interval, modulo 2^32, counted \n        using the rules for counting the nlMatrixSDOctets object (note \n        that the corresponding nlMatrixSDOctets object selected is the \n        one whose source address is equal to nlMatrixTopNDestAddress \n        and whose destination address is equal to \n        nlMatrixTopNSourceAddress.) \n \n        Note that if the value of nlMatrixTopNControlRateBase is equal \n        to nlMatrixTopNHighCapacityOctets, the sort of topN entries is \n        based entirely on nlMatrixTopNHighCapacityOctetRate, and not on \n        the value of this object.')
nlMatrixTopNHighCapacityReverseOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOverflowOctetRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOverflowOctetRate.setDescription('The number of octets seen from the destination host to the \n        source host during this sampling interval, divided by 2^32, \n        truncating fractions (i.e., X DIV 2^32), and counted \n        using the rules for counting the nlMatrixSDOctets object (note \n        that the corresponding nlMatrixSDOctets object selected is the \n        one whose source address is equal to nlMatrixTopNDestAddress \n        and whose destination address is equal to \n        nlMatrixTopNSourceAddress.) \n \n        Note that if the value of nlMatrixTopNControlRateBase is equal \n        to nlMatrixTopNHighCapacityOctets, the sort of topN entries is \n        based entirely on nlMatrixTopNHighCapacityOctetRate, and not on \n        the value of this object.')
nlMatrixTopNHighCapacityReverseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 12), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOctetRate.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOctetRate.setDescription('The number of octets seen from the destination host to the \n        source host during this sampling interval, counted \n        using the rules for counting the nlMatrixSDOctets object (note \n        that the corresponding nlMatrixSDOctets object selected is the \n \n \n \n \n \n \n \n \n \n \n \n        one whose source address is equal to nlMatrixTopNDestAddress \n        and whose destination address is equal to \n        nlMatrixTopNSourceAddress.) \n \n        Note that if the value of nlMatrixTopNControlRateBase is equal \n        to nlMatrixTopNHighCapacityOctets, the sort of topN entries is \n        based entirely on nlMatrixTopNHighCapacityOctetRate, and not on \n        the value of this object.')
alHostHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 16, 2), )
if mibBuilder.loadTexts: alHostHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alHostTable.')
alHostHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 16, 2, 1), ).setIndexNames((0, "RMON2-MIB", "hlHostControlIndex"), (0, "RMON2-MIB", "alHostTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlHostAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alHostHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alHostEntry. These objects will be created by the agent \n        for all alHostEntries associated with whichever \n        hlHostControlEntries it deems appropriate. (i.e., either all \n        alHostHighCapacityEntries associated with a particular \n        hlHostControlEntry will be created, or none of them will \n        be.)')
alHostHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityInOverflowPkts.setDescription('The number of times the associated alHostInPkts \n        counter has overflowed.')
alHostHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInPkts.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityInPkts.setDescription('The number of packets of this protocol type without errors \n        transmitted to this address since it was added to the \n        alHostHighCapacityTable.  Note that this is the number of \n        link-layer packets, so if a single network-layer packet \n        is fragmented into several link-layer frames, this counter \n        is incremented several times.')
alHostHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityOutOverflowPkts.setDescription('The number of times the associated alHostOutPkts \n        counter has overflowed.')
alHostHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutPkts.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityOutPkts.setDescription('The number of packets of this protocol type without errors \n        transmitted by this address since it was added to the \n        alHostHighCapacityTable.  Note that this is the number of \n        link-layer packets, so if a single network-layer packet \n        is fragmented into several link-layer frames, this counter \n \n \n \n \n \n \n \n \n \n \n \n        is incremented several times.')
alHostHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityInOverflowOctets.setDescription('The number of times the associated alHostInOctets \n        counter has overflowed.')
alHostHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 6), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInOctets.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityInOctets.setDescription("The number of octets transmitted to this address \n        of this protocol type since it was added to the \n        alHostHighCapacityTable (excluding framing bits but \n        including FCS octets), excluding those octets in \n        packets that contained errors. \n \n        Note this doesn't count just those octets in the particular \n        protocol frames, but includes the entire packet that contained \n        the protocol.")
alHostHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityOutOverflowOctets.setDescription('The number of times the associated alHostOutOctets \n        counter has overflowed.')
alHostHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 8), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutOctets.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityOutOctets.setDescription("The number of octets transmitted by this address \n        of this protocol type since it was added to the \n        alHostHighCapacityTable (excluding framing bits but \n \n \n \n \n \n \n \n \n \n \n \n        including FCS octets), excluding those octets in \n        packets that contained errors. \n \n        Note this doesn't count just those octets in the particular \n        protocol frames, but includes the entire packet that contained \n        the protocol.")
alMatrixSDHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 5), )
if mibBuilder.loadTexts: alMatrixSDHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: alMatrixSDHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alMatrixSDTable.')
alMatrixSDHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 5, 1), ).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "alMatrixSDTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixSDSourceAddress"), (0, "RMON2-MIB", "nlMatrixSDDestAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alMatrixSDHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: alMatrixSDHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alMatrixSDEntry. These objects will be created by the agent \n        for all alMatrixSDEntries associated with whichever \n        hlMatrixControlEntries it deems appropriate. (i.e., either all \n        alMatrixSDHighCapacityEntries associated with a particular \n        hlMatrixControlEntry will be created, or none of them will \n        be.)')
alMatrixSDHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: alMatrixSDHighCapacityOverflowPkts.setDescription('The number of times the associated alMatrixSDPkts \n        counter has overflowed.')
alMatrixSDHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: alMatrixSDHighCapacityPkts.setDescription('The number of packets of this protocol type without errors \n        transmitted from the source address to the destination address \n        since this entry was added to the alMatrixSDHighCapacityTable. \n        Note that this is the number of link-layer packets, so if a \n        single network-layer packet is fragmented into several \n        link-layer frames, this counter is incremented several times.')
alMatrixSDHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: alMatrixSDHighCapacityOverflowOctets.setDescription('The number of times the associated alMatrixSDOctets \n        counter has overflowed.')
alMatrixSDHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: alMatrixSDHighCapacityOctets.setDescription("The number of octets in packets of this protocol type \n        transmitted from the source address to the destination address \n        since this entry was added to the alMatrixSDHighCapacityTable \n        (excluding framing bits but including FCS octets), excluding \n        those octets in packets that contained errors. \n \n        Note this doesn't count just those octets in the particular \n        protocol frames, but includes the entire packet that contained \n        the protocol.")
alMatrixDSHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 6), )
if mibBuilder.loadTexts: alMatrixDSHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: alMatrixDSHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alMatrixDSTable.')
alMatrixDSHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 6, 1), ).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "alMatrixDSTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixDSDestAddress"), (0, "RMON2-MIB", "nlMatrixDSSourceAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alMatrixDSHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: alMatrixDSHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alMatrixSDTable. These objects will be created by the agent \n        for all alMatrixDSEntries associated with whichever \n        hlMatrixControlEntries it deems appropriate. (i.e., either all \n        alMatrixDSHighCapacityEntries associated with a particular \n        hlMatrixControlEntry will be created, or none of them will \n        be.)')
alMatrixDSHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: alMatrixDSHighCapacityOverflowPkts.setDescription('The number of times the associated alMatrixDSPkts \n        counter has overflowed.')
alMatrixDSHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityPkts.setStatus('current')
if mibBuilder.loadTexts: alMatrixDSHighCapacityPkts.setDescription('The number of packets of this protocol type without errors \n        transmitted from the source address to the destination address \n        since this entry was added to the alMatrixDSHighCapacityTable. \n        Note that this is the number of link-layer packets, so if a \n        single network-layer packet is fragmented into several \n        link-layer frames, this counter is incremented several times.')
alMatrixDSHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: alMatrixDSHighCapacityOverflowOctets.setDescription('The number of times the associated alMatrixDSOctets \n        counter has overflowed.')
alMatrixDSHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityOctets.setStatus('current')
if mibBuilder.loadTexts: alMatrixDSHighCapacityOctets.setDescription("The number of octets in packets of this protocol type \n        transmitted from the source address to the destination address \n        since this entry was added to the alMatrixDSHighCapacityTable \n        (excluding framing bits but including FCS octets), excluding \n        those octets in packets that contained errors. \n \n        Note this doesn't count just those octets in the particular \n        protocol frames, but includes the entire packet that contained \n        the protocol.")
alMatrixTopNControlRateBase = MibScalar((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("alMatrixTopNTerminalsPkts", 1), ("alMatrixTopNTerminalsOctets", 2), ("alMatrixTopNAllPkts", 3), ("alMatrixTopNAllOctets", 4), ("alMatrixTopNTerminalsHighCapacityPkts", 5), ("alMatrixTopNTerminalsHighCapacityOctets", 6), ("alMatrixTopNAllHighCapacityPkts", 7), ("alMatrixTopNAllHighCapacityOctets", 8)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alMatrixTopNControlRateBase.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNControlRateBase.setDescription('The variable for each alMatrix[SD/DS] entry that the \n        alMatrixTopNEntries are sorted by, as well as the \n        selector of the view of the matrix table that will be \n        used, as well as a control for the table that the results \n        will be reported in. \n \n        The values alMatrixTopNTerminalsPkts, \n        alMatrixTopNTerminalsOctets, \n        alMatrixTopNTerminalsHighCapacityPkts, and \n        alMatrixTopNTerminalsHighCapacityOctets cause collection \n        only from protocols that have no child protocols that are \n        counted. The values alMatrixTopNAllPkts, \n        alMatrixTopNAllOctets, alMatrixTopNAllHighCapacityPkts, and \n        alMatrixTopNAllHighCapacityOctets cause collection from all \n        alMatrix entries. \n \n        This object may not be modified if the associated \n        alMatrixTopNControlStatus object is equal to active(1).')
alMatrixTopNHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 7), )
if mibBuilder.loadTexts: alMatrixTopNHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alMatrixTopNTable when alMatrixTopNControlRateBase specifies \n        a High Capacity TopN Report.')
alMatrixTopNHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 7, 1), ).setIndexNames((0, "RMON2-MIB", "alMatrixTopNControlIndex"), (0, "RMON2-MIB", "alMatrixTopNIndex"))
if mibBuilder.loadTexts: alMatrixTopNHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        alMatrixTopNEntry when alMatrixTopNControlRateBase specifies \n \n \n \n \n \n \n \n \n \n \n \n        a High Capacity TopN Report. These objects will be created by \n        the agent for all alMatrixTopNEntries associated with whichever \n        alMatrixTopNControlEntries have a alMatrixTopNControlRateBase \n        that specify a high capacity report.')
alMatrixTopNHighCapacityBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityBasePktRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityBasePktRate.setDescription('The number of packets seen of this protocol from the source \n        host to the destination host during this sampling interval, \n        modulo 2^32, counted using the rules for counting the \n        alMatrixSDPkts object.')
alMatrixTopNHighCapacityOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOverflowPktRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOverflowPktRate.setDescription('The number of packets seen of this protocol from the source host \n        to the destination host during this sampling interval, \n        divided by 2^32, truncating fractions (i.e., X DIV 2^32), \n        and counted using the rules for counting the \n        alMatrixSDPkts object.')
alMatrixTopNHighCapacityPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 3), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityPktRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityPktRate.setDescription('The number of packets seen of this protocol from the source \n        host to the destination host during this sampling interval, \n        counted using the rules for counting the \n        alMatrixSDPkts object. \n        If the value of alMatrixTopNControlRateBase is \n        alMatrixTopNTerminalsPkts, alMatrixTopNAllPkts, \n        alMatrixTopNTerminalsHighCapacityPkts, or \n        alMatrixTopNAllHighCapacityPkts, this variable will be used \n        to sort this report.')
alMatrixTopNHighCapacityReverseBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseBasePktRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseBasePktRate.setDescription('The number of packets seen of this protocol from the \n        destination host to the source host during this sampling \n        interval, modulo 2^32, counted using the rules for counting \n        the alMatrixSDPkts object (note that the corresponding \n        alMatrixSDPkts object selected is the one whose source address \n        is equal to alMatrixTopNDestAddress and whose destination \n        address is equal to alMatrixTopNSourceAddress.)')
alMatrixTopNHighCapacityReverseOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOverflowPktRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOverflowPktRate.setDescription('The number of packets seen of this protocol from the \n        destination host to the source host during this sampling \n        interval, divided by 2^32, truncating fractions \n        (i.e., X DIV 2^32), and counted using the rules for \n        counting the alMatrixSDPkts object (note that the \n        corresponding alMatrixSDPkts object selected is the \n        one whose source address is equal to alMatrixTopNDestAddress \n        and whose destination address is equal to \n        alMatrixTopNSourceAddress.)')
alMatrixTopNHighCapacityReversePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 6), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReversePktRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReversePktRate.setDescription('The number of packets seen of this protocol from the \n        destination host to the source host during this sampling \n        interval, counted using the rules for counting the \n        alMatrixSDPkts object (note that the corresponding \n        alMatrixSDPkts object selected is the one whose source address \n        is equal to alMatrixTopNDestAddress and whose destination \n        address is equal to alMatrixTopNSourceAddress.)')
alMatrixTopNHighCapacityBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityBaseOctetRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityBaseOctetRate.setDescription('The number of octets seen of this protocol from the source host \n        to the destination host during this sampling interval, \n        modulo 2^32, counted using the rules for counting the \n        alMatrixSDOctets object.')
alMatrixTopNHighCapacityOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOverflowOctetRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOverflowOctetRate.setDescription('The number of octets seen of this protocol from the source host \n        to the destination host during this sampling interval, \n        divided by 2^32, truncating fractions (i.e., X DIV 2^32), \n        and counted using the rules for counting the \n        alMatrixSDOctets object.')
alMatrixTopNHighCapacityOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 9), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOctetRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOctetRate.setDescription('The number of octets seen of this protocol from the source host \n        to the destination host during this sampling interval, \n        counted using the rules for counting the \n \n \n \n \n \n \n \n \n \n \n \n        alMatrixSDOctets object. \n        If the value of alMatrixTopNControlRateBase is \n        alMatrixTopNTerminalsOctets, alMatrixTopNAllOctets, \n        alMatrixTopNTerminalsHighCapacityOctets, or \n        alMatrixTopNAllHighCapacityOctets, this variable will be used \n        to sort this report.')
alMatrixTopNHighCapacityReverseBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseBaseOctetRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseBaseOctetRate.setDescription('The number of octets seen of this protocol from the \n        destination host to the source host during this sampling \n        interval, modulo 2^32, counted using the rules for counting \n        the alMatrixSDOctets object (note that the corresponding \n        alMatrixSDOctets object selected is the one whose source \n        address is equal to alMatrixTopNDestAddress and whose \n        destination address is equal to alMatrixTopNSourceAddress.)')
alMatrixTopNHighCapacityReverseOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOverflowOctetRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOverflowOctetRate.setDescription('The number of octets seen of this protocol from the \n        destination host to the source host during this sampling \n        interval, divided by 2^32, truncating fractions (i.e., X DIV \n        2^32), and counted using the rules for counting the \n        alMatrixSDOctets object (note that the corresponding \n        alMatrixSDOctets object selected is the one whose source \n        address is equal to alMatrixTopNDestAddress and whose \n        destination address is equal to alMatrixTopNSourceAddress.)')
alMatrixTopNHighCapacityReverseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 12), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOctetRate.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOctetRate.setDescription('The number of octets seen of this protocol from the \n        destination host to the source host during this sampling \n        interval, counted using the rules for counting the \n \n \n \n \n \n \n \n \n \n \n \n        alMatrixSDOctets object (note that the corresponding \n        alMatrixSDOctets object selected is the one whose source \n        address is equal to alMatrixTopNDestAddress and whose \n        destination address is equal to alMatrixTopNSourceAddress.)')
usrHistoryHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 18, 4), )
if mibBuilder.loadTexts: usrHistoryHighCapacityTable.setStatus('current')
if mibBuilder.loadTexts: usrHistoryHighCapacityTable.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        usrHistoryTable.')
usrHistoryHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 18, 4, 1), ).setIndexNames((0, "RMON2-MIB", "usrHistoryControlIndex"), (0, "RMON2-MIB", "usrHistorySampleIndex"), (0, "RMON2-MIB", "usrHistoryObjectIndex"))
if mibBuilder.loadTexts: usrHistoryHighCapacityEntry.setStatus('current')
if mibBuilder.loadTexts: usrHistoryHighCapacityEntry.setDescription('Contains the High Capacity RMON extensions to the RMON-2 \n        usrHistoryEntry. These objects will be created by the agent \n        for all usrHistoryEntries associated with whichever \n        usrHistoryControlEntries it deems appropriate. (i.e., either all \n        usrHistoryHighCapacityEntries associated with a particular \n        usrHistoryControlEntry will be created, or none of them will \n        be.)')
usrHistoryHighCapacityOverflowAbsValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 4, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryHighCapacityOverflowAbsValue.setStatus('current')
if mibBuilder.loadTexts: usrHistoryHighCapacityOverflowAbsValue.setDescription("The absolute value (i.e. unsigned value) of the \n        user-specified statistic during the last sampling period, \n        divided by 2^32, truncating fractions (i.e., X DIV 2^32). \n        The value during the current sampling period is not made \n \n \n \n \n \n \n \n \n \n \n \n        available until the period is completed. \n \n        To obtain the true value for this sampling interval, the \n        associated instance of usrHistoryValStatus must be checked, \n        and usrHistoryAbsValue adjusted as necessary. \n \n        If the MIB instance could not be accessed during the sampling \n        interval, then this object will have a value of zero and the \n        associated instance of usrHistoryValStatus will be set to \n        'valueNotAvailable(1)'.")
usrHistoryHighCapacityAbsValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 4, 1, 2), RmonGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryHighCapacityAbsValue.setStatus('current')
if mibBuilder.loadTexts: usrHistoryHighCapacityAbsValue.setDescription("The absolute value (i.e. unsigned value) of the \n        user-specified statistic during the last sampling period. The \n        value during the current sampling period is not made available \n        until the period is completed. \n \n        To obtain the true value for this sampling interval, the \n        associated instance of usrHistoryValStatus must be checked, \n        and usrHistoryHighCapacityAbsValue adjusted as necessary. \n \n        If the MIB instance could not be accessed during the sampling \n        interval, then this object will have a value of zero and the \n        associated instance of usrHistoryValStatus will be set to \n        'valueNotAvailable(1)'.")
hcRMONCapabilities = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 16), Bits().clone(namedValues=NamedValues(("mediaIndependentGroup", 0), ("etherStatsHighCapacityGroup", 1), ("etherHistoryHighCapacityGroup", 2), ("hostHighCapacityGroup", 3), ("hostTopNHighCapacityGroup", 4), ("matrixHighCapacityGroup", 5), ("captureBufferHighCapacityGroup", 6), ("protocolDistributionHighCapacityGroup", 7), ("nlHostHighCapacityGroup", 8), ("nlMatrixHighCapacityGroup", 9), ("nlMatrixTopNHighCapacityGroup", 10), ("alHostHighCapacityGroup", 11), ("alMatrixHighCapacityGroup", 12), ("alMatrixTopNHighCapacityGroup", 13), ("usrHistoryHighCapacityGroup", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcRMONCapabilities.setStatus('current')
if mibBuilder.loadTexts: hcRMONCapabilities.setDescription('An indication of the High Capacity RMON MIB groups supported \n        on at least one interface by this probe.')
hcRmonMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 6))
hcRmonMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 7))
hcRmonMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 6, 1)).setObjects(("HC-RMON-MIB", "mediaIndependentGroup"), ("HC-RMON-MIB", "hcRMONInformationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcRmonMIBCompliance = hcRmonMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: hcRmonMIBCompliance.setDescription('Describes the minimum requirements for conformance to the \n        high capacity RMON MIB.')
hcRmon2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 6, 2)).setObjects(("HC-RMON-MIB", "mediaIndependentGroup"), ("HC-RMON-MIB", "protocolDistributionHighCapacityGroup"), ("HC-RMON-MIB", "nlHostHighCapacityGroup"), ("HC-RMON-MIB", "nlMatrixHighCapacityGroup"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityGroup"), ("HC-RMON-MIB", "usrHistoryHighCapacityGroup"), ("HC-RMON-MIB", "hcRMONInformationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcRmon2MIBCompliance = hcRmon2MIBCompliance.setStatus('current')
if mibBuilder.loadTexts: hcRmon2MIBCompliance.setDescription('Describes the requirements for conformance to \n        the High Capacity RMON 2 MIB')
hcRmon2MIBApplicationLayerCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 6, 3)).setObjects(("HC-RMON-MIB", "mediaIndependentGroup"), ("HC-RMON-MIB", "protocolDistributionHighCapacityGroup"), ("HC-RMON-MIB", "nlHostHighCapacityGroup"), ("HC-RMON-MIB", "nlMatrixHighCapacityGroup"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityGroup"), ("HC-RMON-MIB", "alHostHighCapacityGroup"), ("HC-RMON-MIB", "alMatrixHighCapacityGroup"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityGroup"), ("HC-RMON-MIB", "usrHistoryHighCapacityGroup"), ("HC-RMON-MIB", "hcRMONInformationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcRmon2MIBApplicationLayerCompliance = hcRmon2MIBApplicationLayerCompliance.setStatus('current')
if mibBuilder.loadTexts: hcRmon2MIBApplicationLayerCompliance.setDescription('Describes the requirements for conformance to \n        the High Capacity RMON2 MIB with Application Layer Enhancements.')
mediaIndependentGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 1)).setObjects(("HC-RMON-MIB", "mediaIndependentIndex"), ("HC-RMON-MIB", "mediaIndependentDataSource"), ("HC-RMON-MIB", "mediaIndependentDropEvents"), ("HC-RMON-MIB", "mediaIndependentDroppedFrames"), ("HC-RMON-MIB", "mediaIndependentInPkts"), ("HC-RMON-MIB", "mediaIndependentInOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentInHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentOutPkts"), ("HC-RMON-MIB", "mediaIndependentOutOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentOutHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentInOctets"), ("HC-RMON-MIB", "mediaIndependentInOverflowOctets"), ("HC-RMON-MIB", "mediaIndependentInHighCapacityOctets"), ("HC-RMON-MIB", "mediaIndependentOutOctets"), ("HC-RMON-MIB", "mediaIndependentOutOverflowOctets"), ("HC-RMON-MIB", "mediaIndependentOutHighCapacityOctets"), ("HC-RMON-MIB", "mediaIndependentInNUCastPkts"), ("HC-RMON-MIB", "mediaIndependentInNUCastOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentInNUCastHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentOutNUCastPkts"), ("HC-RMON-MIB", "mediaIndependentOutNUCastOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentOutNUCastHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentInErrors"), ("HC-RMON-MIB", "mediaIndependentOutErrors"), ("HC-RMON-MIB", "mediaIndependentInputSpeed"), ("HC-RMON-MIB", "mediaIndependentOutputSpeed"), ("HC-RMON-MIB", "mediaIndependentOwner"), ("HC-RMON-MIB", "mediaIndependentStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaIndependentGroup = mediaIndependentGroup.setStatus('current')
if mibBuilder.loadTexts: mediaIndependentGroup.setDescription('Collects utilization statistics for any type of network.')
etherStatsHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 2)).setObjects(("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowOctets"), ("HC-RMON-MIB", "etherStatsHighCapacityOctets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts64Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts64Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts65to127Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts65to127Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts128to255Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts128to255Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts256to511Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts256to511Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts512to1023Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts512to1023Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts1024to1518Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts1024to1518Octets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    etherStatsHighCapacityGroup = etherStatsHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: etherStatsHighCapacityGroup.setDescription('Collects utilization statistics for ethernet networks.')
etherHistoryHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 3)).setObjects(("HC-RMON-MIB", "etherHistoryHighCapacityOverflowPkts"), ("HC-RMON-MIB", "etherHistoryHighCapacityPkts"), ("HC-RMON-MIB", "etherHistoryHighCapacityOverflowOctets"), ("HC-RMON-MIB", "etherHistoryHighCapacityOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    etherHistoryHighCapacityGroup = etherHistoryHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: etherHistoryHighCapacityGroup.setDescription('Collects utilization statistics for ethernet networks.')
hostHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 4)).setObjects(("HC-RMON-MIB", "hostHighCapacityInOverflowPkts"), ("HC-RMON-MIB", "hostHighCapacityInPkts"), ("HC-RMON-MIB", "hostHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "hostHighCapacityOutPkts"), ("HC-RMON-MIB", "hostHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "hostHighCapacityInOctets"), ("HC-RMON-MIB", "hostHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "hostHighCapacityOutOctets"), ("HC-RMON-MIB", "hostTimeHighCapacityInOverflowPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityInPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityOutPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "hostTimeHighCapacityInOctets"), ("HC-RMON-MIB", "hostTimeHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "hostTimeHighCapacityOutOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hostHighCapacityGroup = hostHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: hostHighCapacityGroup.setDescription('Collects utilization and error statistics per host.')
hostTopNHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 5)).setObjects(("HC-RMON-MIB", "hostTopNHighCapacityBaseRate"), ("HC-RMON-MIB", "hostTopNHighCapacityOverflowRate"), ("HC-RMON-MIB", "hostTopNHighCapacityRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hostTopNHighCapacityGroup = hostTopNHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: hostTopNHighCapacityGroup.setDescription('Prepares sorted reports of utilization and error statistics \n        per host.')
matrixHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 6)).setObjects(("HC-RMON-MIB", "matrixSDHighCapacityOverflowPkts"), ("HC-RMON-MIB", "matrixSDHighCapacityPkts"), ("HC-RMON-MIB", "matrixSDHighCapacityOverflowOctets"), ("HC-RMON-MIB", "matrixSDHighCapacityOctets"), ("HC-RMON-MIB", "matrixDSHighCapacityOverflowPkts"), ("HC-RMON-MIB", "matrixDSHighCapacityPkts"), ("HC-RMON-MIB", "matrixDSHighCapacityOverflowOctets"), ("HC-RMON-MIB", "matrixDSHighCapacityOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    matrixHighCapacityGroup = matrixHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: matrixHighCapacityGroup.setDescription('Collects utilization statistics per conversation.')
captureBufferHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 7)).setObjects(("HC-RMON-MIB", "captureBufferPacketHighCapacityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    captureBufferHighCapacityGroup = captureBufferHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: captureBufferHighCapacityGroup.setDescription('Provides finer granularity timestamps.')
protocolDistributionHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 8)).setObjects(("HC-RMON-MIB", "protocolDistStatsHighCapacityOverflowPkts"), ("HC-RMON-MIB", "protocolDistStatsHighCapacityPkts"), ("HC-RMON-MIB", "protocolDistStatsHighCapacityOverflowOctets"), ("HC-RMON-MIB", "protocolDistStatsHighCapacityOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    protocolDistributionHighCapacityGroup = protocolDistributionHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: protocolDistributionHighCapacityGroup.setDescription('Collects the relative amounts of octets and packets for the \n        different protocols detected on a network segment.')
nlHostHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 9)).setObjects(("HC-RMON-MIB", "nlHostHighCapacityInOverflowPkts"), ("HC-RMON-MIB", "nlHostHighCapacityInPkts"), ("HC-RMON-MIB", "nlHostHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "nlHostHighCapacityOutPkts"), ("HC-RMON-MIB", "nlHostHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "nlHostHighCapacityInOctets"), ("HC-RMON-MIB", "nlHostHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "nlHostHighCapacityOutOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nlHostHighCapacityGroup = nlHostHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: nlHostHighCapacityGroup.setDescription('Counts the amount of traffic sent from and to each network \n        address discovered by the probe.')
nlMatrixHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 10)).setObjects(("HC-RMON-MIB", "nlMatrixSDHighCapacityOverflowPkts"), ("HC-RMON-MIB", "nlMatrixSDHighCapacityPkts"), ("HC-RMON-MIB", "nlMatrixSDHighCapacityOverflowOctets"), ("HC-RMON-MIB", "nlMatrixSDHighCapacityOctets"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityOverflowPkts"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityPkts"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityOverflowOctets"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nlMatrixHighCapacityGroup = nlMatrixHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: nlMatrixHighCapacityGroup.setDescription('Counts the amount of traffic sent between each pair of \n        network addresses discovered by the probe.')
nlMatrixTopNHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 11)).setObjects(("HC-RMON-MIB", "nlMatrixTopNHighCapacityBasePktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityOverflowPktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityPktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseBasePktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseOverflowPktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReversePktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityBaseOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityOverflowOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseBaseOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseOverflowOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseOctetRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nlMatrixTopNHighCapacityGroup = nlMatrixTopNHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityGroup.setDescription('Prepares sorted reports of the amount of traffic sent between \n        each pair of network addresses discovered by the probe.')
alHostHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 12)).setObjects(("HC-RMON-MIB", "alHostHighCapacityInOverflowPkts"), ("HC-RMON-MIB", "alHostHighCapacityInPkts"), ("HC-RMON-MIB", "alHostHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "alHostHighCapacityOutPkts"), ("HC-RMON-MIB", "alHostHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "alHostHighCapacityInOctets"), ("HC-RMON-MIB", "alHostHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "alHostHighCapacityOutOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alHostHighCapacityGroup = alHostHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: alHostHighCapacityGroup.setDescription('Counts the amount of traffic, by protocol, sent from and to \n        each network address discovered by the probe.')
alMatrixHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 13)).setObjects(("HC-RMON-MIB", "alMatrixSDHighCapacityOverflowPkts"), ("HC-RMON-MIB", "alMatrixSDHighCapacityPkts"), ("HC-RMON-MIB", "alMatrixSDHighCapacityOverflowOctets"), ("HC-RMON-MIB", "alMatrixSDHighCapacityOctets"), ("HC-RMON-MIB", "alMatrixDSHighCapacityOverflowPkts"), ("HC-RMON-MIB", "alMatrixDSHighCapacityPkts"), ("HC-RMON-MIB", "alMatrixDSHighCapacityOverflowOctets"), ("HC-RMON-MIB", "alMatrixDSHighCapacityOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alMatrixHighCapacityGroup = alMatrixHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: alMatrixHighCapacityGroup.setDescription('Counts the amount of traffic, by protocol, sent between each \n        pair of network addresses discovered by the \n        probe.')
alMatrixTopNHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 14)).setObjects(("HC-RMON-MIB", "alMatrixTopNHighCapacityBasePktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityOverflowPktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityPktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseBasePktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseOverflowPktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReversePktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityBaseOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityOverflowOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseBaseOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseOverflowOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseOctetRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alMatrixTopNHighCapacityGroup = alMatrixTopNHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: alMatrixTopNHighCapacityGroup.setDescription('Prepares sorted reports of the amount of traffic per protocol \n        sent between each pair of network addresses discovered by the \n        probe.')
usrHistoryHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 15)).setObjects(("HC-RMON-MIB", "usrHistoryHighCapacityOverflowAbsValue"), ("HC-RMON-MIB", "usrHistoryHighCapacityAbsValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    usrHistoryHighCapacityGroup = usrHistoryHighCapacityGroup.setStatus('current')
if mibBuilder.loadTexts: usrHistoryHighCapacityGroup.setDescription('Provides user-defined collection of historical information \n        from MIB objects on the probe with scalability to statistics \n        from high-capacity networks.')
hcRMONInformationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 16)).setObjects(("HC-RMON-MIB", "hcRMONCapabilities"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcRMONInformationGroup = hcRMONInformationGroup.setStatus('current')
if mibBuilder.loadTexts: hcRMONInformationGroup.setDescription('An indication of the high capacity RMON groups supported on \n        at least one interface by this probe.')
mibBuilder.exportSymbols("HC-RMON-MIB", mediaIndependentInPkts=mediaIndependentInPkts, ZeroBasedCounter64=ZeroBasedCounter64, usrHistoryHighCapacityEntry=usrHistoryHighCapacityEntry, mediaIndependentInHighCapacityOctets=mediaIndependentInHighCapacityOctets, hcRMONCapabilities=hcRMONCapabilities, nlMatrixDSHighCapacityTable=nlMatrixDSHighCapacityTable, alMatrixTopNControlRateBase=alMatrixTopNControlRateBase, usrHistoryHighCapacityAbsValue=usrHistoryHighCapacityAbsValue, etherHistoryHighCapacityTable=etherHistoryHighCapacityTable, nlMatrixTopNHighCapacityOctetRate=nlMatrixTopNHighCapacityOctetRate, protocolDistStatsHighCapacityOverflowPkts=protocolDistStatsHighCapacityOverflowPkts, hostHighCapacityGroup=hostHighCapacityGroup, alMatrixTopNHighCapacityReversePktRate=alMatrixTopNHighCapacityReversePktRate, etherStatsHighCapacityPkts128to255Octets=etherStatsHighCapacityPkts128to255Octets, alMatrixSDHighCapacityTable=alMatrixSDHighCapacityTable, etherHistoryHighCapacityEntry=etherHistoryHighCapacityEntry, alMatrixSDHighCapacityOverflowOctets=alMatrixSDHighCapacityOverflowOctets, protocolDistStatsHighCapacityOctets=protocolDistStatsHighCapacityOctets, etherStatsHighCapacityPkts1024to1518Octets=etherStatsHighCapacityPkts1024to1518Octets, alHostHighCapacityOutOverflowPkts=alHostHighCapacityOutOverflowPkts, usrHistoryHighCapacityOverflowAbsValue=usrHistoryHighCapacityOverflowAbsValue, hcRmonMIBGroups=hcRmonMIBGroups, mediaIndependentOutHighCapacityOctets=mediaIndependentOutHighCapacityOctets, matrixSDHighCapacityPkts=matrixSDHighCapacityPkts, hostTimeHighCapacityInOctets=hostTimeHighCapacityInOctets, alMatrixTopNHighCapacityReverseBaseOctetRate=alMatrixTopNHighCapacityReverseBaseOctetRate, alMatrixDSHighCapacityOctets=alMatrixDSHighCapacityOctets, etherStatsHighCapacityOctets=etherStatsHighCapacityOctets, alHostHighCapacityGroup=alHostHighCapacityGroup, nlMatrixDSHighCapacityEntry=nlMatrixDSHighCapacityEntry, mediaIndependentOutNUCastPkts=mediaIndependentOutNUCastPkts, matrixDSHighCapacityOverflowPkts=matrixDSHighCapacityOverflowPkts, alMatrixSDHighCapacityOverflowPkts=alMatrixSDHighCapacityOverflowPkts, nlMatrixSDHighCapacityOverflowPkts=nlMatrixSDHighCapacityOverflowPkts, alHostHighCapacityInOctets=alHostHighCapacityInOctets, etherHistoryHighCapacityOverflowPkts=etherHistoryHighCapacityOverflowPkts, hostTimeHighCapacityEntry=hostTimeHighCapacityEntry, nlHostHighCapacityOutOctets=nlHostHighCapacityOutOctets, matrixDSHighCapacityOctets=matrixDSHighCapacityOctets, nlMatrixDSHighCapacityPkts=nlMatrixDSHighCapacityPkts, hostTimeHighCapacityOutOverflowPkts=hostTimeHighCapacityOutOverflowPkts, captureBufferHighCapacityTable=captureBufferHighCapacityTable, matrixSDHighCapacityOverflowPkts=matrixSDHighCapacityOverflowPkts, etherStatsHighCapacityTable=etherStatsHighCapacityTable, hostTopNHighCapacityEntry=hostTopNHighCapacityEntry, matrixSDHighCapacityOctets=matrixSDHighCapacityOctets, mediaIndependentInOctets=mediaIndependentInOctets, etherStatsHighCapacityOverflowPkts=etherStatsHighCapacityOverflowPkts, alMatrixTopNHighCapacityOverflowOctetRate=alMatrixTopNHighCapacityOverflowOctetRate, hostHighCapacityTable=hostHighCapacityTable, etherStatsHighCapacityOverflowOctets=etherStatsHighCapacityOverflowOctets, hostHighCapacityInOverflowOctets=hostHighCapacityInOverflowOctets, mediaIndependentInNUCastOverflowPkts=mediaIndependentInNUCastOverflowPkts, alHostHighCapacityTable=alHostHighCapacityTable, etherHistoryHighCapacityPkts=etherHistoryHighCapacityPkts, etherStatsHighCapacityOverflowPkts512to1023Octets=etherStatsHighCapacityOverflowPkts512to1023Octets, nlMatrixTopNHighCapacityGroup=nlMatrixTopNHighCapacityGroup, protocolDistStatsHighCapacityPkts=protocolDistStatsHighCapacityPkts, hostTimeHighCapacityOutOctets=hostTimeHighCapacityOutOctets, matrixDSHighCapacityOverflowOctets=matrixDSHighCapacityOverflowOctets, mediaIndependentOutOverflowOctets=mediaIndependentOutOverflowOctets, alMatrixTopNHighCapacityEntry=alMatrixTopNHighCapacityEntry, alMatrixTopNHighCapacityReverseOverflowOctetRate=alMatrixTopNHighCapacityReverseOverflowOctetRate, mediaIndependentInHighCapacityPkts=mediaIndependentInHighCapacityPkts, alMatrixTopNHighCapacityReverseOverflowPktRate=alMatrixTopNHighCapacityReverseOverflowPktRate, protocolDistStatsHighCapacityOverflowOctets=protocolDistStatsHighCapacityOverflowOctets, mediaIndependentOutOverflowPkts=mediaIndependentOutOverflowPkts, nlMatrixTopNControlRateBase=nlMatrixTopNControlRateBase, etherHistoryHighCapacityOctets=etherHistoryHighCapacityOctets, nlMatrixDSHighCapacityOverflowOctets=nlMatrixDSHighCapacityOverflowOctets, mediaIndependentOutNUCastHighCapacityPkts=mediaIndependentOutNUCastHighCapacityPkts, captureBufferHighCapacityEntry=captureBufferHighCapacityEntry, alHostHighCapacityInOverflowPkts=alHostHighCapacityInOverflowPkts, nlMatrixTopNHighCapacityEntry=nlMatrixTopNHighCapacityEntry, alMatrixTopNHighCapacityGroup=alMatrixTopNHighCapacityGroup, PYSNMP_MODULE_ID=hcRMON, alHostHighCapacityInOverflowOctets=alHostHighCapacityInOverflowOctets, etherStatsHighCapacityOverflowPkts256to511Octets=etherStatsHighCapacityOverflowPkts256to511Octets, nlMatrixHighCapacityGroup=nlMatrixHighCapacityGroup, nlHostHighCapacityInOverflowOctets=nlHostHighCapacityInOverflowOctets, nlMatrixTopNHighCapacityReverseOverflowOctetRate=nlMatrixTopNHighCapacityReverseOverflowOctetRate, nlHostHighCapacityGroup=nlHostHighCapacityGroup, mediaIndependentDataSource=mediaIndependentDataSource, mediaIndependentInErrors=mediaIndependentInErrors, alMatrixDSHighCapacityTable=alMatrixDSHighCapacityTable, etherStatsHighCapacityPkts256to511Octets=etherStatsHighCapacityPkts256to511Octets, matrixSDHighCapacityTable=matrixSDHighCapacityTable, nlMatrixSDHighCapacityEntry=nlMatrixSDHighCapacityEntry, mediaIndependentOutputSpeed=mediaIndependentOutputSpeed, etherStatsHighCapacityEntry=etherStatsHighCapacityEntry, nlHostHighCapacityInPkts=nlHostHighCapacityInPkts, hostHighCapacityOutPkts=hostHighCapacityOutPkts, mediaIndependentOutNUCastOverflowPkts=mediaIndependentOutNUCastOverflowPkts, mediaIndependentOutOctets=mediaIndependentOutOctets, alMatrixSDHighCapacityOctets=alMatrixSDHighCapacityOctets, matrixSDHighCapacityOverflowOctets=matrixSDHighCapacityOverflowOctets, nlMatrixTopNHighCapacityReverseBaseOctetRate=nlMatrixTopNHighCapacityReverseBaseOctetRate, hcRMON=hcRMON, hostHighCapacityOutOctets=hostHighCapacityOutOctets, hostTopNHighCapacityBaseRate=hostTopNHighCapacityBaseRate, nlMatrixTopNHighCapacityPktRate=nlMatrixTopNHighCapacityPktRate, mediaIndependentStats=mediaIndependentStats, etherHistoryHighCapacityOverflowOctets=etherHistoryHighCapacityOverflowOctets, nlMatrixTopNHighCapacityBasePktRate=nlMatrixTopNHighCapacityBasePktRate, alMatrixTopNHighCapacityOctetRate=alMatrixTopNHighCapacityOctetRate, hostTopNHighCapacityRate=hostTopNHighCapacityRate, alMatrixDSHighCapacityPkts=alMatrixDSHighCapacityPkts, hcRmonMIBCompliance=hcRmonMIBCompliance, etherStatsHighCapacityOverflowPkts64Octets=etherStatsHighCapacityOverflowPkts64Octets, alHostHighCapacityOutOctets=alHostHighCapacityOutOctets, hostHighCapacityOutOverflowOctets=hostHighCapacityOutOverflowOctets, matrixDSHighCapacityEntry=matrixDSHighCapacityEntry, alHostHighCapacityInPkts=alHostHighCapacityInPkts, etherStatsHighCapacityPkts65to127Octets=etherStatsHighCapacityPkts65to127Octets, mediaIndependentTable=mediaIndependentTable, alMatrixTopNHighCapacityBasePktRate=alMatrixTopNHighCapacityBasePktRate, nlMatrixTopNHighCapacityReverseBasePktRate=nlMatrixTopNHighCapacityReverseBasePktRate, nlMatrixTopNHighCapacityReverseOctetRate=nlMatrixTopNHighCapacityReverseOctetRate, alMatrixTopNHighCapacityOverflowPktRate=alMatrixTopNHighCapacityOverflowPktRate, mediaIndependentDroppedFrames=mediaIndependentDroppedFrames, hcRmonMIBCompliances=hcRmonMIBCompliances, alHostHighCapacityOutOverflowOctets=alHostHighCapacityOutOverflowOctets, hostHighCapacityEntry=hostHighCapacityEntry, nlHostHighCapacityInOctets=nlHostHighCapacityInOctets, nlMatrixTopNHighCapacityOverflowOctetRate=nlMatrixTopNHighCapacityOverflowOctetRate, hcRmon2MIBApplicationLayerCompliance=hcRmon2MIBApplicationLayerCompliance, mediaIndependentEntry=mediaIndependentEntry, nlMatrixSDHighCapacityOctets=nlMatrixSDHighCapacityOctets, etherStatsHighCapacityPkts=etherStatsHighCapacityPkts, mediaIndependentInOverflowOctets=mediaIndependentInOverflowOctets, nlMatrixTopNHighCapacityBaseOctetRate=nlMatrixTopNHighCapacityBaseOctetRate, mediaIndependentIndex=mediaIndependentIndex, nlMatrixSDHighCapacityTable=nlMatrixSDHighCapacityTable, nlHostHighCapacityOutPkts=nlHostHighCapacityOutPkts, etherStatsHighCapacityPkts512to1023Octets=etherStatsHighCapacityPkts512to1023Octets, alMatrixTopNHighCapacityReverseOctetRate=alMatrixTopNHighCapacityReverseOctetRate, nlHostHighCapacityEntry=nlHostHighCapacityEntry, matrixSDHighCapacityEntry=matrixSDHighCapacityEntry, alHostHighCapacityOutPkts=alHostHighCapacityOutPkts, etherHistoryHighCapacityGroup=etherHistoryHighCapacityGroup, nlMatrixTopNHighCapacityReverseOverflowPktRate=nlMatrixTopNHighCapacityReverseOverflowPktRate, captureBufferHighCapacityGroup=captureBufferHighCapacityGroup, mediaIndependentOutHighCapacityPkts=mediaIndependentOutHighCapacityPkts, hcRMONInformationGroup=hcRMONInformationGroup, mediaIndependentInNUCastPkts=mediaIndependentInNUCastPkts, alMatrixDSHighCapacityEntry=alMatrixDSHighCapacityEntry, hostTimeHighCapacityInOverflowPkts=hostTimeHighCapacityInOverflowPkts, alMatrixHighCapacityGroup=alMatrixHighCapacityGroup, usrHistoryHighCapacityGroup=usrHistoryHighCapacityGroup, alMatrixSDHighCapacityPkts=alMatrixSDHighCapacityPkts, nlHostHighCapacityTable=nlHostHighCapacityTable, protocolDistStatsHighCapacityEntry=protocolDistStatsHighCapacityEntry, nlHostHighCapacityOutOverflowOctets=nlHostHighCapacityOutOverflowOctets, nlMatrixDSHighCapacityOctets=nlMatrixDSHighCapacityOctets, usrHistoryHighCapacityTable=usrHistoryHighCapacityTable, mediaIndependentOutPkts=mediaIndependentOutPkts, nlMatrixSDHighCapacityPkts=nlMatrixSDHighCapacityPkts, mediaIndependentGroup=mediaIndependentGroup, mediaIndependentStatus=mediaIndependentStatus, hostTopNHighCapacityOverflowRate=hostTopNHighCapacityOverflowRate, captureBufferPacketHighCapacityTime=captureBufferPacketHighCapacityTime, alMatrixSDHighCapacityEntry=alMatrixSDHighCapacityEntry, hostTopNHighCapacityGroup=hostTopNHighCapacityGroup, matrixDSHighCapacityTable=matrixDSHighCapacityTable, alMatrixTopNHighCapacityReverseBasePktRate=alMatrixTopNHighCapacityReverseBasePktRate, RmonGauge64=RmonGauge64, nlMatrixTopNHighCapacityOverflowPktRate=nlMatrixTopNHighCapacityOverflowPktRate, hostTimeHighCapacityTable=hostTimeHighCapacityTable, etherStatsHighCapacityOverflowPkts65to127Octets=etherStatsHighCapacityOverflowPkts65to127Octets, nlHostHighCapacityOutOverflowPkts=nlHostHighCapacityOutOverflowPkts, etherStatsHighCapacityOverflowPkts1024to1518Octets=etherStatsHighCapacityOverflowPkts1024to1518Octets, matrixDSHighCapacityPkts=matrixDSHighCapacityPkts, mediaIndependentInNUCastHighCapacityPkts=mediaIndependentInNUCastHighCapacityPkts, hostHighCapacityInOverflowPkts=hostHighCapacityInOverflowPkts, hostTopNRateBase=hostTopNRateBase, alMatrixDSHighCapacityOverflowOctets=alMatrixDSHighCapacityOverflowOctets, mediaIndependentOwner=mediaIndependentOwner, mediaIndependentInOverflowPkts=mediaIndependentInOverflowPkts, nlMatrixDSHighCapacityOverflowPkts=nlMatrixDSHighCapacityOverflowPkts, hostTimeHighCapacityInPkts=hostTimeHighCapacityInPkts, nlMatrixTopNHighCapacityTable=nlMatrixTopNHighCapacityTable, alMatrixDSHighCapacityOverflowPkts=alMatrixDSHighCapacityOverflowPkts, hostTimeHighCapacityInOverflowOctets=hostTimeHighCapacityInOverflowOctets, nlHostHighCapacityInOverflowPkts=nlHostHighCapacityInOverflowPkts, etherStatsHighCapacityOverflowPkts128to255Octets=etherStatsHighCapacityOverflowPkts128to255Octets, hostHighCapacityInOctets=hostHighCapacityInOctets, hostTopNHighCapacityTable=hostTopNHighCapacityTable, hcRmon2MIBCompliance=hcRmon2MIBCompliance, etherStatsHighCapacityGroup=etherStatsHighCapacityGroup, matrixHighCapacityGroup=matrixHighCapacityGroup, etherStatsHighCapacityPkts64Octets=etherStatsHighCapacityPkts64Octets, alHostHighCapacityEntry=alHostHighCapacityEntry, mediaIndependentOutErrors=mediaIndependentOutErrors, hostTimeHighCapacityOutOverflowOctets=hostTimeHighCapacityOutOverflowOctets, mediaIndependentDropEvents=mediaIndependentDropEvents, alMatrixTopNHighCapacityBaseOctetRate=alMatrixTopNHighCapacityBaseOctetRate, nlMatrixSDHighCapacityOverflowOctets=nlMatrixSDHighCapacityOverflowOctets, nlMatrixTopNHighCapacityReversePktRate=nlMatrixTopNHighCapacityReversePktRate, protocolDistStatsHighCapacityTable=protocolDistStatsHighCapacityTable, alMatrixTopNHighCapacityTable=alMatrixTopNHighCapacityTable, alMatrixTopNHighCapacityPktRate=alMatrixTopNHighCapacityPktRate, mediaIndependentInputSpeed=mediaIndependentInputSpeed, hostHighCapacityInPkts=hostHighCapacityInPkts, protocolDistributionHighCapacityGroup=protocolDistributionHighCapacityGroup, hostHighCapacityOutOverflowPkts=hostHighCapacityOutOverflowPkts, hostTimeHighCapacityOutPkts=hostTimeHighCapacityOutPkts)
