#
# PySNMP MIB module PRVT-CR-LDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-CR-LDP-MIB
# Produced by pysmi-1.1.3 at Sat Nov 20 22:41:06 2021
# On host fv-az33-360 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
ipSwitch, = mibBuilder.importSymbols("PRVT-SWITCH-MIB", "ipSwitch")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, Integer32, Unsigned32, MibIdentifier, IpAddress, Gauge32, ObjectIdentity, ModuleIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter32, NotificationType, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Integer32", "Unsigned32", "MibIdentifier", "IpAddress", "Gauge32", "ObjectIdentity", "ModuleIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter32", "NotificationType", "Counter64")
TextualConvention, DisplayString, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue", "RowStatus")
prvtCrLdp = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3))
prvtCrLdp.setRevisions(('2008-01-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtCrLdp.setRevisionsDescriptions(('Initial',))
if mibBuilder.loadTexts: prvtCrLdp.setLastUpdated('200801010000Z')
if mibBuilder.loadTexts: prvtCrLdp.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtCrLdp.setContactInfo(' BATM/Telco Systems Support team\nEmail:\nFor North America: techsupport@telco.com\nFor North Europe: support@batm.de, info@batm.de\nFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtCrLdp.setDescription('The MIB module for management of the PRVT-CR-LDP')
mpls = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5))
prvtCrLdpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1))
class PrvtCrldpAdminStatus(TextualConvention, Integer32):
    description = 'The value determines the desired administrative\nstatus of a PRVT-CR-LDP table entry.\nThe up and down states indicate that the traffic\nflow is enabled or disabled respectively for the\nprotocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("up", 1), ("down", 2))

class PrvtCrldpOperStatus(TextualConvention, Integer32):
    description = 'The value determines the operational status of a\nPRVT-CR-LDP table entry. The up and down states indicate\nthat the traffic flow is enabled or disabled respectively.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("up", 1), ("down", 2), ("goingUp", 3), ("goingDown", 4), ("actFailed", 5))

class PrvtCrldpIndex(TextualConvention, Unsigned32):
    description = 'A general purpose SNMP index into the prvtHafEntity table.'
    status = 'current'
    displayHint = 'd'

prvtcrldpSigTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1), )
if mibBuilder.loadTexts: prvtcrldpSigTable.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigTable.setDescription('The table of active instances of PRVT-CR-LDP Signaling.')
prvtcrldpSigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpSigIndex"))
if mibBuilder.loadTexts: prvtcrldpSigEntry.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigEntry.setDescription('Each of these entries represents an instance of\nPRVT-CR-LDP Signaling running in the HAF. Some of these instances\nwill be the primary, and others may be backups.')
prvtcrldpSigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 1), PrvtCrldpIndex())
if mibBuilder.loadTexts: prvtcrldpSigIndex.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigIndex.setDescription('The index of this prvtcrldpSigEntry. This is the\nHAF entity index passed on the product create\nparameters.')
prvtcrldpSigPathManagerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 2), PrvtCrldpIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigPathManagerIndex.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigPathManagerIndex.setDescription('The index of the Path Manager instance to which this\ninstance of Signaling is to join. See prvtcrldpPmTable.')
prvtcrldpSigLsrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigLsrIndex.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigLsrIndex.setDescription('The index of the PRVT-LMGR product instance to which this\nPRVT-CR-LDP Signaling is to join as its LDB interface provider.\nSee prvtlmgrLsrEntityTable.')
prvtcrldpSigSocketIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigSocketIfIndex.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigSocketIfIndex.setDescription('Management assigned interface identifier for the IP Sockets\ncomponent interface to PRVT-CR-LDP Signalling.')
prvtcrldpSigSessionBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 5), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigSessionBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigSessionBufPoolSize.setDescription('The number of pre-reserved buffers available for sending\nsockets and LDI messages for each LDP session. This is used\nto pace the sockets and LDI data flows for each LDP session.')
prvtcrldpSigEMBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 6), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigEMBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigEMBufPoolSize.setDescription("The number of pre-reserved buffers available for sending\nsockets, LDBI, NHR and I3 messages within Entity Manager\nThis is used to pace Entity Manager's sockets, LDBI, NHR\nand I3 data flows.")
prvtcrldpSigAMBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 7), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigAMBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigAMBufPoolSize.setDescription("The number of pre-reserved buffers available for sending\nsockets messages within Adjacency Manager. This is used\nto pace Adjacency Manager's sockets data flows.")
prvtcrldpSigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 8), PrvtCrldpAdminStatus().clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigAdminStatus.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigAdminStatus.setDescription('This object is used to activate the PRVT-CR-LDP Signaling instance.')
prvtcrldpSigOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 9), PrvtCrldpOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtcrldpSigOperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigOperStatus.setDescription('The current operational status of this instance of\nPRVT-CR-LDP Signaling.')
prvtcrldpSigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigRowStatus.setDescription("Used to create and delete a PRVT-CR-LDP Signaling Table entry.\nWhen this object is set to 'active', only the\nprvtcrldpSigAdminStatus object in the row may be modified.")
prvtcrldpSigUseI3Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigUseI3Interface.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigUseI3Interface.setDescription('Used to indicate whether this PRVT-CR-LDP Signaling instance\nshould use the I3 interface or the IPR interface to determine\ninformation regarding local interface configuration. Use of\nthe IPR interface is deprecated, but nevertheless this field\ndefaults to its use for back-compatibility reasons.')
prvtcrldpSigConformanceFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 12), Bits().clone(namedValues=NamedValues(("maxPduLen", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigConformanceFlags.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigConformanceFlags.setDescription("Flags specifying how PRVT-LDP Session Controller should\nbehave in situations either where the interpretation of\nstrict conformance is debatable, or where strictly\nconformant behavior contradicts the general IETF principle\nof being liberal on receipt.\n\nmaxPduLen If set, this flag means that PRVT-LDP should\nabort session initialization if the peer (in the passive\nrole) proposes a max PDU length that is larger than\nPRVT-LDP's proposed value. The interpretation here is that\nthe passive peer's value should be the already negotiated\nvalue, not its raw value.")
prvtcrldpSigUseIPv6Transport = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigUseIPv6Transport.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigUseIPv6Transport.setDescription('Used to indicate whether the PRVT-CR-LDP signaling is to use\nIPv6 transport where possible.\n\nNote that if PRVT-LDP is configured with an IPv4 transport\naddress, IPv4 transport will be used for multicast and\nIPv6 sockets using a IPv4 mapped IPv6 address will be used\nfor unicast when this field is set to True.')
prvtcrldpSigSessStatusTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigSessStatusTrapEnable.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigSessStatusTrapEnable.setDescription('If this object is true, then it enables the generation of\nmplsLdpSessionUp and mplsLdpSessionDown traps, otherwise\nthese traps are not generated.')
prvtcrldpSigSessThreshTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigSessThreshTrapEnable.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigSessThreshTrapEnable.setDescription('If this object is true, then it enables the generation of\nmplsLdpInitSessionThresholdExceeded traps, otherwise these\ntraps are not generated.')
prvtcrldpSigPathVecLimitTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 1, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpSigPathVecLimitTrapEnable.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpSigPathVecLimitTrapEnable.setDescription('If this object is true, then it enables the generation of\nmplsLdpPathVectorLimitMismatch traps, otherwise these\ntraps are not generated.')
prvtcrldpPmTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2), )
if mibBuilder.loadTexts: prvtcrldpPmTable.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmTable.setDescription('The table of active instances of PRVT-CR-LDP Path Manager.')
prvtcrldpPmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1), ).setIndexNames((0, "PRVT-CR-LDP-MIB", "prvtcrldpPmIndex"))
if mibBuilder.loadTexts: prvtcrldpPmEntry.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmEntry.setDescription('Each of these entries represents an instance of\nPRVT-CR-LDP Path Manager running in the HAF. Some of these instances\nwill be the primary, and others may be backups.')
prvtcrldpPmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 1), PrvtCrldpIndex())
if mibBuilder.loadTexts: prvtcrldpPmIndex.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmIndex.setDescription('The index of this prvtcrldpPmEntry. This is the\nHAF entity index passed on the product create\nparameters.')
prvtcrldpPmLsrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmLsrIndex.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmLsrIndex.setDescription('The index of the PRVT-LMGR product instance to which this\nPRVT-CR-LDP Path Manager is to join as its LDB interface provider.\nSee prvtlmgrLsrEntityTable.')
prvtcrldpPmLdpEntityAutoCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 3), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmLdpEntityAutoCreate.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmLdpEntityAutoCreate.setDescription("When set to 'true', the Entity Manager component of PRVT-CR-LDP\ncreates Entities automatically based on interfaces known to\nEntity Manager. When set to 'false' Entities are not\nautomatically created.")
prvtcrldpPmLdpEntityAutoStart = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 4), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmLdpEntityAutoStart.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmLdpEntityAutoStart.setDescription("When set to 'true', the Entity Manager component of PRVT-CR-LDP\nautomatically starts Entities. Both configured and automatically\ncreated Entities are automatically started. When set to 'false'\nEntities are not automatically started.")
prvtcrldpPmLdpEntityReuse = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 5), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmLdpEntityReuse.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmLdpEntityReuse.setDescription("When set to 'true', the same Entity can be used for multiple\ninterfaces. That is, the per-platform label space behaves as\na per-interface label space. When set to 'false', the same\nentity cannot be used for multiple interfaces.")
prvtcrldpPmLdpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("version1", 1))).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmLdpVersion.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmLdpVersion.setDescription('An indication of the LDP version supported.')
prvtcrldpPmUseLdpFt = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmUseLdpFt.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmUseLdpFt.setDescription("When set to 'true', PRVT-CR-LDP implements fault tolerance\nprocedures for LDP and CR-LDP. When set to 'false', fault\ntolerance procedures are not used.")
prvtcrldpPmAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmAsNumber.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmAsNumber.setDescription('The number identifying the autonomous system (AS) to which\nthis node belongs.')
prvtcrldpPmIprBufPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 9), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmIprBufPoolSize.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmIprBufPoolSize.setDescription('The size of the buffer pool used for sending either\n(deprecated) IPRI messages or for sending NHR and I3\nmessages. This is used to pace IPR/NHR+I3 data flows from\nPM.')
prvtcrldpPmLdpSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmLdpSupported.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmLdpSupported.setDescription("When set to 'true', PRVT-CR-LDP implements LDP\nfunctionality. When set to 'false' received LDP requests\nare rejected.\nNote that at least one of prvtcrldpPmLdpSupported and\nprvtcrldpPmCrLdpSupported must be set to 'true' before\nactivating a prvtcrldpPmTable row. Both prvtcrldpPmLdpSupported\nand prvtcrldpPmCrLdpSupported may be set to 'true'.")
prvtcrldpPmCrLdpSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmCrLdpSupported.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmCrLdpSupported.setDescription("When set to 'true', PRVT-CR-LDP implements CR-LDP\nfunctionality. When set to 'false' received CR-LDP requests\nare rejected.\nNote that at least one of prvtcrldpPmLdpSupported and\nprvtcrldpPmCrLdpSupported must be set to 'true' before\nactivating a prvtcrldpPmTable row. Both prvtcrldpPmLdpSupported\nand prvtcrldpPmCrLdpSupported may be set to 'true'.")
prvtcrldpPmQueryFECSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmQueryFECSupported.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmQueryFECSupported.setDescription("When set to 'true', PRVT-CR-LDP queries the routing stub\nwhen a label mapping for an unrecognized FEC is received\nto determine whether the FEC should be recognized and the\ncorresponding switch programming performed or not. If set\nto 'false' PRVT-CR-LDP creates a dummy FEC for the mapping\nand retains or releases the mapping based on the label\nretention policy for the session.")
prvtcrldpPmAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 13), PrvtCrldpAdminStatus().clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmAdminStatus.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmAdminStatus.setDescription('This object is used to activate the PRVT-CR-LDP Path Manager instance.')
prvtcrldpPmOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 14), PrvtCrldpOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prvtcrldpPmOperStatus.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmOperStatus.setDescription('The current operational status of this instance of\nPRVT-CR-LDP Path Manager.')
prvtcrldpPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmRowStatus.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmRowStatus.setDescription("Used to create and delete a PRVT-CR-LDP Path Manager Table entry.\nWhen this object is set to 'active', only the\nprvtcrldpPmAdminStatus object in the row may be modified.")
prvtcrldpPmRestartCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmRestartCapable.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmRestartCapable.setDescription('A flag to indicate whether the local node should advertise\nitself as LDP restart capable if the Label Switch\nController or Label Data Forwarder is capable of\nsupporting the required procedures.')
prvtcrldpPmReconnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(10000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmReconnectTime.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmReconnectTime.setDescription('The time in milliseconds that the local node takes to\nrestart LDP and bring up the LDP sessions.\nThis is advertised to neighbors in the FT Session TLV in\nInitialization messages.\n\nThe value chosen should be large enough for LDP to be\nterminated and restarted.\n\nOnly used if prvtcrldpPmRestartCapable is set to true.')
prvtcrldpPmRecoveryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(10000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmRecoveryTime.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmRecoveryTime.setDescription('The period of time in milliseconds that the local node\nis willing to retain its MPLS forwarding state, if any,\nthat it preserved across the restart.\n\nThe time is from the end of the restart time configured\nabove.\n\nOnly used if prvtcrldpPmRestartCapable is set to true.')
prvtcrldpPmMaxPeerReconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(10000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmMaxPeerReconnect.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmMaxPeerReconnect.setDescription('The maximum period of time in milliseconds that LDP\nshould wait for a restart capable neighbor to restore an\nLDP session.\n\nLDP waits for the minimum of this time and the\nReconnect Timeout advertised in the FT Session TLV in\nthe Initialization message from the neighbor.\n\nOnly used if prvtcrldpPmRestartCapable is set to true.')
prvtcrldpPmMaxPeerRecovery = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(10000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmMaxPeerRecovery.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmMaxPeerRecovery.setDescription('The maximum period of time in milliseconds that LDP\nshould wait for a restart capable neighbor to refresh\nLabel Mappings previously received from that neighbor\nbefore deleting the stale bindings.\n\nLDP waits for the minimum of this time and the\nRecovery Time advertised in the FT Session TLV in\nthe Initialization message from the neighbor.\n\nOnly used if prvtcrldpPmRestartCapable is set to true.')
prvtcrldpPmAdjDwnHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmAdjDwnHoldTime.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmAdjDwnHoldTime.setDescription('The time in milliseconds to hold a failed LDP Hello\nadjacency to distinguish between LDP peer failure\nand interface failure.\n\nThis field is used to ensure that LDP retains adjacency\nmulti-link LSPs during peer restart recovery when the peer\nrestarts and an LDP Hello adjacency goes down before the\nLDP session.\n\nWhen an LDP Hello adjacency fails, Path Manager waits\nuntil the adjacency holding timer expires before tearing\ndown any LSP out segments associated with the adjacency.\n\nIf the LDP session fails before the adjacency holding\ntimer expires, Path Manager performs peer restart recovery\ninstead of tearing down any LSP out segments.\n\nIf the adjacency holding timer expires and the LDP session\nis still active then Path Manager assumes that the\ninterface has failed but the peer is still active. In\nthis case Path Manager tears down LSP out segments\nassociated with the adjacency.\n\nThe value chosen should be large enough for the LDP\nsession to fail if the LDP peer has failed.\n\nOnly used if _restart_capable_ is set to AMB_TRUE, and\ncannot be modified when the _row_status_ is ACTIVE.')
prvtcrldpPmOutSegProgOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("connFirst", 1))).clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmOutSegProgOrder.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmOutSegProgOrder.setDescription('This determines the order in which LDP connects and\nreleases out segments.\n\ndefault: This will release all out-segments on a session\nbefore programming new out-segments on the same session.\nNo ordering for out-segments across different sessions is\nenforced when ECMP is in use.\n\nconnFirst: This mode forces all the out-segments for an\nLSP to be programmed before any out-segments are released.\nThis ordering is only supported if the LSC stub supports\nimplicit XCs.')
prvtcrldpPmSupportIpv6 = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmSupportIpv6.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmSupportIpv6.setDescription("This field indicates whether LDP Path Manager supports\nIPv6 addresses, FECs and routes.\n\nIf this field is set to false then no IPv6 addresses will\nbe accepted over the NHR and I3 interfaces and all LDP\nprotocol messages for IPv6 addresses or FECs will be\nreturned to the peer as an LDP status code of 'Unsupported\nAddress Family'.")
prvtcrldpPmPolicySupportFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 24), Bits().clone(namedValues=NamedValues(("policySupported", 0), ("perFecOptimizationSupported", 1), ("suppressAddressPolicy", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmPolicySupportFlags.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmPolicySupportFlags.setDescription('This field contains bit flags which indicate whether\nPRVT-LDP supports LDP Policy and if per FEC policy\noptimization is to be used.\n\nThe supported bit flags are defined below.\n- policySupported\n- perFecOptimizationSupported\n- suppressAddressPolicy.\n\nThe policySupported flag indicates that PRVT-LDP will\nenforce policy decisions made by the user through a number\nof user exits. If this flag is not set PRVT-LDP will not\ncall policy user exits.\n\nThe perFecOptimizationSupported flag indicates that PRVT-LDP\nprovides policy on a per FEC basis as opposed to a per FEC\nper session basis. This results in policy user exits only\nbeing called once per FEC. This field is only significant\nif the policySupported flag is set. This feature is used\nto reduce the number of calls to the Policy User Exits\nparticularly when a change in Policy is being implemented.\n\nIf the perFecOptimizationSupported flag is not set then\nPRVT-LDP Path Manager enforces policy on a per FEC per peer\nbasis.\n\nIf this flag is set policy is enforced on a per FEC basis\nand the same policy decision is assumed to apply for all\npeers.\n\nThe suppressAddressPolicy flag if set prevents PRVT-LDP from\nperforming any Policy processing on receipt of a Address\nor Address Withdraw message from a peer.\n\nIf this field is not set then its default value is\ndetermined by the RCP_USER_DO_POLICY compile time flag.\n\nChanges to the value of policy_support_flags are not\npermitted whilst the MIB row is active.')
prvtcrldpPmCheckOutSegIntfaceStat = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 6, 5, 3, 1, 2, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prvtcrldpPmCheckOutSegIntfaceStat.setStatus('current')
if mibBuilder.loadTexts: prvtcrldpPmCheckOutSegIntfaceStat.setDescription("This field indicates whether LDP Path Manager makes the\nprogramming of each out segment conditional on the status\nof the interface where the out segment is programmed.\n\nWhen set to false, LDP Path Manager assumes that the\navailability of interfaces for programming is reflected in\nthe adjacency and session information that it receives\nfrom LDP Session Controller, and in the routing\ninformation that it receives from the NHR stub.\n\nWhen set to true, LDP Path Manager tracks interface\nstatus itself and uses this in addition to input from LDP\nSession Controller and the NHR stub to decide whether an\nout segment should be programmed on a particular\ninterface. If the other inputs indicate 'yes', but the\nrelevant interface is (or goes) down, LDP Path Manager\nwill not program that out segment (or will remove the\nexisting out segment on that interface).\n\nThis field cannot be changed when the row is active.")
mibBuilder.exportSymbols("PRVT-CR-LDP-MIB", prvtcrldpPmMaxPeerReconnect=prvtcrldpPmMaxPeerReconnect, PrvtCrldpOperStatus=PrvtCrldpOperStatus, prvtcrldpPmRowStatus=prvtcrldpPmRowStatus, prvtcrldpPmAdminStatus=prvtcrldpPmAdminStatus, prvtcrldpPmLdpEntityAutoCreate=prvtcrldpPmLdpEntityAutoCreate, prvtcrldpSigIndex=prvtcrldpSigIndex, prvtcrldpPmEntry=prvtcrldpPmEntry, prvtcrldpPmCheckOutSegIntfaceStat=prvtcrldpPmCheckOutSegIntfaceStat, prvtcrldpSigOperStatus=prvtcrldpSigOperStatus, prvtcrldpPmLdpSupported=prvtcrldpPmLdpSupported, prvtcrldpPmIndex=prvtcrldpPmIndex, prvtcrldpPmRestartCapable=prvtcrldpPmRestartCapable, prvtcrldpSigPathManagerIndex=prvtcrldpSigPathManagerIndex, prvtcrldpSigAMBufPoolSize=prvtcrldpSigAMBufPoolSize, prvtcrldpPmLdpEntityReuse=prvtcrldpPmLdpEntityReuse, prvtcrldpPmReconnectTime=prvtcrldpPmReconnectTime, prvtcrldpPmLdpVersion=prvtcrldpPmLdpVersion, prvtcrldpSigConformanceFlags=prvtcrldpSigConformanceFlags, prvtCrLdp=prvtCrLdp, prvtcrldpSigLsrIndex=prvtcrldpSigLsrIndex, prvtCrLdpObjects=prvtCrLdpObjects, prvtcrldpSigSessThreshTrapEnable=prvtcrldpSigSessThreshTrapEnable, prvtcrldpSigUseI3Interface=prvtcrldpSigUseI3Interface, prvtcrldpSigTable=prvtcrldpSigTable, prvtcrldpPmAdjDwnHoldTime=prvtcrldpPmAdjDwnHoldTime, prvtcrldpPmLsrIndex=prvtcrldpPmLsrIndex, prvtcrldpPmAsNumber=prvtcrldpPmAsNumber, prvtcrldpPmLdpEntityAutoStart=prvtcrldpPmLdpEntityAutoStart, prvtcrldpSigRowStatus=prvtcrldpSigRowStatus, prvtcrldpPmSupportIpv6=prvtcrldpPmSupportIpv6, prvtcrldpSigAdminStatus=prvtcrldpSigAdminStatus, prvtcrldpPmMaxPeerRecovery=prvtcrldpPmMaxPeerRecovery, prvtcrldpSigPathVecLimitTrapEnable=prvtcrldpSigPathVecLimitTrapEnable, prvtcrldpPmOutSegProgOrder=prvtcrldpPmOutSegProgOrder, prvtcrldpSigSessStatusTrapEnable=prvtcrldpSigSessStatusTrapEnable, PrvtCrldpAdminStatus=PrvtCrldpAdminStatus, prvtcrldpSigEntry=prvtcrldpSigEntry, prvtcrldpPmRecoveryTime=prvtcrldpPmRecoveryTime, PrvtCrldpIndex=PrvtCrldpIndex, mpls=mpls, prvtcrldpPmIprBufPoolSize=prvtcrldpPmIprBufPoolSize, prvtcrldpPmOperStatus=prvtcrldpPmOperStatus, prvtcrldpSigSessionBufPoolSize=prvtcrldpSigSessionBufPoolSize, prvtcrldpPmTable=prvtcrldpPmTable, prvtcrldpPmUseLdpFt=prvtcrldpPmUseLdpFt, prvtcrldpPmQueryFECSupported=prvtcrldpPmQueryFECSupported, prvtcrldpSigUseIPv6Transport=prvtcrldpSigUseIPv6Transport, PYSNMP_MODULE_ID=prvtCrLdp, prvtcrldpSigSocketIfIndex=prvtcrldpSigSocketIfIndex, prvtcrldpSigEMBufPoolSize=prvtcrldpSigEMBufPoolSize, prvtcrldpPmCrLdpSupported=prvtcrldpPmCrLdpSupported, prvtcrldpPmPolicySupportFlags=prvtcrldpPmPolicySupportFlags)
