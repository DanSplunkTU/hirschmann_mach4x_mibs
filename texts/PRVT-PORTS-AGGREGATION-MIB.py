#
# PySNMP MIB module PRVT-PORTS-AGGREGATION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/telco-systems/binos/PRVT-PORTS-AGGREGATION-MIB
# Produced by pysmi-1.1.3 at Sun Nov 28 16:43:32 2021
# On host fv-az126-355 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
ifIndex, ifOperStatus, ifAdminStatus = mibBuilder.importSymbols("IF-MIB", "ifIndex", "ifOperStatus", "ifAdminStatus")
configL2IfaceUnit, configL2IfaceSlot, switch, configL2IfacePort = mibBuilder.importSymbols("PRVT-SWITCH-MIB", "configL2IfaceUnit", "configL2IfaceSlot", "switch", "configL2IfacePort")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, TimeTicks, Counter32, ObjectIdentity, MibIdentifier, IpAddress, Counter64, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Gauge32, NotificationType, iso, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "TimeTicks", "Counter32", "ObjectIdentity", "MibIdentifier", "IpAddress", "Counter64", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Gauge32", "NotificationType", "iso", "Integer32")
TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString")
prvtPortsAggregationMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 738, 1, 5, 106))
prvtPortsAggregationMib.setRevisions(('2008-09-20 00:00', '2005-02-16 00:00', '2004-10-29 00:00', '2003-05-06 00:00', '2002-12-24 00:00', '2002-11-11 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: prvtPortsAggregationMib.setRevisionsDescriptions(('Added notifications for aggregation members.', 'Fixed spelling errors and changed the contact info.', 'Added aggregationLacpPortKey', 'Moved to SMI-V2.', 'Added enabling and disabling for LACP.', 'Initial version.',))
if mibBuilder.loadTexts: prvtPortsAggregationMib.setLastUpdated('200809200000Z')
if mibBuilder.loadTexts: prvtPortsAggregationMib.setOrganization('BATM Advanced Communication')
if mibBuilder.loadTexts: prvtPortsAggregationMib.setContactInfo(' BATM/Telco Systems Support team\nEmail: \nFor North America: techsupport@telco.com\nFor North Europe: support@batm.de, info@batm.de\nFor the rest of the world: techsupport@telco.com')
if mibBuilder.loadTexts: prvtPortsAggregationMib.setDescription('The Ports Aggregation MIB module for managing switch or ipSwitch\nstatic and dynamic port aggregation.')
portsAggregation = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1))
portsAggregationConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2))
portsAggregationTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 3))
maxAggregatorId = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxAggregatorId.setStatus('current')
if mibBuilder.loadTexts: maxAggregatorId.setDescription('The maximum allowed aggregator ID for this unit.')
aggregationLacpSystemPriority = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aggregationLacpSystemPriority.setStatus('current')
if mibBuilder.loadTexts: aggregationLacpSystemPriority.setDescription('The LACP system priority.')
portsAggregationTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3), )
if mibBuilder.loadTexts: portsAggregationTable.setStatus('current')
if mibBuilder.loadTexts: portsAggregationTable.setDescription('This table contains the status of all the trunks in the system\nIt can contain two major types: static and dynamic trunks.')
portsAggregationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1), ).setIndexNames((0, "PRVT-PORTS-AGGREGATION-MIB", "aggregatorId"))
if mibBuilder.loadTexts: portsAggregationEntry.setStatus('current')
if mibBuilder.loadTexts: portsAggregationEntry.setDescription('Ports aggregation entry.')
aggregatorId = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: aggregatorId.setStatus('current')
if mibBuilder.loadTexts: aggregatorId.setDescription('The internal trunk ID.')
aggregatorIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorIfIndex.setStatus('current')
if mibBuilder.loadTexts: aggregatorIfIndex.setDescription('The interface index from MIB-II ifTable.')
aggregatorType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("staticTrunk", 1), ("protocol-802-1ad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorType.setStatus('current')
if mibBuilder.loadTexts: aggregatorType.setDescription('This variable describes the trunk type.')
aggregatorName = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aggregatorName.setStatus('current')
if mibBuilder.loadTexts: aggregatorName.setDescription("The aggregator's name.")
aggregatorPortsMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 5), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorPortsMembers.setStatus('current')
if mibBuilder.loadTexts: aggregatorPortsMembers.setDescription('The ports that are members of this trunk.')
aggregatorPortsActive = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 6), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorPortsActive.setStatus('current')
if mibBuilder.loadTexts: aggregatorPortsActive.setDescription('The active ports that are members of this trunk.')
aggregatorL2DropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2DropEvents.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2DropEvents.setDescription('The total number of events in which packets\nwere dropped by the probe due to lack of resources.\nNote that this number is not necessarily the number of\npackets dropped; it is just the number of times this\ncondition has been detected.')
aggregatorL2Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Octets.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Octets.setDescription('The total number of octets of data (including\nthose in bad packets) received on the\nnetwork (excluding framing bits but including\nFCS octets).\n\nThis object can be used as a reasonable estimate of\nEthernet utilization. If greater precision is\ndesired, the etherStatsPkts and etherStatsOctets\nobjects should be sampled before and after a common\ninterval. The differences in the sampled values are\nPkts and Octets, respectively, and the number of\nseconds in the interval is Interval. These values\nare used to calculate the Utilization as follows:\n\nPkts * (9.6 + 6.4) + (Octets * .8)\nUtilization = \nInterval * 10,000\n\nThe result of this equation is the Ethernet segment utilization \nwhich is the percent utilization of the ethernet\nsegment on a 0 to 100 percent scale.')
aggregatorL2Pkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Pkts.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Pkts.setDescription('The total number of packets (including bad packets,\nbroadcast packets, and multicast packets) received.')
aggregatorL2BroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2BroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2BroadcastPkts.setDescription('The total number of good packets received that were\ndirected to the broadcast address. Note that this\ndoes not include multicast packets.')
aggregatorL2MulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2MulticastPkts.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2MulticastPkts.setDescription('The total number of good packets received that were\ndirected to a multicast address. Note that this\nnumber does not include packets directed to the\nbroadcast address.')
aggregatorL2CRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2CRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2CRCAlignErrors.setDescription('The total number of packets received that\nhad a length (excluding framing bits, but\nincluding FCS octets) of between 64 and 1518\noctets, inclusive, but had either a bad\nFrame Check Sequence (FCS) with an integral\nnumber of octets (FCS Error) or a bad FCS with\na non-integral number of octets (Alignment Error).')
aggregatorL2UndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2UndersizePkts.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2UndersizePkts.setDescription('The total number of packets received that were\nless than 64 octets long (excluding framing bits,\nbut including FCS octets) and were otherwise well\nformed.')
aggregatorL2OversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2OversizePkts.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2OversizePkts.setDescription('The total number of packets received that were\nlonger than 1518 octets (excluding framing bits,\nbut including FCS octets) and were otherwise\nwell formed.')
aggregatorL2Fragments = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Fragments.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Fragments.setDescription('The total number of packets received that were less\nthan 64 octets in length (excluding framing bits but\nincluding FCS octets) and had either a bad Frame\nCheck Sequence (FCS) with an integral number of\noctets (FCS Error) or a bad FCS with a non-integral\nnumber of octets (Alignment Error).\n\nNote that it is entirely normal for\netherStatsFragments to increment. This is because\nit counts both runts (which are normal occurrences\ndue to collisions) and noise hits.')
aggregatorL2Jabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Jabbers.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Jabbers.setDescription('The total number of packets received that were\nlonger than 1518 octets (excluding framing bits,\nbut including FCS octets), and had either a bad\nFrame Check Sequence (FCS) with an integral number\nof octets (FCS Error) or a bad FCS with a\nnon-integral number of octets (Alignment Error).\n\nNote that this definition of jabber is different\nfrom the definition in IEEE-802.3 section 8.2.1.5\n(10BASE5) and section 10.3.1.4 (10BASE2). These\ndocuments define jabber as the condition in which any\npacket exceeds 20 ms. The allowed range to detect\njabber is between 20 ms and 150 ms.')
aggregatorL2Collisions = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Collisions.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Collisions.setDescription("The best estimate of the total number of collisions\non this Ethernet segment.\n\nThe value returned will depend on the RMON probe's location. \nSections 8.2.1.3 (10BASE-5) and 10.3.1.3 (10BASE-2) of \nIEEE standard 802.3 states that a station must detect a collision in\nthe receive mode if three or more stations are\ntransmitting simultaneously. A repeater port must\ndetect a collision when two or more stations are\ntransmitting simultaneously. Thus a probe placed on\na repeater port could record more collisions than a\nprobe connected to a station on the same segment\nwould.\n\nProbe location plays a much smaller role when\nconsidering 10BASE-T. Section 14.2.1.4 (10BASE-T) of IEEE\nstandard 802.3 defines a collision as the\nsimultaneous presence of signals on the DO and RD\ncircuits (transmitting and receiving at the same\ntime). A 10BASE-T station can only detect\ncollisions when it is transmitting. Thus probes\nplaced on a station and a repeater, should report\nthe same number of collisions.\n\nNote also that an RMON probe inside a repeater\nshould ideally report collisions between the\nrepeater and one or more other hosts (transmit\ncollisions as defined by IEEE 802.3k) plus receiver\ncollisions observed on any coaxial segments to which\nthe repeater is connected.")
aggregatorL2Pkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Pkts64Octets.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Pkts64Octets.setDescription('The total number of packets (including bad\npackets) received that were 64 octets in length\n(excluding framing bits but including FCS octets).')
aggregatorL2Pkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Pkts65to127Octets.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Pkts65to127Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n65 and 127 octets in length inclusive\n(excluding framing bits but including FCS octets).')
aggregatorL2Pkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Pkts128to255Octets.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Pkts128to255Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n128 and 255 octets in length inclusive\n(excluding framing bits but including FCS octets).')
aggregatorL2Pkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Pkts256to511Octets.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Pkts256to511Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n256 and 511 octets in length inclusive\n(excluding framing bits but including FCS octets).')
aggregatorL2Pkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Pkts512to1023Octets.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Pkts512to1023Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n512 and 1023 octets in length inclusive\n(excluding framing bits but including FCS octets).')
aggregatorL2Pkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregatorL2Pkts1024to1518Octets.setStatus('current')
if mibBuilder.loadTexts: aggregatorL2Pkts1024to1518Octets.setDescription('The total number of packets (including bad\npackets) received that were between\n1024 and 1518 octets in length inclusive\n(excluding framing bits but including FCS octets).')
aggregationLacpSystemEnable = MibScalar((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aggregationLacpSystemEnable.setStatus('current')
if mibBuilder.loadTexts: aggregationLacpSystemEnable.setDescription('This value enable/disable the LACP system globaly')
portsAggregationConfigTable = MibTable((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2, 1), )
if mibBuilder.loadTexts: portsAggregationConfigTable.setStatus('current')
if mibBuilder.loadTexts: portsAggregationConfigTable.setDescription('This table contains only the static (created by management) port trunk configuration.')
portsAggregationConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2, 1, 1), ).setIndexNames((0, "PRVT-SWITCH-MIB", "configL2IfaceUnit"), (0, "PRVT-SWITCH-MIB", "configL2IfaceSlot"), (0, "PRVT-SWITCH-MIB", "configL2IfacePort"))
if mibBuilder.loadTexts: portsAggregationConfigEntry.setStatus('current')
if mibBuilder.loadTexts: portsAggregationConfigEntry.setDescription('Port aggregation config entry.')
staticAggregationID = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: staticAggregationID.setStatus('current')
if mibBuilder.loadTexts: staticAggregationID.setDescription(' A number representing the aggregation group that this port belongs to.\n0 means that this port does not belong to any static group.')
dynamicAggregationID = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dynamicAggregationID.setStatus('current')
if mibBuilder.loadTexts: dynamicAggregationID.setDescription(' A number representing the aggregation group that this port belongs to.\n0 means that this port does not belong to any dynamic group')
aggregationType = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("static", 2), ("protocol-802-1adAcive", 3), ("protocol-802-1adPassive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aggregationType.setStatus('current')
if mibBuilder.loadTexts: aggregationType.setDescription('Specifies the aggregation type of the interface - disable(1) if the port does not belong to a group,\nstatic(2) if the port belongs to a static group, and protocol-802-1adAcive(3) or protocol-802-1adPassive(4)\nif the interface is part of a dynamic group.')
aggregationLacpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aggregationLacpPortPriority.setStatus('current')
if mibBuilder.loadTexts: aggregationLacpPortPriority.setDescription('LACP priority for a port')
aggregationLacpPortKey = MibTableColumn((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aggregationLacpPortKey.setStatus('current')
if mibBuilder.loadTexts: aggregationLacpPortKey.setDescription('LACP identification key for a port')
lagMemberLinkUp = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 3, 1)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifIndex"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"))
if mibBuilder.loadTexts: lagMemberLinkUp.setStatus('current')
if mibBuilder.loadTexts: lagMemberLinkUp.setDescription('This notification is generated when lag link becomes\nup. \nThe first ifIndex indicates the id of the trunk \ninterface. \nThe second one shows the port member with link status change')
lagMemberLinkDown = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 3, 2)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifIndex"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"))
if mibBuilder.loadTexts: lagMemberLinkDown.setStatus('current')
if mibBuilder.loadTexts: lagMemberLinkDown.setDescription('This notification is generated when lag link becomes\ndown.\nThe first ifIndex indicates the id of the trunk \ninterface. \nThe second one shows the port member with link status change')
lagMemberAdd = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 3, 3)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: lagMemberAdd.setStatus('current')
if mibBuilder.loadTexts: lagMemberAdd.setDescription('This notification is generated when a new port is added to \na lag link. \nThe first ifIndex indicates the id of the trunk \ninterface. \nThe second one shows the added port member')
lagMemberRemove = NotificationType((1, 3, 6, 1, 4, 1, 738, 1, 5, 106, 3, 4)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: lagMemberRemove.setStatus('current')
if mibBuilder.loadTexts: lagMemberRemove.setDescription('This notification is generated when a port is removed from \na lag.\nThe first ifIndex indicates the id of the trunk \ninterface. \nThe second one shows the removed port member')
mibBuilder.exportSymbols("PRVT-PORTS-AGGREGATION-MIB", aggregatorL2Collisions=aggregatorL2Collisions, portsAggregationEntry=portsAggregationEntry, aggregatorIfIndex=aggregatorIfIndex, lagMemberLinkDown=lagMemberLinkDown, PYSNMP_MODULE_ID=prvtPortsAggregationMib, aggregatorId=aggregatorId, aggregatorL2Fragments=aggregatorL2Fragments, aggregatorL2OversizePkts=aggregatorL2OversizePkts, aggregatorType=aggregatorType, portsAggregationConfigTable=portsAggregationConfigTable, aggregatorL2Pkts256to511Octets=aggregatorL2Pkts256to511Octets, aggregationLacpSystemEnable=aggregationLacpSystemEnable, staticAggregationID=staticAggregationID, aggregatorL2MulticastPkts=aggregatorL2MulticastPkts, aggregatorName=aggregatorName, lagMemberAdd=lagMemberAdd, aggregatorL2UndersizePkts=aggregatorL2UndersizePkts, aggregatorL2Pkts512to1023Octets=aggregatorL2Pkts512to1023Octets, dynamicAggregationID=dynamicAggregationID, portsAggregationConfigEntry=portsAggregationConfigEntry, portsAggregationTable=portsAggregationTable, aggregationLacpPortPriority=aggregationLacpPortPriority, maxAggregatorId=maxAggregatorId, prvtPortsAggregationMib=prvtPortsAggregationMib, aggregationLacpSystemPriority=aggregationLacpSystemPriority, aggregatorL2Pkts128to255Octets=aggregatorL2Pkts128to255Octets, portsAggregationTraps=portsAggregationTraps, aggregatorL2Pkts=aggregatorL2Pkts, portsAggregation=portsAggregation, lagMemberLinkUp=lagMemberLinkUp, lagMemberRemove=lagMemberRemove, aggregatorL2Jabbers=aggregatorL2Jabbers, aggregationType=aggregationType, aggregatorL2Octets=aggregatorL2Octets, aggregatorL2Pkts1024to1518Octets=aggregatorL2Pkts1024to1518Octets, aggregatorL2Pkts64Octets=aggregatorL2Pkts64Octets, aggregationLacpPortKey=aggregationLacpPortKey, aggregatorPortsActive=aggregatorPortsActive, aggregatorPortsMembers=aggregatorPortsMembers, portsAggregationConfig=portsAggregationConfig, aggregatorL2DropEvents=aggregatorL2DropEvents, aggregatorL2BroadcastPkts=aggregatorL2BroadcastPkts, aggregatorL2Pkts65to127Octets=aggregatorL2Pkts65to127Octets, aggregatorL2CRCAlignErrors=aggregatorL2CRCAlignErrors)
