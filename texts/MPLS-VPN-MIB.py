#
# PySNMP MIB module MPLS-VPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/MPLS-VPN-MIB
# Produced by pysmi-1.1.0 at Tue Nov 16 11:27:02 2021
# On host fv-az77-509 platform Linux version 5.11.0-1020-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
experimental, Unsigned32, Integer32, Counter64, Bits, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, TimeTicks, NotificationType, Counter32, iso, IpAddress, ModuleIdentity, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "experimental", "Unsigned32", "Integer32", "Counter64", "Bits", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "TimeTicks", "NotificationType", "Counter32", "iso", "IpAddress", "ModuleIdentity", "ObjectIdentity")
TimeStamp, TextualConvention, DisplayString, RowStatus, TruthValue, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TextualConvention", "DisplayString", "RowStatus", "TruthValue", "StorageType")
mplsVpnMIB = ModuleIdentity((1, 3, 6, 1, 3, 118))
mplsVpnMIB.setRevisions(('2001-10-15 12:00', '2001-10-05 12:00', '2001-07-17 12:00', '2001-07-10 12:00', '2001-06-19 12:00', '2001-05-30 12:00', '2000-09-30 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsVpnMIB.setRevisionsDescriptions(('Fixed compilation errors from last version. \n\n         Changed mplsVpnInterfaceVpnRouteDistProtocol to be a BITS\n         structure to allow more than one to be selected.\n\n         Changed mplsIfDown -> mplsVrfIfDown\n         Changed mplsIfUp -> mplsVrfIfUp\n         ', 'Added integer index and removed route distinguisher index \n         from mplsVpnVrfRouteTargetTable.\n\n         Removed mplsVpn ifType; simply use mpls(166) ifType for\n         MPLS VPN-enabled interfaces instead.\n\n         Removed interface and protocol-related objects from\n         mplsVpnVrfTable.\n\n         Moved mplsVpnVrfConfMaxPossibleRoutes from \n         mplsVpnVrfTable to scalar object.\n\n         Removed mplsVpnActiveVrfInterfaces scalar object.\n         Removed mplsVpnVrfUpTime object from mplsVpnVrfTable.\n\n         Added MplsVpnVrfBgpNbrPrefixTable providing a linkage with\n         the bgp4PathAttrTable of the BGPv4 MIB.', "Removed mplsVpnVrfRouteTargetImport/Export from route target\n         table, and modified indexing to better reflect N <> R\n         distribution policy. Also added new object called\n         mplsVpnVrfRouteTargetType which denotes import/export\n         policy for the specified route target. \n\n         Added mplsVpnInterfaceConfRowStatus which allows for\n         an interface to be associated with a VPN through SNMP\n         configuration.\n\n\n         Added VrfName to index of VrfInterfaceConfEntry which allows\n         interfaces to be associated with the appropriate VRF.\n\n         Modified description of mplsVpnVrfConfMaxPossibleRoutes and\n         mplsVpnVrfConfMaxRoutes to allow for undetermined value.\n\n         Removed 'both' enumerated value in mplsVpnVrfBgpNbrRole.\n\n         Updated example to reflect these changes.", 'Renamed mplsNumVrfSecViolationThreshExceeded to \n         mplsNumVrfSecIllegalLabelThreshExceeded, and removed\n         mplsVpnInterfaceConfIndex from varbind.\n\n         Changed MplsVpnId TC from SnmpAdminString to OCTET STRING.\n\n         Added mplsVpnVrfSecIllegalLabelRcvThresh to \n         mplsVpnVrfSecEntry.\n\n         Changed duplicate mplsVpnVrfRouteTargetImport in \n         mplsVpnVrfRouteTargetEntry INDEX to \n         mplsVpnVrfRouteTargetExport.', 'Fixed several compile errors.', 'Updated most of document and MIB to reflect comments from WG.', 'Initial draft version.',))
if mibBuilder.loadTexts: mplsVpnMIB.setLastUpdated('200110151200Z')
if mibBuilder.loadTexts: mplsVpnMIB.setOrganization('Provider Provisioned Virtual Private\n                 Networks Working Group.')
if mibBuilder.loadTexts: mplsVpnMIB.setContactInfo('        Thomas D. Nadeau\n                   tnadeau@cisco.com\n\n                   Luyuan Fang\n                   luyuanfang@att.com\n\n                   Stephen Brannon\n\n                   Fabio M. Chiussi\n                   fabio@bell-labs.com\n\n                   Joseph Dube\n                   jdube@avici.com\n\n                   Martin Tatham\n                   martin.tatham@bt.com\n\n                   Harmen van der Linde\n                   hvdl@att.com\n\n                   Comments and discussion to ppvpn@ietf.org')
if mibBuilder.loadTexts: mplsVpnMIB.setDescription('This MIB contains managed object definitions for the\n         Multiprotocol Label Switching (MPLS)/Border Gateway\n\n\n         Protocol (BGP) Virtual Private Networks (VPNs) as\n         defined in : Rosen, E., Viswanathan, A., and R.\n         Callon, Multiprotocol Label Switching Architecture,\n         RFC3031, January 2001.')
class MplsVpnId(TextualConvention, OctetString):
    reference = "RFC 2685 [VPN-RFC2685] Fox B., et al, 'Virtual Private\n         Networks Identifier', September 1999."
    description = 'An identifier that is assigned to each MPLS/BGP VPN and\n        is used to uniquely identify it. This is assigned by the\n        system operator or NMS and SHOULD be unique throughout\n\n\n        the MPLS domain. If this is the case, then this identifier\n        can then be used at any LSR within a specific MPLS domain\n        to identify this MPLS/BGP VPN. It may also be possible to\n        preserve the uniqueness of this identifier across MPLS\n        domain boundaries, in which case this identifier can then\n        be used to uniquely identify MPLS/BGP VPNs on a more global\n        basis.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 31)

class MplsVpnRouteDistinguisher(TextualConvention, OctetString):
    description = 'Syntax for a route distinguisher and route target.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 256)

mplsVpnNotifications = MibIdentifier((1, 3, 6, 1, 3, 118, 0))
mplsVpnObjects = MibIdentifier((1, 3, 6, 1, 3, 118, 1))
mplsVpnScalars = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 1))
mplsVpnConf = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 2))
mplsVpnPerf = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 3))
mplsVpnRoute = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 4))
mplsVpnConformance = MibIdentifier((1, 3, 6, 1, 3, 118, 3))
mplsVpnConfiguredVrfs = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnConfiguredVrfs.setStatus('current')
if mibBuilder.loadTexts: mplsVpnConfiguredVrfs.setDescription('The number of VRFs which are configured on this node.')
mplsVpnActiveVrfs = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnActiveVrfs.setStatus('current')
if mibBuilder.loadTexts: mplsVpnActiveVrfs.setDescription('The number of VRFs which are active on this node.\n        That is, those VRFs whose corresponding mplsVpnVrfOperStatus \n        object value is equal to operational (1).')
mplsVpnConnectedInterfaces = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnConnectedInterfaces.setStatus('current')
if mibBuilder.loadTexts: mplsVpnConnectedInterfaces.setDescription('Total number of interfaces connected to a VRF.')
mplsVpnNotificationEnable = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsVpnNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnNotificationEnable.setDescription('If this object is true, then it enables the\n         generation of all notifications defined in \n         this MIB.')
mplsVpnVrfConfMaxPossibleRoutes = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfConfMaxPossibleRoutes.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfMaxPossibleRoutes.setDescription('Denotes maximum number of routes which the device\n      will allow all VRFs jointly to hold. If this value is\n      set to 0, this indicates that the device is \n      unable to determine the absolute maximum. In this\n      case, the configured maximum MAY not actually\n      be allowed by the device.')
mplsVpnInterfaceConfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 1), )
if mibBuilder.loadTexts: mplsVpnInterfaceConfTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceConfTable.setDescription('This table specifies per-interface MPLS capability\n        and associated information.')
mplsVpnInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 1, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnInterfaceConfIndex"))
if mibBuilder.loadTexts: mplsVpnInterfaceConfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceConfEntry.setDescription('An entry in this table is created by an LSR for\n        every interface capable of supporting MPLS/BGP VPN.\n\n\n        Each entry in this table is meant to correspond to\n        an entry in the Interfaces Table.')
mplsVpnInterfaceConfIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: mplsVpnInterfaceConfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2,\n        McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsVpnInterfaceConfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceConfIndex.setDescription('This is a unique index for an entry in the\n        MplsVPNInterfaceConfTable. A non-zero index for an\n        entry indicates the ifIndex for the corresponding\n        interface entry in the MPLS-VPN-layer in the ifTable.\n        Note that this table does not necessarily correspond\n        one-to-one with all entries in the Interface MIB\n        having an ifType of MPLS-layer; rather, only those\n        which are enabled for MPLS/BGP VPN functionality.')
mplsVpnInterfaceLabelEdgeType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("providerEdge", 1), ("customerEdge", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnInterfaceLabelEdgeType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceLabelEdgeType.setDescription('Either the providerEdge(0) (PE) or customerEdge(1)\n       (CE) bit MUST be set.')
mplsVpnInterfaceVpnClassification = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("carrierOfCarrier", 1), ("enterprise", 2), ("interProvider", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnInterfaceVpnClassification.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceVpnClassification.setDescription("Denotes whether this link participates in a\n        carrier-of-carrier's, enterprise, or inter-provider\n        scenario.")
mplsVpnInterfaceVpnRouteDistProtocol = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 4), Bits().clone(namedValues=NamedValues(("dummy", 0), ("none", 1), ("bgp", 2), ("ospf", 3), ("rip", 4), ("isis", 5), ("other", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnInterfaceVpnRouteDistProtocol.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceVpnRouteDistProtocol.setDescription('Denotes the route distribution protocol across the\n        PE-CE link. Note that more than one routing protocol\n        may be enabled at the same time.')
mplsVpnInterfaceConfStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnInterfaceConfStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceConfStorageType.setDescription('The storage type for this entry.')
mplsVpnInterfaceConfRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnInterfaceConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceConfRowStatus.setDescription('The row status for this entry. This value is\n        used to create a row in this table, signifying\n        that the specified interface is to be associated\n        with the specified interface. If this operation\n        succeeds, the interface will have been associated,\n        otherwise the agent would not allow the association. \n        If the agent only allows read-only operations on\n        this table, it will create entries in this table\n        as they are created.')
mplsVpnVrfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 2), )
if mibBuilder.loadTexts: mplsVpnVrfTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfTable.setDescription('This table specifies per-interface MPLS/BGP VPN\n        VRF Table capability and associated information.\n        Entries in this table define VRF routing instances\n        associated with MPLS/VPN interfaces. Note that\n        multiple interfaces can belong to the same VRF\n        instance. The collection of all VRF instances\n        comprises an actual VPN.')
mplsVpnVrfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 2, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"))
if mibBuilder.loadTexts: mplsVpnVrfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfEntry.setDescription('An entry in this table is created by an LSR for\n        every VRF capable of supporting MPLS/BGP VPN. The\n        indexing provides an ordering of VRFs per-VPN\n        interface.')
mplsVpnVrfName = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 1), MplsVpnId())
if mibBuilder.loadTexts: mplsVpnVrfName.setReference('RFC 2685 [VPN-RFC2685] Fox B., et al, `Virtual\n\n\n        Private Networks Identifier`, September 1999.')
if mibBuilder.loadTexts: mplsVpnVrfName.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfName.setDescription('The human-readable name of this VPN. This MAY\n        be equivalent to the RFC2685 VPN-ID.')
mplsVpnVrfDescription = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 2), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfDescription.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfDescription.setDescription('The human-readable description of this VRF.')
mplsVpnVrfRouteDistinguisher = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 3), MplsVpnRouteDistinguisher()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteDistinguisher.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteDistinguisher.setDescription('The route distinguisher for this VRF.')
mplsVpnVrfCreationTime = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfCreationTime.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfCreationTime.setDescription('The time at which this VRF entry was created.')
mplsVpnVrfOperStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfOperStatus.setDescription('Denotes whether a VRF is operational or not. A VRF is \n        up(1) when at least one interface associated with the\n        VRF, which ifOperStatus is up(1). A VRF is down(2) when:\n\n        a. There does not exist at least one interface whose\n           ifOperStatus is up(1).\n\n        b. There are no interfaces associated with the VRF.')
mplsVpnVrfActiveInterfaces = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfActiveInterfaces.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfActiveInterfaces.setDescription('Total number of interfaces connected to this VRF with \n\n\n        ifOperStatus = up(1). \n\n        This counter should be incremented when:\n\n        a. When the ifOperStatus of one of the connected interfaces \n           changes from down(2) to up(1).\n\n        b. When an interface with ifOperStatus = up(1) is connected\n           to this VRF.\n\n        This counter should be decremented when:\n\n        a. When the ifOperStatus of one of the connected interfaces \n           changes from up(1) to down(2).\n\n        b. When one of the connected interfaces with \n           ifOperStatus = up(1) gets disconnected from this VRF.')
mplsVpnVrfAssociatedInterfaces = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfAssociatedInterfaces.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfAssociatedInterfaces.setDescription('Total number of interfaces connected to this VRF \n        (independent of ifOperStatus type).')
mplsVpnVrfConfMidRouteThreshold = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfMidRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfMidRouteThreshold.setDescription('Denotes mid-level water marker for the number\n      of routes which  this VRF may hold.')
mplsVpnVrfConfHighRouteThreshold = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfHighRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfHighRouteThreshold.setDescription('Denotes high-level water marker for the number of\n      routes which  this VRF may hold.')
mplsVpnVrfConfMaxRoutes = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfMaxRoutes.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfMaxRoutes.setDescription('Denotes maximum number of routes which this VRF is\n      configured to hold. This value MUST be less than or\n      equal to mplsVrfMaxPossibleRoutes unless it is set\n      to 0.')
mplsVpnVrfConfLastChanged = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfConfLastChanged.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfLastChanged.setDescription('The value of sysUpTime at the time of the last\n      change of this table entry, which includes changes of\n      VRF parameters defined in this table or addition or\n      deletion of interfaces associated with this VRF.')
mplsVpnVrfConfRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfRowStatus.setDescription('This variable is used to create, modify, and/or\n        delete a row in this table.')
mplsVpnVrfConfStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 13), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfStorageType.setDescription('The storage type for this entry.')
mplsVpnVrfRouteTargetTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 3), )
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetTable.setDescription('This table specifies per-VRF route target association.\n           Each entry identifies a connectivity policy supported\n           as part of a VPN.')
mplsVpnVrfRouteTargetEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 3, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTargetIndex"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTargetType"))
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetEntry.setDescription(' An entry in this table is created by an LSR for\n           each route target configured for a VRF supporting\n           a MPLS/BGP VPN instance. The indexing provides an\n           ordering per-VRF instance.')
mplsVpnVrfRouteTargetIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetIndex.setDescription('Auxiliary index for route-targets configured for a \n           particular VRF.')
mplsVpnVrfRouteTargetType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("import", 1), ("export", 2), ("both", 3))))
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetType.setDescription('The route target export distribution type.')
mplsVpnVrfRouteTarget = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 4), MplsVpnRouteDistinguisher()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTarget.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTarget.setDescription('The route target distribution policy.')
mplsVpnVrfRouteTargetDescr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetDescr.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetDescr.setDescription('Description of the route target.')
mplsVpnVrfRouteTargetRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetRowStatus.setDescription('Row status for this entry.')
mplsVpnVrfBgpNbrAddrTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 4), )
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrTable.setDescription('Each entry in this table specifies a per-interface \n        MPLS/EBGP neighbor.')
mplsVpnVrfBgpNbrAddrEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 4, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnInterfaceConfIndex"), (0, "MPLS-VPN-MIB", "mplsVpnVrfBgpNbrIndex"))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrEntry.setDescription('An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS/BGP VPN. The\n          indexing provides an ordering of VRFs per-VPN\n          interface.')
mplsVpnVrfBgpNbrIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrIndex.setDescription('This is a unique tertiary index for an entry in the\n          MplsVpnVrfBgpNbrAddrEntry Table.')
mplsVpnVrfBgpNbrRole = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ce", 1), ("pe", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRole.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRole.setDescription('Denotes the role played by this EBGP neighbor\n        with respect to this VRF.')
mplsVpnVrfBgpNbrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrType.setDescription('Denotes the address family of the PE address.')
mplsVpnVrfBgpNbrAddr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddr.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddr.setDescription('Denotes the EBGP neighbor address.')
mplsVpnVrfBgpNbrRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRowStatus.setDescription('This variable is used to create, modify, and/or\n        delete a row in this table.')
mplsVpnVrfBgpNbrStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrStorageType.setDescription('The storage type for this entry.')
mplsVpnVrfBgpNbrPrefixTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 5), )
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixTable.setDescription('This table specifies per-VRF vpnv4 multi-protocol\n        prefixes supported by BGP.')
mplsVpnVrfBgpNbrPrefixEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 5, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrIpAddrPrefix"), (0, "MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrIpAddrPrefixLen"), (0, "MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrPeer"))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixEntry.setDescription('An entry in this table is created by an LSR for\n        every BGP prefix associated with a VRF supporting a \n        MPLS/BGP VPN. The indexing provides an ordering of \n        BGP prefixes per VRF.')
mplsVpnVrfBgpPathAttrPeer = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 1), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrPeer.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrPeer.setDescription('The IP address of the peer where the path\n        information was learned.')
mplsVpnVrfBgpPathAttrIpAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32)))
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrIpAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrIpAddrPrefixLen.setDescription('Length in bits of the IP address prefix\n        in the Network Layer Reachability\n        Information field.')
mplsVpnVrfBgpPathAttrIpAddrPrefix = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 3), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrIpAddrPrefix.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrIpAddrPrefix.setDescription('An IP address prefix in the Network Layer\n        Reachability Information field.  This object\n        is an IP address containing the prefix with\n        length specified by mplsVpnVrfBgpPathAttrIpAddrPrefixLen.\n        Any bits beyond the length specified by\n        mplsVpnVrfBgpPathAttrIpAddrPrefixLen are zeroed.')
mplsVpnVrfBgpPathAttrOrigin = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrOrigin.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrOrigin.setDescription('The ultimate origin of the path\n        information.')
mplsVpnVrfBgpPathAttrASPathSegment = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrASPathSegment.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrASPathSegment.setDescription('The sequence of AS path segments.  Each AS\n         path segment is represented by a triple\n         <type, length, value>.\n\n          The type is a 1-octet field which has two\n          possible values:\n              1      AS_SET: unordered set of ASs a\n                     route in the UPDATE\n                     message has traversed\n              2      AS_SEQUENCE: ordered set of ASs\n                     a route in the UPDATE\n                     message has traversed.\n                     The length is a 1-octet field containing the\n\n\n                     number of ASs in the value field.\n\n                     The value field contains one or more AS\n                     numbers, each AS is represented in the octet\n                     string as a pair of octets according to the\n                     following algorithm:\n\n                     first-byte-of-pair = ASNumber / 256;\n                     second-byte-of-pair = ASNumber & 255;')
mplsVpnVrfBgpPathAttrNextHop = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrNextHop.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrNextHop.setDescription('The address of the border router that\n         should be used for the destination\n         network.')
mplsVpnVrfBgpPathAttrMultiExitDisc = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrMultiExitDisc.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrMultiExitDisc.setDescription('This metric is used to discriminate\n         between multiple exit points to an\n         adjacent autonomous system.  A value of -1\n         indicates the absence of this attribute.')
mplsVpnVrfBgpPathAttrLocalPref = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrLocalPref.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrLocalPref.setDescription("The originating BGP4 speaker's degree of\n            preference for an advertised route.  A\n            value of -1 indicates the absence of this\n            attribute.")
mplsVpnVrfBgpPathAttrAtomicAggregate = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lessSpecificRrouteNotSelected", 1), ("lessSpecificRouteSelected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrAtomicAggregate.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrAtomicAggregate.setDescription('Whether or not the local system has\n              selected a less specific route without\n              selecting a more specific route.')
mplsVpnVrfBgpPathAttrAggregatorAS = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrAggregatorAS.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrAggregatorAS.setDescription('The AS number of the last BGP4 speaker that\n              performed route aggregation.  A value of\n              zero (0) indicates the absence of this\n              attribute.')
mplsVpnVrfBgpPathAttrAggregatorAddr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 11), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrAggregatorAddr.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrAggregatorAddr.setDescription('The IP address of the last BGP4 speaker\n             that performed route aggregation.  A value\n             of 0.0.0.0 indicates the absence of this\n             attribute.')
mplsVpnVrfBgpPathAttrCalcLocalPref = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrCalcLocalPref.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrCalcLocalPref.setDescription('The degree of preference calculated by the\n             receiving BGP4 speaker for an advertised\n             route.  A value of -1 indicates the\n             absence of this attribute.')
mplsVpnVrfBgpPathAttrBest = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrBest.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrBest.setDescription('An indication of whether or not this route\n             was chosen as the best BGP4 route.')
mplsVpnVrfBgpPathAttrUnknown = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrUnknown.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPathAttrUnknown.setDescription('One or more path attributes not understood\n             by this BGP4 speaker.  Size zero (0)\n             indicates the absence of such\n             attribute(s).  Octets beyond the maximum\n             size, if any, are not recorded by this\n             object.')
mplsVpnVrfSecTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 6), )
if mibBuilder.loadTexts: mplsVpnVrfSecTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecTable.setDescription('This table specifies per MPLS/BGP VPN VRF Table security\n        features.')
mplsVpnVrfSecEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 6, 1), )
mplsVpnVrfEntry.registerAugmentions(("MPLS-VPN-MIB", "mplsVpnVrfSecEntry"))
mplsVpnVrfSecEntry.setIndexNames(*mplsVpnVrfEntry.getIndexNames())
if mibBuilder.loadTexts: mplsVpnVrfSecEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecEntry.setDescription('An entry in this table is created by an LSR for\n        every VRF capable of supporting MPLS/BGP VPN. Each\n        entry in this table is used to indicate security-related\n        information for each VRF entry.')
mplsVpnVrfSecIllegalLabelViolations = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLabelViolations.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLabelViolations.setDescription('Indicates the number of illegally received labels on this VPN/VRF.')
mplsVpnVrfSecIllegalLabelRcvThresh = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 6, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLabelRcvThresh.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLabelRcvThresh.setDescription('The number of illegally received labels above which this \n        notification is issued.')
mplsVpnVrfPerfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 3, 1), )
if mibBuilder.loadTexts: mplsVpnVrfPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfTable.setDescription('This table specifies per MPLS/BGP VPN VRF Table performance\n        information.')
mplsVpnVrfPerfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 3, 1, 1), )
mplsVpnVrfEntry.registerAugmentions(("MPLS-VPN-MIB", "mplsVpnVrfPerfEntry"))
mplsVpnVrfPerfEntry.setIndexNames(*mplsVpnVrfEntry.getIndexNames())
if mibBuilder.loadTexts: mplsVpnVrfPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfEntry.setDescription('An entry in this table is created by an LSR for\n        every VRF capable of supporting MPLS/BGP VPN.')
mplsVpnVrfPerfRoutesAdded = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesAdded.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesAdded.setDescription('Indicates the number of routes added to this VPN/VRF over the\n        coarse of its lifetime.')
mplsVpnVrfPerfRoutesDeleted = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesDeleted.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesDeleted.setDescription('Indicates the number of routes removed from this VPN/VRF.')
mplsVpnVrfPerfCurrNumRoutes = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfCurrNumRoutes.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfCurrNumRoutes.setDescription('Indicates the number of routes currently used by this VRF.')
mplsVpnVrfRouteTable = MibTable((1, 3, 6, 1, 3, 118, 1, 4, 1), )
if mibBuilder.loadTexts: mplsVpnVrfRouteTable.setReference('1.  RFC 1213 Section 6.6, The IP Group.\n        2.  RFC 2096 ')
if mibBuilder.loadTexts: mplsVpnVrfRouteTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTable.setDescription('This table specifies per-interface MPLS/BGP VPN VRF Table\n        routing information. Entries in this table define VRF routing\n        entries associated with the specified MPLS/VPN interfaces. Note\n        that this table contains both BGP and IGP routes, as both may\n        appear in the same VRF.')
mplsVpnVrfRouteEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 4, 1, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteDest"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteMask"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTos"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteNextHop"))
if mibBuilder.loadTexts: mplsVpnVrfRouteEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteEntry.setDescription('An entry in this table is created by an LSR for every route\n        present configured (either dynamically or statically) within\n        the context of a specific VRF capable of supporting MPLS/BGP\n        VPN. The indexing provides an ordering of VRFs per-VPN\n        interface.')
mplsVpnVrfRouteDest = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 1), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfRouteDest.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteDest.setDescription('The destination IP address of this route.\n           This object may not take a Multicast (Class D)\n           address value.\n\n           Any assignment (implicit or otherwise) of an\n           instance of this object to a value x must be\n           rejected if the bit-wise logical-AND of x with\n           the value of the corresponding instance of the\n           mplsVpnVrfRouteMask object is not equal to x.')
mplsVpnVrfRouteDestAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteDestAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteDestAddrType.setDescription('The address type of the mplsVpnVrfRouteDest\n           entry.')
mplsVpnVrfRouteMask = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 3), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfRouteMask.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMask.setDescription('Indicate the mask to be logical-ANDed with the\n           destination  address  before  being compared to\n           the value  in  the  mplsVpnVrfRouteDest field.\n           For those  systems  that  do  not support\n           arbitrary subnet masks, an agent constructs the\n           value of the mplsVpnVrfRouteMask by reference\n\n\n           to the IP Address Class.\n\n           Any assignment (implicit or otherwise) of an\n           instance of this object to a value x must be\n           rejected if the bit-wise logical-AND of x with\n           the value of the corresponding instance of the\n           mplsVpnVrfRouteDest object is not equal to\n           mplsVpnVrfRouteDest.')
mplsVpnVrfRouteMaskAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMaskAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMaskAddrType.setDescription('The address type of mplsVpnVrfRouteMask.')
mplsVpnVrfRouteTos = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 5), Unsigned32())
if mibBuilder.loadTexts: mplsVpnVrfRouteTos.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTos.setDescription('The IP TOS Field is used to specify the policy to\n          be applied to this route.  The encoding of IP TOS\n          is as specified  by  the  following convention.\n          Zero indicates the default path if no more\n          specific policy applies.\n\n          +-----+-----+-----+-----+-----+-----+-----+-----+\n          |                 |                       |     |\n          |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |\n          |                 |                       |     |\n          +-----+-----+-----+-----+-----+-----+-----+-----+\n\n                     IP TOS                IP TOS\n                Field     Policy      Field     Policy\n                Contents    Code      Contents    Code\n                0 0 0 0  ==>   0      0 0 0 1  ==>   2\n                0 0 1 0  ==>   4      0 0 1 1  ==>   6\n                0 1 0 0  ==>   8      0 1 0 1  ==>  10\n                0 1 1 0  ==>  12      0 1 1 1  ==>  14\n                1 0 0 0  ==>  16      1 0 0 1  ==>  18\n                1 0 1 0  ==>  20      1 0 1 1  ==>  22\n                1 1 0 0  ==>  24      1 1 0 1  ==>  26\n                1 1 1 0  ==>  28      1 1 1 1  ==>  30.')
mplsVpnVrfRouteNextHop = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 6), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHop.setDescription('On remote routes, the address of the next\n           system en route; Otherwise, 0.0.0.0. .')
mplsVpnVrfRouteNextHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 7), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAddrType.setDescription('The address type of the mplsVpnVrfRouteNextHopAddrType\n           object.')
mplsVpnVrfRouteIfIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 8), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteIfIndex.setDescription('The ifIndex value that identifies the local\n           interface  through  which  the next hop of this\n           route should be reached.')
mplsVpnVrfRouteType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteType.setDescription('The type of route.  Note that local(3)  refers\n           to a route for which the next hop is the final\n           destination; remote(4) refers to a route for\n           that the next  hop is not the final destination.\n           Routes which do not result in traffic forwarding or\n           rejection should not be displayed even if the\n           implementation keeps them stored internally.\n\n           reject (2) refers to a route which, if matched,\n           discards the message as unreachable. This is used\n           in some protocols as a means of correctly aggregating\n           routes.')
mplsVpnVrfRouteProto = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("ciscoEigrp", 16)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteProto.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteProto.setDescription('The routing mechanism via which this route was\n           learned.  Inclusion of values for gateway rout-\n           ing protocols is not  intended  to  imply  that\n           hosts should support those protocols.')
mplsVpnVrfRouteAge = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfRouteAge.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteAge.setDescription("The number of seconds since this route was\n           last updated or otherwise determined to be\n           correct. Note that no semantics of `too old'\n           can be implied except through knowledge of the\n           routing protocol by which the route was\n           learned.")
mplsVpnVrfRouteInfo = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 12), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteInfo.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteInfo.setDescription("A reference to MIB definitions specific to the\n           particular routing protocol which is responsi-\n\n\n           ble for this route, as determined by the  value\n           specified  in the route's mplsVpnVrfRouteProto\n           value. If this information is not present, its\n           value SHOULD be set to the OBJECT IDENTIFIER\n           { 0 0 }, which is a syntactically valid object\n           identif-ier, and any implementation conforming\n           to ASN.1 and the Basic Encoding Rules must be\n           able to generate and recognize this value.")
mplsVpnVrfRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 13), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAS.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop.\n           The semantics of this object are determined by\n           the routing-protocol specified in the route's\n           mplsVpnVrfRouteProto value. When this object is\n           unknown or not relevant its value should be set\n           to zero.")
mplsVpnVrfRouteMetric1 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric1.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric1.setDescription("The primary routing metric for this route.\n           The semantics of this metric are determined by\n           the routing-protocol specified in  the  route's\n           mplsVpnVrfRouteProto value. If this metric is not\n           used, its value should be set to -1.")
mplsVpnVrfRouteMetric2 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric2.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric2.setDescription("An alternate routing metric for this route.\n           The semantics of this metric are determined by\n           the routing-protocol specified in  the  route's\n           mplsVpnVrfRouteProto value. If this metric is not\n           used, its value should be set to -1.")
mplsVpnVrfRouteMetric3 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric3.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric3.setDescription("An alternate routing metric for this route.\n           The semantics of this metric are determined by\n           the routing-protocol specified in  the  route's\n           mplsVpnVrfRouteProto value. If this metric is not\n           used, its value should be set to -1.")
mplsVpnVrfRouteMetric4 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric4.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric4.setDescription("An alternate routing metric for this route.\n           The semantics of this metric are determined by\n           the routing-protocol specified in  the  route's\n           mplsVpnVrfRouteProto value. If this metric is not\n           used, its value should be set to -1.")
mplsVpnVrfRouteMetric5 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric5.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric5.setDescription("An alternate routing metric for this route.\n           The semantics of this metric are determined by\n           the routing-protocol specified in  the  route's\n           mplsVpnVrfRouteProto value. If this metric is not\n           used, its value should be set to -1.")
mplsVpnVrfRouteRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteRowStatus.setDescription('Row status for this table. It is used according\n           to row installation and removal conventions.')
mplsVpnVrfRouteStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 20), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteStorageType.setDescription('Storage type value.')
mplsVrfIfUp = NotificationType((1, 3, 6, 1, 3, 118, 0, 1))
if mibBuilder.loadTexts: mplsVrfIfUp.setStatus('current')
if mibBuilder.loadTexts: mplsVrfIfUp.setDescription('This notification is generated when:\n        a. The ifOperStatus of an interface associated with a VRF \n           changes to the up(1) state.\n        b. When an interface with ifOperStatus = up(1) is \n           associated with a VRF.')
mplsVrfIfDown = NotificationType((1, 3, 6, 1, 3, 118, 0, 2))
if mibBuilder.loadTexts: mplsVrfIfDown.setStatus('current')
if mibBuilder.loadTexts: mplsVrfIfDown.setDescription('This notification is generated when:\n        a. The ifOperStatus of an interface associated with a VRF \n           changes to the down(1) state.\n        b. When an interface with ifOperStatus = up(1) state is \n           disassociated with a VRF.')
mplsNumVrfRouteMidThreshExceeded = NotificationType((1, 3, 6, 1, 3, 118, 0, 3))
if mibBuilder.loadTexts: mplsNumVrfRouteMidThreshExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsNumVrfRouteMidThreshExceeded.setDescription('This notification is generated when the number of routes\n        contained by the specified VRF exceeds the value indicated by\n        mplsVrfMidRouteThreshold.')
mplsNumVrfRouteMaxThreshExceeded = NotificationType((1, 3, 6, 1, 3, 118, 0, 4))
if mibBuilder.loadTexts: mplsNumVrfRouteMaxThreshExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsNumVrfRouteMaxThreshExceeded.setDescription('This notification is generated when the number of routes\n        contained by the specified VRF reaches or attempts to exceed\n        the maximum allowed value as indicated by\n        mplsVrfMaxRouteThreshold.')
mplsNumVrfSecIllegalLabelThreshExceeded = NotificationType((1, 3, 6, 1, 3, 118, 0, 5))
if mibBuilder.loadTexts: mplsNumVrfSecIllegalLabelThreshExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsNumVrfSecIllegalLabelThreshExceeded.setDescription('This notification is generated when the number of illegal\n        label violations on a VRF as indicated by \n        mplsVpnVrfSecIllegalLabelViolations has exceeded \n        mplsVpnVrfSecIllegalLabelRcvThresh. The threshold is not \n        included in the varbind here because the value of \n        mplsVpnVrfSecIllegalLabelViolations should be one greater than \n        the threshold at the time this notification is issued.')
mplsVpnGroups = MibIdentifier((1, 3, 6, 1, 3, 118, 3, 1))
mplsVpnCompliances = MibIdentifier((1, 3, 6, 1, 3, 118, 3, 2))
mplsVpnModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 118, 3, 2, 1)).setObjects(("MPLS-VPN-MIB", "mplsVpnScalarGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfGroup"), ("MPLS-VPN-MIB", "mplsVpnInterfaceGroup"), ("MPLS-VPN-MIB", "mplsVpnPerfGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnModuleCompliance = mplsVpnModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsVpnModuleCompliance.setDescription('Compliance statement for agents that support the\n           MPLS VPN MIB.')
mplsVpnScalarGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 1)).setObjects(("MPLS-VPN-MIB", "mplsVpnConfiguredVrfs"), ("MPLS-VPN-MIB", "mplsVpnActiveVrfs"), ("MPLS-VPN-MIB", "mplsVpnConnectedInterfaces"), ("MPLS-VPN-MIB", "mplsVpnNotificationEnable"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMaxPossibleRoutes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnScalarGroup = mplsVpnScalarGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnScalarGroup.setDescription('Collection of scalar objects required for MPLS VPN\n              management.')
mplsVpnVrfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 2)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfDescription"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteDistinguisher"), ("MPLS-VPN-MIB", "mplsVpnVrfCreationTime"), ("MPLS-VPN-MIB", "mplsVpnVrfOperStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfActiveInterfaces"), ("MPLS-VPN-MIB", "mplsVpnVrfAssociatedInterfaces"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMidRouteThreshold"), ("MPLS-VPN-MIB", "mplsVpnVrfConfHighRouteThreshold"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMaxRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfConfLastChanged"), ("MPLS-VPN-MIB", "mplsVpnVrfConfRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfConfStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfGroup = mplsVpnVrfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfGroup.setDescription('Collection of objects needed for MPLS VPN VRF\n              management.')
mplsVpnInterfaceGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 3)).setObjects(("MPLS-VPN-MIB", "mplsVpnInterfaceLabelEdgeType"), ("MPLS-VPN-MIB", "mplsVpnInterfaceVpnClassification"), ("MPLS-VPN-MIB", "mplsVpnInterfaceVpnRouteDistProtocol"), ("MPLS-VPN-MIB", "mplsVpnInterfaceConfStorageType"), ("MPLS-VPN-MIB", "mplsVpnInterfaceConfRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnInterfaceGroup = mplsVpnInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnInterfaceGroup.setDescription('Collection of objects needed for MPLS VPN interface\n              management.')
mplsVpnPerfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 4)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfPerfRoutesAdded"), ("MPLS-VPN-MIB", "mplsVpnVrfPerfRoutesDeleted"), ("MPLS-VPN-MIB", "mplsVpnVrfPerfCurrNumRoutes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnPerfGroup = mplsVpnPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnPerfGroup.setDescription('Collection of objects needed for MPLS VPN\n              performance information.')
mplsVpnVrfBgpNbrGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 5)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrRole"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrType"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrAddr"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfBgpNbrGroup = mplsVpnVrfBgpNbrGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrGroup.setDescription('Collection of objects needed for MPLS VPN\n              bgp neighbor-related information.')
mplsVpnVrfBgpPrefixGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 6)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrOrigin"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrASPathSegment"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrNextHop"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrMultiExitDisc"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrLocalPref"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrAtomicAggregate"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrAggregatorAS"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrAggregatorAddr"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrCalcLocalPref"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrBest"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPathAttrUnknown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfBgpPrefixGroup = mplsVpnVrfBgpPrefixGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPrefixGroup.setDescription('Collection of objects needed for MPLS VPN\n              bgp neighbor-related information.')
mplsVpnSecGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 7)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLabelViolations"), ("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLabelRcvThresh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnSecGroup = mplsVpnSecGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnSecGroup.setDescription('Collection of objects needed for MPLS VPN\n              security-related information.')
mplsVpnVrfRouteGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 8)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfRouteDestAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMaskAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHopAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteIfIndex"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteProto"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteAge"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteInfo"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHopAS"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric1"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric2"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric3"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric4"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric5"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfRouteGroup = mplsVpnVrfRouteGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteGroup.setDescription('Objects required for VRF route table management.')
mplsVpnVrfRouteTargetGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 9)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfRouteTarget"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetDescr"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfRouteTargetGroup = mplsVpnVrfRouteTargetGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetGroup.setDescription('Objects required for VRF route target management.')
mplsVpnNotificationGroup = NotificationGroup((1, 3, 6, 1, 3, 118, 3, 1, 10)).setObjects(("MPLS-VPN-MIB", "mplsVrfIfUp"), ("MPLS-VPN-MIB", "mplsVrfIfDown"), ("MPLS-VPN-MIB", "mplsNumVrfRouteMidThreshExceeded"), ("MPLS-VPN-MIB", "mplsNumVrfRouteMaxThreshExceeded"), ("MPLS-VPN-MIB", "mplsNumVrfSecIllegalLabelThreshExceeded"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnNotificationGroup = mplsVpnNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnNotificationGroup.setDescription('Objects required for MPLS VPN notifications.')
mibBuilder.exportSymbols("MPLS-VPN-MIB", mplsVpnVrfName=mplsVpnVrfName, mplsVpnVrfRouteTable=mplsVpnVrfRouteTable, mplsVpnVrfRouteTargetRowStatus=mplsVpnVrfRouteTargetRowStatus, mplsVpnVrfRouteDest=mplsVpnVrfRouteDest, MplsVpnRouteDistinguisher=MplsVpnRouteDistinguisher, mplsVpnVrfBgpPathAttrAtomicAggregate=mplsVpnVrfBgpPathAttrAtomicAggregate, mplsVpnVrfPerfRoutesAdded=mplsVpnVrfPerfRoutesAdded, mplsVpnSecGroup=mplsVpnSecGroup, mplsVpnNotifications=mplsVpnNotifications, mplsVpnVrfPerfRoutesDeleted=mplsVpnVrfPerfRoutesDeleted, mplsVpnVrfRouteTarget=mplsVpnVrfRouteTarget, mplsVpnVrfRouteNextHop=mplsVpnVrfRouteNextHop, mplsVpnObjects=mplsVpnObjects, mplsVpnMIB=mplsVpnMIB, mplsVpnVrfRouteDistinguisher=mplsVpnVrfRouteDistinguisher, mplsVpnConf=mplsVpnConf, mplsVpnVrfBgpPathAttrNextHop=mplsVpnVrfBgpPathAttrNextHop, mplsVpnVrfRouteStorageType=mplsVpnVrfRouteStorageType, mplsVpnVrfBgpPathAttrIpAddrPrefix=mplsVpnVrfBgpPathAttrIpAddrPrefix, mplsVpnVrfRouteProto=mplsVpnVrfRouteProto, mplsVpnVrfRouteNextHopAS=mplsVpnVrfRouteNextHopAS, mplsVpnVrfRouteMask=mplsVpnVrfRouteMask, mplsVrfIfUp=mplsVrfIfUp, mplsVpnInterfaceConfIndex=mplsVpnInterfaceConfIndex, mplsVpnVrfConfRowStatus=mplsVpnVrfConfRowStatus, mplsVpnVrfBgpNbrAddrEntry=mplsVpnVrfBgpNbrAddrEntry, mplsVpnVrfRouteRowStatus=mplsVpnVrfRouteRowStatus, mplsVpnVrfEntry=mplsVpnVrfEntry, mplsVpnVrfRouteTos=mplsVpnVrfRouteTos, mplsVpnVrfRouteMetric2=mplsVpnVrfRouteMetric2, mplsVpnVrfRouteMetric5=mplsVpnVrfRouteMetric5, mplsVpnInterfaceConfEntry=mplsVpnInterfaceConfEntry, mplsVpnVrfPerfEntry=mplsVpnVrfPerfEntry, mplsVpnVrfBgpPathAttrPeer=mplsVpnVrfBgpPathAttrPeer, mplsVpnVrfRouteMetric1=mplsVpnVrfRouteMetric1, mplsVpnVrfConfLastChanged=mplsVpnVrfConfLastChanged, mplsVpnVrfRouteTargetIndex=mplsVpnVrfRouteTargetIndex, mplsVpnVrfBgpPathAttrUnknown=mplsVpnVrfBgpPathAttrUnknown, mplsVpnVrfBgpPathAttrAggregatorAddr=mplsVpnVrfBgpPathAttrAggregatorAddr, mplsVpnConfiguredVrfs=mplsVpnConfiguredVrfs, mplsVpnVrfConfMaxPossibleRoutes=mplsVpnVrfConfMaxPossibleRoutes, mplsVpnVrfBgpNbrStorageType=mplsVpnVrfBgpNbrStorageType, mplsVpnVrfBgpPathAttrBest=mplsVpnVrfBgpPathAttrBest, mplsVpnVrfPerfCurrNumRoutes=mplsVpnVrfPerfCurrNumRoutes, mplsVpnInterfaceVpnClassification=mplsVpnInterfaceVpnClassification, mplsVpnVrfBgpPrefixGroup=mplsVpnVrfBgpPrefixGroup, mplsVpnVrfRouteTargetType=mplsVpnVrfRouteTargetType, mplsVpnVrfBgpPathAttrMultiExitDisc=mplsVpnVrfBgpPathAttrMultiExitDisc, mplsVpnVrfRouteGroup=mplsVpnVrfRouteGroup, mplsVpnVrfRouteTargetDescr=mplsVpnVrfRouteTargetDescr, mplsVpnGroups=mplsVpnGroups, mplsVpnVrfTable=mplsVpnVrfTable, mplsVpnActiveVrfs=mplsVpnActiveVrfs, mplsVpnVrfDescription=mplsVpnVrfDescription, mplsVpnPerf=mplsVpnPerf, mplsVpnVrfRouteDestAddrType=mplsVpnVrfRouteDestAddrType, mplsVpnInterfaceVpnRouteDistProtocol=mplsVpnInterfaceVpnRouteDistProtocol, MplsVpnId=MplsVpnId, mplsVpnVrfRouteIfIndex=mplsVpnVrfRouteIfIndex, mplsVpnVrfBgpNbrPrefixTable=mplsVpnVrfBgpNbrPrefixTable, mplsVpnVrfRouteTargetEntry=mplsVpnVrfRouteTargetEntry, mplsVpnVrfBgpNbrRowStatus=mplsVpnVrfBgpNbrRowStatus, mplsVpnInterfaceConfStorageType=mplsVpnInterfaceConfStorageType, mplsVpnVrfPerfTable=mplsVpnVrfPerfTable, mplsVpnVrfRouteAge=mplsVpnVrfRouteAge, mplsVpnVrfConfStorageType=mplsVpnVrfConfStorageType, mplsVpnVrfConfMaxRoutes=mplsVpnVrfConfMaxRoutes, mplsVpnVrfRouteNextHopAddrType=mplsVpnVrfRouteNextHopAddrType, mplsNumVrfSecIllegalLabelThreshExceeded=mplsNumVrfSecIllegalLabelThreshExceeded, mplsVpnVrfRouteMaskAddrType=mplsVpnVrfRouteMaskAddrType, mplsVpnVrfBgpNbrAddrTable=mplsVpnVrfBgpNbrAddrTable, mplsVpnVrfBgpPathAttrLocalPref=mplsVpnVrfBgpPathAttrLocalPref, mplsVpnVrfCreationTime=mplsVpnVrfCreationTime, mplsVpnInterfaceLabelEdgeType=mplsVpnInterfaceLabelEdgeType, mplsVpnVrfRouteMetric4=mplsVpnVrfRouteMetric4, mplsVpnVrfBgpPathAttrIpAddrPrefixLen=mplsVpnVrfBgpPathAttrIpAddrPrefixLen, mplsVpnVrfBgpNbrPrefixEntry=mplsVpnVrfBgpNbrPrefixEntry, mplsVrfIfDown=mplsVrfIfDown, mplsVpnVrfGroup=mplsVpnVrfGroup, mplsVpnVrfBgpNbrType=mplsVpnVrfBgpNbrType, mplsVpnVrfBgpNbrAddr=mplsVpnVrfBgpNbrAddr, mplsVpnPerfGroup=mplsVpnPerfGroup, mplsVpnNotificationGroup=mplsVpnNotificationGroup, mplsVpnVrfRouteType=mplsVpnVrfRouteType, mplsVpnVrfBgpPathAttrOrigin=mplsVpnVrfBgpPathAttrOrigin, mplsVpnVrfBgpNbrIndex=mplsVpnVrfBgpNbrIndex, mplsVpnModuleCompliance=mplsVpnModuleCompliance, mplsVpnVrfSecIllegalLabelRcvThresh=mplsVpnVrfSecIllegalLabelRcvThresh, mplsVpnScalars=mplsVpnScalars, mplsVpnVrfRouteTargetGroup=mplsVpnVrfRouteTargetGroup, mplsVpnCompliances=mplsVpnCompliances, mplsVpnVrfBgpPathAttrASPathSegment=mplsVpnVrfBgpPathAttrASPathSegment, mplsVpnVrfSecTable=mplsVpnVrfSecTable, mplsVpnVrfAssociatedInterfaces=mplsVpnVrfAssociatedInterfaces, PYSNMP_MODULE_ID=mplsVpnMIB, mplsVpnVrfRouteMetric3=mplsVpnVrfRouteMetric3, mplsNumVrfRouteMaxThreshExceeded=mplsNumVrfRouteMaxThreshExceeded, mplsVpnVrfSecIllegalLabelViolations=mplsVpnVrfSecIllegalLabelViolations, mplsVpnInterfaceConfTable=mplsVpnInterfaceConfTable, mplsVpnConnectedInterfaces=mplsVpnConnectedInterfaces, mplsVpnVrfConfHighRouteThreshold=mplsVpnVrfConfHighRouteThreshold, mplsNumVrfRouteMidThreshExceeded=mplsNumVrfRouteMidThreshExceeded, mplsVpnInterfaceConfRowStatus=mplsVpnInterfaceConfRowStatus, mplsVpnNotificationEnable=mplsVpnNotificationEnable, mplsVpnVrfRouteTargetTable=mplsVpnVrfRouteTargetTable, mplsVpnVrfBgpNbrGroup=mplsVpnVrfBgpNbrGroup, mplsVpnRoute=mplsVpnRoute, mplsVpnVrfBgpNbrRole=mplsVpnVrfBgpNbrRole, mplsVpnScalarGroup=mplsVpnScalarGroup, mplsVpnVrfActiveInterfaces=mplsVpnVrfActiveInterfaces, mplsVpnVrfRouteEntry=mplsVpnVrfRouteEntry, mplsVpnConformance=mplsVpnConformance, mplsVpnVrfBgpPathAttrCalcLocalPref=mplsVpnVrfBgpPathAttrCalcLocalPref, mplsVpnInterfaceGroup=mplsVpnInterfaceGroup, mplsVpnVrfConfMidRouteThreshold=mplsVpnVrfConfMidRouteThreshold, mplsVpnVrfSecEntry=mplsVpnVrfSecEntry, mplsVpnVrfRouteInfo=mplsVpnVrfRouteInfo, mplsVpnVrfOperStatus=mplsVpnVrfOperStatus, mplsVpnVrfBgpPathAttrAggregatorAS=mplsVpnVrfBgpPathAttrAggregatorAS)
