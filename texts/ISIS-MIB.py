#
# PySNMP MIB module ISIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/ISIS-MIB
# Produced by pysmi-1.1.0 at Mon Nov 15 18:14:10 2021
# On host fv-az36-522 platform Linux version 5.11.0-1020-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
IndexInteger, IndexIntegerNextFree = mibBuilder.importSymbols("DIFFSERV-MIB", "IndexInteger", "IndexIntegerNextFree")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddressPrefixLength, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Counter32, Gauge32, MibIdentifier, iso, TimeTicks, Counter64, ObjectIdentity, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, NotificationType, Integer32, Unsigned32, mib_2, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "MibIdentifier", "iso", "TimeTicks", "Counter64", "ObjectIdentity", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "NotificationType", "Integer32", "Unsigned32", "mib-2", "ModuleIdentity")
RowStatus, TextualConvention, TruthValue, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "DisplayString", "TimeStamp")
isisMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 138))
isisMIB.setRevisions(('2006-04-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: isisMIB.setRevisionsDescriptions(('Initial version, published as RFC 4444.',))
if mibBuilder.loadTexts: isisMIB.setLastUpdated('200604040000Z')
if mibBuilder.loadTexts: isisMIB.setOrganization('IETF IS-IS for IP Internets Working Group')
if mibBuilder.loadTexts: isisMIB.setContactInfo('IS-IS for IP Internets working Group\n             http://www.ietf.org/html.charters/isis-charter.html\n             isis-wg@ietf.org\n\n             Jeff Parker\n             Department of Computer Science\n             Middlebury College,\n             Middlebury, Vermont 05753\n             jeffp at middlbury dot edu')
if mibBuilder.loadTexts: isisMIB.setDescription('This document describes a management information base for\n             the IS-IS Routing protocol, as described in ISO 10589,\n             when it is used to construct routing tables for IP\n             networks, as described in RFC 1195.\n\n             This document is based on a 1994 IETF document by Chris\n             Gunner.  This version has been modified to include\n             current syntax, to exclude portions of the protocol that\n             are not relevant to IP, and to add management support for\n             current practice.\n\n\n\n\n\n\n             Copyright (C) The Internet Society (2006).  This version\n             of this MIB module is part of RFC 4444; see the RFC\n             itself for full legal notices.')
isisNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 0))
isisObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1))
isisConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 2))
isisSystem = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 1))
isisSysLevel = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 2))
isisCirc = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 3))
isisCircLevelValues = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 4))
isisCounters = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 5))
isisISAdj = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 6))
isisReachAddr = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 7))
isisIPReachAddr = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 8))
isisLSPDataBase = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 9))
isisNotification = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 10))
class IsisOSINSAddress(TextualConvention, OctetString):
    description = 'OSI Network Service Address, e.g., NSAP, SNPA, or Network\n             Entity Title'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 20)

class IsisSystemID(TextualConvention, OctetString):
    reference = '{ISIS.aoi systemId (119)}'
    description = 'The ID for an Intermediate System.  This should\n             be unique within a network, and is included\n             in all PDUs originated by an Intermediate System.\n             The protocol does not place any meanings upon\n             the bits, other than using ordering to break\n             ties in electing a Designated IS on a LAN.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class IsisLinkStatePDUID(TextualConvention, OctetString):
    reference = '{See section 9.8 of ISO 10589}'
    description = 'The 8-byte Link State PDU (LSP) ID,\n             consisting of the 6-byte SystemID of the\n             originating IS; a one-byte PseudoNode ID,\n             which is 0 unless the LSP represents the\n             topology of a LAN; and a one-byte LSP\n             fragment number that is issued in sequence,\n             starting with 0.  Non-zero PseudoNode IDs\n             need to be unique to the IS but need not\n             match the IfIndex.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class IsisAdminState(TextualConvention, Integer32):
    description = 'Type used in enabling and disabling a row.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("on", 1), ("off", 2))

class IsisLSPBuffSize(TextualConvention, Unsigned32):
    description = 'Integer sub-range for maximum LSP size.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(512, 16000)

class IsisLevelState(TextualConvention, Integer32):
    description = 'States of the IS-IS protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("off", 1), ("on", 2), ("waiting", 3), ("overloaded", 4))

class IsisSupportedProtocol(TextualConvention, Integer32):
    reference = '{See section 5.3.1 of RFC 1195}'
    description = 'Types of network protocol supported by Integrated IS-IS.\n             The values for ISO8473 and IP are those registered for\n             these protocols in ISO TR9577.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(129, 142, 204))
    namedValues = NamedValues(("iso8473", 129), ("ipV6", 142), ("ip", 204))

class IsisDefaultMetric(TextualConvention, Unsigned32):
    reference = '{See section 7.2.2 of ISO 10589}'
    description = "Integer sub-range for default metric for single hop.\n             ISO 10589 provides for 4 types of metric.  Only the\n             'default' metric is used in practice."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 63)

class IsisWideMetric(TextualConvention, Unsigned32):
    reference = '{See section 3 of RFC 3784}'
    description = 'Wide metric for IS Neighbors.  ISO 10589 provides a\n             6-bit metric.  Traffic Engineering extensions provide\n             24-bit metrics.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 16777215)

class IsisFullMetric(TextualConvention, Unsigned32):
    reference = '{See section 4 of RFC 3784}'
    description = 'Full metric for IP Routes.  Traffic Engineering extensions\n             provide 32-bit metrics.'
    status = 'current'
    displayHint = 'd'

class IsisMetricType(TextualConvention, Integer32):
    reference = '{See section 7.2.2 of ISO 10589}'
    description = 'Is this an Internal or External Metric?'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("internal", 1), ("external", 2))

class IsisMetricStyle(TextualConvention, Integer32):
    reference = '{See section 5 of RFC 3787}'
    description = 'Do we use RFC 1195 style metrics or wide metrics?'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("narrow", 1), ("wide", 2), ("both", 3))

class IsisISLevel(TextualConvention, Integer32):
    reference = '{See definitions 3.6.1 and 3.6.11 of ISO 10589}'
    description = 'Identifies a level.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("area", 1), ("domain", 2))

class IsisLevel(TextualConvention, Integer32):
    reference = '{See definitions 3.6.1 and 3.6.11 of ISO 10589}'
    description = 'Identifies one or more levels.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("level1", 1), ("level2", 2), ("level1and2", 3))

class IsisPDUHeader(TextualConvention, OctetString):
    description = 'A block to contain the header from a PDU.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 64)

class IsisCircuitID(TextualConvention, OctetString):
    reference = '{See section 7.2.7 of ISO 10589}'
    description = 'ID for a circuit.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(7, 7), )
class IsisISPriority(TextualConvention, Unsigned32):
    reference = '{See section 9.5 of ISO 10589}'
    description = 'Integer sub-range for IS-IS priority.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 127)

class IsisUnsigned16TC(TextualConvention, Unsigned32):
    description = 'An Unsigned32 further restricted to 16 bits.  Note that\n             the ASN.1 BER encoding may still require 24 bits for\n             some values.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class IsisUnsigned8TC(TextualConvention, Unsigned32):
    description = 'An Unsigned32 further restricted to 8 bits.  Note that\n             the ASN.1 BER encoding may still require 16 bits for\n             some values.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

isisSysObject = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 1, 1))
isisSysVersion = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unknown", 0), ("one", 1))).clone('one')).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysVersion.setReference('{ISIS.aoi version (1)}')
if mibBuilder.loadTexts: isisSysVersion.setStatus('current')
if mibBuilder.loadTexts: isisSysVersion.setDescription('The version number of the IS-IS protocol that\n             is implemented.')
isisSysLevelType = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 2), IsisLevel().clone('level1and2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelType.setReference('{ISIS.aoi iSType (2)}')
if mibBuilder.loadTexts: isisSysLevelType.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelType.setDescription("At which levels is the Intermediate System\n             running? This object may not be modified when\n             the isisSysAdminState variable is in state 'on'\n             for this Intermediate System.\n\n             Configured values MUST survive an agent reboot.")
isisSysID = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 3), IsisSystemID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysID.setReference('{ISIS.aoi systemId (119)}')
if mibBuilder.loadTexts: isisSysID.setStatus('current')
if mibBuilder.loadTexts: isisSysID.setDescription('The ID for this Intermediate System.\n             This value is appended to each of the\n             area addresses to form the Network Entity Titles.\n             The derivation of a value for this object is\n             implementation specific.  Some implementations may\n             automatically assign values and not permit an\n             SNMP write, while others may require the value\n             to be set manually.\n\n             Configured values MUST survive an agent reboot.')
isisSysMaxPathSplits = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysMaxPathSplits.setReference('{ISIS.aoi maximumPathSplits (3)}')
if mibBuilder.loadTexts: isisSysMaxPathSplits.setStatus('current')
if mibBuilder.loadTexts: isisSysMaxPathSplits.setDescription("Maximum number of paths with equal routing metric value\n             which it is permitted to split between.  This object\n             may not be modified when the isisSysAdminState variable\n             is in state 'on' for this Intermediate System.\n\n             Configured values MUST survive an agent reboot.")
isisSysMaxLSPGenInt = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65235)).clone(900)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysMaxLSPGenInt.setReference('{ISIS.aoi maximumLSPGenerationInterval (6)}')
if mibBuilder.loadTexts: isisSysMaxLSPGenInt.setStatus('current')
if mibBuilder.loadTexts: isisSysMaxLSPGenInt.setDescription('Maximum interval, in seconds, between generated LSPs\n             by this Intermediate System.  This object follows\n             the ResettingTimer behavior.  The value must be\n             greater than any value configured for\n             isisSysLevelMinLSPGenInt, and should be at least 300\n             seconds less than isisSysMaxAge.\n\n             Configured values MUST survive an agent reboot.')
isisSysPollESHelloRate = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 6), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(50)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysPollESHelloRate.setReference('{ISIS.aoi pollESHelloRate (13)}')
if mibBuilder.loadTexts: isisSysPollESHelloRate.setStatus('current')
if mibBuilder.loadTexts: isisSysPollESHelloRate.setDescription('The value, in seconds, to be used for the suggested ES\n             configuration timer in ISH PDUs when soliciting the ES\n             configuration.\n\n             Configured values MUST survive an agent reboot.')
isisSysWaitTime = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 7), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(60)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysWaitTime.setReference('{ISIS.aoi waitingTime (15)}')
if mibBuilder.loadTexts: isisSysWaitTime.setStatus('current')
if mibBuilder.loadTexts: isisSysWaitTime.setDescription("Number of seconds to delay in state 'waiting' before\n             entering the state 'on'.  This object follows the\n             ResettingTimer behavior.\n\n             Configured values MUST survive an agent reboot.")
isisSysAdminState = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 8), IsisAdminState().clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysAdminState.setStatus('current')
if mibBuilder.loadTexts: isisSysAdminState.setDescription("The administrative state of this Intermediate\n             System.  Setting this object to the value 'on'\n             when its current value is 'off' enables\n             the Intermediate System.\n\n             Configured values MUST survive an agent reboot.")
isisSysL2toL1Leaking = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysL2toL1Leaking.setStatus('current')
if mibBuilder.loadTexts: isisSysL2toL1Leaking.setDescription('If true, allow the router to leak L2 routes into L1.\n\n             Configured values MUST survive an agent reboot.')
isisSysMaxAge = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 10), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(350, 65535)).clone(1200)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysMaxAge.setStatus('current')
if mibBuilder.loadTexts: isisSysMaxAge.setDescription('Value to place in RemainingLifeTime field of\n             the LSPs we generate.\n             This should be at least 300 seconds greater than\n             isisSysMaxLSPGenInt.\n\n             Configured values MUST survive an agent reboot.')
isisSysReceiveLSPBufferSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 11), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1492, 16000)).clone(1492)).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysReceiveLSPBufferSize.setStatus('current')
if mibBuilder.loadTexts: isisSysReceiveLSPBufferSize.setDescription('Size of the largest buffer we are designed or\n             configured to store.  This should be at least\n             as big as the maximum isisSysLevelOrigLSPBuffSize\n             supported by the system.\n\n\n\n             If resources allow, we will store and flood LSPs\n             larger than isisSysReceiveLSPBufferSize, as this\n             can help avoid problems in networks with different\n             values for isisSysLevelOrigLSPBuffSize.\n\n             Configured values MUST survive an agent reboot.')
isisSysProtSupported = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 12), Bits().clone(namedValues=NamedValues(("iso8473", 0), ("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysProtSupported.setStatus('current')
if mibBuilder.loadTexts: isisSysProtSupported.setDescription('This attribute contains the set of protocols\n             supported by this Intermediate System.')
isisSysNotificationEnable = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 13), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: isisSysNotificationEnable.setDescription('If this object is set to true(1), then it enables\n             the emission of IS-IS Notifications.  If it is\n             set to false(2), these notifications are not sent.\n\n             Configured values MUST survive an agent reboot.')
isisManAreaAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 2), )
if mibBuilder.loadTexts: isisManAreaAddrTable.setReference('{ISIS.aoi manualAreaAddresses (10)}')
if mibBuilder.loadTexts: isisManAreaAddrTable.setStatus('current')
if mibBuilder.loadTexts: isisManAreaAddrTable.setDescription("The set of manual area addresses configured on this\n             Intermediate System.\n\n             At least one row in which the value of\n             isisManAreaAddrExistState is active must be present.\n             The maximum number of rows in this table for\n\n\n\n             which the object isisManAreaAddrExistState has the\n             value active is 3.\n\n             An attempt to create more than 3 rows of\n             isisManAreaAddrEntry with state 'active' in one\n             instance of the IS-IS protocol should\n             return inconsistentValue.")
isisManAreaAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 2, 1), ).setIndexNames((0, "ISIS-MIB", "isisManAreaAddr"))
if mibBuilder.loadTexts: isisManAreaAddrEntry.setStatus('current')
if mibBuilder.loadTexts: isisManAreaAddrEntry.setDescription('Each entry contains one area address manually configured\n             on this system.\n\n             Dynamically created rows MUST survive an agent reboot.')
isisManAreaAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 2, 1, 1), IsisOSINSAddress())
if mibBuilder.loadTexts: isisManAreaAddr.setStatus('current')
if mibBuilder.loadTexts: isisManAreaAddr.setDescription('A manually configured area address for this system.\n\n             Note: An index for the entry {1, {49.0001} active} in\n             this table would be the ordered pair\n             (1, (0x03 0x49 0x00 0x01)), as the length of an octet\n             string is part of the OID.')
isisManAreaAddrExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisManAreaAddrExistState.setStatus('current')
if mibBuilder.loadTexts: isisManAreaAddrExistState.setDescription("The state of the isisManAreaAddrEntry.  If the\n             isisSysAdminState for this Intermediate System is 'on' and\n             an attempt is made to set this object to the value\n             'destroy' or 'notInService' when this is the only\n             isisManAreaAddrEntry in state 'active' for this\n             Intermediate System should return inconsistentValue.\n\n             A row entry cannot be modified when the value of this\n             object is 'active'.")
isisAreaAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 3), )
if mibBuilder.loadTexts: isisAreaAddrTable.setReference('{ISIS.aoi areaAddresses (18)}')
if mibBuilder.loadTexts: isisAreaAddrTable.setStatus('current')
if mibBuilder.loadTexts: isisAreaAddrTable.setDescription('The union of the sets of area addresses reported in all\n             Level 1 LSPs with fragment number zero generated by this\n             Intermediate System, or received from other Intermediate\n             Systems that are reachable via Level 1 routing.')
isisAreaAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 3, 1), ).setIndexNames((0, "ISIS-MIB", "isisAreaAddr"))
if mibBuilder.loadTexts: isisAreaAddrEntry.setStatus('current')
if mibBuilder.loadTexts: isisAreaAddrEntry.setDescription('Each entry contains one area address reported in a\n             Level 1 LSP generated or received by this Intermediate\n             System.\n\n             Dynamically learned rows do not survive an agent reboot.')
isisAreaAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 3, 1, 1), IsisOSINSAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisAreaAddr.setStatus('current')
if mibBuilder.loadTexts: isisAreaAddr.setDescription('An area address reported in a Level 1 LSP.')
isisSummAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 4), )
if mibBuilder.loadTexts: isisSummAddrTable.setStatus('current')
if mibBuilder.loadTexts: isisSummAddrTable.setDescription('The set of IP summary addresses to use in forming\n             summary TLVs originated by this Intermediate System.\n\n             An administrator may use a summary address to combine\n             and modify IP Reachability announcements.  If the\n             Intermediate system can reach any subset of the summary\n             address, the summary address MUST be announced instead,\n             at the configured metric.')
isisSummAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1), ).setIndexNames((0, "ISIS-MIB", "isisSummAddressType"), (0, "ISIS-MIB", "isisSummAddress"), (0, "ISIS-MIB", "isisSummAddrPrefixLen"))
if mibBuilder.loadTexts: isisSummAddrEntry.setStatus('current')
if mibBuilder.loadTexts: isisSummAddrEntry.setDescription('Each entry contains one IP summary address.\n\n             Dynamically created rows MUST survive an agent reboot.\n\n             Implementers need to be aware that if the total number\n             of elements (octets or sub-identifiers) in\n             isisSummAddress and isisSummAddrPrefixLen is too great,\n             then OIDs of column instances in this table will have\n             more than 128 subidentifiers and cannot be accessed\n             using SNMPv1, SNMPv2c, or SNMPv3.')
isisSummAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: isisSummAddressType.setStatus('current')
if mibBuilder.loadTexts: isisSummAddressType.setDescription('The Type of IP address for this summary address.')
isisSummAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 2), InetAddress())
if mibBuilder.loadTexts: isisSummAddress.setStatus('current')
if mibBuilder.loadTexts: isisSummAddress.setDescription('The IP Address value for this summary address.\n             The address must not contain any set host bits\n             (bits set after the address prefix determined by\n             isisSummAddrPrefixLen).\n\n             The type of this address is determined by the value of\n             the isisSummAddressType object.')
isisSummAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: isisSummAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: isisSummAddrPrefixLen.setDescription('The Length of the IP NetMask for this summary address.\n\n             The values for the index objects isisSummAddress and\n\n\n\n             isisSummAddrPrefixLen must be consistent.  When the value\n             of isisSummAddress (excluding the zone index, if one\n             is present) is x, then the bitwise logical-AND\n             of x with the value of the mask formed from the\n             corresponding index object isisSummAddrPrefixLen MUST be\n             equal to x.  If not, then the index pair is not\n             consistent, and an inconsistentName error must be\n             returned on SET or CREATE requests.')
isisSummAddrExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisSummAddrExistState.setStatus('current')
if mibBuilder.loadTexts: isisSummAddrExistState.setDescription("The existence state of this summary address.  Support\n             for 'createAndWait' and 'notInService' is not required.\n\n             A row entry cannot be modified when the value of this\n             object is 'active'.")
isisSummAddrMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 5), IsisDefaultMetric().clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisSummAddrMetric.setStatus('current')
if mibBuilder.loadTexts: isisSummAddrMetric.setDescription('The metric value to announce this summary\n             address within LSPs generated by this system.')
isisSummAddrFullMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 6), IsisFullMetric().clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisSummAddrFullMetric.setStatus('current')
if mibBuilder.loadTexts: isisSummAddrFullMetric.setDescription('The wide metric value to announce this summary\n             address within LSPs generated by this system.')
isisRedistributeAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 5), )
if mibBuilder.loadTexts: isisRedistributeAddrTable.setStatus('current')
if mibBuilder.loadTexts: isisRedistributeAddrTable.setDescription('This table provides criteria to decide if a route should\n             be leaked from L2 to L1 when Domain Wide Prefix leaking is\n             enabled.\n\n             Addresses that match the summary mask in the table MUST\n             be announced at L1 by routers when isisSysL2toL1Leaking\n             is enabled.  Routes that fall into the ranges specified\n             are announced as is, without being summarized.  Routes\n             that do not match a summary mask are not announced.')
isisRedistributeAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1), ).setIndexNames((0, "ISIS-MIB", "isisRedistributeAddrType"), (0, "ISIS-MIB", "isisRedistributeAddrAddress"), (0, "ISIS-MIB", "isisRedistributeAddrPrefixLen"))
if mibBuilder.loadTexts: isisRedistributeAddrEntry.setStatus('current')
if mibBuilder.loadTexts: isisRedistributeAddrEntry.setDescription('Each entry contains one configured IP summary\n             address to manage leaking L2 addresses into L1.\n\n             Dynamically created rows MUST survive an agent reboot.\n\n             Implementers need to be aware that if the total number\n             of elements (octets or sub-identifiers) in\n             isisRedistributeAddrAddress and\n             isisRedistributeAddrPrefixLen is too great, then OIDs\n             of column instances in this table will have more than\n             128 subidentifiers and cannot be accessed using SNMPv1,\n             SNMPv2c, or SNMPv3.')
isisRedistributeAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 1), InetAddressType())
if mibBuilder.loadTexts: isisRedistributeAddrType.setStatus('current')
if mibBuilder.loadTexts: isisRedistributeAddrType.setDescription('The Type of IP address for this summary address.')
isisRedistributeAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 2), InetAddress())
if mibBuilder.loadTexts: isisRedistributeAddrAddress.setStatus('current')
if mibBuilder.loadTexts: isisRedistributeAddrAddress.setDescription('The IP Address value for this summary address.\n             The type of this address is determined by the\n             value of the isisRedistributeAddrType object.\n             The address must not contain any set host bits -\n             bits set after the address prefix determined by\n             isisRedistributeAddrPrefixLen.')
isisRedistributeAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: isisRedistributeAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: isisRedistributeAddrPrefixLen.setDescription('The Length of the IP NetMask for this summary address.\n\n             The values for the index objects\n             isisRedistributeAddrAddress and\n             isisRedistributeAddrPrefixLen must be consistent.\n             When the value of isisRedistributeAddrAddress\n             (excluding the zone index, if one is present) is x,\n             then the bitwise logical-AND of x with the value of\n             the mask formed from the corresponding index object\n             isisRedistributeAddrPrefixLen MUST be equal to x.\n             If not, then the index pair is not consistent, and an\n             inconsistentName error must be returned on SET or\n             CREATE requests.')
isisRedistributeAddrExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRedistributeAddrExistState.setStatus('current')
if mibBuilder.loadTexts: isisRedistributeAddrExistState.setDescription("The existence state of this summary address.  Support\n\n\n\n             for createAndWait and notInService is not required.\n\n             A row entry cannot be modified when the value of this\n             object is 'active'.")
isisRouterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 6), )
if mibBuilder.loadTexts: isisRouterTable.setStatus('current')
if mibBuilder.loadTexts: isisRouterTable.setDescription('The set of hostnames and router ID.')
isisRouterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1), ).setIndexNames((0, "ISIS-MIB", "isisRouterSysID"), (0, "ISIS-MIB", "isisRouterLevel"))
if mibBuilder.loadTexts: isisRouterEntry.setStatus('current')
if mibBuilder.loadTexts: isisRouterEntry.setDescription('Each entry tracks information about one Intermediate\n             System at one level.\n\n             Dynamically learned rows do not survive an agent reboot.')
isisRouterSysID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 1), IsisSystemID())
if mibBuilder.loadTexts: isisRouterSysID.setStatus('current')
if mibBuilder.loadTexts: isisRouterSysID.setDescription('The System ID of the Intermediate System.')
isisRouterLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 2), IsisISLevel())
if mibBuilder.loadTexts: isisRouterLevel.setStatus('current')
if mibBuilder.loadTexts: isisRouterLevel.setDescription('The level at which the information about this\n             Intermediate System was received.')
isisRouterHostName = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisRouterHostName.setStatus('current')
if mibBuilder.loadTexts: isisRouterHostName.setDescription('The hostname listed in the LSP, or a zero-length\n             string if none.')
isisRouterID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisRouterID.setStatus('current')
if mibBuilder.loadTexts: isisRouterID.setDescription('The Router ID found in the LSP, or zero if none.')
isisSysLevelTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 2, 1), )
if mibBuilder.loadTexts: isisSysLevelTable.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelTable.setDescription('Level specific information about the System.')
isisSysLevelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1), ).setIndexNames((0, "ISIS-MIB", "isisSysLevelIndex"))
if mibBuilder.loadTexts: isisSysLevelEntry.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelEntry.setDescription('Each row describes variables configured for Area or Domain.\n\n             Configured values MUST survive an agent reboot.')
isisSysLevelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 1), IsisISLevel())
if mibBuilder.loadTexts: isisSysLevelIndex.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelIndex.setDescription('The level that this entry describes.')
isisSysLevelOrigLSPBuffSize = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 2), IsisLSPBuffSize().clone(1492)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelOrigLSPBuffSize.setReference('{ISIS.aoi originatingL1LSPBufferSize (9)}')
if mibBuilder.loadTexts: isisSysLevelOrigLSPBuffSize.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelOrigLSPBuffSize.setDescription("The maximum size of LSPs and SNPs originated by\n             this Intermediate System at this level.  This\n             object may not be modified when the isisSysAdminState\n             variable is in state 'on' for this Intermediate System.")
isisSysLevelMinLSPGenInt = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 3), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelMinLSPGenInt.setReference('{ISIS.aoi minimumLSPGenerationInterval (11)}')
if mibBuilder.loadTexts: isisSysLevelMinLSPGenInt.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelMinLSPGenInt.setDescription('Minimum interval, in seconds, between successive\n             generation of LSPs with the same LSPID at this level\n             by this Intermediate System.')
isisSysLevelState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 4), IsisLevelState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysLevelState.setReference('{ISIS.aoi l1State (17)}')
if mibBuilder.loadTexts: isisSysLevelState.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelState.setDescription("The state of the database at this level.\n             The value 'off' indicates that IS-IS is not active at\n             this level.\n             The value 'on' indicates that IS-IS is active at this\n             level and is not overloaded.\n             The value 'waiting' indicates a database that is low on\n             an essential resource, such as memory.\n             The administrator may force the state to 'overloaded'\n             by setting the object isisSysLevelSetOverload.\n             If the state is 'waiting' or 'overloaded', we\n             originate LSPs with the overload bit set.")
isisSysLevelSetOverload = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelSetOverload.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelSetOverload.setDescription('Administratively set the overload bit for the level.\n             The overload bit MUST continue to be set if the\n             implementation runs out of memory, independent of\n             this variable.  It may also be set manually independent\n             of this variable, using the isisSysLevelSetOverloadUntil\n             object.')
isisSysLevelSetOverloadUntil = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 6), Unsigned32()).setUnits('Seconds until clearing manually set Overload Bit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelSetOverloadUntil.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelSetOverloadUntil.setDescription("If this object is non-zero, the overload bit is set at\n             this level when the isisSysAdminState variable goes to\n             state 'on' for this Intermediate System.  The overload bit\n             remains set for isisSysLevelSetOverloadUntil seconds.\n             When isisSysLevelSetOverloadUntil seconds have elapsed,\n             the overload flag remains set if the implementation has\n             run out of memory, or if it is set manually using the\n             isisSysLevelSetOverload object.\n\n             If isisSysLevelSetOverload is false, the system clears\n             the overload bit when isisSysLevelSetOverloadUntil seconds\n             have elapsed, if the system has not run out of memory.")
isisSysLevelMetricStyle = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 7), IsisMetricStyle().clone('narrow')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelMetricStyle.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelMetricStyle.setDescription('Which style of metric do we generate in our LSPs\n             at this level?')
isisSysLevelSPFConsiders = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 8), IsisMetricStyle().clone('narrow')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelSPFConsiders.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelSPFConsiders.setDescription('Which style of metric do we consider in our\n             SPF computation at this level?')
isisSysLevelTEEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelTEEnabled.setStatus('current')
if mibBuilder.loadTexts: isisSysLevelTEEnabled.setDescription('Do we do Traffic Engineering at this level?')
isisNextCircIndex = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 3, 1), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisNextCircIndex.setStatus('current')
if mibBuilder.loadTexts: isisNextCircIndex.setDescription("This object is used to assist a management\n             application in creating new rows in the\n             isisCircTable.  If it is possible to create\n             a new instance of isisCircEntry, then this\n             object will contain a non-zero value that\n             is not in use as the index of any row in the\n             isisCircTable.  The network manager reads the\n             value of this object and then (if the\n             value read is non-zero) attempts to create\n             the corresponding instance of isisCircEntry.\n             If the set request fails with the code\n             'inconsistentValue', then the process must be\n             repeated;  if the set request succeeds, then\n             the agent will change the value of this object\n             according to an implementation-specific\n             algorithm.")
isisCircTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 3, 2), )
if mibBuilder.loadTexts: isisCircTable.setStatus('current')
if mibBuilder.loadTexts: isisCircTable.setDescription('The table of circuits used by this\n             Intermediate System.')
isisCircEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"))
if mibBuilder.loadTexts: isisCircEntry.setStatus('current')
if mibBuilder.loadTexts: isisCircEntry.setDescription('An isisCircEntry exists for each circuit configured\n             for Integrated IS-IS on this system.\n\n             Dynamically created rows MUST survive an agent reboot.')
isisCircIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 1), IndexInteger())
if mibBuilder.loadTexts: isisCircIndex.setStatus('current')
if mibBuilder.loadTexts: isisCircIndex.setDescription('An index used to uniquely identify this circuit.\n             When creating a row in this table, the\n             isisNextCircIndex object should be retrieved,\n             and its value should be specified as the value\n             of this index using a SET operation.  A retrieved\n             value of zero(0) indicates that no rows can be\n             created at this time.')
isisCircIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 2), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircIfIndex.setStatus('current')
if mibBuilder.loadTexts: isisCircIfIndex.setDescription('The value of ifIndex for the interface to which this\n             circuit corresponds.  This object cannot be modified\n             after creation.')
isisCircAdminState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 3), IsisAdminState().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircAdminState.setStatus('current')
if mibBuilder.loadTexts: isisCircAdminState.setDescription('The administrative state of the circuit.')
isisCircExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircExistState.setStatus('current')
if mibBuilder.loadTexts: isisCircExistState.setDescription("The existence state of this circuit.  Setting the state\n             to 'notInService' halts the generation and processing of\n             IS-IS protocol PDUs on this circuit.  Setting the state\n             to destroy will also erase any configuration associated\n             with the circuit.  Support for 'createAndWait' and\n             'notInService' is not required.\n\n             A row entry cannot be modified when the value of this\n             object is 'active'.")
isisCircType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("broadcast", 1), ("ptToPt", 2), ("staticIn", 3), ("staticOut", 4), ("dA", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircType.setReference('{ISIS.aoi type (33)}')
if mibBuilder.loadTexts: isisCircType.setStatus('current')
if mibBuilder.loadTexts: isisCircType.setDescription('The type of the circuit.  This object follows the\n             ReplaceOnlyWhileDisabled behavior.  The type specified\n             must be compatible with the type of the interface defined\n\n\n\n             by the value of isisCircIfIndex.')
isisCircExtDomain = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircExtDomain.setReference('{ISIS.aoi externalDomain (46)}')
if mibBuilder.loadTexts: isisCircExtDomain.setStatus('current')
if mibBuilder.loadTexts: isisCircExtDomain.setDescription('If true, suppress normal transmission of and\n             interpretation of Intra-domain IS-IS PDUs on this\n             circuit.')
isisCircLevelType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 7), IsisLevel().clone('level1and2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircLevelType.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelType.setDescription('Indicates which type of packets will be sent and\n             accepted on this circuit.  The values set will be\n             saved, but the values used will be modified by\n             the settings of isisSysLevelType.  Thus, if the\n             isisSysTpe is level2 and the isisCircLevelType\n             for a circuit is level1, the circuit will not send\n             or receive IS-IS packets.  This object follows the\n             ReplaceOnlyWhileDisabled behavior.')
isisCircPassiveCircuit = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircPassiveCircuit.setStatus('current')
if mibBuilder.loadTexts: isisCircPassiveCircuit.setDescription('Should we include this interface in LSPs, even if\n             it is not running the IS-IS Protocol?')
isisCircMeshGroupEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("blocked", 2), ("set", 3))).clone('inactive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircMeshGroupEnabled.setReference('{ RFC 2973 }')
if mibBuilder.loadTexts: isisCircMeshGroupEnabled.setStatus('current')
if mibBuilder.loadTexts: isisCircMeshGroupEnabled.setDescription('Is this port a member of a mesh group, or is it\n             blocked?  Circuits in the same mesh group act as a\n             virtual multiaccess network.  LSPs seen on one circuit\n             in a mesh group will not be flooded to another circuit\n             in the same mesh group.')
isisCircMeshGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircMeshGroup.setReference('{ RFC 2973 }')
if mibBuilder.loadTexts: isisCircMeshGroup.setStatus('current')
if mibBuilder.loadTexts: isisCircMeshGroup.setDescription('Circuits in the same mesh group act as a virtual\n             multiaccess network.  LSPs seen on one circuit in\n             a mesh group will not be flooded to another circuit\n             in the same mesh group.  If isisCircMeshGroupEnabled\n             is inactive or blocked, this value is ignored.')
isisCircSmallHellos = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircSmallHellos.setStatus('current')
if mibBuilder.loadTexts: isisCircSmallHellos.setDescription('Can we send unpadded hellos on LAN circuits?  False\n             means the LAN Hellos must be padded.\n             Implementations should allow the administrator to read\n             this value.  An implementation need not be able to\n             support unpadded hellos to be conformant.')
isisCircLastUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLastUpTime.setStatus('current')
if mibBuilder.loadTexts: isisCircLastUpTime.setDescription("How long the circuit has been enabled, measured in\n             hundredths of seconds since the last re-initialization\n             of the network management subsystem; 0 if the\n             circuit has never been 'on'.")
isisCirc3WayEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCirc3WayEnabled.setStatus('current')
if mibBuilder.loadTexts: isisCirc3WayEnabled.setDescription('Is this circuit enabled to run 3Way handshake?')
isisCircExtendedCircID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 14), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircExtendedCircID.setStatus('current')
if mibBuilder.loadTexts: isisCircExtendedCircID.setDescription('The value to be used as the extended circuit ID in\n             3Way handshake.  This value is only used if\n             isisCirc3WayEnabled is true, and it must be unique\n             across all circuits on this IS.')
isisCircLevelTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 4, 1), )
if mibBuilder.loadTexts: isisCircLevelTable.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelTable.setDescription('Level specific information about circuits used by IS-IS.')
isisCircLevelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisCircLevelIndex"))
if mibBuilder.loadTexts: isisCircLevelEntry.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelEntry.setDescription('An isisCircLevelEntry exists for each level on\n             each circuit configured for Integrated IS-IS on\n             this system.\n\n             Configured values MUST survive an agent reboot.')
isisCircLevelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 1), IsisISLevel())
if mibBuilder.loadTexts: isisCircLevelIndex.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelIndex.setDescription('The level that this entry describes.')
isisCircLevelMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 2), IsisDefaultMetric().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelMetric.setReference('{ISIS.aoi l1DefaultMetric (35)}')
if mibBuilder.loadTexts: isisCircLevelMetric.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelMetric.setDescription('The metric value of this circuit for this level.')
isisCircLevelWideMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 3), IsisWideMetric().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelWideMetric.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelWideMetric.setDescription('The wide metric value of this circuit for this level.')
isisCircLevelISPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 4), IsisISPriority().clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelISPriority.setReference('{ISIS.aoi l2IntermediateSystemPriority (73)}')
if mibBuilder.loadTexts: isisCircLevelISPriority.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelISPriority.setDescription('The priority for becoming the LAN-Designated\n             Intermediate System at this level.')
isisCircLevelIDOctet = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLevelIDOctet.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelIDOctet.setDescription('A one-byte identifier for the circuit selected by the\n             Intermediate System.\n\n             On point-to-point circuits, the value is used as the Local\n             Circuit ID in point-to-point IIH PDUs transmitted on this\n             circuit.  In this case, values of isisCircLevelIDOctet do\n             not need to be unique.\n\n             For broadcast circuits, the value is used to generate the\n             LAN ID that will be used if this Intermediate System is\n             elected as the Designated IS on this circuit.  The value\n             is required to differ on LANs where the Intermediate System\n             is the Designated Intermediate System.')
isisCircLevelID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 6), IsisCircuitID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLevelID.setReference('{ISIS.aoi ptPtCircuitID (51)}')
if mibBuilder.loadTexts: isisCircLevelID.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelID.setDescription('On a point-to-point circuit with a fully initialized\n             adjacency to a peer IS, the value of this object is\n             the circuit ID negotiated during adjacency initialization.\n\n\n\n             On a point to point circuit without such an adjacency,\n             the value is the concatenation of the local system ID\n             and the one-byte isisCircLevelIDOctet for this circuit,\n             i.e., the value that would be proposed for the circuit ID.\n             On other circuit types, the value returned is the zero-\n             length OCTET STRING.')
isisCircLevelDesIS = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 7), IsisCircuitID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLevelDesIS.setReference('{ISIS.aoi l2DesignatedIntermediateSystem (75)}')
if mibBuilder.loadTexts: isisCircLevelDesIS.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelDesIS.setDescription('The ID of the LAN-Designated Intermediate System\n             on this circuit at this level.  If, for any reason,\n             this system is not partaking in the relevant\n             Designated Intermediate System election process,\n             then the value returned is the zero-length OCTET STRING.')
isisCircLevelHelloMultiplier = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelHelloMultiplier.setReference('{ISIS.aoi iSISHelloTimer (45)}')
if mibBuilder.loadTexts: isisCircLevelHelloMultiplier.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelHelloMultiplier.setDescription('This value is multiplied by the corresponding HelloTimer,\n             and the result in seconds (rounded up) is used as the\n             holding time in transmitted hellos, to be used by\n             receivers of hello packets from this IS.')
isisCircLevelHelloTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 600000)).clone(3000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelHelloTimer.setReference('{ISIS.aoi iSISHelloTimer (45)}')
if mibBuilder.loadTexts: isisCircLevelHelloTimer.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelHelloTimer.setDescription('Maximum period, in milliseconds, between IIH PDUs\n             on multiaccess networks at this level for LANs.\n             The value at L1 is used as the period between\n             Hellos on L1L2 point-to-point circuits.  Setting\n             this value at level 2 on an L1L2 point-to-point\n             circuit will result in an error of InconsistentValue.\n\n\n\n\n             This object follows the ResettingTimer behavior.')
isisCircLevelDRHelloTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 120000)).clone(1000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelDRHelloTimer.setReference('{ISIS.aoi iSISHelloTimer (45)}')
if mibBuilder.loadTexts: isisCircLevelDRHelloTimer.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelDRHelloTimer.setDescription('Period, in milliseconds, between Hello PDUs on\n             multiaccess networks when this IS is the Designated\n             Intermediate System.  This object follows the\n             ResettingTimer behavior.')
isisCircLevelLSPThrottle = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 11), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelLSPThrottle.setReference('{ISIS.aoi minimumBroadcastLSPTransmissionInterval (5)}')
if mibBuilder.loadTexts: isisCircLevelLSPThrottle.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelLSPThrottle.setDescription('Minimal interval of time, in milliseconds, between\n             transmissions of LSPs on an interface at this level.')
isisCircLevelMinLSPRetransInt = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelMinLSPRetransInt.setReference('{ISIS.aoi minimumLSPTransmissionInterval (5)}')
if mibBuilder.loadTexts: isisCircLevelMinLSPRetransInt.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelMinLSPRetransInt.setDescription('Minimum interval, in seconds, between re-transmission of\n             an LSP at this level.  This object follows the\n             ResettingTimer behavior.\n\n             Note that isisCircLevelLSPThrottle controls\n             how fast we send back-to-back LSPs.  This variable\n             controls how fast we re-send the same LSP.')
isisCircLevelCSNPInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelCSNPInterval.setReference('{ISIS.aoi completeSNPInterval (8)}')
if mibBuilder.loadTexts: isisCircLevelCSNPInterval.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelCSNPInterval.setDescription('Interval of time, in seconds, between periodic\n             transmission of a complete set of CSNPs on\n             multiaccess networks if this router is the\n             designated router at this level.\n             This object follows the ResettingTimer behavior.')
isisCircLevelPartSNPInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(2)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelPartSNPInterval.setReference('{ISIS.aoi partialSNPInterval (14)}')
if mibBuilder.loadTexts: isisCircLevelPartSNPInterval.setStatus('current')
if mibBuilder.loadTexts: isisCircLevelPartSNPInterval.setDescription('Minimum interval, in seconds, between sending Partial\n             Sequence Number PDUs at this level.  This object\n             follows the ResettingTimer behavior.')
isisSystemCounterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 5, 1), )
if mibBuilder.loadTexts: isisSystemCounterTable.setStatus('current')
if mibBuilder.loadTexts: isisSystemCounterTable.setDescription('System-wide counters for this Intermediate System.')
isisSystemCounterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1), ).setIndexNames((0, "ISIS-MIB", "isisSysStatLevel"))
if mibBuilder.loadTexts: isisSystemCounterEntry.setStatus('current')
if mibBuilder.loadTexts: isisSystemCounterEntry.setDescription('System-wide IS-IS counters.')
isisSysStatLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 1), IsisISLevel())
if mibBuilder.loadTexts: isisSysStatLevel.setStatus('current')
if mibBuilder.loadTexts: isisSysStatLevel.setDescription('The level that this entry describes.')
isisSysStatCorrLSPs = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 2), Counter32()).setUnits('Number of corrupted in-memory frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatCorrLSPs.setReference('{ISIS.aoi corruptedLSPsDetected (19)}')
if mibBuilder.loadTexts: isisSysStatCorrLSPs.setStatus('current')
if mibBuilder.loadTexts: isisSysStatCorrLSPs.setDescription('Number of corrupted in-memory LSPs detected.\n\n             LSPs received from the wire with a bad checksum\n             are silently dropped and are not counted.\n\n\n\n\n             LSPs received from the wire with parse errors\n             are counted by isisSysStatLSPErrors.')
isisSysStatAuthTypeFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 3), Counter32()).setUnits('Number of frames with authentication type mismatches').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatAuthTypeFails.setStatus('current')
if mibBuilder.loadTexts: isisSysStatAuthTypeFails.setDescription('The number of authentication type mismatches recognized\n             by this Intermediate System.')
isisSysStatAuthFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 4), Counter32()).setUnits('Number of frames with authentication key failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatAuthFails.setStatus('current')
if mibBuilder.loadTexts: isisSysStatAuthFails.setDescription('The number of authentication key failures recognized\n             by this Intermediate System.')
isisSysStatLSPDbaseOloads = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatLSPDbaseOloads.setReference('{ISIS.aoi lSPL1DatabaseOverloads (20)}')
if mibBuilder.loadTexts: isisSysStatLSPDbaseOloads.setStatus('current')
if mibBuilder.loadTexts: isisSysStatLSPDbaseOloads.setDescription('Number of times the LSP database has become\n             overloaded.')
isisSysStatManAddrDropFromAreas = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatManAddrDropFromAreas.setReference('{ISIS.aoi manualAddressesDroppedFromArea (21)}')
if mibBuilder.loadTexts: isisSysStatManAddrDropFromAreas.setStatus('current')
if mibBuilder.loadTexts: isisSysStatManAddrDropFromAreas.setDescription('Number of times a manual address has been dropped from\n             the area.')
isisSysStatAttmptToExMaxSeqNums = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatAttmptToExMaxSeqNums.setReference('{ISIS.aoi attemptsToExceedmaximumSequenceNumber (22)}')
if mibBuilder.loadTexts: isisSysStatAttmptToExMaxSeqNums.setStatus('current')
if mibBuilder.loadTexts: isisSysStatAttmptToExMaxSeqNums.setDescription('Number of times the IS has attempted to exceed the\n             maximum sequence number.')
isisSysStatSeqNumSkips = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatSeqNumSkips.setReference('{ISIS.aoi sequenceNumberSkips (23)}')
if mibBuilder.loadTexts: isisSysStatSeqNumSkips.setStatus('current')
if mibBuilder.loadTexts: isisSysStatSeqNumSkips.setDescription('Number of times a sequence number skip has occurred.')
isisSysStatOwnLSPPurges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatOwnLSPPurges.setReference('{ISIS.aoi ownLSPPurges (24)}')
if mibBuilder.loadTexts: isisSysStatOwnLSPPurges.setStatus('current')
if mibBuilder.loadTexts: isisSysStatOwnLSPPurges.setDescription("Number of times a zero-aged copy of the system's own LSP\n             is received from some other node.")
isisSysStatIDFieldLenMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 10), Counter32()).setUnits('Number of frames with ID length mismatches').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatIDFieldLenMismatches.setReference('{ISIS.aoi iDFieldLengthMismatches (25)}')
if mibBuilder.loadTexts: isisSysStatIDFieldLenMismatches.setStatus('current')
if mibBuilder.loadTexts: isisSysStatIDFieldLenMismatches.setDescription('Number of times a PDU is received with a different value\n             for ID field length from that of the receiving system.')
isisSysStatPartChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatPartChanges.setStatus('current')
if mibBuilder.loadTexts: isisSysStatPartChanges.setDescription('Partition changes.')
isisSysStatSPFRuns = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatSPFRuns.setStatus('current')
if mibBuilder.loadTexts: isisSysStatSPFRuns.setDescription('Number of times we ran SPF at this level.')
isisSysStatLSPErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 13), Counter32()).setUnits('Number of frames with errors that we have received').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatLSPErrors.setStatus('current')
if mibBuilder.loadTexts: isisSysStatLSPErrors.setDescription('Number of LSPs with errors we have received.')
isisCircuitCounterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 5, 2), )
if mibBuilder.loadTexts: isisCircuitCounterTable.setStatus('current')
if mibBuilder.loadTexts: isisCircuitCounterTable.setDescription('Circuit specific counters for this\n             Intermediate System.')
isisCircuitCounterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisCircuitType"))
if mibBuilder.loadTexts: isisCircuitCounterEntry.setStatus('current')
if mibBuilder.loadTexts: isisCircuitCounterEntry.setDescription('An isisCircuitCounterEntry exists for each circuit\n             used by Integrated IS-IS on this system.')
isisCircuitType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lanlevel1", 1), ("lanlevel2", 2), ("p2pcircuit", 3))))
if mibBuilder.loadTexts: isisCircuitType.setStatus('current')
if mibBuilder.loadTexts: isisCircuitType.setDescription('What type of circuit saw these counts?\n\n             The point-to-point Hello PDU includes\n             both L1 and L2, and ISs form a single\n             adjacency on point-to-point links.\n             Thus, we combine counts on\n             point-to-point links into one group.')
isisCircAdjChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircAdjChanges.setReference('{ISIS.aoi changesInAdjacencyState (40)}')
if mibBuilder.loadTexts: isisCircAdjChanges.setStatus('current')
if mibBuilder.loadTexts: isisCircAdjChanges.setDescription('The number of times an adjacency state change has\n             occurred on this circuit.')
isisCircNumAdj = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircNumAdj.setReference('{ISIS.aoi changesInAdjacencyState (40)}')
if mibBuilder.loadTexts: isisCircNumAdj.setStatus('current')
if mibBuilder.loadTexts: isisCircNumAdj.setDescription('The number of adjacencies on this circuit.')
isisCircInitFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircInitFails.setStatus('current')
if mibBuilder.loadTexts: isisCircInitFails.setDescription('The number of times initialization of this circuit has\n             failed.  This counts events such as PPP NCP failures.\n             Failures to form an adjacency are counted by\n             isisCircRejAdjs.')
isisCircRejAdjs = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircRejAdjs.setReference('{ISIS.aoi rejectedAdjacencies (42)}')
if mibBuilder.loadTexts: isisCircRejAdjs.setStatus('current')
if mibBuilder.loadTexts: isisCircRejAdjs.setDescription('The number of times an adjacency has been rejected on\n             this circuit.')
isisCircIDFieldLenMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 6), Counter32()).setUnits('Number of frames with ID field length mismatch').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircIDFieldLenMismatches.setReference('{ISIS.aoi iDFieldLengthMismatches (25)}')
if mibBuilder.loadTexts: isisCircIDFieldLenMismatches.setStatus('current')
if mibBuilder.loadTexts: isisCircIDFieldLenMismatches.setDescription('The number of times an IS-IS control PDU with an ID\n             field length different from that for this system has been\n             received.')
isisCircMaxAreaAddrMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircMaxAreaAddrMismatches.setReference('{ISIS.aoi iDFieldLengthMismatches (25)}')
if mibBuilder.loadTexts: isisCircMaxAreaAddrMismatches.setStatus('current')
if mibBuilder.loadTexts: isisCircMaxAreaAddrMismatches.setDescription('The number of times an IS-IS control PDU with a\n             max area address field different from that for this\n             system has been received.')
isisCircAuthTypeFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircAuthTypeFails.setStatus('current')
if mibBuilder.loadTexts: isisCircAuthTypeFails.setDescription('The number of times an IS-IS control PDU with\n             an auth type field different from that for this\n             system has been received.')
isisCircAuthFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircAuthFails.setStatus('current')
if mibBuilder.loadTexts: isisCircAuthFails.setDescription('The number of times an IS-IS control PDU with\n             the correct auth type has failed to pass authentication\n             validation.')
isisCircLANDesISChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLANDesISChanges.setStatus('current')
if mibBuilder.loadTexts: isisCircLANDesISChanges.setDescription('The number of times the Designated IS has changed\n             on this circuit at this level.  If the circuit is\n             point to point, this count is zero.')
isisPacketCounterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 5, 3), )
if mibBuilder.loadTexts: isisPacketCounterTable.setStatus('current')
if mibBuilder.loadTexts: isisPacketCounterTable.setDescription('Information about IS-IS protocol traffic at one level,\n             on one circuit, in one direction.')
isisPacketCounterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisPacketCountLevel"), (0, "ISIS-MIB", "isisPacketCountDirection"))
if mibBuilder.loadTexts: isisPacketCounterEntry.setStatus('current')
if mibBuilder.loadTexts: isisPacketCounterEntry.setDescription('Information about IS-IS protocol traffic at one level,\n             on one circuit, in one direction.')
isisPacketCountLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 1), IsisISLevel())
if mibBuilder.loadTexts: isisPacketCountLevel.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountLevel.setDescription('The level at which these PDU counts have been collected.')
isisPacketCountDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sending", 1), ("receiving", 2))))
if mibBuilder.loadTexts: isisPacketCountDirection.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountDirection.setDescription('Were we sending or receiving these PDUs?')
isisPacketCountIIHello = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 3), Counter32()).setUnits('Number of IS-IS Hellos frames seen in this direction\n              at this level').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountIIHello.setReference('{ISIS.aoi iSISControlPDUsSent (43)}')
if mibBuilder.loadTexts: isisPacketCountIIHello.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountIIHello.setDescription('The number of IS-IS Hello PDUs seen in this\n             direction at this level.\n\n             Point-to-Point IIH PDUs are counted at\n             the lowest enabled level: at L1 on L1 or L1L2 circuits,\n             and at L2 otherwise.')
isisPacketCountISHello = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 4), Counter32()).setUnits('Number of ES-IS frames seen in this direction at\n             this level.').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountISHello.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountISHello.setDescription('The number of ES-IS Hello PDUs seen in this\n             direction.  ISH PDUs are counted at the\n             lowest enabled level: at L1 on L1 or L1L2\n             circuits, and at L2 otherwise.')
isisPacketCountESHello = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 5), Counter32()).setUnits('Number of ES Hello frames seen in this direction at\n             this level').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountESHello.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountESHello.setDescription('The number of ES Hello PDUs seen in this\n             direction.  ESH PDUs are counted at the\n             lowest enabled level: at L1 on L1 or L1L2\n             circuits, and at L2 otherwise.')
isisPacketCountLSP = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 6), Counter32()).setUnits('Number of IS-IS LSP frames seen in this direction at\n             this level').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountLSP.setReference('{ISIS.aoi iSISControlPDUsSent (43)}')
if mibBuilder.loadTexts: isisPacketCountLSP.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountLSP.setDescription('The number of IS-IS LSPs seen in this\n             direction at this level.')
isisPacketCountCSNP = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 7), Counter32()).setUnits('Number of IS-IS CSNP frames seen in this direction at\n             this level').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountCSNP.setReference('{ISIS.aoi iSISControlPDUsSent (43)}')
if mibBuilder.loadTexts: isisPacketCountCSNP.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountCSNP.setDescription('The number of IS-IS CSNPs seen in this\n             direction at this level.')
isisPacketCountPSNP = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 8), Counter32()).setUnits('Number of IS-IS PSNP frames seen in this direction at\n             this level').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountPSNP.setReference('{ISIS.aoi iSISControlPDUsSent (43)}')
if mibBuilder.loadTexts: isisPacketCountPSNP.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountPSNP.setDescription('The number of IS-IS PSNPs seen in this\n             direction at this level.')
isisPacketCountUnknown = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 9), Counter32()).setUnits('Number of unknown IS-IS frames seen at this level').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountUnknown.setReference('{ISIS.aoi iSISControlPDUsSent (43)}')
if mibBuilder.loadTexts: isisPacketCountUnknown.setStatus('current')
if mibBuilder.loadTexts: isisPacketCountUnknown.setDescription('The number of unknown IS-IS PDUs seen\n             at this level.')
isisISAdjTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 1), )
if mibBuilder.loadTexts: isisISAdjTable.setStatus('current')
if mibBuilder.loadTexts: isisISAdjTable.setDescription('The table of adjacencies to Intermediate Systems.')
isisISAdjEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"))
if mibBuilder.loadTexts: isisISAdjEntry.setStatus('current')
if mibBuilder.loadTexts: isisISAdjEntry.setDescription('Each entry corresponds to one adjacency to an\n             Intermediate System on this system.\n\n             Dynamically learned rows do not survive an agent reboot.')
isisISAdjIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: isisISAdjIndex.setStatus('current')
if mibBuilder.loadTexts: isisISAdjIndex.setDescription('A unique value identifying the IS adjacency from all\n             other such adjacencies on this circuit.  This value is\n             automatically assigned by the system when the adjacency\n             is created.')
isisISAdjState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("down", 1), ("initializing", 2), ("up", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjState.setReference('{ISIS.aoi adjacencyState (78)}')
if mibBuilder.loadTexts: isisISAdjState.setStatus('current')
if mibBuilder.loadTexts: isisISAdjState.setDescription('The state of the adjacency.')
isisISAdj3WayState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("up", 0), ("initializing", 1), ("down", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdj3WayState.setReference('{ RFC 3373 }')
if mibBuilder.loadTexts: isisISAdj3WayState.setStatus('current')
if mibBuilder.loadTexts: isisISAdj3WayState.setDescription('The 3Way state of the adjacency.  These are picked\n             to match the historical on-the-wire representation\n             of the 3Way state and are not intended to match\n             isisISAdjState.')
isisISAdjNeighSNPAAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 4), IsisOSINSAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighSNPAAddress.setReference('{ISIS.aoi neighbourSNPAAddress (79)}')
if mibBuilder.loadTexts: isisISAdjNeighSNPAAddress.setStatus('current')
if mibBuilder.loadTexts: isisISAdjNeighSNPAAddress.setDescription('The SNPA address of the neighboring system.')
isisISAdjNeighSysType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("l1IntermediateSystem", 1), ("l2IntermediateSystem", 2), ("l1L2IntermediateSystem", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighSysType.setReference('{ISIS.aoi neighbourSystemType (80)}')
if mibBuilder.loadTexts: isisISAdjNeighSysType.setStatus('current')
if mibBuilder.loadTexts: isisISAdjNeighSysType.setDescription('The type of the neighboring system.')
isisISAdjNeighSysID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 6), IsisSystemID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighSysID.setReference('{ISIS.aoi neighbourSystemIds (83)}')
if mibBuilder.loadTexts: isisISAdjNeighSysID.setStatus('current')
if mibBuilder.loadTexts: isisISAdjNeighSysID.setDescription('The system ID of the neighboring Intermediate\n             System.')
isisISAdjNbrExtendedCircID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNbrExtendedCircID.setStatus('current')
if mibBuilder.loadTexts: isisISAdjNbrExtendedCircID.setDescription('The 4-byte Extended Circuit ID learned from the\n             Neighbor during 3-way handshake, or 0.')
isisISAdjUsage = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 8), IsisLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjUsage.setReference('{ISIS.aoi adjacencyUsage (82)}')
if mibBuilder.loadTexts: isisISAdjUsage.setStatus('current')
if mibBuilder.loadTexts: isisISAdjUsage.setDescription('How is the adjacency used?  On a point-to-point link,\n             this might be level1and2, but on a LAN, the usage will\n             be level1 on the adjacency between peers at L1,\n             and level2 for the adjacency between peers at L2.')
isisISAdjHoldTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 9), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjHoldTimer.setReference('{ISIS.aoi holdingTimer (85)}')
if mibBuilder.loadTexts: isisISAdjHoldTimer.setStatus('current')
if mibBuilder.loadTexts: isisISAdjHoldTimer.setDescription('The holding time, in seconds, for this adjacency.\n             This value is based on received IIH PDUs and\n             the elapsed time since receipt.')
isisISAdjNeighPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 10), IsisISPriority()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighPriority.setReference('{ISIS.aoi lANPriority (86)}')
if mibBuilder.loadTexts: isisISAdjNeighPriority.setStatus('current')
if mibBuilder.loadTexts: isisISAdjNeighPriority.setDescription('Priority of the neighboring Intermediate System for\n             becoming the Designated Intermediate System.')
isisISAdjLastUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjLastUpTime.setStatus('current')
if mibBuilder.loadTexts: isisISAdjLastUpTime.setDescription("When the adjacency most recently entered the state 'up',\n             measured in hundredths of a second since the last\n             re-initialization of the network management subsystem.\n             Holds 0 if the adjacency has never been in state 'up'.")
isisISAdjAreaAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 2), )
if mibBuilder.loadTexts: isisISAdjAreaAddrTable.setReference('{ISIS.aoi areaAddressesOfNeighbour (84)}')
if mibBuilder.loadTexts: isisISAdjAreaAddrTable.setStatus('current')
if mibBuilder.loadTexts: isisISAdjAreaAddrTable.setDescription('This table contains the set of Area Addresses of\n             neighboring Intermediate Systems as reported in received\n             IIH PDUs.')
isisISAdjAreaAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 2, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"), (0, "ISIS-MIB", "isisISAdjAreaAddrIndex"))
if mibBuilder.loadTexts: isisISAdjAreaAddrEntry.setStatus('current')
if mibBuilder.loadTexts: isisISAdjAreaAddrEntry.setDescription('Each entry contains one Area Address reported by a\n             neighboring Intermediate System in its IIH PDUs.\n\n             Dynamically learned rows do not survive an agent reboot.')
isisISAdjAreaAddrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: isisISAdjAreaAddrIndex.setStatus('current')
if mibBuilder.loadTexts: isisISAdjAreaAddrIndex.setDescription('An index for the areas associated with one neighbor.\n             This provides a simple way to walk the table.')
isisISAdjAreaAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 2, 1, 2), IsisOSINSAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjAreaAddress.setStatus('current')
if mibBuilder.loadTexts: isisISAdjAreaAddress.setDescription('One Area Address as reported in IIH PDUs received from\n             the neighbor.')
isisISAdjIPAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 3), )
if mibBuilder.loadTexts: isisISAdjIPAddrTable.setStatus('current')
if mibBuilder.loadTexts: isisISAdjIPAddrTable.setDescription('This table contains the set of IP Addresses of\n             neighboring Intermediate Systems as reported in received\n             IIH PDUs.')
isisISAdjIPAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"), (0, "ISIS-MIB", "isisISAdjIPAddrIndex"))
if mibBuilder.loadTexts: isisISAdjIPAddrEntry.setStatus('current')
if mibBuilder.loadTexts: isisISAdjIPAddrEntry.setDescription('Each entry contains one IP Address reported by a\n             neighboring Intermediate System in its IIH PDUs.\n\n             Dynamically learned rows do not survive an agent reboot.')
isisISAdjIPAddrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: isisISAdjIPAddrIndex.setStatus('current')
if mibBuilder.loadTexts: isisISAdjIPAddrIndex.setDescription('An index to this table that identifies the IP addresses\n             to which this entry belongs.')
isisISAdjIPAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjIPAddrType.setStatus('current')
if mibBuilder.loadTexts: isisISAdjIPAddrType.setDescription('The type of one IP Address as reported in IIH PDUs\n\n\n\n             received from the neighbor.')
isisISAdjIPAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjIPAddrAddress.setStatus('current')
if mibBuilder.loadTexts: isisISAdjIPAddrAddress.setDescription('One IP Address as reported in IIH PDUs received from the\n             neighbor.\n\n             The type of this address is determined by the value of\n             the isisISAdjIPAddrType object.')
isisISAdjProtSuppTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 4), )
if mibBuilder.loadTexts: isisISAdjProtSuppTable.setStatus('current')
if mibBuilder.loadTexts: isisISAdjProtSuppTable.setDescription('This table contains the set of protocols supported by\n             neighboring Intermediate Systems as reported in received\n             IIH PDUs.')
isisISAdjProtSuppEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 4, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"), (0, "ISIS-MIB", "isisISAdjProtSuppProtocol"))
if mibBuilder.loadTexts: isisISAdjProtSuppEntry.setStatus('current')
if mibBuilder.loadTexts: isisISAdjProtSuppEntry.setDescription('Each entry contains one protocol supported by a\n             neighboring Intermediate System as reported in its IIH\n             PDUs.\n\n             Dynamically learned rows do not survive an agent reboot.')
isisISAdjProtSuppProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 4, 1, 1), IsisSupportedProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjProtSuppProtocol.setStatus('current')
if mibBuilder.loadTexts: isisISAdjProtSuppProtocol.setDescription('One supported protocol as reported in IIH PDUs received\n             from the neighbor.')
isisRATable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 7, 1), )
if mibBuilder.loadTexts: isisRATable.setStatus('current')
if mibBuilder.loadTexts: isisRATable.setDescription('The table of Reachable Addresses to NSAPs or Address\n             Prefixes.')
isisRAEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1), ).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisRAIndex"))
if mibBuilder.loadTexts: isisRAEntry.setStatus('current')
if mibBuilder.loadTexts: isisRAEntry.setDescription('Each entry defines a configured Reachable Address\n             to an NSAP or Address Prefix.\n\n             Dynamically created rows MUST survive an agent reboot.')
isisRAIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: isisRAIndex.setStatus('current')
if mibBuilder.loadTexts: isisRAIndex.setDescription('The identifier for this isisRAEntry.  This value must be\n             unique amongst all Reachable Addresses on the same parent\n             Circuit.')
isisRAExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAExistState.setStatus('current')
if mibBuilder.loadTexts: isisRAExistState.setDescription("The existence state of this Reachable Address.  This\n             object follows the ManualOrAutomatic behaviors.  Support\n             for 'createAndWait' and 'notInService' is not required.\n\n             A row entry cannot be modified when the value of this\n             object is 'active'.")
isisRAAdminState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 3), IsisAdminState().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAAdminState.setStatus('current')
if mibBuilder.loadTexts: isisRAAdminState.setDescription('The administrative state of the Reachable Address.  This\n             object follows the ManualOrAutomatic behaviors.')
isisRAAddrPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 4), IsisOSINSAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAAddrPrefix.setReference('{ISIS.aoi addressPrefix (98)}')
if mibBuilder.loadTexts: isisRAAddrPrefix.setStatus('current')
if mibBuilder.loadTexts: isisRAAddrPrefix.setDescription('The destination of this Reachable Address.  This is an\n             Address Prefix.  This object follows the\n             ReplaceOnlyWhileDisabled and ManualOrAutomatic\n             behaviors.')
isisRAMapType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("explicit", 2), ("extractIDI", 3), ("extractDSP", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAMapType.setReference('{ISO10589-ISIS.aoi mappingType (107)}')
if mibBuilder.loadTexts: isisRAMapType.setStatus('current')
if mibBuilder.loadTexts: isisRAMapType.setDescription('The type of mapping to be employed to ascertain the SNPA\n             Address that should be used in forwarding PDUs for this\n             Reachable Address prefix.  This object follows the\n             ManualOrAutomatic behavior.  The following values of\n             mapping type are defined:\n\n                 none: The mapping is null because the neighbor SNPA is\n                       implicit by nature of the subnetwork (e.g., a\n                       point-to-point linkage).\n\n                 explicit: The subnetwork addresses in the object\n                       isisRASNPAAddress are to be used.\n\n                 extractIDI: The SNPA is embedded in the IDI of\n                       the destination NSAP Address.  The mapping\n                       algorithm extracts the SNPA to be used\n                       according to the format and encoding rules of\n                       ISO8473/Add2.  This SNPA extraction algorithm can\n                       be used in conjunction with Reachable Address\n                       prefixes from the X.121, F.69, E.163, and E.164\n\n\n\n                       addressing subdomains.\n\n                 extractDSP: All, or a suffix, of the SNPA is embedded\n                       in the DSP of the destination address.  This SNPA\n                       extraction algorithm extracts the embedded\n                       subnetwork addressing information by performing a\n                       logical AND of the isisRASNPAMask object value\n                       with the destination address.  The part of the\n                       SNPA extracted from the destination NSAP is\n                       appended to the isisRASNPAPrefix object value to\n                       form the next hop subnetwork addressing\n                       information.')
isisRAMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 6), IsisDefaultMetric().clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAMetric.setReference('{ISIS.aoi DefaultMetric (99)}')
if mibBuilder.loadTexts: isisRAMetric.setStatus('current')
if mibBuilder.loadTexts: isisRAMetric.setDescription('The metric value for reaching the specified\n             prefix over this circuit.  This object follows the\n             ManualOrAutomatic behavior.')
isisRAMetricType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 7), IsisMetricType().clone('internal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAMetricType.setReference('{ISIS.aoi DefaultMetricType (103)}')
if mibBuilder.loadTexts: isisRAMetricType.setStatus('current')
if mibBuilder.loadTexts: isisRAMetricType.setDescription('Indicates whether the metric is internal or\n             external.  This object follows the ManualOrAutomatic\n             behavior.')
isisRASNPAAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 8), IsisOSINSAddress().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRASNPAAddress.setReference('{ISIS.aoi sNPAAddresses (109)}')
if mibBuilder.loadTexts: isisRASNPAAddress.setStatus('current')
if mibBuilder.loadTexts: isisRASNPAAddress.setDescription('The SNPA Address to which a PDU may be forwarded in\n             order to reach a destination that matches the address\n             prefix of the Reachable Address.  This object follows the\n\n\n\n             ManualOrAutomatic behavior.')
isisRASNPAMask = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 9), IsisOSINSAddress().clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRASNPAMask.setReference('{ISIS.aoi sNPAMask (122)}')
if mibBuilder.loadTexts: isisRASNPAMask.setStatus('current')
if mibBuilder.loadTexts: isisRASNPAMask.setDescription('A bit mask with 1 bit indicating the positions in the\n             effective destination address from which embedded SNPA\n             information is to be extracted.  For the extraction, the\n             first octet of the isisRASNPAMask object value is aligned\n             with the first octet (AFI) of the NSAP Address.  If the\n             isisRASNPAMask object value and NSAP Address are of\n             different lengths, the shorter of the two is logically\n             padded with zeros before performing the extraction.  This\n             object follows the ManualOrAutomatic behavior.')
isisRASNPAPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 10), IsisOSINSAddress().clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRASNPAPrefix.setReference('{ISIS.aoi sNPAPrefix (123)}')
if mibBuilder.loadTexts: isisRASNPAPrefix.setStatus('current')
if mibBuilder.loadTexts: isisRASNPAPrefix.setDescription('A fixed SNPA prefix for use when the isisRAMapType is\n             extractDSP.  The SNPA Address to use is formed by\n             concatenating the fixed SNPA prefix with a variable SNPA\n             part that is extracted from the effective destination\n             address.  For Reachable Address prefixes in which the\n             entire SNPA is embedded in the DSP, the SNPA Prefix shall\n             be null.  This object follows the ManualOrAutomatic\n             behavior.')
isisRAType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("automatic", 2))).clone('manual')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAType.setStatus('current')
if mibBuilder.loadTexts: isisRAType.setDescription('The type of Reachable address.  Those of type\n             manual are created by the network manager.  Those\n             of type automatic are created through propagation\n             of routing information from another routing\n             protocol (e.g., IDRP). ')
isisIPRATable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 8, 1), )
if mibBuilder.loadTexts: isisIPRATable.setStatus('current')
if mibBuilder.loadTexts: isisIPRATable.setDescription('The table of IP Reachable Addresses to networks,\n             subnetworks, or hosts either manually configured or\n             learned from another protocol.')
isisIPRAEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1), ).setIndexNames((0, "ISIS-MIB", "isisSysLevelIndex"), (0, "ISIS-MIB", "isisIPRADestType"), (0, "ISIS-MIB", "isisIPRADest"), (0, "ISIS-MIB", "isisIPRADestPrefixLen"), (0, "ISIS-MIB", "isisIPRANextHopIndex"))
if mibBuilder.loadTexts: isisIPRAEntry.setStatus('current')
if mibBuilder.loadTexts: isisIPRAEntry.setDescription('Each entry defines an IP Reachable Address to a network,\n             subnetwork, or host.\n\n             Each IP Reachable Address may have multiple entries in the\n             table, one for each equal cost path to the reachable\n             address.\n\n             Dynamically created rows MUST survive an agent reboot.\n\n             Implementers need to be aware that if the total number\n             of elements (octets or sub-identifiers) in\n             isisIPRADestr, isisIPRADestPrefixLen, and\n             isisIPRANextHopIndex is too great, then OIDs of column\n             instances in this table will have more than 128\n             subidentifiers and cannot be accessed using SNMPv1,\n\n\n\n             SNMPv2c, or SNMPv3.')
isisIPRADestType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 1), InetAddressType())
if mibBuilder.loadTexts: isisIPRADestType.setStatus('current')
if mibBuilder.loadTexts: isisIPRADestType.setDescription('The type of this IP Reachable Address.')
isisIPRADest = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 2), InetAddress())
if mibBuilder.loadTexts: isisIPRADest.setStatus('current')
if mibBuilder.loadTexts: isisIPRADest.setDescription('The destination of this IP Reachable Address.  This is\n             a network address, subnetwork address, or host\n             address.\n\n             The type of this address is determined by the value of\n             the isisIPRADestType object.')
isisIPRADestPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: isisIPRADestPrefixLen.setStatus('current')
if mibBuilder.loadTexts: isisIPRADestPrefixLen.setDescription('The length of the IP Netmask for Reachability Address.\n\n             The values for the index objects isisIPRADest and\n             isisIPRADestPrefixLen must be consistent.  When the value\n             of isisIPRADest (excluding the zone index, if one\n             is present) is x, then the bitwise logical-AND\n             of x with the value of the mask formed from the\n             corresponding index object isisIPRADestPrefixLen MUST be\n             equal to x.  If not, then the index pair is not\n             consistent, and an inconsistentName error must be\n             returned on SET or CREATE requests.')
isisIPRANextHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: isisIPRANextHopIndex.setStatus('current')
if mibBuilder.loadTexts: isisIPRANextHopIndex.setDescription('Index of next hop.  Used when there are multiple Equal\n             Cost Multipath alternatives for the same destination.')
isisIPRANextHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRANextHopType.setStatus('current')
if mibBuilder.loadTexts: isisIPRANextHopType.setDescription('The type of the IP next hop address.')
isisIPRANextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRANextHop.setStatus('current')
if mibBuilder.loadTexts: isisIPRANextHop.setDescription('The IP next hop to this destination.\n\n             The type of this address is determined by the value of\n             the isisIPRANextHopType object.')
isisIPRAType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("automatic", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAType.setStatus('current')
if mibBuilder.loadTexts: isisIPRAType.setDescription('The type of this IP Reachable Address.  Those of type\n             manual are created by the network manager.  Those of type\n             automatic are created through propagation of routing\n             information from another routing protocol.  This object\n             follows the ManualOrAutomatic behavior.')
isisIPRAExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAExistState.setStatus('current')
if mibBuilder.loadTexts: isisIPRAExistState.setDescription("The state of this IP Reachable Address.  This object\n             follows the ExistenceState and ManualOrAutomatic\n             behaviors.  Support for 'createAndWait' and\n             'notInService' is not required.\n\n             A row entry cannot be modified when the value of this\n             object is 'active'.")
isisIPRAAdminState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 9), IsisAdminState().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAAdminState.setStatus('current')
if mibBuilder.loadTexts: isisIPRAAdminState.setDescription('The administrative state of the IP Reachable Address.  This\n             object follows the IsisAdminState and ManualOrAutomatic\n\n\n\n             behaviors.')
isisIPRAMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 10), IsisDefaultMetric().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAMetric.setStatus('current')
if mibBuilder.loadTexts: isisIPRAMetric.setDescription('The metric value for reaching the specified\n             destination over this circuit.  This object follows the\n             ManualOrAutomatic behavior.')
isisIPRAMetricType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 11), IsisMetricType().clone('internal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAMetricType.setStatus('current')
if mibBuilder.loadTexts: isisIPRAMetricType.setDescription('Indicates whether the metric is internal or\n             external.  This object follows the ManualOrAutomatic\n             behavior.')
isisIPRAFullMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 12), IsisFullMetric().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAFullMetric.setStatus('current')
if mibBuilder.loadTexts: isisIPRAFullMetric.setDescription('The wide metric value for reaching the specified\n             destination over this circuit.  This object follows the\n             ManualOrAutomatic behavior.')
isisIPRASNPAAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 13), IsisOSINSAddress().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRASNPAAddress.setStatus('current')
if mibBuilder.loadTexts: isisIPRASNPAAddress.setDescription('The SNPA Address to which a PDU may be forwarded in\n             order to reach a destination that matches this IP\n             Reachable Address.  This object follows the\n             ManualOrAutomatic behavior.')
isisIPRASourceType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("static", 1), ("direct", 2), ("ospfv2", 3), ("ospfv3", 4), ("isis", 5), ("rip", 6), ("igrp", 7), ("eigrp", 8), ("bgp", 9), ("other", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisIPRASourceType.setStatus('current')
if mibBuilder.loadTexts: isisIPRASourceType.setDescription('The origin of this route.')
isisLSPSummaryTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 9, 1), )
if mibBuilder.loadTexts: isisLSPSummaryTable.setStatus('current')
if mibBuilder.loadTexts: isisLSPSummaryTable.setDescription('The table of LSP Headers.')
isisLSPSummaryEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1), ).setIndexNames((0, "ISIS-MIB", "isisLSPLevel"), (0, "ISIS-MIB", "isisLSPID"))
if mibBuilder.loadTexts: isisLSPSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: isisLSPSummaryEntry.setDescription('Each entry provides a summary describing an\n             LSP currently stored in the system.\n\n             Dynamically learned rows will not survive an\n             agent reboot.')
isisLSPLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 1), IsisISLevel())
if mibBuilder.loadTexts: isisLSPLevel.setStatus('current')
if mibBuilder.loadTexts: isisLSPLevel.setDescription('At which level does this LSP appear?')
isisLSPID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 2), IsisLinkStatePDUID())
if mibBuilder.loadTexts: isisLSPID.setStatus('current')
if mibBuilder.loadTexts: isisLSPID.setDescription('The 8-byte LSP ID for this Link State PDU.')
isisLSPSeq = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPSeq.setStatus('current')
if mibBuilder.loadTexts: isisLSPSeq.setDescription('The sequence number for this LSP.')
isisLSPZeroLife = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPZeroLife.setStatus('current')
if mibBuilder.loadTexts: isisLSPZeroLife.setDescription('Is this LSP being purged by this system?')
isisLSPChecksum = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 5), IsisUnsigned16TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPChecksum.setStatus('current')
if mibBuilder.loadTexts: isisLSPChecksum.setDescription('The 16-bit Fletcher Checksum for this LSP.')
isisLSPLifetimeRemain = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 6), IsisUnsigned16TC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPLifetimeRemain.setStatus('current')
if mibBuilder.loadTexts: isisLSPLifetimeRemain.setDescription('The remaining lifetime, in seconds, for this LSP.')
isisLSPPDULength = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 7), IsisUnsigned16TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPPDULength.setStatus('current')
if mibBuilder.loadTexts: isisLSPPDULength.setDescription('The length of this LSP.')
isisLSPAttributes = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 8), IsisUnsigned8TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPAttributes.setStatus('current')
if mibBuilder.loadTexts: isisLSPAttributes.setDescription('Flags carried by the LSP.')
isisLSPTLVTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 9, 2), )
if mibBuilder.loadTexts: isisLSPTLVTable.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVTable.setDescription('The table of LSPs in the database.')
isisLSPTLVEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1), ).setIndexNames((0, "ISIS-MIB", "isisLSPLevel"), (0, "ISIS-MIB", "isisLSPID"), (0, "ISIS-MIB", "isisLSPTLVIndex"))
if mibBuilder.loadTexts: isisLSPTLVEntry.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVEntry.setDescription('Each entry describes a TLV within\n             an LSP currently stored in the system.\n\n             Dynamically learned rows will not survive an\n             agent reboot.')
isisLSPTLVIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: isisLSPTLVIndex.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVIndex.setDescription('The index of this TLV in the LSP.  The first TLV has\n             index 1, and the Nth TLV has an index of N.')
isisLSPTLVSeq = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVSeq.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVSeq.setDescription('The sequence number for this LSP.')
isisLSPTLVChecksum = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 3), IsisUnsigned16TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVChecksum.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVChecksum.setDescription('The 16-bit Fletcher Checksum for this LSP.')
isisLSPTLVType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 4), IsisUnsigned8TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVType.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVType.setDescription('The type of this TLV.')
isisLSPTLVLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 5), IsisUnsigned8TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVLen.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVLen.setDescription('The length of this TLV.')
isisLSPTLVValue = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVValue.setStatus('current')
if mibBuilder.loadTexts: isisLSPTLVValue.setDescription('The value of this TLV.')
isisNotificationEntry = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 10, 1))
isisNotificationSysLevelIndex = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 1), IsisLevel()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisNotificationSysLevelIndex.setStatus('current')
if mibBuilder.loadTexts: isisNotificationSysLevelIndex.setDescription('The system level for this notification.')
isisNotificationCircIfIndex = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisNotificationCircIfIndex.setStatus('current')
if mibBuilder.loadTexts: isisNotificationCircIfIndex.setDescription('The identifier of this circuit relevant to\n             this notification.')
isisPduLspId = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 3), IsisLinkStatePDUID()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduLspId.setStatus('current')
if mibBuilder.loadTexts: isisPduLspId.setDescription('An Octet String that uniquely identifies\n             a Link State PDU.')
isisPduFragment = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 4), IsisPDUHeader()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduFragment.setStatus('current')
if mibBuilder.loadTexts: isisPduFragment.setDescription('Holds up to 64 initial bytes of a PDU that\n             triggered the notification.')
isisPduFieldLen = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 5), IsisUnsigned8TC()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduFieldLen.setStatus('current')
if mibBuilder.loadTexts: isisPduFieldLen.setDescription('Holds the System ID length reported in PDU we received.')
isisPduMaxAreaAddress = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 6), IsisUnsigned8TC()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduMaxAreaAddress.setStatus('current')
if mibBuilder.loadTexts: isisPduMaxAreaAddress.setDescription('Holds the Max Area Addresses reported in a PDU\n             we received.')
isisPduProtocolVersion = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 7), IsisUnsigned8TC()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: isisPduProtocolVersion.setDescription('Holds the Protocol version reported in PDU we received.')
isisPduLspSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduLspSize.setStatus('current')
if mibBuilder.loadTexts: isisPduLspSize.setDescription('Holds the size of LSP we received that is too\n             big to forward.')
isisPduOriginatingBufferSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 9), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduOriginatingBufferSize.setStatus('current')
if mibBuilder.loadTexts: isisPduOriginatingBufferSize.setDescription('Holds the size of isisSysLevelOrigLSPBuffSize advertised\n             by the peer in the originatingLSPBufferSize TLV.\n             If the peer does not advertise this TLV, this\n             value is set to 0.')
isisPduBufferSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 10), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduBufferSize.setStatus('current')
if mibBuilder.loadTexts: isisPduBufferSize.setDescription('Holds the size of LSP received from peer.')
isisPduProtocolsSupported = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisPduProtocolsSupported.setStatus('current')
if mibBuilder.loadTexts: isisPduProtocolsSupported.setDescription('The list of protocols supported by an\n             adjacent system.  This may be empty.')
isisAdjState = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("down", 1), ("initializing", 2), ("up", 3), ("failed", 4)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisAdjState.setStatus('current')
if mibBuilder.loadTexts: isisAdjState.setDescription('The current state of an adjacency.')
isisErrorOffset = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 13), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisErrorOffset.setStatus('current')
if mibBuilder.loadTexts: isisErrorOffset.setDescription('An offset to a problem in a PDU.  If the problem\n             is a malformed TLV, this points to the beginning\n             of the TLV.  If the problem is in the header, this\n             points to the byte that is suspicious.')
isisErrorTLVType = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisErrorTLVType.setStatus('current')
if mibBuilder.loadTexts: isisErrorTLVType.setDescription('The type for a malformed TLV.')
isisNotificationAreaAddress = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 15), IsisOSINSAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: isisNotificationAreaAddress.setStatus('current')
if mibBuilder.loadTexts: isisNotificationAreaAddress.setDescription('An Area Address.')
isisDatabaseOverload = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 1)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisSysLevelState"))
if mibBuilder.loadTexts: isisDatabaseOverload.setStatus('current')
if mibBuilder.loadTexts: isisDatabaseOverload.setDescription('This notification is generated when the system\n             enters or leaves the Overload state.  The number\n             of times this has been generated and cleared is kept\n             track of by isisSysStatLSPDbaseOloads.')
isisManualAddressDrops = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 2)).setObjects(("ISIS-MIB", "isisNotificationAreaAddress"))
if mibBuilder.loadTexts: isisManualAddressDrops.setStatus('current')
if mibBuilder.loadTexts: isisManualAddressDrops.setDescription('This notification is generated when one of the\n             manual areaAddresses assigned to this system is\n             ignored when computing routes.  The object\n             isisNotificationAreaAddress describes the area that\n             has been dropped.\n\n             The number of times this event has been generated\n             is counted by isisSysStatManAddrDropFromAreas.\n\n             The agent must throttle the generation of\n             consecutive isisManualAddressDrops notifications\n             so that there is at least a 5-second gap between\n             notifications of this type.  When notifications\n             are throttled, they are dropped, not queued for\n             sending at a future time.')
isisCorruptedLSPDetected = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 3)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisPduLspId"))
if mibBuilder.loadTexts: isisCorruptedLSPDetected.setStatus('current')
if mibBuilder.loadTexts: isisCorruptedLSPDetected.setDescription('This notification is generated when we find that\n             an LSP that was stored in memory has become\n             corrupted.  The number of times this has been\n             generated is counted by isisSysCorrLSPs.\n\n             We forward an LSP ID.  We may have independent\n             knowledge of the ID, but in some implementations\n             there is a chance that the ID itself will be\n             corrupted.')
isisAttemptToExceedMaxSequence = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 4)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisPduLspId"))
if mibBuilder.loadTexts: isisAttemptToExceedMaxSequence.setStatus('current')
if mibBuilder.loadTexts: isisAttemptToExceedMaxSequence.setDescription('When the sequence number on an LSP we generate\n             wraps the 32-bit sequence counter, we purge and\n             wait to re-announce this information.  This\n             notification describes that event.  Since these\n             should not be generated rapidly, we generate\n             an event each time this happens.\n\n             While the first 6 bytes of the LSPID are ours,\n             the other two contain useful information.')
isisIDLenMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 5)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisPduFieldLen"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisIDLenMismatch.setStatus('current')
if mibBuilder.loadTexts: isisIDLenMismatch.setDescription('A notification sent when we receive a PDU\n             with a different value for the System ID Length.\n             This notification includes an index to identify\n             the circuit where we saw the PDU and the header of\n             the PDU, which may help a network manager identify\n             the source of the confusion.\n\n             The agent must throttle the generation of\n             consecutive isisIDLenMismatch notifications\n             so that there is at least a 5-second gap between\n             notifications of this type.  When notifications\n             are throttled, they are dropped, not queued for\n             sending at a future time.')
isisMaxAreaAddressesMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 6)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisPduMaxAreaAddress"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisMaxAreaAddressesMismatch.setStatus('current')
if mibBuilder.loadTexts: isisMaxAreaAddressesMismatch.setDescription('A notification sent when we receive a PDU\n             with a different value for the Maximum Area\n             Addresses.  This notification includes the\n             header of the packet, which may help a\n             network manager identify the source of the\n             confusion.\n\n             The agent must throttle the generation of\n             consecutive isisMaxAreaAddressesMismatch\n             notifications so that there is at least a 5-second\n             gap between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisOwnLSPPurge = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 7)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"))
if mibBuilder.loadTexts: isisOwnLSPPurge.setStatus('current')
if mibBuilder.loadTexts: isisOwnLSPPurge.setDescription('A notification sent when we receive a PDU\n             with our systemID and zero age.  This\n             notification includes the circuit Index\n             and router ID from the LSP, if available,\n             which may help a network manager\n             identify the source of the confusion.')
isisSequenceNumberSkip = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 8)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"))
if mibBuilder.loadTexts: isisSequenceNumberSkip.setStatus('current')
if mibBuilder.loadTexts: isisSequenceNumberSkip.setDescription('When we receive an LSP with our System ID\n             and different contents, we may need to reissue\n             the LSP with a higher sequence number.\n\n             We send this notification if we need to increase\n             the sequence number by more than one.  If two\n             Intermediate Systems are configured with the same\n             System ID, this notification will fire.')
isisAuthenticationTypeFailure = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 9)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisAuthenticationTypeFailure.setStatus('current')
if mibBuilder.loadTexts: isisAuthenticationTypeFailure.setDescription('A notification sent when we receive a PDU\n             with the wrong authentication type field.\n             This notification includes the header of the\n             packet, which may help a network manager\n             identify the source of the confusion.\n\n             The agent must throttle the generation of\n             consecutive isisAuthenticationTypeFailure\n             notifications so that there is at least a 5-second\n             gap between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisAuthenticationFailure = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 10)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisAuthenticationFailure.setStatus('current')
if mibBuilder.loadTexts: isisAuthenticationFailure.setDescription('A notification sent when we receive a PDU\n             with an incorrect authentication information\n             field.  This notification includes the header\n             of the packet, which may help a network manager\n             identify the source of the confusion.\n\n\n\n             The agent must throttle the generation of\n             consecutive isisAuthenticationFailure\n             notifications so that there is at least a 5-second\n             gap between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisVersionSkew = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 11)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduProtocolVersion"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisVersionSkew.setStatus('current')
if mibBuilder.loadTexts: isisVersionSkew.setDescription('A notification sent when we receive a Hello\n             PDU from an IS running a different version\n             of the protocol.  This notification includes\n             the header of the packet, which may help a\n             network manager identify the source of the\n             confusion.\n\n             The agent must throttle the generation of\n             consecutive isisVersionSkew notifications\n             so that there is at least a 5-second gap\n             between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisAreaMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 12)).setObjects(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisAreaMismatch.setStatus('current')
if mibBuilder.loadTexts: isisAreaMismatch.setDescription('A notification sent when we receive a Hello\n             PDU from an IS that does not share any\n             area address.  This notification includes\n             the header of the packet, which may help a\n             network manager identify the source of the\n             confusion.\n\n\n\n\n             The agent must throttle the generation of\n             consecutive isisAreaMismatch notifications\n             so that there is at least a 5-second gap\n             between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisRejectedAdjacency = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 13)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisRejectedAdjacency.setStatus('current')
if mibBuilder.loadTexts: isisRejectedAdjacency.setDescription('A notification sent when we receive a Hello\n             PDU from an IS but do not establish an\n             adjacency for some reason.\n\n             The agent must throttle the generation of\n             consecutive isisRejectedAdjacency notifications\n             so that there is at least a 5-second gap\n             between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisLSPTooLargeToPropagate = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 14)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspSize"), ("ISIS-MIB", "isisPduLspId"))
if mibBuilder.loadTexts: isisLSPTooLargeToPropagate.setStatus('current')
if mibBuilder.loadTexts: isisLSPTooLargeToPropagate.setDescription('A notification sent when we attempt to propagate\n             an LSP that is larger than the dataLinkBlockSize\n             for the circuit.\n\n             The agent must throttle the generation of\n             consecutive isisLSPTooLargeToPropagate notifications\n             so that there is at least a 5-second gap\n             between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n\n\n\n             queued for sending at a future time.')
isisOrigLSPBuffSizeMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 15)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisPduOriginatingBufferSize"), ("ISIS-MIB", "isisPduBufferSize"))
if mibBuilder.loadTexts: isisOrigLSPBuffSizeMismatch.setStatus('current')
if mibBuilder.loadTexts: isisOrigLSPBuffSizeMismatch.setDescription('A notification sent when a Level 1 LSP or Level\n             2 LSP is received that is larger than the local\n             value for isisSysLevelOrigLSPBuffSize, or when an\n             LSP is received that contains the supported Buffer Size\n             option and the value in the PDU option field does\n             not match the local value for isisSysLevelOrigLSPBuffSize.\n             We pass up the size from the option field and the\n             size of the LSP when one of them exceeds our configuration.\n\n             The agent must throttle the generation of\n             consecutive isisOrigLSPBuffSizeMismatch notifications\n             so that there is at least a 5-second gap\n             between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisProtocolsSupportedMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 16)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduProtocolsSupported"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisPduFragment"))
if mibBuilder.loadTexts: isisProtocolsSupportedMismatch.setStatus('current')
if mibBuilder.loadTexts: isisProtocolsSupportedMismatch.setDescription('A notification sent when a non-pseudonode\n             segment 0 LSP is received that has no matching\n             protocols supported.  This may be because the system\n             does not generate the field, or because there are no\n             common elements.  The list of protocols supported\n             should be included in the notification: it may be\n\n\n\n             empty if the TLV is not supported, or if the\n             TLV is empty.\n\n             The agent must throttle the generation of\n             consecutive isisProtocolsSupportedMismatch\n             notifications so that there is at least a 5-second\n             gap between notifications of this type.  When\n             notifications are throttled, they are dropped, not\n             queued for sending at a future time.')
isisAdjacencyChange = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 17)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisAdjState"))
if mibBuilder.loadTexts: isisAdjacencyChange.setStatus('current')
if mibBuilder.loadTexts: isisAdjacencyChange.setDescription('A notification sent when an adjacency changes\n             state, entering or leaving state up.\n             The first 6 bytes of the isisPduLspId are the\n             SystemID of the adjacent IS.\n             The isisAdjState is the new state of the adjacency.')
isisLSPErrorDetected = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 18)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisErrorOffset"), ("ISIS-MIB", "isisErrorTLVType"))
if mibBuilder.loadTexts: isisLSPErrorDetected.setStatus('current')
if mibBuilder.loadTexts: isisLSPErrorDetected.setDescription('This notification is generated when we receive\n             an LSP with a parse error.  The isisCircIfIndex\n             holds an index of the circuit on which the PDU\n             arrived.  The isisPduFragment holds the start of the\n             LSP, and the isisErrorOffset points to the problem.\n\n             If the problem is a malformed TLV, isisErrorOffset\n             points to the start of the TLV, and isisErrorTLVType\n\n\n\n             holds the value of the type.\n\n             If the problem is with the LSP header, isisErrorOffset\n             points to the suspicious byte.\n\n             The number of such LSPs is accumulated in\n             isisSysStatLSPErrors.')
isisCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 2, 1))
isisGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 2, 2))
isisCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 138, 2, 1, 1)).setObjects(("ISIS-MIB", "isisSystemGroup"), ("ISIS-MIB", "isisCircuitGroup"), ("ISIS-MIB", "isisISAdjGroup"), ("ISIS-MIB", "isisNotificationObjectGroup"), ("ISIS-MIB", "isisNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisCompliance = isisCompliance.setStatus('current')
if mibBuilder.loadTexts: isisCompliance.setDescription('The compliance statement for agents that support\n             the IS-IS MIB.\n\n             There are a number of INDEX objects that cannot be\n             represented in the form of OBJECT clauses in SMIv2,\n             but for which there are compliance requirements.\n             Those requirements and similar requirements for\n             related objects are expressed below, in\n             pseudo-OBJECT clause form, in this description:\n\n             -- OBJECT isisSummAddressType\n             -- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n             --\n             -- DESCRIPTION\n             --    The MIB requires support for IPv4 Summary\n             --    Addresses and anticipates the support of\n             --    IPv6 addresses.\n             --\n             --\n             -- OBJECT isisRedistributeAddrType\n             -- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n             --\n             -- DESCRIPTION\n             --    The MIB requires support for IPv4\n             --    Redistribution Addresses and anticipates\n             --    the support of IPv6 addresses.')
isisAdvancedCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 138, 2, 1, 2)).setObjects(("ISIS-MIB", "isisSystemGroup"), ("ISIS-MIB", "isisCircuitGroup"), ("ISIS-MIB", "isisISAdjGroup"), ("ISIS-MIB", "isisNotificationObjectGroup"), ("ISIS-MIB", "isisNotificationGroup"), ("ISIS-MIB", "isisISPDUCounterGroup"), ("ISIS-MIB", "isisRATableGroup"), ("ISIS-MIB", "isisISIPRADestGroup"), ("ISIS-MIB", "isisLSPGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisAdvancedCompliance = isisAdvancedCompliance.setStatus('current')
if mibBuilder.loadTexts: isisAdvancedCompliance.setDescription('The compliance statement for agents that fully\n             support the IS-IS MIB.\n\n             There are a number of INDEX objects that cannot be\n             represented in the form of OBJECT clauses in SMIv2,\n             but for which there are compliance requirements.\n             Those requirements and similar requirements for\n             related objects are expressed below, in\n             pseudo-OBJECT clause form, in this description:\n\n             -- OBJECT isisSummAddressType\n             -- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n             --\n             -- DESCRIPTION\n             --    The MIB requires support for IPv4 Summary\n             --    Addresses and anticipates the support of\n             --    IPv6 addresses.\n             --\n             --\n             -- OBJECT isisRedistributeAddrType\n             -- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n             --\n             -- DESCRIPTION\n             --    The MIB requires support for IPv4\n             --    Redistribution Addresses and anticipates\n             --    the support of IPv6 addresses.')
isisReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 138, 2, 1, 3)).setObjects(("ISIS-MIB", "isisSystemGroup"), ("ISIS-MIB", "isisCircuitGroup"), ("ISIS-MIB", "isisISAdjGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisReadOnlyCompliance = isisReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: isisReadOnlyCompliance.setDescription('When this MIB is implemented without support for\n                read-create (i.e., in read-only mode), the\n                implementation can claim read-only compliance.  Such\n                a device can then be monitored but cannot be\n\n\n\n                configured with this MIB.')
isisSystemGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 1)).setObjects(("ISIS-MIB", "isisSysVersion"), ("ISIS-MIB", "isisSysLevelType"), ("ISIS-MIB", "isisSysID"), ("ISIS-MIB", "isisSysMaxPathSplits"), ("ISIS-MIB", "isisSysMaxLSPGenInt"), ("ISIS-MIB", "isisSysPollESHelloRate"), ("ISIS-MIB", "isisSysWaitTime"), ("ISIS-MIB", "isisSysAdminState"), ("ISIS-MIB", "isisSysL2toL1Leaking"), ("ISIS-MIB", "isisSysMaxAge"), ("ISIS-MIB", "isisSysProtSupported"), ("ISIS-MIB", "isisSysNotificationEnable"), ("ISIS-MIB", "isisManAreaAddrExistState"), ("ISIS-MIB", "isisSysLevelOrigLSPBuffSize"), ("ISIS-MIB", "isisSysLevelMinLSPGenInt"), ("ISIS-MIB", "isisSysLevelState"), ("ISIS-MIB", "isisSysLevelSetOverload"), ("ISIS-MIB", "isisSysLevelSetOverloadUntil"), ("ISIS-MIB", "isisSysLevelMetricStyle"), ("ISIS-MIB", "isisSysLevelSPFConsiders"), ("ISIS-MIB", "isisSysLevelTEEnabled"), ("ISIS-MIB", "isisSysReceiveLSPBufferSize"), ("ISIS-MIB", "isisSummAddrExistState"), ("ISIS-MIB", "isisSummAddrMetric"), ("ISIS-MIB", "isisAreaAddr"), ("ISIS-MIB", "isisSummAddrFullMetric"), ("ISIS-MIB", "isisRedistributeAddrExistState"), ("ISIS-MIB", "isisRouterHostName"), ("ISIS-MIB", "isisRouterID"), ("ISIS-MIB", "isisSysStatCorrLSPs"), ("ISIS-MIB", "isisSysStatLSPDbaseOloads"), ("ISIS-MIB", "isisSysStatManAddrDropFromAreas"), ("ISIS-MIB", "isisSysStatAttmptToExMaxSeqNums"), ("ISIS-MIB", "isisSysStatSeqNumSkips"), ("ISIS-MIB", "isisSysStatOwnLSPPurges"), ("ISIS-MIB", "isisSysStatIDFieldLenMismatches"), ("ISIS-MIB", "isisSysStatPartChanges"), ("ISIS-MIB", "isisSysStatSPFRuns"), ("ISIS-MIB", "isisSysStatAuthTypeFails"), ("ISIS-MIB", "isisSysStatAuthFails"), ("ISIS-MIB", "isisSysStatLSPErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisSystemGroup = isisSystemGroup.setStatus('current')
if mibBuilder.loadTexts: isisSystemGroup.setDescription('The collections of objects used to manage an\n             IS-IS router.')
isisCircuitGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 2)).setObjects(("ISIS-MIB", "isisNextCircIndex"), ("ISIS-MIB", "isisCircAdminState"), ("ISIS-MIB", "isisCircExistState"), ("ISIS-MIB", "isisCircType"), ("ISIS-MIB", "isisCircExtDomain"), ("ISIS-MIB", "isisCircLevelType"), ("ISIS-MIB", "isisCircAdjChanges"), ("ISIS-MIB", "isisCircNumAdj"), ("ISIS-MIB", "isisCircInitFails"), ("ISIS-MIB", "isisCircRejAdjs"), ("ISIS-MIB", "isisCircIDFieldLenMismatches"), ("ISIS-MIB", "isisCircMaxAreaAddrMismatches"), ("ISIS-MIB", "isisCircAuthTypeFails"), ("ISIS-MIB", "isisCircAuthFails"), ("ISIS-MIB", "isisCircLANDesISChanges"), ("ISIS-MIB", "isisCircPassiveCircuit"), ("ISIS-MIB", "isisCircMeshGroupEnabled"), ("ISIS-MIB", "isisCircMeshGroup"), ("ISIS-MIB", "isisCircSmallHellos"), ("ISIS-MIB", "isisCircLastUpTime"), ("ISIS-MIB", "isisCirc3WayEnabled"), ("ISIS-MIB", "isisCircExtendedCircID"), ("ISIS-MIB", "isisCircIfIndex"), ("ISIS-MIB", "isisCircLevelMetric"), ("ISIS-MIB", "isisCircLevelWideMetric"), ("ISIS-MIB", "isisCircLevelISPriority"), ("ISIS-MIB", "isisCircLevelIDOctet"), ("ISIS-MIB", "isisCircLevelID"), ("ISIS-MIB", "isisCircLevelDesIS"), ("ISIS-MIB", "isisCircLevelHelloMultiplier"), ("ISIS-MIB", "isisCircLevelHelloTimer"), ("ISIS-MIB", "isisCircLevelDRHelloTimer"), ("ISIS-MIB", "isisCircLevelLSPThrottle"), ("ISIS-MIB", "isisCircLevelMinLSPRetransInt"), ("ISIS-MIB", "isisCircLevelCSNPInterval"), ("ISIS-MIB", "isisCircLevelPartSNPInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisCircuitGroup = isisCircuitGroup.setStatus('current')
if mibBuilder.loadTexts: isisCircuitGroup.setDescription('The collections of objects used to describe an\n             IS-IS Circuit.')
isisISAdjGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 3)).setObjects(("ISIS-MIB", "isisISAdjState"), ("ISIS-MIB", "isisISAdj3WayState"), ("ISIS-MIB", "isisISAdjNeighSNPAAddress"), ("ISIS-MIB", "isisISAdjNeighSysType"), ("ISIS-MIB", "isisISAdjNeighSysID"), ("ISIS-MIB", "isisISAdjNbrExtendedCircID"), ("ISIS-MIB", "isisISAdjUsage"), ("ISIS-MIB", "isisISAdjHoldTimer"), ("ISIS-MIB", "isisISAdjNeighPriority"), ("ISIS-MIB", "isisISAdjLastUpTime"), ("ISIS-MIB", "isisISAdjAreaAddress"), ("ISIS-MIB", "isisISAdjIPAddrType"), ("ISIS-MIB", "isisISAdjIPAddrAddress"), ("ISIS-MIB", "isisISAdjProtSuppProtocol"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisISAdjGroup = isisISAdjGroup.setStatus('current')
if mibBuilder.loadTexts: isisISAdjGroup.setDescription('The collections of objects used to manage an\n             IS-IS Adjacency.')
isisNotificationObjectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 4)).setObjects(("ISIS-MIB", "isisNotificationSysLevelIndex"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisPduFieldLen"), ("ISIS-MIB", "isisPduMaxAreaAddress"), ("ISIS-MIB", "isisPduProtocolVersion"), ("ISIS-MIB", "isisPduLspSize"), ("ISIS-MIB", "isisPduOriginatingBufferSize"), ("ISIS-MIB", "isisPduBufferSize"), ("ISIS-MIB", "isisPduProtocolsSupported"), ("ISIS-MIB", "isisAdjState"), ("ISIS-MIB", "isisErrorOffset"), ("ISIS-MIB", "isisErrorTLVType"), ("ISIS-MIB", "isisNotificationAreaAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisNotificationObjectGroup = isisNotificationObjectGroup.setStatus('current')
if mibBuilder.loadTexts: isisNotificationObjectGroup.setDescription('The objects used to record notification parameters.')
isisNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 5)).setObjects(("ISIS-MIB", "isisDatabaseOverload"), ("ISIS-MIB", "isisManualAddressDrops"), ("ISIS-MIB", "isisCorruptedLSPDetected"), ("ISIS-MIB", "isisAttemptToExceedMaxSequence"), ("ISIS-MIB", "isisIDLenMismatch"), ("ISIS-MIB", "isisMaxAreaAddressesMismatch"), ("ISIS-MIB", "isisOwnLSPPurge"), ("ISIS-MIB", "isisSequenceNumberSkip"), ("ISIS-MIB", "isisAuthenticationTypeFailure"), ("ISIS-MIB", "isisAuthenticationFailure"), ("ISIS-MIB", "isisVersionSkew"), ("ISIS-MIB", "isisAreaMismatch"), ("ISIS-MIB", "isisRejectedAdjacency"), ("ISIS-MIB", "isisLSPTooLargeToPropagate"), ("ISIS-MIB", "isisOrigLSPBuffSizeMismatch"), ("ISIS-MIB", "isisProtocolsSupportedMismatch"), ("ISIS-MIB", "isisAdjacencyChange"), ("ISIS-MIB", "isisLSPErrorDetected"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisNotificationGroup = isisNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: isisNotificationGroup.setDescription('The collections of notifications sent by an IS.')
isisISPDUCounterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 6)).setObjects(("ISIS-MIB", "isisPacketCountIIHello"), ("ISIS-MIB", "isisPacketCountISHello"), ("ISIS-MIB", "isisPacketCountESHello"), ("ISIS-MIB", "isisPacketCountLSP"), ("ISIS-MIB", "isisPacketCountCSNP"), ("ISIS-MIB", "isisPacketCountPSNP"), ("ISIS-MIB", "isisPacketCountUnknown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisISPDUCounterGroup = isisISPDUCounterGroup.setStatus('current')
if mibBuilder.loadTexts: isisISPDUCounterGroup.setDescription('The collections of objects used to count protocol PDUs.')
isisRATableGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 7)).setObjects(("ISIS-MIB", "isisRAExistState"), ("ISIS-MIB", "isisRAAdminState"), ("ISIS-MIB", "isisRAAddrPrefix"), ("ISIS-MIB", "isisRAMapType"), ("ISIS-MIB", "isisRAMetric"), ("ISIS-MIB", "isisRAMetricType"), ("ISIS-MIB", "isisRASNPAAddress"), ("ISIS-MIB", "isisRASNPAMask"), ("ISIS-MIB", "isisRASNPAPrefix"), ("ISIS-MIB", "isisRAType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisRATableGroup = isisRATableGroup.setStatus('current')
if mibBuilder.loadTexts: isisRATableGroup.setDescription('The collections of objects used to manage the\n\n\n\n             reachable NSAP prefixes.')
isisISIPRADestGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 8)).setObjects(("ISIS-MIB", "isisIPRANextHopType"), ("ISIS-MIB", "isisIPRANextHop"), ("ISIS-MIB", "isisIPRAType"), ("ISIS-MIB", "isisIPRAExistState"), ("ISIS-MIB", "isisIPRAAdminState"), ("ISIS-MIB", "isisIPRAMetric"), ("ISIS-MIB", "isisIPRAFullMetric"), ("ISIS-MIB", "isisIPRAMetricType"), ("ISIS-MIB", "isisIPRASNPAAddress"), ("ISIS-MIB", "isisIPRASourceType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisISIPRADestGroup = isisISIPRADestGroup.setStatus('current')
if mibBuilder.loadTexts: isisISIPRADestGroup.setDescription('The collections of objects used to manage configured\n             IP addresses.')
isisLSPGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 9)).setObjects(("ISIS-MIB", "isisLSPSeq"), ("ISIS-MIB", "isisLSPZeroLife"), ("ISIS-MIB", "isisLSPChecksum"), ("ISIS-MIB", "isisLSPLifetimeRemain"), ("ISIS-MIB", "isisLSPPDULength"), ("ISIS-MIB", "isisLSPAttributes"), ("ISIS-MIB", "isisLSPTLVSeq"), ("ISIS-MIB", "isisLSPTLVChecksum"), ("ISIS-MIB", "isisLSPTLVType"), ("ISIS-MIB", "isisLSPTLVLen"), ("ISIS-MIB", "isisLSPTLVValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isisLSPGroup = isisLSPGroup.setStatus('current')
if mibBuilder.loadTexts: isisLSPGroup.setDescription('The collections of objects used to observe the LSP\n             Database.')
mibBuilder.exportSymbols("ISIS-MIB", isisCircLevelIndex=isisCircLevelIndex, isisSysStatAttmptToExMaxSeqNums=isisSysStatAttmptToExMaxSeqNums, isisISAdjLastUpTime=isisISAdjLastUpTime, IsisMetricType=IsisMetricType, isisSysVersion=isisSysVersion, isisCircLevelType=isisCircLevelType, isisSysStatPartChanges=isisSysStatPartChanges, isisSummAddrExistState=isisSummAddrExistState, isisSysLevelSPFConsiders=isisSysLevelSPFConsiders, isisISAdjIPAddrType=isisISAdjIPAddrType, isisISPDUCounterGroup=isisISPDUCounterGroup, isisPacketCounterEntry=isisPacketCounterEntry, isisISAdjTable=isisISAdjTable, isisNotificationSysLevelIndex=isisNotificationSysLevelIndex, isisSysLevelType=isisSysLevelType, isisManAreaAddrTable=isisManAreaAddrTable, isisSysLevelState=isisSysLevelState, isisLSPTLVIndex=isisLSPTLVIndex, isisPduLspSize=isisPduLspSize, isisISAdjIndex=isisISAdjIndex, IsisWideMetric=IsisWideMetric, isisIPReachAddr=isisIPReachAddr, IsisLevel=IsisLevel, isisCircNumAdj=isisCircNumAdj, isisCircLevelDesIS=isisCircLevelDesIS, isisSysStatLSPDbaseOloads=isisSysStatLSPDbaseOloads, isisCircRejAdjs=isisCircRejAdjs, isisPacketCountLSP=isisPacketCountLSP, isisLSPSeq=isisLSPSeq, isisReachAddr=isisReachAddr, isisAttemptToExceedMaxSequence=isisAttemptToExceedMaxSequence, isisISIPRADestGroup=isisISIPRADestGroup, isisSysMaxLSPGenInt=isisSysMaxLSPGenInt, isisCircAuthFails=isisCircAuthFails, IsisSupportedProtocol=IsisSupportedProtocol, isisManAreaAddrEntry=isisManAreaAddrEntry, isisPacketCountISHello=isisPacketCountISHello, isisISAdjAreaAddrTable=isisISAdjAreaAddrTable, isisSystem=isisSystem, isisRedistributeAddrAddress=isisRedistributeAddrAddress, isisISAdjIPAddrTable=isisISAdjIPAddrTable, isisISAdjProtSuppEntry=isisISAdjProtSuppEntry, isisProtocolsSupportedMismatch=isisProtocolsSupportedMismatch, isisCircLastUpTime=isisCircLastUpTime, isisAreaMismatch=isisAreaMismatch, isisManAreaAddrExistState=isisManAreaAddrExistState, isisCircIndex=isisCircIndex, isisCircLevelWideMetric=isisCircLevelWideMetric, isisRATableGroup=isisRATableGroup, isisCircIfIndex=isisCircIfIndex, isisCircLevelEntry=isisCircLevelEntry, isisLSPErrorDetected=isisLSPErrorDetected, isisNotificationObjectGroup=isisNotificationObjectGroup, isisIPRADest=isisIPRADest, isisNotification=isisNotification, isisSystemGroup=isisSystemGroup, isisPduFieldLen=isisPduFieldLen, isisManualAddressDrops=isisManualAddressDrops, IsisMetricStyle=IsisMetricStyle, isisCircLevelISPriority=isisCircLevelISPriority, isisCircMaxAreaAddrMismatches=isisCircMaxAreaAddrMismatches, isisIPRANextHopIndex=isisIPRANextHopIndex, IsisAdminState=IsisAdminState, isisSysLevelMetricStyle=isisSysLevelMetricStyle, isisSysLevel=isisSysLevel, isisCircInitFails=isisCircInitFails, isisManAreaAddr=isisManAreaAddr, isisSysLevelTable=isisSysLevelTable, isisIPRASNPAAddress=isisIPRASNPAAddress, isisAdjacencyChange=isisAdjacencyChange, isisGroups=isisGroups, isisRouterTable=isisRouterTable, isisISAdjProtSuppProtocol=isisISAdjProtSuppProtocol, isisIPRANextHop=isisIPRANextHop, isisAuthenticationFailure=isisAuthenticationFailure, isisAuthenticationTypeFailure=isisAuthenticationTypeFailure, IsisCircuitID=IsisCircuitID, isisVersionSkew=isisVersionSkew, isisMaxAreaAddressesMismatch=isisMaxAreaAddressesMismatch, isisRouterSysID=isisRouterSysID, isisRedistributeAddrTable=isisRedistributeAddrTable, isisPacketCountDirection=isisPacketCountDirection, isisCircEntry=isisCircEntry, isisCircuitCounterTable=isisCircuitCounterTable, IsisLSPBuffSize=IsisLSPBuffSize, isisSysStatSeqNumSkips=isisSysStatSeqNumSkips, isisCircType=isisCircType, isisSummAddrPrefixLen=isisSummAddrPrefixLen, isisSysLevelIndex=isisSysLevelIndex, isisSystemCounterTable=isisSystemCounterTable, isisSysStatCorrLSPs=isisSysStatCorrLSPs, isisCircExistState=isisCircExistState, isisCircLevelDRHelloTimer=isisCircLevelDRHelloTimer, isisIPRAAdminState=isisIPRAAdminState, isisRedistributeAddrType=isisRedistributeAddrType, isisLSPGroup=isisLSPGroup, isisPacketCountLevel=isisPacketCountLevel, IsisISPriority=IsisISPriority, isisSysStatSPFRuns=isisSysStatSPFRuns, isisLSPTLVValue=isisLSPTLVValue, isisSysStatAuthFails=isisSysStatAuthFails, isisAreaAddrEntry=isisAreaAddrEntry, isisRAAdminState=isisRAAdminState, isisISAdjNbrExtendedCircID=isisISAdjNbrExtendedCircID, isisErrorOffset=isisErrorOffset, isisCounters=isisCounters, isisSysStatIDFieldLenMismatches=isisSysStatIDFieldLenMismatches, isisReadOnlyCompliance=isisReadOnlyCompliance, isisCircLevelCSNPInterval=isisCircLevelCSNPInterval, isisISAdjIPAddrIndex=isisISAdjIPAddrIndex, isisLSPTLVSeq=isisLSPTLVSeq, IsisDefaultMetric=IsisDefaultMetric, isisCircPassiveCircuit=isisCircPassiveCircuit, isisISAdjNeighSNPAAddress=isisISAdjNeighSNPAAddress, isisPacketCountESHello=isisPacketCountESHello, isisISAdjState=isisISAdjState, isisRedistributeAddrEntry=isisRedistributeAddrEntry, isisISAdjProtSuppTable=isisISAdjProtSuppTable, isisSysStatLevel=isisSysStatLevel, isisNotifications=isisNotifications, isisRouterHostName=isisRouterHostName, isisPduMaxAreaAddress=isisPduMaxAreaAddress, isisISAdj=isisISAdj, isisCircExtDomain=isisCircExtDomain, isisCircLANDesISChanges=isisCircLANDesISChanges, isisRAAddrPrefix=isisRAAddrPrefix, isisPduFragment=isisPduFragment, isisCirc=isisCirc, isisCirc3WayEnabled=isisCirc3WayEnabled, isisPacketCountUnknown=isisPacketCountUnknown, isisSysLevelSetOverload=isisSysLevelSetOverload, isisSummAddrMetric=isisSummAddrMetric, isisIPRASourceType=isisIPRASourceType, isisCircLevelMinLSPRetransInt=isisCircLevelMinLSPRetransInt, isisSummAddress=isisSummAddress, isisAreaAddrTable=isisAreaAddrTable, isisCircMeshGroupEnabled=isisCircMeshGroupEnabled, isisSysLevelMinLSPGenInt=isisSysLevelMinLSPGenInt, isisCircLevelHelloTimer=isisCircLevelHelloTimer, isisOrigLSPBuffSizeMismatch=isisOrigLSPBuffSizeMismatch, isisRAMetricType=isisRAMetricType, isisLSPChecksum=isisLSPChecksum, IsisSystemID=IsisSystemID, isisPacketCountPSNP=isisPacketCountPSNP, isisRATable=isisRATable, isisISAdjEntry=isisISAdjEntry, isisLSPTLVType=isisLSPTLVType, isisCircLevelLSPThrottle=isisCircLevelLSPThrottle, isisCircLevelIDOctet=isisCircLevelIDOctet, isisISAdjAreaAddrIndex=isisISAdjAreaAddrIndex, IsisUnsigned16TC=IsisUnsigned16TC, isisCircExtendedCircID=isisCircExtendedCircID, isisObjects=isisObjects, isisNotificationEntry=isisNotificationEntry, isisLSPLevel=isisLSPLevel, isisSummAddressType=isisSummAddressType, isisSysProtSupported=isisSysProtSupported, isisPacketCountCSNP=isisPacketCountCSNP, isisSystemCounterEntry=isisSystemCounterEntry, isisSummAddrEntry=isisSummAddrEntry, isisIPRATable=isisIPRATable, isisISAdjIPAddrAddress=isisISAdjIPAddrAddress, isisCorruptedLSPDetected=isisCorruptedLSPDetected, isisCircAdjChanges=isisCircAdjChanges, isisISAdjGroup=isisISAdjGroup, isisCircIDFieldLenMismatches=isisCircIDFieldLenMismatches, isisCompliances=isisCompliances, isisAreaAddr=isisAreaAddr, isisRouterLevel=isisRouterLevel, isisLSPID=isisLSPID, IsisUnsigned8TC=IsisUnsigned8TC, isisCircLevelHelloMultiplier=isisCircLevelHelloMultiplier, isisSysWaitTime=isisSysWaitTime, isisLSPZeroLife=isisLSPZeroLife, IsisFullMetric=IsisFullMetric, isisRAIndex=isisRAIndex, isisIPRAEntry=isisIPRAEntry, isisLSPAttributes=isisLSPAttributes, isisCircSmallHellos=isisCircSmallHellos, isisIPRADestPrefixLen=isisIPRADestPrefixLen, isisIPRAExistState=isisIPRAExistState, isisISAdjAreaAddrEntry=isisISAdjAreaAddrEntry, isisCircAuthTypeFails=isisCircAuthTypeFails, PYSNMP_MODULE_ID=isisMIB, isisISAdj3WayState=isisISAdj3WayState, isisRedistributeAddrPrefixLen=isisRedistributeAddrPrefixLen, isisRAEntry=isisRAEntry, isisIPRAType=isisIPRAType, isisRejectedAdjacency=isisRejectedAdjacency, isisLSPPDULength=isisLSPPDULength, isisNotificationCircIfIndex=isisNotificationCircIfIndex, isisISAdjNeighSysType=isisISAdjNeighSysType, isisErrorTLVType=isisErrorTLVType, isisRAExistState=isisRAExistState, isisSysNotificationEnable=isisSysNotificationEnable, isisSysLevelEntry=isisSysLevelEntry, isisLSPTLVLen=isisLSPTLVLen, isisISAdjAreaAddress=isisISAdjAreaAddress, isisSysReceiveLSPBufferSize=isisSysReceiveLSPBufferSize, isisCircTable=isisCircTable, isisRASNPAAddress=isisRASNPAAddress, isisCircLevelID=isisCircLevelID, isisLSPTLVTable=isisLSPTLVTable, isisSysLevelSetOverloadUntil=isisSysLevelSetOverloadUntil, isisAdvancedCompliance=isisAdvancedCompliance, isisSysStatManAddrDropFromAreas=isisSysStatManAddrDropFromAreas, isisISAdjNeighSysID=isisISAdjNeighSysID, isisRASNPAMask=isisRASNPAMask, IsisLinkStatePDUID=IsisLinkStatePDUID, isisSysMaxAge=isisSysMaxAge, isisCircLevelMetric=isisCircLevelMetric, isisSysStatLSPErrors=isisSysStatLSPErrors, isisLSPDataBase=isisLSPDataBase, isisSysObject=isisSysObject, isisSysL2toL1Leaking=isisSysL2toL1Leaking, isisISAdjUsage=isisISAdjUsage, isisRAMetric=isisRAMetric, isisLSPTooLargeToPropagate=isisLSPTooLargeToPropagate, isisRouterID=isisRouterID, isisNextCircIndex=isisNextCircIndex, isisConformance=isisConformance, isisOwnLSPPurge=isisOwnLSPPurge, isisCircLevelPartSNPInterval=isisCircLevelPartSNPInterval, isisLSPSummaryEntry=isisLSPSummaryEntry, isisCircuitType=isisCircuitType, isisSummAddrFullMetric=isisSummAddrFullMetric, isisIPRADestType=isisIPRADestType, isisLSPTLVChecksum=isisLSPTLVChecksum, isisAdjState=isisAdjState, isisIDLenMismatch=isisIDLenMismatch, isisRAMapType=isisRAMapType, isisRedistributeAddrExistState=isisRedistributeAddrExistState, isisPduBufferSize=isisPduBufferSize, isisPacketCountIIHello=isisPacketCountIIHello, isisIPRAMetric=isisIPRAMetric, isisCircLevelValues=isisCircLevelValues, isisPduOriginatingBufferSize=isisPduOriginatingBufferSize, isisCircLevelTable=isisCircLevelTable, isisISAdjNeighPriority=isisISAdjNeighPriority, isisLSPSummaryTable=isisLSPSummaryTable, isisDatabaseOverload=isisDatabaseOverload, isisSysID=isisSysID, isisNotificationAreaAddress=isisNotificationAreaAddress, isisSysLevelTEEnabled=isisSysLevelTEEnabled, isisIPRAMetricType=isisIPRAMetricType, isisSysAdminState=isisSysAdminState, IsisLevelState=IsisLevelState, isisSequenceNumberSkip=isisSequenceNumberSkip, isisSysLevelOrigLSPBuffSize=isisSysLevelOrigLSPBuffSize, isisCircuitCounterEntry=isisCircuitCounterEntry, IsisOSINSAddress=IsisOSINSAddress, isisIPRANextHopType=isisIPRANextHopType, isisCircAdminState=isisCircAdminState, isisPduProtocolsSupported=isisPduProtocolsSupported)
mibBuilder.exportSymbols("ISIS-MIB", isisLSPTLVEntry=isisLSPTLVEntry, isisISAdjIPAddrEntry=isisISAdjIPAddrEntry, isisRouterEntry=isisRouterEntry, isisCircMeshGroup=isisCircMeshGroup, isisSummAddrTable=isisSummAddrTable, isisRASNPAPrefix=isisRASNPAPrefix, isisCircuitGroup=isisCircuitGroup, isisSysMaxPathSplits=isisSysMaxPathSplits, isisIPRAFullMetric=isisIPRAFullMetric, IsisISLevel=IsisISLevel, isisISAdjHoldTimer=isisISAdjHoldTimer, isisLSPLifetimeRemain=isisLSPLifetimeRemain, isisSysStatOwnLSPPurges=isisSysStatOwnLSPPurges, isisPduLspId=isisPduLspId, IsisPDUHeader=IsisPDUHeader, isisPacketCounterTable=isisPacketCounterTable, isisRAType=isisRAType, isisMIB=isisMIB, isisSysPollESHelloRate=isisSysPollESHelloRate, isisPduProtocolVersion=isisPduProtocolVersion, isisSysStatAuthTypeFails=isisSysStatAuthTypeFails, isisCompliance=isisCompliance, isisNotificationGroup=isisNotificationGroup)
