#
# PySNMP MIB module PW-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/PW-STD-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 04:09:12 2022
# On host fv-az77-149 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
HCPerfCurrentCount, HCPerfTimeElapsed, HCPerfValidIntervals, HCPerfIntervalCount = mibBuilder.importSymbols("HC-PerfHist-TC-MIB", "HCPerfCurrentCount", "HCPerfTimeElapsed", "HCPerfValidIntervals", "HCPerfIntervalCount")
IANAPwPsnTypeTC, IANAPwCapabilities, IANAPwTypeTC = mibBuilder.importSymbols("IANA-PWE3-MIB", "IANAPwPsnTypeTC", "IANAPwCapabilities", "IANAPwTypeTC")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
PwCwStatusTC, PwIDType, PwIndexType, PwFragSize, PwOperStatusTC, PwStatus, PwIndexOrZeroType, PwGroupID, PwGenIdType, PwAttachmentIdentifierType, PwFragStatus = mibBuilder.importSymbols("PW-TC-STD-MIB", "PwCwStatusTC", "PwIDType", "PwIndexType", "PwFragSize", "PwOperStatusTC", "PwStatus", "PwIndexOrZeroType", "PwGroupID", "PwGenIdType", "PwAttachmentIdentifierType", "PwFragStatus")
PerfIntervalCount, PerfCurrentCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfIntervalCount", "PerfCurrentCount")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
TimeTicks, NotificationType, MibIdentifier, Gauge32, iso, ObjectIdentity, Counter64, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ModuleIdentity, Counter32, Integer32, transmission, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "NotificationType", "MibIdentifier", "Gauge32", "iso", "ObjectIdentity", "Counter64", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ModuleIdentity", "Counter32", "Integer32", "transmission", "IpAddress")
StorageType, TimeStamp, DisplayString, RowStatus, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TimeStamp", "DisplayString", "RowStatus", "TruthValue", "TextualConvention")
pwStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 246))
pwStdMIB.setRevisions(('2009-06-11 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pwStdMIB.setRevisionsDescriptions(('Initial version published as part of RFC 5601.',))
if mibBuilder.loadTexts: pwStdMIB.setLastUpdated('200906110000Z')
if mibBuilder.loadTexts: pwStdMIB.setOrganization('Pseudowire Edge-to-Edge Emulation (PWE3) Working\n                 Group')
if mibBuilder.loadTexts: pwStdMIB.setContactInfo('David Zelig\n       Email: davidz@oversi.com\n\n       Thomas D. Nadeau\n       Email: tom.nadeau@bt.com\n\n       The PWE3 Working Group (email distribution pwe3@ietf.org,\n       http://www.ietf.org/html.charters/pwe3-charter.html)\n       ')
if mibBuilder.loadTexts: pwStdMIB.setDescription("This MIB module contains managed object definitions for\n       pseudowire operation as in Bryant, S. and P. Pate, 'Pseudo\n       Wire Emulation Edge-to-Edge (PWE3) Architecture' [RFC3985],\n       Martini, L., et al, 'Pseudowire Setup and Maintenance Using\n       the Label Distribution Protocol (LDP)' [RFC4447], and\n       Townsley, M., et al, 'Layer Two Tunneling Protocol\n       (Version 3)' [RFC3931].\n\n       This MIB module enables the use of any underlying packet\n       switched network (PSN).  MIB nodules that will support\n       PW operations over specific PSN types are defined in\n       separate memos.\n\n       The indexes for this MIB module are also used to index the\n       PSN-specific tables and the PW-specific tables.  The PW Type\n       dictates which PW-specific MIB module to use.\n\n       Copyright (c) 2009 IETF Trust and the persons identified\n       as authors of the code.  All rights reserved.\n\n       Redistribution and use in source and binary forms, with or\n       without modification, are permitted provided that the following\n       conditions are met:\n\n       - Redistributions of source code must retain the above\n         copyright notice, this list of conditions and the following\n         disclaimer.\n\n       - Redistributions in binary form must reproduce the above\n         copyright notice, this list of conditions and the following\n         disclaimer in the documentation and/or other materials\n         provided with the distribution.\n\n       - Neither the name of Internet Society, IETF or IETF Trust, nor\n         the names of specific contributors, may be used to endorse or\n         promote products derived from this software without specific\n         prior written permission.\n\n       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n       CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n       MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n       DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n       CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n       SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n       NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n       HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n       CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n       OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n       EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n       This version of this MIB module is part of RFC 5601;\n       see the RFC itself for full legal notices.\n       ")
pwNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 246, 0))
pwObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 246, 1))
pwConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 246, 2))
pwIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 246, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwIndexNext.setStatus('current')
if mibBuilder.loadTexts: pwIndexNext.setDescription('This object contains an appropriate value to be used for\n        pwIndex when creating entries in the pwTable.  The value 0\n        indicates that no unassigned entries are available.  To\n        obtain the value of pwIndex for a new entry in the pwTable,\n        the manager issues a management protocol retrieval\n        operation.  The agent will determine through its local policy\n        when this index value will be made available for reuse.')
pwTable = MibTable((1, 3, 6, 1, 2, 1, 10, 246, 1, 2), )
if mibBuilder.loadTexts: pwTable.setStatus('current')
if mibBuilder.loadTexts: pwTable.setDescription('This table specifies information for configuring and\n        status monitoring that is common to all service types\n        and PSN types.')
pwEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwEntry.setStatus('current')
if mibBuilder.loadTexts: pwEntry.setDescription("A row in this table represents a pseudowire (PW) virtual\n         connection across a packet network.  It is indexed by\n         pwIndex, which uniquely identifies a singular\n         connection.\n         A row can be created by an operator command from a\n         management plan of a PE, by signaling, or due to auto-\n         discovery process.  An operator's command can be issued via\n         a non-SNMP application; in such case, a row will be created\n         implicitly by the agent.\n         The read-create objects in this table are divided into\n         three categories:\n         1) Objects that MUST NOT be changed after row activation.\n            These are objects that define basic properties of the\n            PW (for example type, destination, etc.).\n         2) Objects that MAY be changed when the PW is\n            defined as not active.  A change of these objects involves\n            re-signaling of the PW or it might be traffic affecting.\n            PW not active is defined as one of the following\n            conditions:\n                a) The pwRowStatus is notInService(2).\n                b) The pwRowStatus is notReady(3).\n                c) The pwAdminStatus is down(2).\n         If the operator needs to change one of the values for an\n         active row, the operator can either set the pwRowStatus to\n         notInService(2) or set pwAdminStatus to down(2).\n         Signaling (or traffic) is initiated again upon setting\n         the pwRowStatus to active(1) or setting the pwAdminStatus\n         to up(1) or testing(3), respectively.\n\n         3) Objects that MAY be changed at any time.\n\n         A PW MAY have an entry in the ifTable in addition to the\n         entry in this table.  In this case, a special ifType for PW\n         will be set in the ifTable, and the ifIndex in the ifTable\n         of the PW will be set in the pwIfIndex object in this table.\n\n         By default, all the read-create objects MUST NOT be\n         changed after row activation, unless specifically indicated\n         in the individual object description.\n\n         Manual entries in this table SHOULD be preserved after a\n         reboot; the agent MUST ensure the integrity of those\n         entries.  If the set of entries of a specific row are found\n         to be inconsistent after reboot, the PW pwOperStatus MUST\n         be declared as notPresent(5).\n         ")
pwIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 1), PwIndexType())
if mibBuilder.loadTexts: pwIndex.setStatus('current')
if mibBuilder.loadTexts: pwIndex.setDescription('A unique index for the conceptual row identifying a PW within\n        this table.')
pwType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 2), IANAPwTypeTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwType.setStatus('current')
if mibBuilder.loadTexts: pwType.setDescription('This value indicates the emulated service to be carried over\n        this PW.\n       ')
pwOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("manual", 1), ("pwIdFecSignaling", 2), ("genFecSignaling", 3), ("l2tpControlProtocol", 4), ("other", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwOwner.setStatus('current')
if mibBuilder.loadTexts: pwOwner.setDescription("This object is set by the operator to indicate the protocol\n         responsible for establishing this PW.\n         'manual' is used in all cases where no maintenance\n         protocol (PW signaling) is used to set up the PW, i.e.,\n         configuration of entries in the PW tables including\n         PW labels, etc., is done by setting the MIB fields manually.\n         'pwIdFecSignaling' is used in case of signaling with the\n         Pwid FEC element with LDP signaling.\n         'genFecSignaling' is used in case of LDP signaling with\n         the generalized FEC.\n         'l2tpControlProtocol' indicates the use of the L2TP\n         control protocol.\n         'other' is used for other types of signaling.")
pwPsnType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 4), IANAPwPsnTypeTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwPsnType.setStatus('current')
if mibBuilder.loadTexts: pwPsnType.setDescription("This object is set by the operator to indicate the PSN type.\n         Based on this object, the relevant PSN table's entry is\n         created in the PSN-specific MIB modules.\n        ")
pwSetUpPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwSetUpPriority.setStatus('current')
if mibBuilder.loadTexts: pwSetUpPriority.setDescription("This object defines the relative priority of the PW\n         during set-up in a lowest-to-highest fashion, where 0\n         is the highest priority.  PWs with the same priority\n         are treated with equal priority.  PWs that have not yet\n\n         completed setup will report 'dormant' in the\n         pwOperStatus.\n         This value is significant if there are competing resources\n         among PWs and the implementation supports this feature.\n         Equal priority handling with competing resources is\n         implementation specific.\n         This object MAY be changed at any time.")
pwHoldingPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwHoldingPriority.setStatus('current')
if mibBuilder.loadTexts: pwHoldingPriority.setDescription('This object defines the relative holding priority of the\n         PW in a lowest-to-highest fashion, where 0 is the highest\n         priority.  PWs with the same priority are treated equally.\n         This value is significant if there are competing resources\n         among PWs and the implementation supports this feature.\n         Equal priority handling with competing resources is\n         implementation specific.\n         This object MAY be changed only if the PW is not active.')
pwPeerAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 8), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: pwPeerAddrType.setDescription("Denotes the address type of the peer node.  It should be\n         set to 'unknown' if PE/PW maintenance protocol is not used\n         and the address is unknown.")
pwPeerAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 9), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwPeerAddr.setStatus('current')
if mibBuilder.loadTexts: pwPeerAddr.setDescription("This object contains the value of the peer node address\n         of the PW/PE maintenance protocol entity.  This object\n         SHOULD contain a value of all zeroes if not applicable\n         (pwPeerAddrType is 'unknown').")
pwAttachedPwIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 10), PwIndexOrZeroType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAttachedPwIndex.setStatus('current')
if mibBuilder.loadTexts: pwAttachedPwIndex.setDescription('If the PW is attached to another PW instead of a local\n        native service, this item indicates the pwIndex of the\n        attached PW.  Otherwise, this object MUST\n        be set to zero.  Attachment to another PW will have no\n        PW specific entry in any of the service MIB modules.')
pwIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwIfIndex.setStatus('current')
if mibBuilder.loadTexts: pwIfIndex.setDescription('This object indicates the ifIndex of the PW if the PW is\n        represented in the ifTable.  Otherwise, it MUST be set\n        to zero.')
pwID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 12), PwIDType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwID.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwID.setStatus('current')
if mibBuilder.loadTexts: pwID.setDescription("Pseudowire identifier.\n\n        If the pwOwner object is 'pwIdFecSignaling' or\n        'l2tpControlProtocol', then this object is signaled in the\n        outgoing PW ID field within the 'Virtual Circuit FEC\n        Element'.  For other values of pwOwner, this object is not\n        signaled and it MAY be set to zero.\n\n        For implementations that support the pwIndexMappingTable,\n        a non-zero value is RECOMMENDED, even if this\n        identifier is not signaled.  This is so that reverse\n        mappings can be provided by pwIndexMappingTable and\n        pwPeerMappingTable.  It is therefore RECOMMENDED that the\n        value of this pwID be unique (or if pwPeerAddrType is not\n        'unknown', at least [pwType, pwID, pwPeerAddrType, pwPeerAddr]\n        is unique.)")
pwLocalGroupID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 13), PwGroupID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwLocalGroupID.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwLocalGroupID.setStatus('current')
if mibBuilder.loadTexts: pwLocalGroupID.setDescription('Used in the Group ID field sent to the peer PW End Service\n        within the maintenance protocol used for PW setup.\n        It SHOULD be set to zero if a maintenance protocol is\n        not used.')
pwGroupAttachmentID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 14), PwAttachmentIdentifierType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwGroupAttachmentID.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwGroupAttachmentID.setStatus('current')
if mibBuilder.loadTexts: pwGroupAttachmentID.setDescription("This object is an octet string representing the attachment\n        group identifier (AGI) that this PW belongs to, which\n        typically identifies the VPN ID.\n        Applicable if pwOwner equals 'genFecSignaling'.")
pwLocalAttachmentID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 15), PwAttachmentIdentifierType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwLocalAttachmentID.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwLocalAttachmentID.setStatus('current')
if mibBuilder.loadTexts: pwLocalAttachmentID.setDescription("This object is an octet string representing the local\n        forwarder attachment individual identifier (AII) to be\n        used by this PW.  It is used as the Source AII (SAII) for\n        outgoing signaling messages and the Target AII (TAII) in\n        the incoming messages from the peer.  Applicable if\n        pwOwner equal 'genFecSignaling'.")
pwRemoteAttachmentID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 16), PwAttachmentIdentifierType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwRemoteAttachmentID.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwRemoteAttachmentID.setStatus('current')
if mibBuilder.loadTexts: pwRemoteAttachmentID.setDescription("This object is an octet string representing the remote\n        forwarder attachment individual identifier (AII) to be\n        used by this PW.  It is used as the TAII for outgoing\n        signaling messages and the SAII in the incoming messages\n        from the peer.\n        Applicable if pwOwner equals 'genFecSignaling'.")
pwCwPreference = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCwPreference.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol.', RFC 4447.")
if mibBuilder.loadTexts: pwCwPreference.setStatus('current')
if mibBuilder.loadTexts: pwCwPreference.setDescription('Defines if the control word will be sent with each packet\n        by the local node.  Some PW types mandate the use of a\n        control word, and in such cases, the value configured for\n        this object has no effect on the existence of the control\n        word.\n        This object MAY be changed only if the PW is not active.')
pwLocalIfMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwLocalIfMtu.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwLocalIfMtu.setStatus('current')
if mibBuilder.loadTexts: pwLocalIfMtu.setDescription('If not equal to zero, the optional IfMtu object in the\n        signaling protocol will be sent with this value, which\n        represents the locally supported MTU size over the\n        interface (or the virtual interface) associated with the\n        PW.\n        This object MAY be changed only if the PW is not active.')
pwLocalIfString = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwLocalIfString.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447, section 5.5.")
if mibBuilder.loadTexts: pwLocalIfString.setStatus('current')
if mibBuilder.loadTexts: pwLocalIfString.setDescription("A PW MAY be associated to an interface (or a virtual\n        interface) in the ifTable of the node as part of the\n        service configuration.  This object defines if the\n        maintenance protocol will send the interface's name\n        (ifAlias) as it appears in the ifTable.  If set to false,\n        the optional element will not be sent.\n        This object MAY be changed only if the PW is not active.")
pwLocalCapabAdvert = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 20), IANAPwCapabilities()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwLocalCapabAdvert.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwLocalCapabAdvert.setStatus('current')
if mibBuilder.loadTexts: pwLocalCapabAdvert.setDescription('If a maintenance protocol is used, it indicates the\n        capabilities the local node will advertise to the peer.  The\n        operator MAY selectively assign a partial set of\n        capabilities.  In case of manual configuration of the PW, the\n        operator SHOULD set non-conflicting options (for example,\n        only a single type of Operations, Administration, and\n        Management (OAM)) out of the available options in the\n        implementation.  It is possible to change the value of\n        this object when the PW is not active.  The agent MUST\n        reject any attempt to set a capability that is not\n        supported.\n\n        The default value MUST be the full set of local node\n        capabilities.')
pwRemoteGroupID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 21), PwGroupID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwRemoteGroupID.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwRemoteGroupID.setStatus('current')
if mibBuilder.loadTexts: pwRemoteGroupID.setDescription('This object is obtained from the Group ID field as\n        received via the maintenance protocol used for PW setup.\n        Value of zero will be reported if not used.\n        Value of 0xFFFFFFFF shall be used if the object is yet to be\n        defined by the PW maintenance protocol.')
pwCwStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 22), PwCwStatusTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCwStatus.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwCwStatus.setStatus('current')
if mibBuilder.loadTexts: pwCwStatus.setDescription('If signaling is used for PW establishment, this object\n        indicates the status of the control word negotiation.\n        For either signaling or manual configuration, it indicates\n        if the control word (CW) is to be present for this PW.')
pwRemoteIfMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwRemoteIfMtu.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwRemoteIfMtu.setStatus('current')
if mibBuilder.loadTexts: pwRemoteIfMtu.setDescription('The remote interface MTU as (optionally) received from the\n        remote node via the maintenance protocol.  The object SHOULD\n        report zero if the MTU is not available.')
pwRemoteIfString = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 24), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwRemoteIfString.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447, section 5.5.")
if mibBuilder.loadTexts: pwRemoteIfString.setStatus('current')
if mibBuilder.loadTexts: pwRemoteIfString.setDescription('Indicates the interface description string as received by\n        the maintenance protocol.  It MUST be a NULL string if a\n        maintenance protocol is not used or the value is not known\n        yet.')
pwRemoteCapabilities = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 25), IANAPwCapabilities()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwRemoteCapabilities.setReference("Martini, et al, 'Pseudowire Setup and Maintenance using\n        the Label Distribution Protocol', RFC 4447.")
if mibBuilder.loadTexts: pwRemoteCapabilities.setStatus('current')
if mibBuilder.loadTexts: pwRemoteCapabilities.setDescription('Indicates the capabilities as received from the peer.')
pwFragmentCfgSize = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 26), PwFragSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwFragmentCfgSize.setReference("Malis A., Townsley M., 'PWE3 Fragmentation and Reassembly',\n        RFC 4623.")
if mibBuilder.loadTexts: pwFragmentCfgSize.setStatus('current')
if mibBuilder.loadTexts: pwFragmentCfgSize.setDescription('If set to a value other than zero, indicates that\n        fragmentation is desired for this PW.\n        This object MAY be changed only if the PW is not active.')
pwRmtFragCapability = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 27), PwFragStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwRmtFragCapability.setReference("Malis A., Townsley M., 'PWE3 Fragmentation and Reassembly',\n        RFC 4623.")
if mibBuilder.loadTexts: pwRmtFragCapability.setStatus('current')
if mibBuilder.loadTexts: pwRmtFragCapability.setDescription('The status of the fragmentation based on the local\n        configuration and the peer capabilities as received from\n        the peer when a control protocol is used.')
pwFcsRetentionCfg = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fcsRetentionDisable", 1), ("fcsRetentionEnable", 2))).clone('fcsRetentionDisable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwFcsRetentionCfg.setReference("Malis A., et al., 'PWE3 Frame Check Sequence Retention',\n        RFC 4720.")
if mibBuilder.loadTexts: pwFcsRetentionCfg.setStatus('current')
if mibBuilder.loadTexts: pwFcsRetentionCfg.setDescription('The local configuration of Frame Check Sequence (FCS)\n        retention for this PW.  FCS retention can be configured for\n        PW types High-Level Data Link Control (HDLC), Point-to-Point\n        Protocol (PPP), and Ethernet only.  If the implementation\n        does not support FCS retention, an error MUST be reported in\n        pwFcsRetentionStatus.  This object MAY be changed only if\n        the PW is not active.')
pwFcsRetentionStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 29), Bits().clone(namedValues=NamedValues(("remoteIndicationUnknown", 0), ("remoteRequestFcsRetention", 1), ("fcsRetentionEnabled", 2), ("fcsRetentionDisabled", 3), ("localFcsRetentionCfgErr", 4), ("fcsRetentionFcsSizeMismatch", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwFcsRetentionStatus.setReference("Malis A., et al., 'PWE3 Frame Check Sequence Retention',\n        RFC 4720")
if mibBuilder.loadTexts: pwFcsRetentionStatus.setStatus('current')
if mibBuilder.loadTexts: pwFcsRetentionStatus.setDescription('The status of the FCS retention negotiation process based on\n       local configuration and the remote advertisement.\n\n       remoteIndicationUnknown - set if a FEC has not been received\n          from the remote.\n\n       remoteRequestFcsRetention - indicates that the peer has\n          requested FCS retention.  FCS retention will be used if\n          the local node is capable and configured to use it for\n          this PW.\n\n       fcsRetentionEnabled - FCS retention is enabled (both peers\n          were configured for FCS retention for signaled PW, or the\n          local node is configured and capable of FCS retention for\n          manually assigned PWs).\n\n       fcsRetentionDisabled - FCS retention is disabled (not\n          configured locally or not advertised by the peer).\n\n       localFcsRetentionCfgErr - set if the local node has been\n          configured for FCS retention but is not capable to support\n          it.\n\n       fcsRetentionFcsSizeMismatch - set if there is an FCS size\n          mismatch between the local and the peer node.\n      ')
pwOutboundLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 30), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwOutboundLabel.setStatus('current')
if mibBuilder.loadTexts: pwOutboundLabel.setDescription("The PW label used in the outbound direction (i.e., toward\n        the PSN).  It might be set manually if pwOwner is 'manual';\n        otherwise, it is set automatically.\n        For MPLS, MPLS over IP, or MPLS over Generic Routing\n        Encapsulation (GRE) PSN, it represents the 20-bit PW tag;\n        for L2TP, it represents the 32-bit Session ID; and for\n        IP PSN, it represents the destination UDP port number.\n        If the label is not yet known (signaling in process), the\n        object SHOULD return a value of 0xFFFFFFFF.\n        For manual configuration, this object MAY be changed only\n        if the PW is not active.")
pwInboundLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 31), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwInboundLabel.setStatus('current')
if mibBuilder.loadTexts: pwInboundLabel.setDescription("The PW label used in the inbound direction (i.e., packets\n        received from the PSN).  It may be set manually if pwOwner\n        is 'manual'; otherwise, it is set automatically.\n        For MPLS, MPLS over IP, or MPLS over GRE PSN, it represents\n        the 20-bit PW tag; for L2TP, it represents the 32-bit\n        Session ID; and for IP PSN, it represents the source\n        UDP port number.\n        If the label is not yet known (signaling in process), the\n        object SHOULD return a value of 0xFFFFFFFF.\n        For manual configuration, this object MAY be changed only\n        if the PW is not active.")
pwName = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 32), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwName.setStatus('current')
if mibBuilder.loadTexts: pwName.setDescription('The canonical name assigned to the PW.  This object MAY be\n        changed at any time.')
pwDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 33), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwDescr.setStatus('current')
if mibBuilder.loadTexts: pwDescr.setDescription('A textual string containing information about the PW.\n        If there is no description, this object contains a zero-\n        length string.  This object MAY be changed at any time.')
pwCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 34), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCreateTime.setStatus('current')
if mibBuilder.loadTexts: pwCreateTime.setDescription('The value of sysUpTime at the time this PW was created.')
pwUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 35), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwUpTime.setStatus('current')
if mibBuilder.loadTexts: pwUpTime.setDescription('Specifies the time since last change of pwOperStatus to\n        Up(1).')
pwLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 36), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwLastChange.setStatus('current')
if mibBuilder.loadTexts: pwLastChange.setDescription('The value of sysUpTime at the time the PW entered\n       its current operational state.  If the current state was\n       entered prior to the last re-initialization of the local\n       network management subsystem, then this object contains a\n       zero value.')
pwAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAdminStatus.setStatus('current')
if mibBuilder.loadTexts: pwAdminStatus.setDescription('The desired operational status of this PW.  This object MAY\n        be set at any time.')
pwOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 38), PwOperStatusTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwOperStatus.setStatus('current')
if mibBuilder.loadTexts: pwOperStatus.setDescription("This object indicates the operational status of the PW; it\n         does not reflect the status of the Customer Edge (CE) bound\n         interface.  It is set to down only if pwNotForwarding,\n         psnFacingPwRxFault, or psnFacingPwTxFault indications are\n         set in pwLocalStatus or pwRemoteStatus.\n         It indicates 'lowerLayerDown' if the only reason for\n         not being in the 'up' state is that either the outer tunnel\n         or physical layer of the network side is in the 'down'\n         state.\n         All other states are declared based on the description\n         of the PwOperStatusTC.\n         ")
pwLocalStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 39), PwStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwLocalStatus.setStatus('current')
if mibBuilder.loadTexts: pwLocalStatus.setDescription('Indicates the status of the PW in the local node.\n         The various indications in this object SHOULD be\n         available independent of the ability of the local node to\n         advertise them or the remote node to accept these status\n         indications through the control protocol.\n        ')
pwRemoteStatusCapable = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("notYetKnown", 2), ("remoteCapable", 3), ("remoteNotCapable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwRemoteStatusCapable.setStatus('current')
if mibBuilder.loadTexts: pwRemoteStatusCapable.setDescription('Indicates the remote node capability to advertise the\n         PW status notification.\n         notApplicable SHOULD be reported for a manually set PW, or\n         if the local node is not capable of accepting the status\n         notification object.\n         notYetKnown SHOULD be reported if the signaling protocol\n         has not yet finished the process of capability\n         determination.\n         remoteCapable and remoteNotcapable SHOULD be reported\n         based on the initial signaling exchange that has\n         determined the remote node capability.\n       ')
pwRemoteStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 41), PwStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwRemoteStatus.setStatus('current')
if mibBuilder.loadTexts: pwRemoteStatus.setDescription("Indicates the status of the PW as was advertised by the\n         remote.  If the remote is not capable of advertising the\n         status object, or the local node is not able to accept\n         the status object through signaling, then the applicable\n         bit is 'pwNotForwarding', which is set if the remote has\n         sent label release or label withdraw for this PW.\n        ")
pwTimeElapsed = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 42), HCPerfTimeElapsed()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: pwTimeElapsed.setDescription('The number of seconds, including partial seconds,\n          that have elapsed since the beginning of the current\n          interval measurement period.')
pwValidIntervals = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 43), HCPerfValidIntervals()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwValidIntervals.setStatus('current')
if mibBuilder.loadTexts: pwValidIntervals.setDescription('The number of previous 15-minute intervals\n       for which data was collected.')
pwRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 44), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwRowStatus.setStatus('current')
if mibBuilder.loadTexts: pwRowStatus.setDescription('For creating, modifying, and deleting this row.\n        This object MAY be changed at any time.')
pwStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 45), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwStorageType.setStatus('current')
if mibBuilder.loadTexts: pwStorageType.setDescription('This variable indicates the storage type for this\n        object.')
pwOamEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 46), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwOamEnable.setStatus('current')
if mibBuilder.loadTexts: pwOamEnable.setDescription('This variable indicates if OAM is enabled for this\n        PW.  It MAY be changed at any time.')
pwGenAGIType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 47), PwGenIdType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwGenAGIType.setStatus('current')
if mibBuilder.loadTexts: pwGenAGIType.setDescription('This variable indicates the AGI type if generalized FEC\n        (129) is used for PW signaling or configuration.  It SHOULD\n        return the value of zero otherwise.')
pwGenLocalAIIType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 48), PwGenIdType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwGenLocalAIIType.setStatus('current')
if mibBuilder.loadTexts: pwGenLocalAIIType.setDescription('This object is the type of the local forwarder\n        attachment individual identifier (AII) to be used\n        by this PW if generalized FEC (129) is used for PW\n        signaling or configuration.')
pwGenRemoteAIIType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 2, 1, 49), PwGenIdType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwGenRemoteAIIType.setStatus('current')
if mibBuilder.loadTexts: pwGenRemoteAIIType.setDescription('This object is the type of the remote forwarder\n        attachment individual identifier (AII) to be used\n        by this PW if generalized FEC (129) is used for PW\n        signaling or configuration.')
pwPerfCurrentTable = MibTable((1, 3, 6, 1, 2, 1, 10, 246, 1, 3), )
if mibBuilder.loadTexts: pwPerfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentTable.setDescription('This table provides per-PW performance information for\n         the current interval.')
pwPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwPerfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentEntry.setDescription('An entry in this table is created by the agent for\n         every PW.')
pwPerfCurrentInHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 1), HCPerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentInHCPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentInHCPackets.setDescription('High-capacity counter for number of packets received by\n         the PW (from the PSN) in the current 15-minute\n         interval.  This is the 64-bit version of\n         pwPerfCurrentInPackets, if pwPerfCurrentInHCPackets\n         is supported according to the rules spelled out\n         in RFC 2863.')
pwPerfCurrentInHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 2), HCPerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentInHCBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentInHCBytes.setDescription('High-capacity counter for number of bytes received by the\n         PW (from the PSN) in the current 15-minute interval.\n         This is the 64-bit version of pwPerfCurrentInBytes, if\n         pwPerfCurrentInHCBytes is supported according to the\n         rules spelled out in RFC 2863.')
pwPerfCurrentOutHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 3), HCPerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentOutHCPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentOutHCPackets.setDescription('High-capacity counter for number of packets forwarded by\n         the PW (to the PSN) in the current 15-minute interval.\n         This is the 64-bit version of pwPerfCurrentOutPackets,\n         if pwPerfCurrentOutHCPackets is supported according to\n         the rules spelled out in RFC 2863.')
pwPerfCurrentOutHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 4), HCPerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentOutHCBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentOutHCBytes.setDescription('High-capacity counter for number of bytes forwarded by\n         the PW (to the PSN) in the current 15-minute interval.\n         This is the 64-bit version of pwPerfCurrentOutBytes,\n         if pwPerfCurrentOutHCBytes is supported according to\n         the rules spelled out in RFC 2863.')
pwPerfCurrentInPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentInPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentInPackets.setDescription('The counter for number of packets received by the PW (from\n         the PSN) in the current 15-minute interval.\n         This is the 32-bit version of pwPerfCurrentInHCPackets,\n         if pwPerfCurrentInHCPackets is supported according to\n         the rules spelled out in RFC 2863.')
pwPerfCurrentInBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentInBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentInBytes.setDescription('The counter for number of bytes received by the\n         PW (from the PSN) in the current 15-minute interval.\n         It MUST be equal to the least significant 32 bits of\n         pwPerfCurrentInHCBytes, if pwPerfCurrentInHCBytes is\n         supported according to the rules spelled out in RFC 2863.')
pwPerfCurrentOutPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentOutPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentOutPackets.setDescription('The counter for number of packets forwarded by\n         the PW (to the PSN) in the current 15-minute interval.\n         It MUST be equal to the least significant 32 bits of\n         pwPerfCurrentOutHCPackets, if\n         pwPerfCurrentOutHCPackets is supported according to the\n         rules spelled out in RFC 2863.')
pwPerfCurrentOutBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 3, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfCurrentOutBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfCurrentOutBytes.setDescription('The counter for number of bytes forwarded by\n         the PW (to the PSN) in the current 15-minute interval.\n         It MUST be equal to the least significant 32 bits of\n         pwPerfCurrentOutHCBytes, if pwPerfCurrentOutHCBytes is\n         supported according to the rules spelled out in RFC 2863.')
pwPerfIntervalTable = MibTable((1, 3, 6, 1, 2, 1, 10, 246, 1, 4), )
if mibBuilder.loadTexts: pwPerfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalTable.setDescription('This table provides per-PW performance information for\n         each interval.')
pwPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-STD-MIB", "pwPerfIntervalNumber"))
if mibBuilder.loadTexts: pwPerfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalEntry.setDescription('An entry in this table is created by the agent for every\n         PW.')
pwPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: pwPerfIntervalNumber.setReference("Tesink, K. 'Definitions of Managed Objects for the\n        SONET/SDH Interface Type', RFC 2558")
if mibBuilder.loadTexts: pwPerfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalNumber.setDescription('A number N, between 1 and 96, which identifies the\n         interval for which the set of statistics is available.\n         The interval identified by 1 is the most recently\n         completed 15-minute interval, and the interval identified\n         by N is the interval immediately preceding the one\n         identified by N-1.\n         The minimum range of N is 1 through 4.  The default range\n         is 1 to 32.  The maximum range of N is 1 through 96.')
pwPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalValidData.setDescription('This variable indicates if the data for this interval\n        is valid.')
pwPerfIntervalTimeElapsed = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 3), HCPerfTimeElapsed()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalTimeElapsed.setDescription('The duration of this interval in seconds.')
pwPerfIntervalInHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 4), HCPerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalInHCPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalInHCPackets.setDescription('High-capacity counter for number of packets received by\n         the PW (from the PSN) during the interval.  This is the\n         64-bit version of pwPerfIntervalInPackets, if\n         pwPerfIntervalInHCPackets is supported according to the\n         rules spelled out in RFC 2863.')
pwPerfIntervalInHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 5), HCPerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalInHCBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalInHCBytes.setDescription('High-capacity counter for number of bytes received by the\n         PW (from the PSN) during the interval.\n         This is the 64-bit version of pwPerfIntervalInBytes, if\n         pwPerfIntervalInHCBytes is supported according to the\n         rules spelled out in RFC 2863.')
pwPerfIntervalOutHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 6), HCPerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalOutHCPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalOutHCPackets.setDescription('High-capacity counter for number of packets forwarded by\n         the PW (to the PSN) during the interval.\n         This is the 64-bit version of pwPerfIntervalOutPackets,\n         if pwPerfIntervalOutHCPackets is supported according to\n         the rules spelled out in RFC 2863.')
pwPerfIntervalOutHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 7), HCPerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalOutHCBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalOutHCBytes.setDescription('High-capacity counter for number of bytes forwarded by\n         the PW (to the PSN) during the interval.\n         This is the 64-bit version of pwPerfIntervalOutBytes,\n         if pwPerfIntervalOutHCBytes is supported according to\n         the rules spelled out in RFC 2863.')
pwPerfIntervalInPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 8), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalInPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalInPackets.setDescription('This value represents the number of packets received\n        by this PW during the interval.\n        It MUST be equal to the least significant 32 bits of\n        pwPerfIntervalInHCPackets, if pwPerfIntervalInHCPackets\n        is supported according to the rules spelled out in\n        RFC 2863.')
pwPerfIntervalInBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalInBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalInBytes.setDescription('This value represents the number of bytes received by\n        this PW during the interval.  It MUST be equal to the\n        least significant 32 bits of pwPerfIntervalInHCBytes, if\n        pwPerfIntervalInHCBytes is supported according to the\n        rules spelled out in RFC 2863.')
pwPerfIntervalOutPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalOutPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalOutPackets.setDescription('This value represents the number of packets sent by this\n        PW during the interval.\n        It MUST be equal to the least significant 32 bits of\n        pwPerfIntervalOutHCPackets, if\n        pwPerfIntervalOutHCPackets is supported according to the\n        rules spelled out in RFC 2863.')
pwPerfIntervalOutBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 4, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfIntervalOutBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerfIntervalOutBytes.setDescription('This value represents the number of bytes sent by this\n        PW during the interval.\n        It MUST be equal to the least significant 32\n        bits of pwPerfIntervalOutHCBytes,\n        if pwPerfIntervalOutHCBytes is supported according to\n        the rules spelled out in RFC 2863.')
pwPerf1DayIntervalTable = MibTable((1, 3, 6, 1, 2, 1, 10, 246, 1, 5), )
if mibBuilder.loadTexts: pwPerf1DayIntervalTable.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalTable.setDescription("This table provides per-PW performance information for\n         the current day's measurement and the previous day's\n\n         interval.")
pwPerf1DayIntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-STD-MIB", "pwPerf1DayIntervalNumber"))
if mibBuilder.loadTexts: pwPerf1DayIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalEntry.setDescription('An entry in this table is created by the agent for every\n         PW.')
pwPerf1DayIntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: pwPerf1DayIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalNumber.setDescription("History Data Interval number.  Interval 1 is the current day's\n      measurement period, interval 2 is the most recent previous\n      day, and interval 30 is 31 days ago.  Intervals 3..31 are\n      optional.")
pwPerf1DayIntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerf1DayIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalValidData.setDescription('This variable indicates if the data for this interval\n        is valid.')
pwPerf1DayIntervalTimeElapsed = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1, 3), HCPerfTimeElapsed()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerf1DayIntervalTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalTimeElapsed.setDescription('The number of seconds in the 1-day interval over which the\n      performance monitoring information is actually counted.\n      This value will be the same as the interval duration except\n      in a situation where performance monitoring data could not\n      be collected for any reason or where agent clock adjustments\n      have been made.')
pwPerf1DayIntervalInHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerf1DayIntervalInHCPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalInHCPackets.setDescription('High-capacity counter for the total number of packets\n         received by the PW (from the PSN).')
pwPerf1DayIntervalInHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerf1DayIntervalInHCBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalInHCBytes.setDescription('High-capacity counter for the total number of bytes\n         received by the PW (from the PSN).')
pwPerf1DayIntervalOutHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerf1DayIntervalOutHCPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalOutHCPackets.setDescription('High-capacity counter for the total number of packets\n         forwarded by the PW (to the PSN).')
pwPerf1DayIntervalOutHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 5, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerf1DayIntervalOutHCBytes.setStatus('current')
if mibBuilder.loadTexts: pwPerf1DayIntervalOutHCBytes.setDescription('High-capacity counter for the total number of bytes\n         forwarded by the PW (to the PSN).')
pwPerfTotalErrorPackets = MibScalar((1, 3, 6, 1, 2, 1, 10, 246, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPerfTotalErrorPackets.setStatus('current')
if mibBuilder.loadTexts: pwPerfTotalErrorPackets.setDescription('Counter for number of errors at the PW processing level,\n         for example, packets received with unknown PW label.')
pwIndexMappingTable = MibTable((1, 3, 6, 1, 2, 1, 10, 246, 1, 7), )
if mibBuilder.loadTexts: pwIndexMappingTable.setStatus('current')
if mibBuilder.loadTexts: pwIndexMappingTable.setDescription('This table enables the reverse mapping of the unique\n         PWid parameters [peer IP, PW type, and PW ID] and the\n         pwIndex.  The table is not applicable for PWs created\n         manually or by using the generalized FEC.')
pwIndexMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 246, 1, 7, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndexMappingPwType"), (0, "PW-STD-MIB", "pwIndexMappingPwID"), (0, "PW-STD-MIB", "pwIndexMappingPeerAddrType"), (0, "PW-STD-MIB", "pwIndexMappingPeerAddr"))
if mibBuilder.loadTexts: pwIndexMappingEntry.setStatus('current')
if mibBuilder.loadTexts: pwIndexMappingEntry.setDescription('An entry in this table MUST be created by the agent for\n         every PW created by the pwTable for which pwOwner\n         equals pwIdFecSignaling and pwID is not zero.\n\n         Implementers need to be aware that if the value of\n         the pwIndexMappingPeerAddr (an OID) has more than\n         113 sub-identifiers, then OIDs of column instances\n         in this table will have more than 128 sub-identifiers\n         and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
pwIndexMappingPwType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 7, 1, 1), IANAPwTypeTC())
if mibBuilder.loadTexts: pwIndexMappingPwType.setStatus('current')
if mibBuilder.loadTexts: pwIndexMappingPwType.setDescription('The PW type (indicates the service) of this PW.')
pwIndexMappingPwID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 7, 1, 2), PwIDType())
if mibBuilder.loadTexts: pwIndexMappingPwID.setStatus('current')
if mibBuilder.loadTexts: pwIndexMappingPwID.setDescription('The PW ID of this PW.  Zero if the PW is configured\n         manually.')
pwIndexMappingPeerAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 7, 1, 3), InetAddressType())
if mibBuilder.loadTexts: pwIndexMappingPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: pwIndexMappingPeerAddrType.setDescription('IP address type of the peer node.')
pwIndexMappingPeerAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 7, 1, 4), InetAddress())
if mibBuilder.loadTexts: pwIndexMappingPeerAddr.setStatus('current')
if mibBuilder.loadTexts: pwIndexMappingPeerAddr.setDescription('IP address of the peer node.')
pwIndexMappingPwIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 7, 1, 5), PwIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwIndexMappingPwIndex.setStatus('current')
if mibBuilder.loadTexts: pwIndexMappingPwIndex.setDescription('The value that represents the PW in the pwTable.')
pwPeerMappingTable = MibTable((1, 3, 6, 1, 2, 1, 10, 246, 1, 8), )
if mibBuilder.loadTexts: pwPeerMappingTable.setStatus('current')
if mibBuilder.loadTexts: pwPeerMappingTable.setDescription('This table provides reverse mapping of the existing PW\n         based on PW type and PW ID ordering.  This table is\n         typically useful for the element management system (EMS)\n         ordered query of existing PWs.')
pwPeerMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 246, 1, 8, 1), ).setIndexNames((0, "PW-STD-MIB", "pwPeerMappingPeerAddrType"), (0, "PW-STD-MIB", "pwPeerMappingPeerAddr"), (0, "PW-STD-MIB", "pwPeerMappingPwType"), (0, "PW-STD-MIB", "pwPeerMappingPwID"))
if mibBuilder.loadTexts: pwPeerMappingEntry.setStatus('current')
if mibBuilder.loadTexts: pwPeerMappingEntry.setDescription('An entry in this table is created by the agent for every\n         PW entry in the pwTable.\n\n        Implementers need to be aware that if the value of the\n        pwPeerMappingPeerAddr (an OID) has more than 113\n        sub-identifiers, then OIDs of column instances in this\n        table will have more than 128 sub-identifiers and cannot\n        be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
pwPeerMappingPeerAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 8, 1, 1), InetAddressType())
if mibBuilder.loadTexts: pwPeerMappingPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: pwPeerMappingPeerAddrType.setDescription('IP address type of the peer node.')
pwPeerMappingPeerAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 8, 1, 2), InetAddress())
if mibBuilder.loadTexts: pwPeerMappingPeerAddr.setStatus('current')
if mibBuilder.loadTexts: pwPeerMappingPeerAddr.setDescription('IP address of the peer node.')
pwPeerMappingPwType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 8, 1, 3), IANAPwTypeTC())
if mibBuilder.loadTexts: pwPeerMappingPwType.setStatus('current')
if mibBuilder.loadTexts: pwPeerMappingPwType.setDescription('The PW type (indicates the emulated service) of this PW.')
pwPeerMappingPwID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 8, 1, 4), PwIDType())
if mibBuilder.loadTexts: pwPeerMappingPwID.setStatus('current')
if mibBuilder.loadTexts: pwPeerMappingPwID.setDescription('The PW ID of this PW.  Zero if the PW is configured\n         manually.')
pwPeerMappingPwIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 8, 1, 5), PwIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwPeerMappingPwIndex.setStatus('current')
if mibBuilder.loadTexts: pwPeerMappingPwIndex.setDescription('The value that represents the PW in the pwTable.')
pwUpDownNotifEnable = MibScalar((1, 3, 6, 1, 2, 1, 10, 246, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwUpDownNotifEnable.setReference('See also [RFC3413] for explanation that\n       notifications are under the ultimate control of the\n       MIB module in this document.')
if mibBuilder.loadTexts: pwUpDownNotifEnable.setStatus('current')
if mibBuilder.loadTexts: pwUpDownNotifEnable.setDescription('If this object is set to true(1), then it enables\n       the emission of pwUp and pwDown\n       notifications; otherwise, these notifications are not\n       emitted.')
pwDeletedNotifEnable = MibScalar((1, 3, 6, 1, 2, 1, 10, 246, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwDeletedNotifEnable.setReference('See also [RFC3413] for explanation that\n       notifications are under the ultimate control of the\n       MIB module in this document.')
if mibBuilder.loadTexts: pwDeletedNotifEnable.setStatus('current')
if mibBuilder.loadTexts: pwDeletedNotifEnable.setDescription('If this object is set to true(1), then it enables the\n       emission of pwDeleted notification; otherwise, this\n       notification is not emitted.')
pwNotifRate = MibScalar((1, 3, 6, 1, 2, 1, 10, 246, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwNotifRate.setStatus('current')
if mibBuilder.loadTexts: pwNotifRate.setDescription('This object defines the maximum number of PW notifications\n       that can be emitted from the device per second.')
pwGenFecIndexMappingTable = MibTable((1, 3, 6, 1, 2, 1, 10, 246, 1, 12), )
if mibBuilder.loadTexts: pwGenFecIndexMappingTable.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingTable.setDescription('This table enables the reverse mapping of the unique\n         PWid parameters [GroupAttachmentID, LocalAttachmentID,\n         and PeerAttachmentID] and the pwIndex.  The table is\n         only applicable for PW using the generalized FEC.')
pwGenFecIndexMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1), ).setIndexNames((0, "PW-STD-MIB", "pwGenFecIndexMappingAGIType"), (0, "PW-STD-MIB", "pwGenFecIndexMappingAGI"), (0, "PW-STD-MIB", "pwGenFecIndexMappingLocalAIIType"), (0, "PW-STD-MIB", "pwGenFecIndexMappingLocalAII"), (0, "PW-STD-MIB", "pwGenFecIndexMappingRemoteAIIType"), (0, "PW-STD-MIB", "pwGenFecIndexMappingRemoteAII"))
if mibBuilder.loadTexts: pwGenFecIndexMappingEntry.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingEntry.setDescription('An entry in this table MUST be created by the agent for\n         every PW created by the pwTable for which pwOwner\n         equals genFecSignaling.\n\n         Implementers need to be aware that if the combined value\n         of pwGenFecIndexMappingAGI, pwGenFecIndexMappingLocalAII,\n         and pwGenFecIndexMappingRemoteAII (OIDs) has more than\n         113 sub-identifiers, then OIDs of column instances\n         in this table will have more than 128 sub-identifiers\n         and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
pwGenFecIndexMappingAGIType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1, 1), PwGenIdType())
if mibBuilder.loadTexts: pwGenFecIndexMappingAGIType.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingAGIType.setDescription('This object is the type of the attachment\n         group identifier (AGI) that this PW belongs to.')
pwGenFecIndexMappingAGI = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1, 2), PwAttachmentIdentifierType())
if mibBuilder.loadTexts: pwGenFecIndexMappingAGI.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingAGI.setDescription('This object is an octet string representing the attachment\n         group identifier (AGI) that this PW belongs to,\n         which typically identifies the VPN ID.')
pwGenFecIndexMappingLocalAIIType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1, 3), PwGenIdType())
if mibBuilder.loadTexts: pwGenFecIndexMappingLocalAIIType.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingLocalAIIType.setDescription('This object is the type of the local forwarder\n         attachment individual identifier (AII) to be used\n         by this PW.')
pwGenFecIndexMappingLocalAII = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1, 4), PwAttachmentIdentifierType())
if mibBuilder.loadTexts: pwGenFecIndexMappingLocalAII.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingLocalAII.setDescription('This object is an octet string representing the local\n         forwarder attachment individual identifier (AII) to be used\n         by this PW.  It is used as the SAII for outgoing signaling\n         messages and the TAII in the incoming messages from the\n         peer.')
pwGenFecIndexMappingRemoteAIIType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1, 5), PwGenIdType())
if mibBuilder.loadTexts: pwGenFecIndexMappingRemoteAIIType.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingRemoteAIIType.setDescription('This object is the type of the remote forwarder\n         attachment individual identifier (AII) to be used\n         by this PW.')
pwGenFecIndexMappingRemoteAII = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1, 6), PwAttachmentIdentifierType())
if mibBuilder.loadTexts: pwGenFecIndexMappingRemoteAII.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingRemoteAII.setDescription('This object is an octet string representing the peer\n         forwarder attachment individual identifier (AII) to be used\n         by this PW.  It is used as the TAII for outgoing signaling\n         messages and the SAII in the incoming messages from the\n         peer.')
pwGenFecIndexMappingPwIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 246, 1, 12, 1, 7), PwIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwGenFecIndexMappingPwIndex.setStatus('current')
if mibBuilder.loadTexts: pwGenFecIndexMappingPwIndex.setDescription('The value that represents the PW in the pwTable.')
pwDown = NotificationType((1, 3, 6, 1, 2, 1, 10, 246, 0, 1)).setObjects(("PW-STD-MIB", "pwOperStatus"), ("PW-STD-MIB", "pwOperStatus"))
if mibBuilder.loadTexts: pwDown.setStatus('current')
if mibBuilder.loadTexts: pwDown.setDescription('This notification is generated when the pwOperStatus\n        object for one or more contiguous entries in the pwTable are\n        about to enter the down(2) or lowerLayerDown(6) state from\n        any other state, except for transition from the\n        notPresent(5) state.  For the purpose of deciding when\n        these notifications occur, the lowerLayerDown(6) state\n        and the down(2) state are considered to be equivalent;\n        i.e., there is no notification on transition from\n        lowerLayerDown(6) into down(2), and there is a trap on\n        transition from any other state except down(2) (and\n        notPresent) into lowerLayerDown(6).\n\n        The included values of pwOperStatus MUST each be equal to\n        down(2) or lowerLayerDown(6).  The two instances of\n        pwOperStatus in this notification indicate the range of\n        indexes that are affected.  Note that all the indexes of\n        the two ends of the range can be derived from the\n        instance identifiers of these two objects.  For cases\n        where a contiguous range of cross-connects have\n        transitioned into the down(2) and lowerLayerDown(6) states\n        at roughly the same time, the device SHOULD issue a single\n        notification for each range of contiguous indexes in an\n        effort to minimize the emission of a large number of\n        notifications.  If a notification has to be issued for\n        just a single cross-connect entry, then the instance\n        identifier (and values) of the two pwOperStatus objects\n        MUST be identical.')
pwUp = NotificationType((1, 3, 6, 1, 2, 1, 10, 246, 0, 2)).setObjects(("PW-STD-MIB", "pwOperStatus"), ("PW-STD-MIB", "pwOperStatus"))
if mibBuilder.loadTexts: pwUp.setStatus('current')
if mibBuilder.loadTexts: pwUp.setDescription('This notification is generated when the pwOperStatus\n        object for one or more contiguous entries in the pwTable are\n        about to enter the up(1) state from some other state\n\n        except the notPresent(5) state and given that the pwDown\n        notification been issued for these entries.  The included\n        values of pwOperStatus MUST both be set equal to this\n        new state (i.e., up(1)).  The two instances of pwOperStatus\n        in this notification indicate the range of indexes that\n        are affected.  Note that all the indexes of the two ends\n        of the range can be derived from the instance identifiers\n        of these two objects.  For cases where a contiguous range\n        of cross-connects have transitioned into the up(1) state\n        at roughly the same time, the device SHOULD issue a single\n        notification for each range of contiguous indexes in an\n        effort to minimize the emission of a large number of\n        notifications.  If a notification has to be issued for\n        just a single cross-connect entry, then the instance\n        identifier (and values) of the two pwOperStatus objects\n        MUST be identical.')
pwDeleted = NotificationType((1, 3, 6, 1, 2, 1, 10, 246, 0, 3)).setObjects(("PW-STD-MIB", "pwType"), ("PW-STD-MIB", "pwID"), ("PW-STD-MIB", "pwPeerAddrType"), ("PW-STD-MIB", "pwPeerAddr"))
if mibBuilder.loadTexts: pwDeleted.setStatus('current')
if mibBuilder.loadTexts: pwDeleted.setDescription('This notification is generated when the PW has been\n        deleted, i.e., when the pwRowStatus has been set to\n        destroy(6) or the PW has been deleted by a non-MIB\n        application or due to an auto-discovery process.\n       ')
pwGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 246, 2, 1))
pwCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 246, 2, 2))
pwModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 246, 2, 2, 1)).setObjects(("PW-STD-MIB", "pwBasicGroup"), ("PW-STD-MIB", "pwPerformanceGeneralGroup"), ("PW-STD-MIB", "pwNotificationGroup"), ("PW-STD-MIB", "pwPwIdGroup"), ("PW-STD-MIB", "pwGeneralizedFecGroup"), ("PW-STD-MIB", "pwFcsGroup"), ("PW-STD-MIB", "pwFragGroup"), ("PW-STD-MIB", "pwPwStatusGroup"), ("PW-STD-MIB", "pwGetNextGroup"), ("PW-STD-MIB", "pwPriorityGroup"), ("PW-STD-MIB", "pwAttachmentGroup"), ("PW-STD-MIB", "pwPeformance1DayIntervalGroup"), ("PW-STD-MIB", "pwPerformanceIntervalGeneralGroup"), ("PW-STD-MIB", "pwPeformanceIntervalGroup"), ("PW-STD-MIB", "pwHCPeformanceIntervalGroup"), ("PW-STD-MIB", "pwMappingTablesGroup"), ("PW-STD-MIB", "pwSignalingGroup"), ("PW-STD-MIB", "pwNotificationControlGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwModuleFullCompliance = pwModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: pwModuleFullCompliance.setDescription('The compliance statement for agents that provide full\n             support for the PW MIB module.  Such devices can\n             then be monitored and configured using\n\n             this MIB module.')
pwModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 246, 2, 2, 2)).setObjects(("PW-STD-MIB", "pwBasicGroup"), ("PW-STD-MIB", "pwNotificationGroup"), ("PW-STD-MIB", "pwPwIdGroup"), ("PW-STD-MIB", "pwGeneralizedFecGroup"), ("PW-STD-MIB", "pwFcsGroup"), ("PW-STD-MIB", "pwFragGroup"), ("PW-STD-MIB", "pwPwStatusGroup"), ("PW-STD-MIB", "pwGetNextGroup"), ("PW-STD-MIB", "pwPriorityGroup"), ("PW-STD-MIB", "pwAttachmentGroup"), ("PW-STD-MIB", "pwPeformance1DayIntervalGroup"), ("PW-STD-MIB", "pwPerformanceIntervalGeneralGroup"), ("PW-STD-MIB", "pwPeformanceIntervalGroup"), ("PW-STD-MIB", "pwHCPeformanceIntervalGroup"), ("PW-STD-MIB", "pwMappingTablesGroup"), ("PW-STD-MIB", "pwSignalingGroup"), ("PW-STD-MIB", "pwNotificationControlGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwModuleReadOnlyCompliance = pwModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: pwModuleReadOnlyCompliance.setDescription('The compliance statement for agents that provide read-\n             only support for the PW MIB module.  Such devices can\n             then be monitored but cannot be configured using this\n             MIB module.')
pwBasicGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 1)).setObjects(("PW-STD-MIB", "pwType"), ("PW-STD-MIB", "pwOwner"), ("PW-STD-MIB", "pwPsnType"), ("PW-STD-MIB", "pwIfIndex"), ("PW-STD-MIB", "pwCwPreference"), ("PW-STD-MIB", "pwLocalIfMtu"), ("PW-STD-MIB", "pwOutboundLabel"), ("PW-STD-MIB", "pwInboundLabel"), ("PW-STD-MIB", "pwName"), ("PW-STD-MIB", "pwDescr"), ("PW-STD-MIB", "pwCreateTime"), ("PW-STD-MIB", "pwUpTime"), ("PW-STD-MIB", "pwLastChange"), ("PW-STD-MIB", "pwAdminStatus"), ("PW-STD-MIB", "pwOperStatus"), ("PW-STD-MIB", "pwLocalStatus"), ("PW-STD-MIB", "pwRowStatus"), ("PW-STD-MIB", "pwStorageType"), ("PW-STD-MIB", "pwOamEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwBasicGroup = pwBasicGroup.setStatus('current')
if mibBuilder.loadTexts: pwBasicGroup.setDescription('Collection of objects that are required in all\n        implementations that support the PW MIB module.')
pwPwIdGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 2)).setObjects(("PW-STD-MIB", "pwID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwPwIdGroup = pwPwIdGroup.setStatus('current')
if mibBuilder.loadTexts: pwPwIdGroup.setDescription('Collection of objects required for PW ID configuration\n        and signaling.')
pwGeneralizedFecGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 3)).setObjects(("PW-STD-MIB", "pwGroupAttachmentID"), ("PW-STD-MIB", "pwLocalAttachmentID"), ("PW-STD-MIB", "pwRemoteAttachmentID"), ("PW-STD-MIB", "pwGenAGIType"), ("PW-STD-MIB", "pwGenLocalAIIType"), ("PW-STD-MIB", "pwGenRemoteAIIType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwGeneralizedFecGroup = pwGeneralizedFecGroup.setStatus('current')
if mibBuilder.loadTexts: pwGeneralizedFecGroup.setDescription('Collection of objects required for generalized FEC\n\n        configuration and signaling.')
pwFcsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 4)).setObjects(("PW-STD-MIB", "pwFcsRetentionCfg"), ("PW-STD-MIB", "pwFcsRetentionStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwFcsGroup = pwFcsGroup.setStatus('current')
if mibBuilder.loadTexts: pwFcsGroup.setDescription('Collection of objects required for FCS retention\n        configuration and signaling.')
pwFragGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 5)).setObjects(("PW-STD-MIB", "pwFragmentCfgSize"), ("PW-STD-MIB", "pwRmtFragCapability"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwFragGroup = pwFragGroup.setStatus('current')
if mibBuilder.loadTexts: pwFragGroup.setDescription('Collection of objects required for fragmentation\n        configuration and signaling.')
pwPwStatusGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 6)).setObjects(("PW-STD-MIB", "pwRemoteCapabilities"), ("PW-STD-MIB", "pwRemoteStatusCapable"), ("PW-STD-MIB", "pwRemoteStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwPwStatusGroup = pwPwStatusGroup.setStatus('current')
if mibBuilder.loadTexts: pwPwStatusGroup.setDescription('Collection of objects required for PW status configuration\n        and signaling.')
pwGetNextGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 7)).setObjects(("PW-STD-MIB", "pwIndexNext"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwGetNextGroup = pwGetNextGroup.setStatus('current')
if mibBuilder.loadTexts: pwGetNextGroup.setDescription('Collection of objects for getting the next available\n\n        index.')
pwPriorityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 8)).setObjects(("PW-STD-MIB", "pwSetUpPriority"), ("PW-STD-MIB", "pwHoldingPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwPriorityGroup = pwPriorityGroup.setStatus('current')
if mibBuilder.loadTexts: pwPriorityGroup.setDescription('Collection of objects for controlling the PW setup and\n        holding priority.')
pwAttachmentGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 9)).setObjects(("PW-STD-MIB", "pwAttachedPwIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAttachmentGroup = pwAttachmentGroup.setStatus('current')
if mibBuilder.loadTexts: pwAttachmentGroup.setDescription('Collection of objects for PW configuration as ifIndex.')
pwPerformanceGeneralGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 10)).setObjects(("PW-STD-MIB", "pwPerfTotalErrorPackets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwPerformanceGeneralGroup = pwPerformanceGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: pwPerformanceGeneralGroup.setDescription('Collection of general objects needed for managing the\n        total running performance parameters.')
pwPeformance1DayIntervalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 11)).setObjects(("PW-STD-MIB", "pwPerf1DayIntervalValidData"), ("PW-STD-MIB", "pwPerf1DayIntervalTimeElapsed"), ("PW-STD-MIB", "pwPerf1DayIntervalInHCPackets"), ("PW-STD-MIB", "pwPerf1DayIntervalInHCBytes"), ("PW-STD-MIB", "pwPerf1DayIntervalOutHCPackets"), ("PW-STD-MIB", "pwPerf1DayIntervalOutHCBytes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwPeformance1DayIntervalGroup = pwPeformance1DayIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: pwPeformance1DayIntervalGroup.setDescription('Collection of objects needed for a PW running 1-day\n\n        interval performance collection.')
pwPerformanceIntervalGeneralGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 12)).setObjects(("PW-STD-MIB", "pwTimeElapsed"), ("PW-STD-MIB", "pwValidIntervals"), ("PW-STD-MIB", "pwPerfIntervalValidData"), ("PW-STD-MIB", "pwPerfIntervalTimeElapsed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwPerformanceIntervalGeneralGroup = pwPerformanceIntervalGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: pwPerformanceIntervalGeneralGroup.setDescription('Collection of general objects needed for managing the\n        interval performance parameters.')
pwPeformanceIntervalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 13)).setObjects(("PW-STD-MIB", "pwPerfCurrentInPackets"), ("PW-STD-MIB", "pwPerfCurrentInBytes"), ("PW-STD-MIB", "pwPerfCurrentOutPackets"), ("PW-STD-MIB", "pwPerfCurrentOutBytes"), ("PW-STD-MIB", "pwPerfIntervalInPackets"), ("PW-STD-MIB", "pwPerfIntervalInBytes"), ("PW-STD-MIB", "pwPerfIntervalOutPackets"), ("PW-STD-MIB", "pwPerfIntervalOutBytes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwPeformanceIntervalGroup = pwPeformanceIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: pwPeformanceIntervalGroup.setDescription('Collection of 32-bit objects needed for PW performance\n        collection in 15-minute intervals.')
pwHCPeformanceIntervalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 14)).setObjects(("PW-STD-MIB", "pwPerfCurrentInHCPackets"), ("PW-STD-MIB", "pwPerfCurrentInHCBytes"), ("PW-STD-MIB", "pwPerfCurrentOutHCPackets"), ("PW-STD-MIB", "pwPerfCurrentOutHCBytes"), ("PW-STD-MIB", "pwPerfIntervalInHCPackets"), ("PW-STD-MIB", "pwPerfIntervalInHCBytes"), ("PW-STD-MIB", "pwPerfIntervalOutHCPackets"), ("PW-STD-MIB", "pwPerfIntervalOutHCBytes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwHCPeformanceIntervalGroup = pwHCPeformanceIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: pwHCPeformanceIntervalGroup.setDescription('Collection of HC objects needed for PW performance\n        collection in 15-minute intervals.')
pwMappingTablesGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 15)).setObjects(("PW-STD-MIB", "pwIndexMappingPwIndex"), ("PW-STD-MIB", "pwPeerMappingPwIndex"), ("PW-STD-MIB", "pwGenFecIndexMappingPwIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMappingTablesGroup = pwMappingTablesGroup.setStatus('current')
if mibBuilder.loadTexts: pwMappingTablesGroup.setDescription('Collection of objects contained in the reverse\n        mapping tables.')
pwNotificationControlGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 16)).setObjects(("PW-STD-MIB", "pwUpDownNotifEnable"), ("PW-STD-MIB", "pwDeletedNotifEnable"), ("PW-STD-MIB", "pwNotifRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwNotificationControlGroup = pwNotificationControlGroup.setStatus('current')
if mibBuilder.loadTexts: pwNotificationControlGroup.setDescription('Collection of objects for controlling the PW\n        notifications.')
pwNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 17)).setObjects(("PW-STD-MIB", "pwUp"), ("PW-STD-MIB", "pwDown"), ("PW-STD-MIB", "pwDeleted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwNotificationGroup = pwNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: pwNotificationGroup.setDescription('Collection of PW notifications objects.')
pwSignalingGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 246, 2, 1, 18)).setObjects(("PW-STD-MIB", "pwPeerAddrType"), ("PW-STD-MIB", "pwPeerAddr"), ("PW-STD-MIB", "pwLocalGroupID"), ("PW-STD-MIB", "pwLocalIfString"), ("PW-STD-MIB", "pwLocalCapabAdvert"), ("PW-STD-MIB", "pwRemoteGroupID"), ("PW-STD-MIB", "pwCwStatus"), ("PW-STD-MIB", "pwRemoteIfMtu"), ("PW-STD-MIB", "pwRemoteIfString"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwSignalingGroup = pwSignalingGroup.setStatus('current')
if mibBuilder.loadTexts: pwSignalingGroup.setDescription('Collection of objects for use in implementations that\n        support the PW signaling.')
mibBuilder.exportSymbols("PW-STD-MIB", pwPeerAddr=pwPeerAddr, pwOutboundLabel=pwOutboundLabel, pwGenLocalAIIType=pwGenLocalAIIType, pwPerfIntervalInBytes=pwPerfIntervalInBytes, pwPeformance1DayIntervalGroup=pwPeformance1DayIntervalGroup, pwGenFecIndexMappingRemoteAII=pwGenFecIndexMappingRemoteAII, pwTable=pwTable, pwOamEnable=pwOamEnable, pwPerfIntervalInHCPackets=pwPerfIntervalInHCPackets, pwConformance=pwConformance, pwGenFecIndexMappingEntry=pwGenFecIndexMappingEntry, pwCompliances=pwCompliances, pwGenFecIndexMappingAGI=pwGenFecIndexMappingAGI, pwAttachmentGroup=pwAttachmentGroup, pwIndexMappingPwIndex=pwIndexMappingPwIndex, pwIfIndex=pwIfIndex, pwHCPeformanceIntervalGroup=pwHCPeformanceIntervalGroup, pwRowStatus=pwRowStatus, pwModuleReadOnlyCompliance=pwModuleReadOnlyCompliance, pwFcsRetentionCfg=pwFcsRetentionCfg, pwPeerMappingPwID=pwPeerMappingPwID, pwPerfCurrentOutHCPackets=pwPerfCurrentOutHCPackets, pwTimeElapsed=pwTimeElapsed, pwIndexMappingPeerAddr=pwIndexMappingPeerAddr, pwFragGroup=pwFragGroup, pwNotifRate=pwNotifRate, pwPsnType=pwPsnType, pwModuleFullCompliance=pwModuleFullCompliance, pwInboundLabel=pwInboundLabel, pwPeerMappingPeerAddrType=pwPeerMappingPeerAddrType, pwPriorityGroup=pwPriorityGroup, pwCwStatus=pwCwStatus, pwPerfCurrentInBytes=pwPerfCurrentInBytes, pwRemoteStatus=pwRemoteStatus, pwPerfCurrentInHCPackets=pwPerfCurrentInHCPackets, pwLocalStatus=pwLocalStatus, pwPerf1DayIntervalInHCPackets=pwPerf1DayIntervalInHCPackets, pwDown=pwDown, pwGenFecIndexMappingLocalAII=pwGenFecIndexMappingLocalAII, pwPerfIntervalOutBytes=pwPerfIntervalOutBytes, pwNotifications=pwNotifications, pwGenFecIndexMappingTable=pwGenFecIndexMappingTable, pwPerfIntervalNumber=pwPerfIntervalNumber, pwPerfIntervalInHCBytes=pwPerfIntervalInHCBytes, pwLocalGroupID=pwLocalGroupID, pwPwStatusGroup=pwPwStatusGroup, pwRemoteCapabilities=pwRemoteCapabilities, pwPerfCurrentOutBytes=pwPerfCurrentOutBytes, pwAdminStatus=pwAdminStatus, pwSignalingGroup=pwSignalingGroup, pwIndexNext=pwIndexNext, pwGenAGIType=pwGenAGIType, pwIndexMappingPwType=pwIndexMappingPwType, pwCreateTime=pwCreateTime, pwPerf1DayIntervalTable=pwPerf1DayIntervalTable, pwRemoteIfString=pwRemoteIfString, pwPerf1DayIntervalInHCBytes=pwPerf1DayIntervalInHCBytes, pwPerformanceIntervalGeneralGroup=pwPerformanceIntervalGeneralGroup, pwPerfIntervalTable=pwPerfIntervalTable, pwPerformanceGeneralGroup=pwPerformanceGeneralGroup, pwPeerAddrType=pwPeerAddrType, pwID=pwID, pwGeneralizedFecGroup=pwGeneralizedFecGroup, pwGroupAttachmentID=pwGroupAttachmentID, pwGenFecIndexMappingAGIType=pwGenFecIndexMappingAGIType, pwPeerMappingPwIndex=pwPeerMappingPwIndex, pwSetUpPriority=pwSetUpPriority, pwPerfCurrentTable=pwPerfCurrentTable, pwPeerMappingTable=pwPeerMappingTable, pwRemoteGroupID=pwRemoteGroupID, pwPerfIntervalOutPackets=pwPerfIntervalOutPackets, pwIndexMappingEntry=pwIndexMappingEntry, pwNotificationGroup=pwNotificationGroup, pwPerfIntervalInPackets=pwPerfIntervalInPackets, pwLocalIfMtu=pwLocalIfMtu, pwOwner=pwOwner, pwRmtFragCapability=pwRmtFragCapability, PYSNMP_MODULE_ID=pwStdMIB, pwPerfIntervalTimeElapsed=pwPerfIntervalTimeElapsed, pwPerfIntervalEntry=pwPerfIntervalEntry, pwIndexMappingTable=pwIndexMappingTable, pwUp=pwUp, pwPeerMappingPeerAddr=pwPeerMappingPeerAddr, pwGetNextGroup=pwGetNextGroup, pwPerf1DayIntervalOutHCBytes=pwPerf1DayIntervalOutHCBytes, pwPerfCurrentOutHCBytes=pwPerfCurrentOutHCBytes, pwRemoteStatusCapable=pwRemoteStatusCapable, pwPerfTotalErrorPackets=pwPerfTotalErrorPackets, pwNotificationControlGroup=pwNotificationControlGroup, pwPerfCurrentInPackets=pwPerfCurrentInPackets, pwPerfCurrentEntry=pwPerfCurrentEntry, pwPerf1DayIntervalValidData=pwPerf1DayIntervalValidData, pwGenFecIndexMappingPwIndex=pwGenFecIndexMappingPwIndex, pwName=pwName, pwPerfCurrentOutPackets=pwPerfCurrentOutPackets, pwLocalCapabAdvert=pwLocalCapabAdvert, pwCwPreference=pwCwPreference, pwValidIntervals=pwValidIntervals, pwPwIdGroup=pwPwIdGroup, pwLocalIfString=pwLocalIfString, pwGenFecIndexMappingRemoteAIIType=pwGenFecIndexMappingRemoteAIIType, pwGenFecIndexMappingLocalAIIType=pwGenFecIndexMappingLocalAIIType, pwType=pwType, pwPerfCurrentInHCBytes=pwPerfCurrentInHCBytes, pwOperStatus=pwOperStatus, pwLastChange=pwLastChange, pwRemoteAttachmentID=pwRemoteAttachmentID, pwPerfIntervalOutHCPackets=pwPerfIntervalOutHCPackets, pwUpDownNotifEnable=pwUpDownNotifEnable, pwPerf1DayIntervalOutHCPackets=pwPerf1DayIntervalOutHCPackets, pwUpTime=pwUpTime, pwPeerMappingEntry=pwPeerMappingEntry, pwAttachedPwIndex=pwAttachedPwIndex, pwLocalAttachmentID=pwLocalAttachmentID, pwPerf1DayIntervalTimeElapsed=pwPerf1DayIntervalTimeElapsed, pwPerfIntervalOutHCBytes=pwPerfIntervalOutHCBytes, pwPerf1DayIntervalNumber=pwPerf1DayIntervalNumber, pwEntry=pwEntry, pwGroups=pwGroups, pwHoldingPriority=pwHoldingPriority, pwStdMIB=pwStdMIB, pwPerf1DayIntervalEntry=pwPerf1DayIntervalEntry, pwMappingTablesGroup=pwMappingTablesGroup, pwIndex=pwIndex, pwStorageType=pwStorageType, pwIndexMappingPeerAddrType=pwIndexMappingPeerAddrType, pwPeformanceIntervalGroup=pwPeformanceIntervalGroup, pwRemoteIfMtu=pwRemoteIfMtu, pwFcsGroup=pwFcsGroup, pwPerfIntervalValidData=pwPerfIntervalValidData, pwDeletedNotifEnable=pwDeletedNotifEnable, pwFragmentCfgSize=pwFragmentCfgSize, pwGenRemoteAIIType=pwGenRemoteAIIType, pwDeleted=pwDeleted, pwObjects=pwObjects, pwIndexMappingPwID=pwIndexMappingPwID, pwPeerMappingPwType=pwPeerMappingPwType, pwFcsRetentionStatus=pwFcsRetentionStatus, pwDescr=pwDescr, pwBasicGroup=pwBasicGroup)
