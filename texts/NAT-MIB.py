#
# PySNMP MIB module NAT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/NAT-TC
# Produced by pysmi-1.1.8 at Sat Jan 15 04:23:20 2022
# On host fv-az39-968 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ifCounterDiscontinuityGroup, ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifCounterDiscontinuityGroup", "ifIndex", "InterfaceIndex")
InetAddress, InetPortNumber, InetAddressType, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetPortNumber", "InetAddressType", "InetAddressPrefixLength")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Gauge32, Counter64, Counter32, ModuleIdentity, IpAddress, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, mib_2, Unsigned32, iso, MibIdentifier, TimeTicks, Bits, NotificationType, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Counter64", "Counter32", "ModuleIdentity", "IpAddress", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mib-2", "Unsigned32", "iso", "MibIdentifier", "TimeTicks", "Bits", "NotificationType", "Integer32")
DisplayString, RowStatus, TextualConvention, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention", "StorageType")
VPNIdOrZero, = mibBuilder.importSymbols("VPN-TC-STD-MIB", "VPNIdOrZero")
natMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 123))
natMIB.setRevisions(('2013-04-26 00:00', '2005-03-21 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: natMIB.setRevisionsDescriptions(('Complete rewrite, published as RFC yyyy.', 'Initial version, published as RFC 4008.',))
if mibBuilder.loadTexts: natMIB.setLastUpdated('201304260000Z')
if mibBuilder.loadTexts: natMIB.setOrganization('IETF Behavior Engineering for Hindrance Avoidance\n                 (BEHAVE) Working Group')
if mibBuilder.loadTexts: natMIB.setContactInfo('Working Group Email: behave@ietf.org\n\n                 Simon Perreault\n                 Viagenie\n                 246 Aberdeen\n                 Quebec, QC  G1R 2E1\n                 Canada\n\n                 Phone: +1 418 656 9254\n                 Email: simon.perreault@viagenie.ca\n                 URI:   http://viagenie.ca\n\n                 Tina Tsou\n                 Huawei Technologies (USA)\n                 2330 Central Expressway\n                 Santa Clara, CA  95050\n                 USA\n\n                 Phone: +1 408 330 4424\n                 Email: tina.tsou.zouting@huawei.com\n\n                 Senthil Sivakumar\n                 Cisco Systems\n                 7100-8 Kit Creek Road\n                 Research Triangle Park, North Carolina  27709\n                 USA\n\n                 Phone: +1 919 392 5158\n                 Email: ssenthil@cisco.com')
if mibBuilder.loadTexts: natMIB.setDescription('This MIB module defines the generic managed objects\n                 for NAT.\n\n                 Copyright (C) The Internet Society (2013).  This\n                 version of this MIB module is part of RFC yyyy; see\n                 the RFC itself for full legal notices.')
natMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 1))
class NatProtocolType(TextualConvention, Integer32):
    description = 'A list of protocols that support the network\n                   address translation.  Inclusion of the values is\n                   not intended to imply that those protocols\n                   need to be supported.  Any change in this\n                   TEXTUAL-CONVENTION should also be reflected in\n                   the definition of NatProtocolMap, which is a\n                   BITS representation of this.'
    status = 'deprecated'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("other", 2), ("icmp", 3), ("udp", 4), ("tcp", 5))

class NatProtocolMap(TextualConvention, Bits):
    description = 'A bitmap of protocol identifiers that support\n                   the network address translation.  Any change\n                   in this TEXTUAL-CONVENTION should also be\n                   reflected in the definition of NatProtocolType.'
    status = 'deprecated'
    namedValues = NamedValues(("other", 0), ("icmp", 1), ("udp", 2), ("tcp", 3))

class NatAddrMapId(TextualConvention, Unsigned32):
    description = 'A unique id that is assigned to each address map\n                   by a NAT enabled device.'
    status = 'deprecated'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class NatBindIdOrZero(TextualConvention, Unsigned32):
    description = 'A unique id that is assigned to each bind by\n                   a NAT enabled device.  The bind id will be zero\n                   in the case of a Symmetric NAT.'
    status = 'deprecated'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class NatBindId(TextualConvention, Unsigned32):
    description = 'A unique id that is assigned to each bind by\n                   a NAT enabled device.'
    status = 'deprecated'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class NatSessionId(TextualConvention, Unsigned32):
    description = 'A unique id that is assigned to each session by\n                   a NAT enabled device.'
    status = 'deprecated'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class NatBindMode(TextualConvention, Integer32):
    description = 'An indication of whether the bind is\n                   an address bind or an address port bind.'
    status = 'deprecated'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("addressBind", 1), ("addressPortBind", 2))

class NatAssociationType(TextualConvention, Integer32):
    description = 'An indication of whether the association is\n                   static or dynamic.'
    status = 'deprecated'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("static", 1), ("dynamic", 2))

class NatTranslationEntity(TextualConvention, Bits):
    description = 'An indication of a) the direction of a session for\n                   which an address map entry, address bind or port\n                   bind is applicable, and b) the entity (source or\n                   destination) within the session that is subject to\n                   translation.'
    status = 'deprecated'
    namedValues = NamedValues(("inboundSrcEndPoint", 0), ("outboundDstEndPoint", 1), ("inboundDstEndPoint", 2), ("outboundSrcEndPoint", 3))

natDefTimeouts = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 1, 1))
natNotifCtrl = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 1, 2))
natBindDefIdleTimeout = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natBindDefIdleTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: natBindDefIdleTimeout.setDescription('The default Bind (Address Bind or Port Bind) idle\n                timeout parameter.\n\n                If the agent is capable of storing non-volatile\n                configuration, then the value of this object must be\n                restored after a re-initialization of the management\n                system.')
natUdpDefIdleTimeout = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(300)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natUdpDefIdleTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: natUdpDefIdleTimeout.setDescription('The default UDP idle timeout parameter.\n\n                If the agent is capable of storing non-volatile\n                configuration, then the value of this object must be\n                restored after a re-initialization of the management\n                system.')
natIcmpDefIdleTimeout = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(300)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natIcmpDefIdleTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: natIcmpDefIdleTimeout.setDescription('The default ICMP idle timeout parameter.\n\n                If the agent is capable of storing non-volatile\n\n                configuration, then the value of this object must be\n                restored after a re-initialization of the management\n                system.')
natOtherDefIdleTimeout = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(60)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natOtherDefIdleTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: natOtherDefIdleTimeout.setDescription('The default idle timeout parameter for protocols\n                represented by the value other (2) in\n                NatProtocolType.\n\n                If the agent is capable of storing non-volatile\n                configuration, then the value of this object must be\n                restored after a re-initialization of the management\n                system.')
natTcpDefIdleTimeout = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(86400)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natTcpDefIdleTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: natTcpDefIdleTimeout.setDescription('The default time interval that a NAT session for an\n                established TCP connection is allowed to remain\n                valid without any activity on the TCP connection.\n\n                If the agent is capable of storing non-volatile\n                configuration, then the value of this object must be\n                restored after a re-initialization of the management\n                system.')
natTcpDefNegTimeout = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(60)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natTcpDefNegTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: natTcpDefNegTimeout.setDescription('The default time interval that a NAT session for a TCP\n                connection that is not in the established state\n                is allowed to remain valid without any activity on\n                the TCP connection.\n\n                If the agent is capable of storing non-volatile\n                configuration, then the value of this object must be\n                restored after a re-initialization of the management\n                system.')
natNotifThrottlingInterval = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 3600), ))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natNotifThrottlingInterval.setStatus('deprecated')
if mibBuilder.loadTexts: natNotifThrottlingInterval.setDescription("This object controls the generation of the\n                natPacketDiscard notification.\n\n                If this object has a value of zero, then no\n                natPacketDiscard notifications will be transmitted by\n                the agent.\n\n                If this object has a non-zero value, then the agent must\n                not generate more than one natPacketDiscard\n                'notification-event' in the indicated period, where a\n                'notification-event' is the generation of a single\n                notification PDU type to a list of notification\n                destinations.  If additional NAT packets are discarded\n                within the throttling period, then notification-events\n                for these changes must be suppressed by the agent until\n                the current throttling period expires.\n\n                If natNotifThrottlingInterval notification generation\n                is enabled, the suggested default throttling period is\n                60 seconds, but generation of the natPacketDiscard\n                notification should be disabled by default.\n\n                If the agent is capable of storing non-volatile\n                configuration, then the value of this object must be\n\n                restored after a re-initialization of the management\n                system.\n\n                The actual transmission of notifications is controlled\n                via the MIB modules in RFC 3413.")
natInterfaceTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 3), )
if mibBuilder.loadTexts: natInterfaceTable.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceTable.setDescription('This table specifies the attributes for interfaces on a\n                device supporting NAT function.')
natInterfaceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: natInterfaceEntry.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceEntry.setDescription('Each entry in the natInterfaceTable holds a set of\n                parameters for an interface, instantiated by\n                ifIndex.  Therefore, the interface index must have been\n                assigned, according to the applicable procedures,\n                before it can be meaningfully used.\n                Generally, this means that the interface must exist.\n\n                When natStorageType is of type nonVolatile, however,\n                this may reflect the configuration for an interface\n                whose ifIndex has been assigned but for which the\n                supporting implementation is not currently present.')
natInterfaceRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("private", 1), ("public", 2))).clone('public')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natInterfaceRealm.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceRealm.setDescription('This object identifies whether this interface is\n                connected to the private or the public realm.')
natInterfaceServiceType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 3, 1, 2), Bits().clone(namedValues=NamedValues(("basicNat", 0), ("napt", 1), ("bidirectionalNat", 2), ("twiceNat", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natInterfaceServiceType.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceServiceType.setDescription('An indication of the direction in which new sessions\n                are permitted and the extent of translation done within\n                the IP and transport headers.')
natInterfaceInTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natInterfaceInTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceInTranslates.setDescription('Number of packets received on this interface that\n                were translated.\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natInterfaceOutTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natInterfaceOutTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceOutTranslates.setDescription('Number of translated packets that were sent out this\n                interface.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natInterfaceDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natInterfaceDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceDiscards.setDescription('Number of packets that had to be rejected/dropped due to\n                a lack of resources for this interface.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natInterfaceStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 3, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natInterfaceStorageType.setReference('Textual Conventions for SMIv2, Section 2.')
if mibBuilder.loadTexts: natInterfaceStorageType.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceStorageType.setDescription("The storage type for this conceptual row.\n                Conceptual rows having the value 'permanent'\n                need not allow write-access to any columnar objects\n                in the row.")
natInterfaceRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 3, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natInterfaceRowStatus.setReference('Textual Conventions for SMIv2, Section 2.')
if mibBuilder.loadTexts: natInterfaceRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: natInterfaceRowStatus.setDescription("The status of this conceptual row.\n\n                Until instances of all corresponding columns are\n                appropriately configured, the value of the\n                corresponding instance of the natInterfaceRowStatus\n\n                column is 'notReady'.\n\n                In particular, a newly created row cannot be made\n                active until the corresponding instance of\n                natInterfaceServiceType has been set.\n\n                None of the objects in this row may be modified\n                while the value of this object is active(1).")
natAddrMapTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 4), )
if mibBuilder.loadTexts: natAddrMapTable.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapTable.setDescription('This table lists address map parameters for NAT.')
natAddrMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "NAT-MIB", "natAddrMapIndex"))
if mibBuilder.loadTexts: natAddrMapEntry.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapEntry.setDescription('This entry represents an address map to be used for\n                NAT and contributes to the dynamic and/or static\n                address mapping tables of the NAT device.')
natAddrMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 1), NatAddrMapId())
if mibBuilder.loadTexts: natAddrMapIndex.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapIndex.setDescription('Along with ifIndex, this object uniquely\n                identifies an entry in the natAddrMapTable.\n                Address map entries are applied in the order\n                specified by natAddrMapIndex.')
natAddrMapName = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapName.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapName.setDescription('Name identifying all map entries in the table associated\n                with the same interface.  All map entries with the same\n                ifIndex MUST have the same map name.')
natAddrMapEntryType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 3), NatAssociationType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapEntryType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapEntryType.setDescription('This parameter can be used to set up static\n                or dynamic address maps.')
natAddrMapTranslationEntity = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 4), NatTranslationEntity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapTranslationEntity.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapTranslationEntity.setDescription('The end-point entity (source or destination) in\n\n                inbound or outbound sessions (i.e., first packets) that\n                may be translated by an address map entry.\n\n                Session direction (inbound or outbound) is\n                derived from the direction of the first packet\n                of a session traversing a NAT interface.\n                NAT address (and Transport-ID) maps may be defined\n                to effect inbound or outbound sessions.\n\n                Traditionally, address maps for Basic NAT and NAPT are\n                configured on a public interface for outbound sessions,\n                effecting translation of source end-point.  The value of\n                this object must be set to outboundSrcEndPoint for\n                those interfaces.\n\n                Alternately, if address maps for Basic NAT and NAPT were\n                to be configured on a private interface, the desired\n                value for this object for the map entries\n                would be inboundSrcEndPoint (i.e., effecting translation\n                of source end-point for inbound sessions).\n\n                If TwiceNAT were to be configured on a private\n                interface, the desired value for this object for the map\n                entries would be a bitmask of inboundSrcEndPoint and\n                inboundDstEndPoint.')
natAddrMapLocalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapLocalAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapLocalAddrType.setDescription('This object specifies the address type used for\n                natAddrMapLocalAddrFrom and natAddrMapLocalAddrTo.')
natAddrMapLocalAddrFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapLocalAddrFrom.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapLocalAddrFrom.setDescription('This object specifies the first IP address of the range\n                of IP addresses mapped by this translation entry.  The\n                value of this object must be less than or equal to the\n                value of the natAddrMapLocalAddrTo object.\n\n                The type of this address is determined by the value of\n                the natAddrMapLocalAddrType object.')
natAddrMapLocalAddrTo = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 7), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapLocalAddrTo.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapLocalAddrTo.setDescription('This object specifies the last IP address of the range\n                of IP addresses mapped by this translation entry.  If\n                only a single address is being mapped, the value of this\n                object is equal to the value of natAddrMapLocalAddrFrom.\n                For a static NAT, the number of addresses in the range\n                defined by natAddrMapLocalAddrFrom and\n                natAddrMapLocalAddrTo must be equal to the number of\n                addresses in the range defined by\n                natAddrMapGlobalAddrFrom and natAddrMapGlobalAddrTo.\n                The value of this object must be greater than or equal\n                to the value of the natAddrMapLocalAddrFrom object.\n\n                The type of this address is determined by the value of\n                the natAddrMapLocalAddrType object.')
natAddrMapLocalPortFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 8), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapLocalPortFrom.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapLocalPortFrom.setDescription('If this conceptual row describes a Basic NAT address\n                mapping, then the value of this object must be zero.  If\n                this conceptual row describes NAPT, then the value of\n                this object specifies the first port number in the range\n                of ports being mapped.\n\n                The value of this object must be less than or equal to\n                the value of the natAddrMapLocalPortTo object.  If the\n                translation specifies a single port, then the value of\n                this object is equal to the value of\n                natAddrMapLocalPortTo.')
natAddrMapLocalPortTo = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 9), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapLocalPortTo.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapLocalPortTo.setDescription('If this conceptual row describes a Basic NAT address\n\n                mapping, then the value of this object must be zero.  If\n                this conceptual row describes NAPT, then the value of\n                this object specifies the last port number in the range\n                of ports being mapped.\n\n                The value of this object must be greater than or equal\n                to the value of the natAddrMapLocalPortFrom object.  If\n                the translation specifies a single port, then the value\n                of this object is equal to the value of\n                natAddrMapLocalPortFrom.')
natAddrMapGlobalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 10), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapGlobalAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapGlobalAddrType.setDescription('This object specifies the address type used for\n                natAddrMapGlobalAddrFrom and natAddrMapGlobalAddrTo.')
natAddrMapGlobalAddrFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 11), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapGlobalAddrFrom.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapGlobalAddrFrom.setDescription('This object specifies the first IP address of the range\n                of IP addresses being mapped to.  The value of this\n                object must be less than or equal to the value of the\n                natAddrMapGlobalAddrTo object.\n\n                The type of this address is determined by the value of\n                the natAddrMapGlobalAddrType object.')
natAddrMapGlobalAddrTo = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 12), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapGlobalAddrTo.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapGlobalAddrTo.setDescription('This object specifies the last IP address of the range\n                of IP addresses being mapped to.  If only a single\n                address is being mapped to, the value of this object is\n                equal to the value of natAddrMapGlobalAddrFrom.  For a\n                static NAT, the number of addresses in the range defined\n                by natAddrMapGlobalAddrFrom and natAddrMapGlobalAddrTo\n                must be equal to the number of addresses in the range\n\n                defined by natAddrMapLocalAddrFrom and\n                natAddrMapLocalAddrTo.  The value of this object must be\n                greater than or equal to the value of the\n                natAddrMapGlobalAddrFrom object.\n\n                The type of this address is determined by the value of\n                the natAddrMapGlobalAddrType object.')
natAddrMapGlobalPortFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 13), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapGlobalPortFrom.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapGlobalPortFrom.setDescription('If this conceptual row describes a Basic NAT address\n                mapping, then the value of this object must be zero.  If\n                this conceptual row describes NAPT, then the value of\n                this object specifies the first port number in the range\n                of ports being mapped to.\n\n                The value of this object must be less than or equal to\n                the value of the natAddrMapGlobalPortTo object.  If the\n                translation specifies a single port, then the value of\n                this object is equal to the value\n                natAddrMapGlobalPortTo.')
natAddrMapGlobalPortTo = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 14), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapGlobalPortTo.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapGlobalPortTo.setDescription('If this conceptual row describes a Basic NAT address\n                mapping, then the value of this object must be zero.  If\n                this conceptual row describes NAPT, then the value of\n                this object specifies the last port number in the range\n                of ports being mapped to.\n\n                The value of this object must be greater than or equal\n                to the value of the natAddrMapGlobalPortFrom object.  If\n                the translation specifies a single port, then the value\n                of this object is equal to the value of\n                natAddrMapGlobalPortFrom.')
natAddrMapProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 15), NatProtocolMap()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapProtocol.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapProtocol.setDescription('This object specifies a bitmap of protocol identifiers.')
natAddrMapInTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrMapInTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapInTranslates.setDescription('The number of inbound packets pertaining to this address\n                map entry that were translated.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natAddrMapOutTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrMapOutTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapOutTranslates.setDescription('The number of outbound packets pertaining to this\n                address map entry that were translated.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natAddrMapDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrMapDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapDiscards.setDescription('The number of packets pertaining to this address map\n                entry that were dropped due to lack of addresses in the\n                address pool identified by this address map.  The value\n                of this object must always be zero in case of static\n                address map.\n\n                Discontinuities in the value of this counter can occur\n\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natAddrMapAddrUsed = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrMapAddrUsed.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapAddrUsed.setDescription('The number of addresses pertaining to this address map\n                that are currently being used from the NAT pool.\n                The value of this object must always be zero in the case\n                of a static address map.')
natAddrMapStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 20), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapStorageType.setReference('Textual Conventions for SMIv2, Section 2.')
if mibBuilder.loadTexts: natAddrMapStorageType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapStorageType.setDescription("The storage type for this conceptual row.\n                Conceptual rows having the value 'permanent'\n                need not allow write-access to any columnar objects\n                in the row.")
natAddrMapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 4, 1, 21), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natAddrMapRowStatus.setReference('Textual Conventions for SMIv2, Section 2.')
if mibBuilder.loadTexts: natAddrMapRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrMapRowStatus.setDescription("The status of this conceptual row.\n\n                Until instances of all corresponding columns are\n                appropriately configured, the value of the\n                corresponding instance of the natAddrMapRowStatus\n                column is 'notReady'.\n\n                None of the objects in this row may be modified\n                while the value of this object is active(1).")
natAddrBindNumberOfEntries = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindNumberOfEntries.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindNumberOfEntries.setDescription('This object maintains a count of the number of entries\n                that currently exist in the natAddrBindTable.')
natAddrBindTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 6), )
if mibBuilder.loadTexts: natAddrBindTable.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindTable.setDescription('This table holds information about the currently\n                active NAT BINDs.')
natAddrBindEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "NAT-MIB", "natAddrBindLocalAddrType"), (0, "NAT-MIB", "natAddrBindLocalAddr"))
if mibBuilder.loadTexts: natAddrBindEntry.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindEntry.setDescription('Each entry in this table holds information about\n                an active address BIND.  These entries are lost\n                upon agent restart.\n\n                This row has indexing which may create variables with\n                more than 128 subidentifiers.  Implementers of this\n                table must be careful not to create entries that would\n                result in OIDs which exceed the 128 subidentifier limit.\n                Otherwise, the information cannot be accessed using\n                SNMPv1, SNMPv2c or SNMPv3.')
natAddrBindLocalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 1), InetAddressType())
if mibBuilder.loadTexts: natAddrBindLocalAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindLocalAddrType.setDescription('This object specifies the address type used for\n                natAddrBindLocalAddr.')
natAddrBindLocalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: natAddrBindLocalAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindLocalAddr.setDescription('This object represents the private-realm specific\n                network layer address, which maps to the public-realm\n                address represented by natAddrBindGlobalAddr.\n\n                The type of this address is determined by the value of\n                the natAddrBindLocalAddrType object.')
natAddrBindGlobalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindGlobalAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindGlobalAddrType.setDescription('This object specifies the address type used for\n                natAddrBindGlobalAddr.')
natAddrBindGlobalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindGlobalAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindGlobalAddr.setDescription('This object represents the public-realm network layer\n                address that maps to the private-realm network layer\n                address represented by natAddrBindLocalAddr.\n\n                The type of this address is determined by the value of\n                the natAddrBindGlobalAddrType object.')
natAddrBindId = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 5), NatBindId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindId.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindId.setDescription('This object represents a bind id that is dynamically\n                assigned to each bind by a NAT enabled device.  Each\n                bind is represented by a bind id that is\n                unique across both, the natAddrBindTable and the\n                natAddrPortBindTable.')
natAddrBindTranslationEntity = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 6), NatTranslationEntity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindTranslationEntity.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindTranslationEntity.setDescription('This object represents the direction of sessions\n                for which this bind is applicable and the endpoint\n                entity (source or destination) within the sessions that\n                is subject to translation using the BIND.\n\n                Orientation of the bind can be a superset of\n                translationEntity of the address map entry which\n                forms the basis for this bind.\n\n                For example, if the translationEntity of an\n                address map entry is outboundSrcEndPoint, the\n                translationEntity of a bind derived from this\n                map entry may either be outboundSrcEndPoint or\n                it may be bidirectional (a bitmask of\n                outboundSrcEndPoint and inboundDstEndPoint).')
natAddrBindType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 7), NatAssociationType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindType.setDescription('This object indicates whether the bind is static or\n                dynamic.')
natAddrBindMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 8), NatAddrMapId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindMapIndex.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindMapIndex.setDescription('This object is a pointer to the natAddrMapTable entry\n                (and the parameters of that entry) which was used in\n                creating this BIND.  This object, in conjunction with\n                the ifIndex (which identifies a unique addrMapName)\n                points to a unique entry in the natAddrMapTable.')
natAddrBindSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindSessions.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindSessions.setDescription('Number of sessions currently using this BIND.')
natAddrBindMaxIdleTime = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindMaxIdleTime.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindMaxIdleTime.setDescription('This object indicates the maximum time for\n                which this bind can be idle with no sessions\n                attached to it.\n\n                The value of this object is of relevance only for\n                dynamic NAT.')
natAddrBindCurrentIdleTime = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindCurrentIdleTime.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindCurrentIdleTime.setDescription('At any given instance, this object indicates the\n                time that this bind has been idle without any sessions\n                attached to it.\n\n                The value of this object is of relevance only for\n                dynamic NAT.')
natAddrBindInTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindInTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindInTranslates.setDescription('The number of inbound packets that were successfully\n                translated by using this bind entry.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natAddrBindOutTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 6, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrBindOutTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrBindOutTranslates.setDescription('The number of outbound packets that were successfully\n                translated using this bind entry.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natAddrPortBindNumberOfEntries = MibScalar((1, 3, 6, 1, 2, 1, 123, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindNumberOfEntries.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindNumberOfEntries.setDescription('This object maintains a count of the number of entries\n                that currently exist in the natAddrPortBindTable.')
natAddrPortBindTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 8), )
if mibBuilder.loadTexts: natAddrPortBindTable.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindTable.setDescription('This table holds information about the currently\n                active NAPT BINDs.')
natAddrPortBindEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "NAT-MIB", "natAddrPortBindLocalAddrType"), (0, "NAT-MIB", "natAddrPortBindLocalAddr"), (0, "NAT-MIB", "natAddrPortBindLocalPort"), (0, "NAT-MIB", "natAddrPortBindProtocol"))
if mibBuilder.loadTexts: natAddrPortBindEntry.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindEntry.setDescription('Each entry in the this table holds information\n                about a NAPT bind that is currently active.\n                These entries are lost upon agent restart.\n\n                This row has indexing which may create variables with\n                more than 128 subidentifiers.  Implementers of this\n                table must be careful not to create entries which would\n                result in OIDs that exceed the 128 subidentifier limit.\n                Otherwise, the information cannot be accessed using\n                SNMPv1, SNMPv2c or SNMPv3.')
natAddrPortBindLocalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 1), InetAddressType())
if mibBuilder.loadTexts: natAddrPortBindLocalAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindLocalAddrType.setDescription('This object specifies the address type used for\n                natAddrPortBindLocalAddr.')
natAddrPortBindLocalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: natAddrPortBindLocalAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindLocalAddr.setDescription('This object represents the private-realm specific\n                network layer address which, in conjunction with\n                natAddrPortBindLocalPort, maps to the public-realm\n                network layer address and transport id represented by\n                natAddrPortBindGlobalAddr and natAddrPortBindGlobalPort\n                respectively.\n\n                The type of this address is determined by the value of\n                the natAddrPortBindLocalAddrType object.')
natAddrPortBindLocalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 3), InetPortNumber())
if mibBuilder.loadTexts: natAddrPortBindLocalPort.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindLocalPort.setDescription('For a protocol value TCP or UDP, this object represents\n                the private-realm specific port number.  On the other\n                hand, for ICMP a bind is created only for query/response\n                type ICMP messages such as ICMP echo, Timestamp, and\n                Information request messages, and this object represents\n                the private-realm specific identifier in the ICMP\n                message, as defined in RFC 792 for ICMPv4 and in RFC\n                2463 for ICMPv6.\n\n                This object, together with natAddrPortBindProtocol,\n                natAddrPortBindLocalAddrType, and\n                natAddrPortBindLocalAddr, constitutes a session endpoint\n                in the private realm.  A bind entry binds a private\n                realm specific endpoint to a public realm specific\n                endpoint, as represented by the tuple of\n                (natAddrPortBindGlobalPort, natAddrPortBindProtocol,\n                natAddrPortBindGlobalAddrType, and\n\n                natAddrPortBindGlobalAddr).')
natAddrPortBindProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 4), NatProtocolType())
if mibBuilder.loadTexts: natAddrPortBindProtocol.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindProtocol.setDescription('This object specifies a protocol identifier.  If the\n                value of this object is none(1), then this bind entry\n                applies to all IP traffic.  Any other value of this\n                object specifies the class of IP traffic to which this\n                BIND applies.')
natAddrPortBindGlobalAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindGlobalAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindGlobalAddrType.setDescription('This object specifies the address type used for\n                natAddrPortBindGlobalAddr.')
natAddrPortBindGlobalAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindGlobalAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindGlobalAddr.setDescription('This object represents the public-realm specific network\n                layer address that, in conjunction with\n                natAddrPortBindGlobalPort, maps to the private-realm\n\n                network layer address and transport id represented by\n                natAddrPortBindLocalAddr and natAddrPortBindLocalPort,\n                respectively.\n\n                The type of this address is determined by the value of\n                the natAddrPortBindGlobalAddrType object.')
natAddrPortBindGlobalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 7), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindGlobalPort.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindGlobalPort.setDescription('For a protocol value TCP or UDP, this object represents\n                the public-realm specific port number.  On the other\n\n                hand, for ICMP a bind is created only for query/response\n                type ICMP messages such as ICMP echo, Timestamp, and\n                Information request messages, and this object represents\n                the public-realm specific identifier in the ICMP\n                message, as defined in RFC 792 for ICMPv4 and in RFC\n                2463 for ICMPv6.\n\n                This object, together with natAddrPortBindProtocol,\n                natAddrPortBindGlobalAddrType, and\n                natAddrPortBindGlobalAddr, constitutes a session\n                endpoint in the public realm.  A bind entry binds a\n                public realm specific endpoint to a private realm\n                specific endpoint, as represented by the tuple of\n                (natAddrPortBindLocalPort, natAddrPortBindProtocol,\n                natAddrPortBindLocalAddrType, and\n                natAddrPortBindLocalAddr).')
natAddrPortBindId = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 8), NatBindId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindId.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindId.setDescription('This object represents a bind id that is dynamically\n                assigned to each bind by a NAT enabled device.  Each\n                bind is represented by a unique bind id across both\n                the natAddrBindTable and the natAddrPortBindTable.')
natAddrPortBindTranslationEntity = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 9), NatTranslationEntity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindTranslationEntity.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindTranslationEntity.setDescription('This object represents the direction of sessions\n                for which this bind is applicable and the entity\n                (source or destination) within the sessions that is\n                subject to translation with the BIND.\n\n                Orientation of the bind can be a superset of the\n                translationEntity of the address map entry that\n                forms the basis for this bind.\n\n                For example, if the translationEntity of an\n                address map entry is outboundSrcEndPoint, the\n                translationEntity of a bind derived from this\n                map entry may either be outboundSrcEndPoint or\n                may be bidirectional (a bitmask of\n\n                outboundSrcEndPoint and inboundDstEndPoint).')
natAddrPortBindType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 10), NatAssociationType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindType.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindType.setDescription('This object indicates whether the bind is static or\n                dynamic.')
natAddrPortBindMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 11), NatAddrMapId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindMapIndex.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindMapIndex.setDescription('This object is a pointer to the natAddrMapTable entry\n                (and the parameters of that entry) used in\n                creating this BIND.  This object, in conjunction with\n                the ifIndex (which identifies a unique addrMapName),\n                points to a unique entry in the natAddrMapTable.')
natAddrPortBindSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindSessions.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindSessions.setDescription('Number of sessions currently using this BIND.')
natAddrPortBindMaxIdleTime = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindMaxIdleTime.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindMaxIdleTime.setDescription('This object indicates the maximum time for\n                which this bind can be idle without any sessions\n                attached to it.\n                The value of this object is of relevance\n                only for dynamic NAT.')
natAddrPortBindCurrentIdleTime = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindCurrentIdleTime.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindCurrentIdleTime.setDescription('At any given instance, this object indicates the\n                time that this bind has been idle without any sessions\n                attached to it.\n\n                The value of this object is of relevance\n                only for dynamic NAT.')
natAddrPortBindInTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindInTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindInTranslates.setDescription('The number of inbound packets that were translated as\n                per this bind entry.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natAddrPortBindOutTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 8, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddrPortBindOutTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natAddrPortBindOutTranslates.setDescription('The number of outbound packets that were translated as\n                per this bind entry.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natSessionTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 9), )
if mibBuilder.loadTexts: natSessionTable.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionTable.setDescription('The (conceptual) table containing one entry for each\n\n                NAT session currently active on this NAT device.')
natSessionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "NAT-MIB", "natSessionIndex"))
if mibBuilder.loadTexts: natSessionEntry.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionEntry.setDescription('An entry (conceptual row) containing information\n                about an active NAT session on this NAT device.\n                These entries are lost upon agent restart.')
natSessionIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 1), NatSessionId())
if mibBuilder.loadTexts: natSessionIndex.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionIndex.setDescription('The session ID for this NAT session.')
natSessionPrivateSrcEPBindId = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 2), NatBindIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateSrcEPBindId.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateSrcEPBindId.setDescription('The bind id associated between private and public\n                source end points.  In the case of Symmetric-NAT,\n                this should be set to zero.')
natSessionPrivateSrcEPBindMode = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 3), NatBindMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateSrcEPBindMode.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateSrcEPBindMode.setDescription('This object indicates whether the bind indicated\n                by the object natSessionPrivateSrcEPBindId\n                is an address bind or an address port bind.')
natSessionPrivateDstEPBindId = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 4), NatBindIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateDstEPBindId.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateDstEPBindId.setDescription('The bind id associated between private and public\n                destination end points.')
natSessionPrivateDstEPBindMode = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 5), NatBindMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateDstEPBindMode.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateDstEPBindMode.setDescription('This object indicates whether the bind indicated\n                by the object natSessionPrivateDstEPBindId\n                is an address bind or an address port bind.')
natSessionDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionDirection.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionDirection.setDescription("The direction of this session with respect to the\n                local network.  'inbound' indicates that this session\n                was initiated from the public network into the private\n                network.  'outbound' indicates that this session was\n                initiated from the private network into the public\n                network.")
natSessionUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionUpTime.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionUpTime.setDescription('The up time of this session in one-hundredths of a\n                second.')
natSessionAddrMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 8), NatAddrMapId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionAddrMapIndex.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionAddrMapIndex.setDescription('This object is a pointer to the natAddrMapTable entry\n                (and the parameters of that entry) used in\n                creating this session.  This object, in conjunction with\n                the ifIndex (which identifies a unique addrMapName),\n                points to a unique entry in the natAddrMapTable.')
natSessionProtocolType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 9), NatProtocolType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionProtocolType.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionProtocolType.setDescription('The protocol type of this session.')
natSessionPrivateAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateAddrType.setDescription('This object specifies the address type used for\n                natSessionPrivateSrcAddr and natSessionPrivateDstAddr.')
natSessionPrivateSrcAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 11), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateSrcAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateSrcAddr.setDescription('The source IP address of the session endpoint that\n                lies in the private network.\n\n                The value of this object must be zero only when the\n                natSessionPrivateSrcEPBindId object has a zero value.\n                When the value of this object is zero, the NAT session\n                lookup will match any IP address to this field.\n\n                The type of this address is determined by the value of\n                the natSessionPrivateAddrType object.')
natSessionPrivateSrcPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 12), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateSrcPort.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateSrcPort.setDescription('When the value of protocol is TCP or UDP, this object\n                represents the source port in the first packet of\n                session while in private-realm.  On the other hand, when\n                the protocol is ICMP, a NAT session is created only for\n                query/response type ICMP messages such as ICMP echo,\n                Timestamp, and Information request messages, and this\n                object represents the private-realm specific identifier\n                in the ICMP message, as defined in RFC 792 for ICMPv4\n                and in RFC 2463 for ICMPv6.\n\n                The value of this object must be zero when the\n                natSessionPrivateSrcEPBindId object has zero value\n                and value of natSessionPrivateSrcEPBindMode is\n                addressPortBind(2).  In such a case, the NAT session\n                lookup will match any port number to this field.\n\n                The value of this object must be zero when the object\n                is not a representative field (SrcPort, DstPort, or\n                ICMP identifier) of the session tuple in either the\n                public realm or the private realm.')
natSessionPrivateDstAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 13), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateDstAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateDstAddr.setDescription('The destination IP address of the session endpoint that\n\n                lies in the private network.\n\n                The value of this object must be zero when the\n                natSessionPrivateDstEPBindId object has a zero value.\n                In such a scenario, the NAT session lookup will match\n                any IP address to this field.\n\n                The type of this address is determined by the value of\n                the natSessionPrivateAddrType object.')
natSessionPrivateDstPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 14), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPrivateDstPort.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPrivateDstPort.setDescription('When the value of protocol is TCP or UDP, this object\n                represents the destination port in the first packet\n                of session while in private-realm.  On the other hand,\n                when the protocol is ICMP, this object is not relevant\n                and should be set to zero.\n\n                The value of this object must be zero when the\n                natSessionPrivateDstEPBindId object has a zero\n                value and natSessionPrivateDstEPBindMode is set to\n                addressPortBind(2).  In such a case, the NAT session\n                lookup will match any port number to this field.\n\n                The value of this object must be zero when the object\n                is not a representative field (SrcPort, DstPort, or\n                ICMP identifier) of the session tuple in either the\n                public realm or the private realm.')
natSessionPublicAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 15), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPublicAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPublicAddrType.setDescription('This object specifies the address type used for\n                natSessionPublicSrcAddr and natSessionPublicDstAddr.')
natSessionPublicSrcAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 16), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPublicSrcAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPublicSrcAddr.setDescription('The source IP address of the session endpoint that\n                lies in the public network.\n\n                The value of this object must be zero when the\n                natSessionPrivateSrcEPBindId object has a zero value.\n                In such a scenario, the NAT session lookup will match\n                any IP address to this field.\n\n                The type of this address is determined by the value of\n                the natSessionPublicAddrType object.')
natSessionPublicSrcPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 17), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPublicSrcPort.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPublicSrcPort.setDescription('When the value of protocol is TCP or UDP, this object\n                represents the source port in the first packet of\n                session while in public-realm.  On the other hand, when\n                protocol is ICMP, a NAT session is created only for\n                query/response type ICMP messages such as ICMP echo,\n                Timestamp, and Information request messages, and this\n                object represents the public-realm specific identifier\n                in the ICMP message, as defined in RFC 792 for ICMPv4\n                and in RFC 2463 for ICMPv6.\n\n                The value of this object must be zero when the\n                natSessionPrivateSrcEPBindId object has a zero value\n                and natSessionPrivateSrcEPBindMode is set to\n                addressPortBind(2).  In such a scenario, the NAT\n                session lookup will match any port number to this\n                field.\n\n                The value of this object must be zero when the object\n                is not a representative field (SrcPort, DstPort or\n                ICMP identifier) of the session tuple in either the\n                public realm or the private realm.')
natSessionPublicDstAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 18), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPublicDstAddr.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPublicDstAddr.setDescription('The destination IP address of the session endpoint that\n                lies in the public network.\n\n                The value of this object must be non-zero when the\n                natSessionPrivateDstEPBindId object has a non-zero\n                value.  If the value of this object and the\n                corresponding natSessionPrivateDstEPBindId object value\n                is zero, then the NAT session lookup will match any IP\n                address to this field.\n\n                The type of this address is determined by the value of\n                the natSessionPublicAddrType object.')
natSessionPublicDstPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 19), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionPublicDstPort.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionPublicDstPort.setDescription('When the value of protocol is TCP or UDP, this object\n                represents the destination port in the first packet of\n                session while in public-realm.  On the other hand, when\n                the protocol is ICMP, this object is not relevant for\n                translation and should be zero.\n\n                The value of this object must be zero when the\n                natSessionPrivateDstEPBindId object has a zero value\n                and natSessionPrivateDstEPBindMode is\n                addressPortBind(2).  In such a scenario, the NAT\n                session lookup will match any port number to this\n                field.\n\n                The value of this object must be zero when the object\n                is not a representative field (SrcPort, DstPort, or\n                ICMP identifier) of the session tuple in either the\n                public realm or the private realm.')
natSessionMaxIdleTime = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 20), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionMaxIdleTime.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionMaxIdleTime.setDescription('The max time for which this session can be idle\n                without detecting a packet.')
natSessionCurrentIdleTime = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 21), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionCurrentIdleTime.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionCurrentIdleTime.setDescription('The time since a packet belonging to this session was\n               last detected.')
natSessionInTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionInTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionInTranslates.setDescription('The number of inbound packets that were translated for\n                this session.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natSessionOutTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 9, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSessionOutTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natSessionOutTranslates.setDescription('The number of outbound packets that were translated for\n                this session.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natProtocolTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 10), )
if mibBuilder.loadTexts: natProtocolTable.setStatus('deprecated')
if mibBuilder.loadTexts: natProtocolTable.setDescription('The (conceptual) table containing per protocol NAT\n                statistics.')
natProtocolEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 10, 1), ).setIndexNames((0, "NAT-MIB", "natProtocol"))
if mibBuilder.loadTexts: natProtocolEntry.setStatus('deprecated')
if mibBuilder.loadTexts: natProtocolEntry.setDescription('An entry (conceptual row) containing NAT statistics\n                pertaining to a particular protocol.')
natProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 10, 1, 1), NatProtocolType())
if mibBuilder.loadTexts: natProtocol.setStatus('deprecated')
if mibBuilder.loadTexts: natProtocol.setDescription('This object represents the protocol pertaining to which\n                parameters are reported.')
natProtocolInTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 10, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natProtocolInTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natProtocolInTranslates.setDescription('The number of inbound packets pertaining to the protocol\n                identified by natProtocol that underwent NAT.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natProtocolOutTranslates = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 10, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natProtocolOutTranslates.setStatus('deprecated')
if mibBuilder.loadTexts: natProtocolOutTranslates.setDescription('The number of outbound packets pertaining to the\n                protocol identified by natProtocol that underwent NAT.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natProtocolDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 10, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natProtocolDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: natProtocolDiscards.setDescription('The number of packets pertaining to the protocol\n                identified by natProtocol that had to be\n                rejected/dropped due to lack of resources.  These\n                rejections could be due to session timeout, resource\n                unavailability, lack of address space, etc.\n\n                Discontinuities in the value of this counter can occur\n                at reinitialization of the management system and at\n                other times, as indicated by the value of\n                ifCounterDiscontinuityTime on the relevant interface.')
natMIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 0))
natPacketDiscard = NotificationType((1, 3, 6, 1, 2, 1, 123, 0, 1)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: natPacketDiscard.setStatus('deprecated')
if mibBuilder.loadTexts: natPacketDiscard.setDescription("This notification is generated when IP packets are\n                discarded by the NAT function; e.g., due to lack of\n                mapping space when NAT is out of addresses or ports.\n\n                Note that the generation of natPacketDiscard\n                notifications is throttled by the agent, as specified\n                by the 'natNotifThrottlingInterval' object.")
natMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 2))
natMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 2, 1))
natMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 2, 2))
natConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 1)).setObjects(("NAT-MIB", "natInterfaceRealm"), ("NAT-MIB", "natInterfaceServiceType"), ("NAT-MIB", "natInterfaceStorageType"), ("NAT-MIB", "natInterfaceRowStatus"), ("NAT-MIB", "natAddrMapName"), ("NAT-MIB", "natAddrMapEntryType"), ("NAT-MIB", "natAddrMapTranslationEntity"), ("NAT-MIB", "natAddrMapLocalAddrType"), ("NAT-MIB", "natAddrMapLocalAddrFrom"), ("NAT-MIB", "natAddrMapLocalAddrTo"), ("NAT-MIB", "natAddrMapLocalPortFrom"), ("NAT-MIB", "natAddrMapLocalPortTo"), ("NAT-MIB", "natAddrMapGlobalAddrType"), ("NAT-MIB", "natAddrMapGlobalAddrFrom"), ("NAT-MIB", "natAddrMapGlobalAddrTo"), ("NAT-MIB", "natAddrMapGlobalPortFrom"), ("NAT-MIB", "natAddrMapGlobalPortTo"), ("NAT-MIB", "natAddrMapProtocol"), ("NAT-MIB", "natAddrMapStorageType"), ("NAT-MIB", "natAddrMapRowStatus"), ("NAT-MIB", "natBindDefIdleTimeout"), ("NAT-MIB", "natUdpDefIdleTimeout"), ("NAT-MIB", "natIcmpDefIdleTimeout"), ("NAT-MIB", "natOtherDefIdleTimeout"), ("NAT-MIB", "natTcpDefIdleTimeout"), ("NAT-MIB", "natTcpDefNegTimeout"), ("NAT-MIB", "natNotifThrottlingInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natConfigGroup = natConfigGroup.setStatus('deprecated')
if mibBuilder.loadTexts: natConfigGroup.setDescription('A collection of configuration-related information\n                required to support management of devices supporting\n                NAT.')
natTranslationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 2)).setObjects(("NAT-MIB", "natAddrBindNumberOfEntries"), ("NAT-MIB", "natAddrBindGlobalAddrType"), ("NAT-MIB", "natAddrBindGlobalAddr"), ("NAT-MIB", "natAddrBindId"), ("NAT-MIB", "natAddrBindTranslationEntity"), ("NAT-MIB", "natAddrBindType"), ("NAT-MIB", "natAddrBindMapIndex"), ("NAT-MIB", "natAddrBindSessions"), ("NAT-MIB", "natAddrBindMaxIdleTime"), ("NAT-MIB", "natAddrBindCurrentIdleTime"), ("NAT-MIB", "natAddrBindInTranslates"), ("NAT-MIB", "natAddrBindOutTranslates"), ("NAT-MIB", "natAddrPortBindNumberOfEntries"), ("NAT-MIB", "natAddrPortBindGlobalAddrType"), ("NAT-MIB", "natAddrPortBindGlobalAddr"), ("NAT-MIB", "natAddrPortBindGlobalPort"), ("NAT-MIB", "natAddrPortBindId"), ("NAT-MIB", "natAddrPortBindTranslationEntity"), ("NAT-MIB", "natAddrPortBindType"), ("NAT-MIB", "natAddrPortBindMapIndex"), ("NAT-MIB", "natAddrPortBindSessions"), ("NAT-MIB", "natAddrPortBindMaxIdleTime"), ("NAT-MIB", "natAddrPortBindCurrentIdleTime"), ("NAT-MIB", "natAddrPortBindInTranslates"), ("NAT-MIB", "natAddrPortBindOutTranslates"), ("NAT-MIB", "natSessionPrivateSrcEPBindId"), ("NAT-MIB", "natSessionPrivateSrcEPBindMode"), ("NAT-MIB", "natSessionPrivateDstEPBindId"), ("NAT-MIB", "natSessionPrivateDstEPBindMode"), ("NAT-MIB", "natSessionDirection"), ("NAT-MIB", "natSessionUpTime"), ("NAT-MIB", "natSessionAddrMapIndex"), ("NAT-MIB", "natSessionProtocolType"), ("NAT-MIB", "natSessionPrivateAddrType"), ("NAT-MIB", "natSessionPrivateSrcAddr"), ("NAT-MIB", "natSessionPrivateSrcPort"), ("NAT-MIB", "natSessionPrivateDstAddr"), ("NAT-MIB", "natSessionPrivateDstPort"), ("NAT-MIB", "natSessionPublicAddrType"), ("NAT-MIB", "natSessionPublicSrcAddr"), ("NAT-MIB", "natSessionPublicSrcPort"), ("NAT-MIB", "natSessionPublicDstAddr"), ("NAT-MIB", "natSessionPublicDstPort"), ("NAT-MIB", "natSessionMaxIdleTime"), ("NAT-MIB", "natSessionCurrentIdleTime"), ("NAT-MIB", "natSessionInTranslates"), ("NAT-MIB", "natSessionOutTranslates"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natTranslationGroup = natTranslationGroup.setStatus('deprecated')
if mibBuilder.loadTexts: natTranslationGroup.setDescription('A collection of BIND-related objects required to support\n                management of devices supporting NAT.')
natStatsInterfaceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 3)).setObjects(("NAT-MIB", "natInterfaceInTranslates"), ("NAT-MIB", "natInterfaceOutTranslates"), ("NAT-MIB", "natInterfaceDiscards"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natStatsInterfaceGroup = natStatsInterfaceGroup.setStatus('deprecated')
if mibBuilder.loadTexts: natStatsInterfaceGroup.setDescription('A collection of NAT statistics associated with the\n                interface on which NAT is configured, to aid\n                troubleshooting/monitoring of the NAT operation.')
natStatsProtocolGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 4)).setObjects(("NAT-MIB", "natProtocolInTranslates"), ("NAT-MIB", "natProtocolOutTranslates"), ("NAT-MIB", "natProtocolDiscards"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natStatsProtocolGroup = natStatsProtocolGroup.setStatus('deprecated')
if mibBuilder.loadTexts: natStatsProtocolGroup.setDescription('A collection of protocol specific NAT statistics,\n                to aid troubleshooting/monitoring of NAT operation.')
natStatsAddrMapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 5)).setObjects(("NAT-MIB", "natAddrMapInTranslates"), ("NAT-MIB", "natAddrMapOutTranslates"), ("NAT-MIB", "natAddrMapDiscards"), ("NAT-MIB", "natAddrMapAddrUsed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natStatsAddrMapGroup = natStatsAddrMapGroup.setStatus('deprecated')
if mibBuilder.loadTexts: natStatsAddrMapGroup.setDescription('A collection of address map specific NAT statistics,\n                to aid troubleshooting/monitoring of NAT operation.')
natMIBNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 6)).setObjects(("NAT-MIB", "natPacketDiscard"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natMIBNotificationGroup = natMIBNotificationGroup.setStatus('deprecated')
if mibBuilder.loadTexts: natMIBNotificationGroup.setDescription('A collection of notifications generated by\n               devices supporting this MIB.')
natMIBFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 123, 2, 2, 1)).setObjects(("IF-MIB", "ifCounterDiscontinuityGroup"), ("NAT-MIB", "natConfigGroup"), ("NAT-MIB", "natTranslationGroup"), ("NAT-MIB", "natStatsInterfaceGroup"), ("NAT-MIB", "natStatsProtocolGroup"), ("NAT-MIB", "natStatsAddrMapGroup"), ("NAT-MIB", "natMIBNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natMIBFullCompliance = natMIBFullCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: natMIBFullCompliance.setDescription('When this MIB is implemented with support for\n                read-create, then such an implementation can claim\n                full compliance.  Such devices can then be both\n                monitored and configured with this MIB.\n\n                The following index objects cannot be added as OBJECT\n                clauses but nevertheless have the compliance\n                requirements:\n                    ')
natMIBReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 123, 2, 2, 2)).setObjects(("IF-MIB", "ifCounterDiscontinuityGroup"), ("NAT-MIB", "natConfigGroup"), ("NAT-MIB", "natTranslationGroup"), ("NAT-MIB", "natStatsInterfaceGroup"), ("NAT-MIB", "natStatsProtocolGroup"), ("NAT-MIB", "natStatsAddrMapGroup"), ("NAT-MIB", "natMIBNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natMIBReadOnlyCompliance = natMIBReadOnlyCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: natMIBReadOnlyCompliance.setDescription('When this MIB is implemented without support for\n                read-create (i.e., in read-only mode), then such an\n                implementation can claim read-only compliance.\n                Such a device can then be monitored but cannot be\n                configured with this MIB.\n\n                The following index objects cannot be added as OBJECT\n                clauses but nevertheless have the compliance\n                requirements:\n                ')
class ProtocolNumber(TextualConvention, Unsigned32):
    description = "A transport protocol number, from the 'protocol-numbers'\n            IANA registry."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class NatPoolId(TextualConvention, Unsigned32):
    description = 'A unique ID that is assigned to each pool.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class NatBehaviorType(TextualConvention, Integer32):
    description = 'Behavior type as described in [RFC4787] sections 4.1 and 5.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("endpointIndependent", 0), ("addressDependent", 1), ("addressAndPortDependent", 2))

class NatPoolingType(TextualConvention, Integer32):
    description = 'Pooling type as described in [RFC4787] sections 4.1.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("arbitrary", 0), ("paired", 1))

class VlanIndexOrZero(TextualConvention, Unsigned32):
    description = 'A value used to index per-VLAN tables: a value of 4095 is\n            not permitted.  A value of 0 indicates no index is present.\n            If the value is between 1 and 4094 inclusive, it represents\n            an IEEE 802.1Q VLAN-ID with global scope within a given\n            bridged domain (see VlanId textual convention in\n            [RFC4363]).  If the value is greater than 4095, then it\n            represents a VLAN with scope local to the particular agent,\n            i.e., one without a global VLAN-ID assigned to it. Such\n            VLANs are outside the scope of IEEE 802.1Q, but it is\n            convenient to be able to manage them in the same way using\n            this MIB.'
    status = 'current'
    displayHint = 'd'

class SubscriberIndex(TextualConvention, Unsigned32):
    description = 'A unique ID that is assigned to each subscriber.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class SubscriberIdentifierType(TextualConvention, Integer32):
    description = "Type of additional classifying information used by the NAT\n            to identify the subscriber from an incoming packet, when\n            the packet source address is not sufficient to do so\n            unambiguously.\n\n            null(0)\n\n               No additional information is needed.\n\n            interfaces(1)\n\n               A set of one or more ingress interface indexes specified\n               by the [RFC2863] InterfaceIndex textual convention.\n\n            vlan(2)\n\n               An ingress VLAN index using the VlanIndexOrZero textual\n               convention, which is the [RFC4363] VlanIndex textual\n               convention modified for local use in this MIB.\n\n            vpn(3)\n\n               An ingress layer 3 VPN identifier using the [RFC4265]\n               VPNIdOrZero textual convention.\n\n            ipencaps(4)\n\n               Incoming source address of an encapsulating IPv4 or IPv6\n               tunnel (e.g., IPv6 as used in DS-Lite, [RFC6333]) as\n               defined by the InetAddressType and InetAddress textual\n               conventions.\n\n            other(5)\n\n               The implementation supports other classifiers and/or\n               combinations of classifier types. In the latter case the\n               implementation MUST specify the semantics of the\n               combination ('OR' or 'AND')."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("null", 0), ("interfaces", 1), ("vlan", 2), ("vpn", 3), ("ipencaps", 4), ("other", 5))

class SubsInterfaceIdRowIndex(TextualConvention, Unsigned32):
    description = 'A unique ID that is assigned to each row in the\n            natSubsInterfaceIdentifierTable.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

natNotifPoolWatermarkLow = NotificationType((1, 3, 6, 1, 2, 1, 123, 0, 2)).setObjects(("NAT-MIB", "natPoolWatermarkLow"))
if mibBuilder.loadTexts: natNotifPoolWatermarkLow.setStatus('current')
if mibBuilder.loadTexts: natNotifPoolWatermarkLow.setDescription("This notification is generated when a pool's usage\n            percentage becomes lower than or equal to the specified\n            threshold. The threshold is specified by the\n            natPoolWatermarkLow object")
natNotifPoolWatermarkHigh = NotificationType((1, 3, 6, 1, 2, 1, 123, 0, 3)).setObjects(("NAT-MIB", "natPoolWatermarkHigh"))
if mibBuilder.loadTexts: natNotifPoolWatermarkHigh.setStatus('current')
if mibBuilder.loadTexts: natNotifPoolWatermarkHigh.setDescription("This notification is generated when a pool's usage\n            percentage becomes greater than or equal to the specified\n            threshold. The threshold is specified by the\n            natPoolWatermarkHigh object")
natNotifMappings = NotificationType((1, 3, 6, 1, 2, 1, 123, 0, 4)).setObjects(("NAT-MIB", "natMappingCreations"), ("NAT-MIB", "natMappingRemovals"))
if mibBuilder.loadTexts: natNotifMappings.setStatus('current')
if mibBuilder.loadTexts: natNotifMappings.setDescription('This notification is generated when the number of active\n            mappings exceeds the value of natMappingsNotifyThreshold.')
natNotifAddrMappings = NotificationType((1, 3, 6, 1, 2, 1, 123, 0, 5)).setObjects(("NAT-MIB", "natAddressMappingCreations"), ("NAT-MIB", "natAddressMappingRemovals"))
if mibBuilder.loadTexts: natNotifAddrMappings.setStatus('current')
if mibBuilder.loadTexts: natNotifAddrMappings.setDescription('This notification is generated when the number of active\n            address mappings exceeds the value of\n            natAddrMapNotifyThreshold.')
natNotifSubscriberMappings = NotificationType((1, 3, 6, 1, 2, 1, 123, 0, 6)).setObjects(("NAT-MIB", "natSubscriberMappingCreations"), ("NAT-MIB", "natSubscriberMappingRemovals"))
if mibBuilder.loadTexts: natNotifSubscriberMappings.setStatus('current')
if mibBuilder.loadTexts: natNotifSubscriberMappings.setDescription('This notification is generated when the number of active\n            mappings exceeds the value of natSubscriberMapNotifyThresh,\n            unless natSubscriberMapNotifyThresh is zero..')
natInstanceTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 11), )
if mibBuilder.loadTexts: natInstanceTable.setStatus('current')
if mibBuilder.loadTexts: natInstanceTable.setDescription('Table of NAT instances.')
natInstanceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 11, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"))
if mibBuilder.loadTexts: natInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: natInstanceEntry.setDescription('Objects related to a single NAT instance.')
natInstanceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 11, 1, 1), Unsigned32())
if mibBuilder.loadTexts: natInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: natInstanceIndex.setDescription('NAT instance index. Semantics of this number are\n            implementation-specific. This object is used as an index for\n            many tables defined below.')
natInstanceAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 11, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natInstanceAlias.setStatus('current')
if mibBuilder.loadTexts: natInstanceAlias.setDescription("This object is an 'alias' name for the NAT instance as\n            specified by a network manager, and provides a non-volatile\n            'handle' for the instance.\n\n            On the first instantiation of a NAT instance, the value of\n            natInstanceAlias associated with that instance is the\n            zero-length string.  As and when a value is written into an\n            instance of natInstanceAlias through a network management\n            set operation, then the agent must retain the supplied value\n            in this obejct instance associated with the same interface\n            for as long as that NAT instance remains instantiated,\n            including across all re-initializations/reboots of the\n            network management system, including those which result in a\n            change of the interface's natInstanceIndex value.\n\n            An example of the value which a network manager might store\n            in this object for a NAT instance is the name/identifier of\n            the interface that brings in internal traffic for this NAT\n            instance or the name of the VRF for internal traffic.\n\n            An agent may choose to provide read-only access if the agent\n            itself assigns an identifier for the NAT instance. An agent\n            which supports write access to this object is required to\n            keep the value in non-valite storage, but it may limit the\n            length of new values depending on how much storage is\n            already occupied by the current values for other\n            NAT instances.")
natCounters = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 1, 12))
natCountersTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 12, 1), )
if mibBuilder.loadTexts: natCountersTable.setStatus('current')
if mibBuilder.loadTexts: natCountersTable.setDescription('Table of counters of a NAT instance. The counters are global\n            across L4 protocols.')
natCountersEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"))
if mibBuilder.loadTexts: natCountersEntry.setStatus('current')
if mibBuilder.loadTexts: natCountersEntry.setDescription('Counters related to a single NAT instance.')
natTranslations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natTranslations.setStatus('current')
if mibBuilder.loadTexts: natTranslations.setDescription('The number of packets translated.')
natOutOfPortErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natOutOfPortErrors.setStatus('current')
if mibBuilder.loadTexts: natOutOfPortErrors.setDescription('The number of packets not translated because no external\n            port was available, excluding quota limitations.')
natResourceErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natResourceErrors.setStatus('current')
if mibBuilder.loadTexts: natResourceErrors.setDescription('The number of packets not translated because of resource\n            constraints (excluding out-of-ports error and quota drops).')
natQuotaDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natQuotaDrops.setStatus('current')
if mibBuilder.loadTexts: natQuotaDrops.setDescription('The number of incoming packets not translated because of\n            quota limitations.  Quotas include absolute limits as well\n            as limits on rate of allocation.')
natMappingCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingCreations.setStatus('current')
if mibBuilder.loadTexts: natMappingCreations.setDescription('Number of mapping creations. This includes static mappings.')
natMappingRemovals = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingRemovals.setStatus('current')
if mibBuilder.loadTexts: natMappingRemovals.setDescription('Number of mapping removals. This includes static mappings.')
natAddressMappingCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddressMappingCreations.setStatus('current')
if mibBuilder.loadTexts: natAddressMappingCreations.setDescription('Number of address mapping creations. This includes static\n            mappings.')
natAddressMappingRemovals = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natAddressMappingRemovals.setStatus('current')
if mibBuilder.loadTexts: natAddressMappingRemovals.setDescription('Number of address mapping removals. This includes static\n            mappings.\n\n            The number of active mappings is equal to\n            natAddressMappingCreations - natAddressMappingRemovals.')
natL4ProtocolTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 12, 2), )
if mibBuilder.loadTexts: natL4ProtocolTable.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolTable.setDescription('Table of protocols with per-protocol counters.')
natL4ProtocolEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "NAT-MIB", "natL4ProtocolNumber"))
if mibBuilder.loadTexts: natL4ProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolEntry.setDescription('Per-protocol counters.')
natL4ProtocolNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1, 1), ProtocolNumber())
if mibBuilder.loadTexts: natL4ProtocolNumber.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolNumber.setDescription("Counters in this conceptual row apply to packets using the\n            transport protocol identified by this object's value.")
natL4ProtocolTranslations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natL4ProtocolTranslations.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolTranslations.setDescription('The number of packets translated.')
natL4ProtocolOutOfPortErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natL4ProtocolOutOfPortErrors.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolOutOfPortErrors.setDescription('The number of packets not translated because no external\n            port was available.')
natL4ProtocolResourceErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natL4ProtocolResourceErrors.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolResourceErrors.setDescription('The number of packets not translated because of resource\n            constraints (excluding out-of-ports errors and quota\n            drops).')
natL4ProtocolQuotaDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natL4ProtocolQuotaDrops.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolQuotaDrops.setDescription('The number of incoming packets not translated because of\n            exceeded quotas. Quotas include absolute limits as well as\n            limits on rate of allocation.')
natL4ProtocolMappingCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natL4ProtocolMappingCreations.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolMappingCreations.setDescription('Number of mapping creations. This includes static mappings.')
natL4ProtocolMappingRemovals = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 12, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natL4ProtocolMappingRemovals.setStatus('current')
if mibBuilder.loadTexts: natL4ProtocolMappingRemovals.setDescription('Number of mapping removals. This includes static mappings.\n\n            The number of active mappings is equal to\n            natL4ProtocolMappingCreations -\n            natL4ProtocolMappingRemovals.')
natLimitsTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 13), )
if mibBuilder.loadTexts: natLimitsTable.setStatus('current')
if mibBuilder.loadTexts: natLimitsTable.setDescription('Table of limits for a NAT instance.')
natLimitsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 13, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"))
if mibBuilder.loadTexts: natLimitsEntry.setStatus('current')
if mibBuilder.loadTexts: natLimitsEntry.setDescription('Limit related to a single NAT instance.')
natLimitMappings = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 13, 1, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natLimitMappings.setStatus('current')
if mibBuilder.loadTexts: natLimitMappings.setDescription('Global limit on the total number of mappings. Zero means\n            unlimited.')
natMappingsNotifyThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 13, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natMappingsNotifyThreshold.setStatus('current')
if mibBuilder.loadTexts: natMappingsNotifyThreshold.setDescription('See natNotifMappings.')
natLimitAddressMappings = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 13, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natLimitAddressMappings.setStatus('current')
if mibBuilder.loadTexts: natLimitAddressMappings.setDescription("Global limit on the total number of internal-to-external\n            address mappings.  Zero means unlimited.\n\n            This limit is only applicable to NATs that have an 'IP\n            address pooling' behavior of 'Paired' [RFC4787].")
natAddrMapNotifyThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 13, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natAddrMapNotifyThreshold.setStatus('current')
if mibBuilder.loadTexts: natAddrMapNotifyThreshold.setDescription('See natNotifAddrMappings.')
natLimitFragments = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 13, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natLimitFragments.setStatus('current')
if mibBuilder.loadTexts: natLimitFragments.setDescription("Global limit on the total number of fragments pending\n            reassembly.  Zero means unlimited.\n\n            This limit is only applicable to NATs having 'Receive\n            Fragments Out of Order' behavior [RFC4787].")
natLimitSubscribers = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 13, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natLimitSubscribers.setStatus('current')
if mibBuilder.loadTexts: natLimitSubscribers.setDescription('Global limit on the number of subscribers with active\n            mappings.  Zero means unlimited.')
natPoolObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 1, 14))
natPoolTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 14, 1), )
if mibBuilder.loadTexts: natPoolTable.setStatus('current')
if mibBuilder.loadTexts: natPoolTable.setDescription('Table of pools.')
natPoolEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 14, 1, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "NAT-MIB", "natPoolIndex"))
if mibBuilder.loadTexts: natPoolEntry.setStatus('current')
if mibBuilder.loadTexts: natPoolEntry.setDescription('Entry in the table of pools.')
natPoolIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 1, 1, 1), NatPoolId())
if mibBuilder.loadTexts: natPoolIndex.setStatus('current')
if mibBuilder.loadTexts: natPoolIndex.setDescription('Index of an address pool.')
natPoolRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPoolRealm.setStatus('current')
if mibBuilder.loadTexts: natPoolRealm.setDescription("Realm to which this pool's addresses belong.")
natPoolWatermarkLow = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natPoolWatermarkLow.setStatus('current')
if mibBuilder.loadTexts: natPoolWatermarkLow.setDescription("Low watermark on a pool's usage, in percentage of the total\n            number of ports available. If set to -1, the watermark is\n            disabled. Otherwise when the usage percentage becomes lower\n            than or equal to natPoolWatermarkLow, a notification is\n            sent. The NAT may also start behaving in low usage mode\n            (this is implementation-defined).\n\n            The pool's current usage percentage can be computed by\n\n            summing (natPoolRangeAllocations -\n            natPoolRangeDeallocations) over all address ranges\n            belonging to this pool, then dividing by the total number of\n            IP addresses in this pool and by the size of the port range\n            in this pool (natPoolPortMax - natPoolPortMin + 1).")
natPoolWatermarkHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natPoolWatermarkHigh.setStatus('current')
if mibBuilder.loadTexts: natPoolWatermarkHigh.setDescription("High watermark on a pool's usage, in percentage of the total\n            number of ports available. If set to -1, the watermark is\n            disabled. Otherwise, when the usage percentage becomes\n            higher than or equal to natPoolWatermarkHigh, a notification\n            is sent.  The NAT may also start behaving in high usage mode\n            (this is implementation-defined).")
natPoolPortMin = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 1, 1, 5), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natPoolPortMin.setStatus('current')
if mibBuilder.loadTexts: natPoolPortMin.setDescription('Minimal port number to be allocated in this pool.')
natPoolPortMax = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 1, 1, 6), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: natPoolPortMax.setStatus('current')
if mibBuilder.loadTexts: natPoolPortMax.setDescription('Maximal port number to be allocated in this pool.')
natPoolRangeTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 14, 2), )
if mibBuilder.loadTexts: natPoolRangeTable.setStatus('current')
if mibBuilder.loadTexts: natPoolRangeTable.setDescription('This table contains address ranges used by pool entries.')
natPoolRangeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 14, 2, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "NAT-MIB", "natPoolRangePoolIndex"))
if mibBuilder.loadTexts: natPoolRangeEntry.setStatus('current')
if mibBuilder.loadTexts: natPoolRangeEntry.setDescription('NAT pool address range.')
natPoolRangePoolIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 2, 1, 1), NatPoolId())
if mibBuilder.loadTexts: natPoolRangePoolIndex.setStatus('current')
if mibBuilder.loadTexts: natPoolRangePoolIndex.setDescription('Index of the address pool to which this address range\n            belongs.  See natPoolIndex.')
natPoolRangeType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 2, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPoolRangeType.setStatus('current')
if mibBuilder.loadTexts: natPoolRangeType.setDescription('The address type of natPoolRangeBegin and\n            natPoolRangeEnd.')
natPoolRangeBegin = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 2, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPoolRangeBegin.setStatus('current')
if mibBuilder.loadTexts: natPoolRangeBegin.setDescription('Lowest address included in this range.')
natPoolRangeEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 2, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPoolRangeEnd.setStatus('current')
if mibBuilder.loadTexts: natPoolRangeEnd.setDescription('Highest address included in this range.')
natPoolRangeAllocations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPoolRangeAllocations.setStatus('current')
if mibBuilder.loadTexts: natPoolRangeAllocations.setDescription('Number of ports that have been allocated on the addresses in\n            this range.')
natPoolRangeDeallocations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 14, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPoolRangeDeallocations.setStatus('current')
if mibBuilder.loadTexts: natPoolRangeDeallocations.setDescription('Number of ports that have been allocated and then\n            deallocated on the addresses in this range.\n\n            The number of ports currently allocated on the addresses in\n            this range can be computed by subtracting\n            natPoolRangeDeallocations from natPoolRangeAllocations.')
natMapObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 1, 15))
natMapIntAddrTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 15, 1), )
if mibBuilder.loadTexts: natMapIntAddrTable.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrTable.setDescription("Table of mappings from internal to external address.\n\n            This table is only applicable to NATs that have an 'IP\n            address pooling' behavior of 'Paired' [RFC4787].")
natMapIntAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "NAT-MIB", "natMapIntAddrIntRealm"), (0, "NAT-MIB", "natMapIntAddrIntType"), (0, "NAT-MIB", "natMapIntAddrInt"))
if mibBuilder.loadTexts: natMapIntAddrEntry.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrEntry.setDescription('Mapping from internal to external address.')
natMapIntAddrIntRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: natMapIntAddrIntRealm.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrIntRealm.setDescription('Realm to which natMapIntAddrInt belongs.')
natMapIntAddrExtRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMapIntAddrExtRealm.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrExtRealm.setDescription('Realm to which natMapIntAddrExt belongs.')
natMapIntAddrIntType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1, 3), InetAddressType())
if mibBuilder.loadTexts: natMapIntAddrIntType.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrIntType.setDescription('Address type for natMapIntAddrInt.')
natMapIntAddrInt = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: natMapIntAddrInt.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrInt.setDescription('Internal address.')
natMapIntAddrExtType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMapIntAddrExtType.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrExtType.setDescription('Address type for natMapIntAddrExt.')
natMapIntAddrExt = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMapIntAddrExt.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrExt.setDescription('External address.')
natMapIntAddrSubsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMapIntAddrSubsIndex.setStatus('current')
if mibBuilder.loadTexts: natMapIntAddrSubsIndex.setDescription('Subscriber to which this address mapping applies, or zero if\n            it applies to all subscribers.')
natMappingTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 15, 2), )
if mibBuilder.loadTexts: natMappingTable.setStatus('current')
if mibBuilder.loadTexts: natMappingTable.setDescription('Table of mappings indexed by external 3-tuple.')
natMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "NAT-MIB", "natMappingProto"), (0, "NAT-MIB", "natMappingExtRealm"), (0, "NAT-MIB", "natMappingExtAddressType"), (0, "NAT-MIB", "natMappingExtAddress"), (0, "NAT-MIB", "natMappingExtPort"))
if mibBuilder.loadTexts: natMappingEntry.setStatus('current')
if mibBuilder.loadTexts: natMappingEntry.setDescription('A single NAT mapping.')
natMappingProto = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 1), ProtocolNumber())
if mibBuilder.loadTexts: natMappingProto.setStatus('current')
if mibBuilder.loadTexts: natMappingProto.setDescription("The mapping's transport protocol number.")
natMappingExtRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: natMappingExtRealm.setStatus('current')
if mibBuilder.loadTexts: natMappingExtRealm.setDescription('The realm to which natMappingExtAddress belongs.')
natMappingExtAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 3), InetAddressType())
if mibBuilder.loadTexts: natMappingExtAddressType.setStatus('current')
if mibBuilder.loadTexts: natMappingExtAddressType.setDescription("Type of the mapping's external address.")
natMappingExtAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: natMappingExtAddress.setStatus('current')
if mibBuilder.loadTexts: natMappingExtAddress.setDescription("The mapping's external address. If this is the undefined\n            address, all external addresses are mapped to the internal\n            address.")
natMappingExtPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 5), InetPortNumber())
if mibBuilder.loadTexts: natMappingExtPort.setStatus('current')
if mibBuilder.loadTexts: natMappingExtPort.setDescription("The mapping's external port number. If this is zero, all\n            external ports are mapped to the internal port.")
natMappingIntRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingIntRealm.setStatus('current')
if mibBuilder.loadTexts: natMappingIntRealm.setDescription('The realm to which natMappingIntAddress belongs.')
natMappingIntAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 7), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingIntAddressType.setStatus('current')
if mibBuilder.loadTexts: natMappingIntAddressType.setDescription("Type of the mapping's internal address.")
natMappingIntAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 8), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingIntAddress.setStatus('current')
if mibBuilder.loadTexts: natMappingIntAddress.setDescription("The mapping's internal address. If this is the undefined\n            address, addresses are not translated.")
natMappingIntPort = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 9), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingIntPort.setStatus('current')
if mibBuilder.loadTexts: natMappingIntPort.setDescription("The mapping's internal port number. If this is zero, ports\n            are not translated.")
natMappingPool = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingPool.setStatus('current')
if mibBuilder.loadTexts: natMappingPool.setDescription("Index of the pool that contains this mapping's external\n            address and port. If zero, no pool is associated with this\n            mapping.")
natMappingMapBehavior = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 11), NatBehaviorType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingMapBehavior.setStatus('current')
if mibBuilder.loadTexts: natMappingMapBehavior.setDescription('Mapping behavior as described in [RFC4787] section 4.1.')
natMappingFilterBehavior = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 12), NatBehaviorType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingFilterBehavior.setStatus('current')
if mibBuilder.loadTexts: natMappingFilterBehavior.setDescription('Filtering behavior as described in [RFC4787] section 5.')
natMappingAddressPooling = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 13), NatPoolingType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingAddressPooling.setStatus('current')
if mibBuilder.loadTexts: natMappingAddressPooling.setDescription('Type of address pooling behavior that was used to create\n            this mapping.')
natMappingSubsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 15, 2, 1, 14), SubscriberIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natMappingSubsIndex.setStatus('current')
if mibBuilder.loadTexts: natMappingSubsIndex.setDescription('Subscriber using this mapping.')
natSubscribers = MibIdentifier((1, 3, 6, 1, 2, 1, 123, 1, 16))
natSubscribersTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 16, 1), )
if mibBuilder.loadTexts: natSubscribersTable.setStatus('current')
if mibBuilder.loadTexts: natSubscribersTable.setDescription('Table of CGN subscribers.')
natSubscribersEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "NAT-MIB", "natSubscriberIndex"))
if mibBuilder.loadTexts: natSubscribersEntry.setStatus('current')
if mibBuilder.loadTexts: natSubscribersEntry.setDescription('Each entry describes a single CGN subscriber or a host\n            served by a managed enterprise NAT.')
natSubscriberIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 1), SubscriberIndex())
if mibBuilder.loadTexts: natSubscriberIndex.setStatus('current')
if mibBuilder.loadTexts: natSubscriberIndex.setDescription('Index of the subscriber or host.')
natSubscriberIdentifierType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 2), SubscriberIdentifierType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberIdentifierType.setStatus('current')
if mibBuilder.loadTexts: natSubscriberIdentifierType.setDescription('Type of additional information needed to identify the\n            subscriber or host from incoming packets, when the packet\n            source address does not do so unambiguously.\n\n            The implementation MUST ensure that the type and the\n            identifier value provided are synchronized, as follows.\n            Unused identifier values MUST be zero or equivalent.\n\n            Type           Identifier object\n\n            null(0)        None.\n            interfaces(1)  natSubsInterfaceIdentifierTable\n            vlan(2)        natSubscriberVlanIdentifier\n            vpn(3)         natSubscriberVpnIdentifier\n            ipencaps(4)    natSubscriberIPEncapsIdType and\n                           natSubscriberIPEncapsIdAddr\n            other(5)       As specified by the implementation')
natSubscriberIntPrefixType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberIntPrefixType.setStatus('current')
if mibBuilder.loadTexts: natSubscriberIntPrefixType.setDescription("Subscriber's internal prefix type.")
natSubscriberIntPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberIntPrefix.setStatus('current')
if mibBuilder.loadTexts: natSubscriberIntPrefix.setDescription("Prefix assigned to a subscriber's CPE.")
natSubscriberIntPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 5), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberIntPrefixLength.setStatus('current')
if mibBuilder.loadTexts: natSubscriberIntPrefixLength.setDescription("Length of the prefix assigned to a subscriber's CPE, in\n            bits.  In case a single address is assigned, this will be 32\n            for IPv4 and 128 for IPv6.")
natSubscriberRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberRealm.setStatus('current')
if mibBuilder.loadTexts: natSubscriberRealm.setDescription('The realm to which this subscriber belongs.')
natSubscriberTranslations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberTranslations.setStatus('current')
if mibBuilder.loadTexts: natSubscriberTranslations.setDescription('The number of translated packets received from or sent to\n            this subscriber.')
natSubscriberOutOfPortErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberOutOfPortErrors.setStatus('current')
if mibBuilder.loadTexts: natSubscriberOutOfPortErrors.setDescription('The number of packets received from this subscriber not\n            translated because no external port was available, excluding\n            quota limitations.')
natSubscriberResourceErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberResourceErrors.setStatus('current')
if mibBuilder.loadTexts: natSubscriberResourceErrors.setDescription('The number of packets received from this subscriber not\n            translated because of resource constraints (excluding\n            out-of-port errors and quota drops).')
natSubscriberQuotaDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberQuotaDrops.setStatus('current')
if mibBuilder.loadTexts: natSubscriberQuotaDrops.setDescription('The number of incoming packets received from or destined to\n            this subscriber not translated because of quota limitations.\n            Quotas include absolute limits as well as limits on the rate\n            of allocation.')
natSubscriberMappingCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberMappingCreations.setStatus('current')
if mibBuilder.loadTexts: natSubscriberMappingCreations.setDescription('Number of mappings created by or for this subscriber.')
natSubscriberMappingRemovals = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberMappingRemovals.setStatus('current')
if mibBuilder.loadTexts: natSubscriberMappingRemovals.setDescription('Number of mappings removed by or for this subscriber.')
natSubscriberLimitMappings = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 13), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natSubscriberLimitMappings.setStatus('current')
if mibBuilder.loadTexts: natSubscriberLimitMappings.setDescription('Limit on the number of active mappings created by or for\n            this subscriber. Zero means unlimited.')
natSubscriberMapNotifyThresh = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 14), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natSubscriberMapNotifyThresh.setStatus('current')
if mibBuilder.loadTexts: natSubscriberMapNotifyThresh.setDescription('See natNotifSubscriberMappings.')
natSubscriberVlanIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 15), VlanIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberVlanIdentifier.setStatus('current')
if mibBuilder.loadTexts: natSubscriberVlanIdentifier.setDescription('When non-zero, VLAN index used to identify subscriber in\n            combination with packet source address.')
natSubscriberVpnIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 16), VPNIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberVpnIdentifier.setStatus('current')
if mibBuilder.loadTexts: natSubscriberVpnIdentifier.setDescription('When non-zero, VPN identifier used to identify subscriber\n\n            in combination with packet source address.')
natSubscriberIPEncapsIdType = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 17), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberIPEncapsIdType.setStatus('current')
if mibBuilder.loadTexts: natSubscriberIPEncapsIdType.setDescription('When not unknown(0), type of address of encapsulating IP\n            ingress tunnel.')
natSubscriberIPEncapsIdAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 1, 1, 18), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubscriberIPEncapsIdAddr.setStatus('current')
if mibBuilder.loadTexts: natSubscriberIPEncapsIdAddr.setDescription('Source address in outer header of packets incoming via IP\n            tunnel, used to identify subscriber in combination with\n            inner packet source address.')
natSubsInterfaceIdentifierTable = MibTable((1, 3, 6, 1, 2, 1, 123, 1, 16, 2), )
if mibBuilder.loadTexts: natSubsInterfaceIdentifierTable.setStatus('current')
if mibBuilder.loadTexts: natSubsInterfaceIdentifierTable.setDescription("Table of interface indexes. If non-empty, used along with\n            packet source address to identify the subscriber sending\n            the packet. 'OR' semantics if multiple interface indexes\n            are present.")
natSubsInterfaceIdentifierEntry = MibTableRow((1, 3, 6, 1, 2, 1, 123, 1, 16, 2, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "NAT-MIB", "natSubsInterfaceIdSubsIndex"), (0, "NAT-MIB", "natSubsInterfaceIdRowIndex"))
if mibBuilder.loadTexts: natSubsInterfaceIdentifierEntry.setStatus('current')
if mibBuilder.loadTexts: natSubsInterfaceIdentifierEntry.setDescription('Each entry provides a single interface index.')
natSubsInterfaceIdSubsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 2, 1, 1), SubscriberIndex())
if mibBuilder.loadTexts: natSubsInterfaceIdSubsIndex.setStatus('current')
if mibBuilder.loadTexts: natSubsInterfaceIdSubsIndex.setDescription('Index of the subscriber to which this conceptual table is\n            related.')
natSubsInterfaceIdRowIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 2, 1, 2), SubsInterfaceIdRowIndex())
if mibBuilder.loadTexts: natSubsInterfaceIdRowIndex.setStatus('current')
if mibBuilder.loadTexts: natSubsInterfaceIdRowIndex.setDescription('Row index.')
natSubsInterfaceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 123, 1, 16, 2, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natSubsInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: natSubsInterfaceIndex.setDescription('Interface index of an ingress interface through which\n            packets from this subscriber may flow.')
natGroupStatelessObjects = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 7)).setObjects(("NAT-MIB", "natInstanceAlias"), ("NAT-MIB", "natTranslations"), ("NAT-MIB", "natResourceErrors"), ("NAT-MIB", "natQuotaDrops"), ("NAT-MIB", "natMappingCreations"), ("NAT-MIB", "natMappingRemovals"), ("NAT-MIB", "natL4ProtocolTranslations"), ("NAT-MIB", "natL4ProtocolResourceErrors"), ("NAT-MIB", "natL4ProtocolQuotaDrops"), ("NAT-MIB", "natL4ProtocolMappingCreations"), ("NAT-MIB", "natL4ProtocolMappingRemovals"), ("NAT-MIB", "natMappingIntRealm"), ("NAT-MIB", "natMappingIntAddressType"), ("NAT-MIB", "natMappingIntAddress"), ("NAT-MIB", "natMappingIntPort"), ("NAT-MIB", "natMappingPool"), ("NAT-MIB", "natMappingMapBehavior"), ("NAT-MIB", "natMappingFilterBehavior"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupStatelessObjects = natGroupStatelessObjects.setStatus('current')
if mibBuilder.loadTexts: natGroupStatelessObjects.setDescription("Basic counters, limits, and thresholds that do not require\n            stateful NAT. That is, they apply to both stateless and\n            stateful NATs.\n\n            For this MIB's purposes, stateless NATs are defined as NATs\n            that do not create mappings dynamically (either implicitly\n            or explicitly using, for instance, the Port Control\n            Protocol).  Their mappings are created statically by the NAT\n            administrator.")
natGroupStatefulObjects = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 8)).setObjects(("NAT-MIB", "natOutOfPortErrors"), ("NAT-MIB", "natL4ProtocolOutOfPortErrors"), ("NAT-MIB", "natLimitMappings"), ("NAT-MIB", "natMappingsNotifyThreshold"), ("NAT-MIB", "natPoolRealm"), ("NAT-MIB", "natPoolWatermarkLow"), ("NAT-MIB", "natPoolWatermarkHigh"), ("NAT-MIB", "natPoolPortMin"), ("NAT-MIB", "natPoolPortMax"), ("NAT-MIB", "natPoolRangeType"), ("NAT-MIB", "natPoolRangeBegin"), ("NAT-MIB", "natPoolRangeEnd"), ("NAT-MIB", "natPoolRangeAllocations"), ("NAT-MIB", "natPoolRangeDeallocations"), ("NAT-MIB", "natMappingAddressPooling"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupStatefulObjects = natGroupStatefulObjects.setStatus('current')
if mibBuilder.loadTexts: natGroupStatefulObjects.setDescription('Basic counters, limits, and thresholds that require stateful\n            NAT.')
natGroupAddrMapObjects = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 9)).setObjects(("NAT-MIB", "natAddressMappingCreations"), ("NAT-MIB", "natAddressMappingRemovals"), ("NAT-MIB", "natLimitAddressMappings"), ("NAT-MIB", "natAddrMapNotifyThreshold"), ("NAT-MIB", "natMapIntAddrExtRealm"), ("NAT-MIB", "natMapIntAddrExtType"), ("NAT-MIB", "natMapIntAddrExt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupAddrMapObjects = natGroupAddrMapObjects.setStatus('current')
if mibBuilder.loadTexts: natGroupAddrMapObjects.setDescription("Objects that require 'Paired IP address pooling' behavior\n            [RFC4787].")
natGroupFragmentObjects = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 10)).setObjects(("NAT-MIB", "natLimitFragments"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupFragmentObjects = natGroupFragmentObjects.setStatus('current')
if mibBuilder.loadTexts: natGroupFragmentObjects.setDescription("Objects that require 'Receive Fragments Out of Order'\n            behavior [RFC4787].")
natGroupBasicNotifications = NotificationGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 11)).setObjects(("NAT-MIB", "natNotifPoolWatermarkLow"), ("NAT-MIB", "natNotifPoolWatermarkHigh"), ("NAT-MIB", "natNotifMappings"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupBasicNotifications = natGroupBasicNotifications.setStatus('current')
if mibBuilder.loadTexts: natGroupBasicNotifications.setDescription('Basic notifications.')
natGroupAddrMapNotifications = NotificationGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 12)).setObjects(("NAT-MIB", "natNotifAddrMappings"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupAddrMapNotifications = natGroupAddrMapNotifications.setStatus('current')
if mibBuilder.loadTexts: natGroupAddrMapNotifications.setDescription('Notifications about address mappings.')
natGroupSubscriberObjects = ObjectGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 13)).setObjects(("NAT-MIB", "natMapIntAddrSubsIndex"), ("NAT-MIB", "natMappingSubsIndex"), ("NAT-MIB", "natSubscriberIdentifierType"), ("NAT-MIB", "natSubscriberIntPrefixType"), ("NAT-MIB", "natSubscriberIntPrefix"), ("NAT-MIB", "natSubscriberIntPrefixLength"), ("NAT-MIB", "natSubscriberRealm"), ("NAT-MIB", "natSubscriberTranslations"), ("NAT-MIB", "natSubscriberOutOfPortErrors"), ("NAT-MIB", "natSubscriberResourceErrors"), ("NAT-MIB", "natSubscriberQuotaDrops"), ("NAT-MIB", "natSubscriberMappingCreations"), ("NAT-MIB", "natSubscriberMappingRemovals"), ("NAT-MIB", "natSubscriberLimitMappings"), ("NAT-MIB", "natSubscriberVlanIdentifier"), ("NAT-MIB", "natSubscriberVpnIdentifier"), ("NAT-MIB", "natSubscriberIPEncapsIdType"), ("NAT-MIB", "natSubscriberIPEncapsIdAddr"), ("NAT-MIB", "natSubsInterfaceIndex"), ("NAT-MIB", "natLimitSubscribers"), ("NAT-MIB", "natSubscriberMapNotifyThresh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupSubscriberObjects = natGroupSubscriberObjects.setStatus('current')
if mibBuilder.loadTexts: natGroupSubscriberObjects.setDescription('Per-subscriber counters, limits, and thresholds.')
natGroupSubscriberNotifications = NotificationGroup((1, 3, 6, 1, 2, 1, 123, 2, 1, 14)).setObjects(("NAT-MIB", "natNotifSubscriberMappings"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natGroupSubscriberNotifications = natGroupSubscriberNotifications.setStatus('current')
if mibBuilder.loadTexts: natGroupSubscriberNotifications.setDescription('Subscriber notifications.')
natBasicStatelessCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 123, 2, 2, 3)).setObjects(("NAT-MIB", "natGroupStatelessObjects"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natBasicStatelessCompliance = natBasicStatelessCompliance.setStatus('current')
if mibBuilder.loadTexts: natBasicStatelessCompliance.setDescription('Basic stateless compliance with this MIB is attained when\n            the objects contained in the mandatory groups are\n            implemented.')
natBasicStatefulCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 123, 2, 2, 4)).setObjects(("NAT-MIB", "natGroupStatelessObjects"), ("NAT-MIB", "natGroupStatefulObjects"), ("NAT-MIB", "natGroupBasicNotifications"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natBasicStatefulCompliance = natBasicStatefulCompliance.setStatus('current')
if mibBuilder.loadTexts: natBasicStatefulCompliance.setDescription('Basic stateful compliance with this MIB is attained when the\n            objects contained in the mandatory groups are implemented.')
natAddrMapCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 123, 2, 2, 5)).setObjects(("NAT-MIB", "natGroupStatelessObjects"), ("NAT-MIB", "natGroupStatefulObjects"), ("NAT-MIB", "natGroupBasicNotifications"), ("NAT-MIB", "natGroupAddrMapObjects"), ("NAT-MIB", "natGroupAddrMapNotifications"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natAddrMapCompliance = natAddrMapCompliance.setStatus('current')
if mibBuilder.loadTexts: natAddrMapCompliance.setDescription("NATs that have 'Paired IP address pooling' behavior\n\n            [RFC4787] and implement the objects in this group can claim\n            this level of compliance.")
natFragmentsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 123, 2, 2, 6)).setObjects(("NAT-MIB", "natGroupStatelessObjects"), ("NAT-MIB", "natGroupStatefulObjects"), ("NAT-MIB", "natGroupBasicNotifications"), ("NAT-MIB", "natGroupFragmentObjects"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natFragmentsCompliance = natFragmentsCompliance.setStatus('current')
if mibBuilder.loadTexts: natFragmentsCompliance.setDescription("NATs that have 'Receive Fragments Out of Order' behavior\n            [RFC4787] and implement the objects in this group can claim\n            this level of compliance.")
natCGNCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 123, 2, 2, 7)).setObjects(("NAT-MIB", "natGroupStatelessObjects"), ("NAT-MIB", "natGroupStatefulObjects"), ("NAT-MIB", "natGroupBasicNotifications"), ("NAT-MIB", "natGroupAddrMapObjects"), ("NAT-MIB", "natGroupAddrMapNotifications"), ("NAT-MIB", "natGroupFragmentObjects"), ("NAT-MIB", "natGroupSubscriberObjects"), ("NAT-MIB", "natGroupSubscriberNotifications"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natCGNCompliance = natCGNCompliance.setStatus('current')
if mibBuilder.loadTexts: natCGNCompliance.setDescription("NATs that have 'Paired IP address pooling' and 'Receive\n            Fragments Out of Order' behavior [RFC4787] and implement the\n            objects in this group can claim this level of compliance.\n\n            This level of compliance is to be expected of a CGN\n            compliant with [RFC6888].")
mibBuilder.exportSymbols("NAT-MIB", NatPoolingType=NatPoolingType, natSubscribersEntry=natSubscribersEntry, natSessionPublicDstPort=natSessionPublicDstPort, natMappingExtRealm=natMappingExtRealm, natAddrPortBindMaxIdleTime=natAddrPortBindMaxIdleTime, natAddrMapDiscards=natAddrMapDiscards, natAddrPortBindGlobalPort=natAddrPortBindGlobalPort, natSessionProtocolType=natSessionProtocolType, natAddrBindSessions=natAddrBindSessions, natSubscribers=natSubscribers, natMIBCompliances=natMIBCompliances, natSessionAddrMapIndex=natSessionAddrMapIndex, natNotifMappings=natNotifMappings, natMapIntAddrExt=natMapIntAddrExt, natGroupAddrMapObjects=natGroupAddrMapObjects, natGroupStatelessObjects=natGroupStatelessObjects, NatTranslationEntity=NatTranslationEntity, natSessionPrivateSrcEPBindId=natSessionPrivateSrcEPBindId, natAddrBindType=natAddrBindType, natMapIntAddrIntType=natMapIntAddrIntType, NatProtocolMap=NatProtocolMap, natAddrBindMaxIdleTime=natAddrBindMaxIdleTime, natProtocolEntry=natProtocolEntry, natL4ProtocolNumber=natL4ProtocolNumber, natNotifAddrMappings=natNotifAddrMappings, natInterfaceTable=natInterfaceTable, SubsInterfaceIdRowIndex=SubsInterfaceIdRowIndex, natSubscriberOutOfPortErrors=natSubscriberOutOfPortErrors, natSessionPrivateDstAddr=natSessionPrivateDstAddr, natStatsAddrMapGroup=natStatsAddrMapGroup, natBasicStatefulCompliance=natBasicStatefulCompliance, NatAddrMapId=NatAddrMapId, natAddrMapGlobalAddrFrom=natAddrMapGlobalAddrFrom, NatBindIdOrZero=NatBindIdOrZero, natMappingProto=natMappingProto, natSubscriberIntPrefix=natSubscriberIntPrefix, natSubscriberMappingRemovals=natSubscriberMappingRemovals, natAddrPortBindId=natAddrPortBindId, natBasicStatelessCompliance=natBasicStatelessCompliance, natSessionDirection=natSessionDirection, natGroupAddrMapNotifications=natGroupAddrMapNotifications, natUdpDefIdleTimeout=natUdpDefIdleTimeout, natInterfaceEntry=natInterfaceEntry, natAddrMapTable=natAddrMapTable, natAddrPortBindType=natAddrPortBindType, NatBehaviorType=NatBehaviorType, natNotifSubscriberMappings=natNotifSubscriberMappings, natAddrBindLocalAddr=natAddrBindLocalAddr, natAddrBindGlobalAddr=natAddrBindGlobalAddr, NatProtocolType=NatProtocolType, natMIBNotifications=natMIBNotifications, natL4ProtocolOutOfPortErrors=natL4ProtocolOutOfPortErrors, natSessionPrivateAddrType=natSessionPrivateAddrType, natAddrMapGlobalAddrType=natAddrMapGlobalAddrType, natPacketDiscard=natPacketDiscard, natAddrBindTranslationEntity=natAddrBindTranslationEntity, natAddressMappingCreations=natAddressMappingCreations, natAddrMapNotifyThreshold=natAddrMapNotifyThreshold, natProtocolDiscards=natProtocolDiscards, natMIBObjects=natMIBObjects, natInterfaceOutTranslates=natInterfaceOutTranslates, natLimitSubscribers=natLimitSubscribers, VlanIndexOrZero=VlanIndexOrZero, natSubscriberIPEncapsIdAddr=natSubscriberIPEncapsIdAddr, natAddressMappingRemovals=natAddressMappingRemovals, natPoolTable=natPoolTable, natCountersTable=natCountersTable, natSessionPublicSrcPort=natSessionPublicSrcPort, SubscriberIndex=SubscriberIndex, natBindDefIdleTimeout=natBindDefIdleTimeout, natAddrMapAddrUsed=natAddrMapAddrUsed, natNotifPoolWatermarkHigh=natNotifPoolWatermarkHigh, natAddrMapTranslationEntity=natAddrMapTranslationEntity, natL4ProtocolEntry=natL4ProtocolEntry, natAddrMapRowStatus=natAddrMapRowStatus, natL4ProtocolTranslations=natL4ProtocolTranslations, natSessionUpTime=natSessionUpTime, natPoolPortMax=natPoolPortMax, natSessionTable=natSessionTable, natPoolRangeEntry=natPoolRangeEntry, NatPoolId=NatPoolId, natMappingPool=natMappingPool, natNotifCtrl=natNotifCtrl, natL4ProtocolTable=natL4ProtocolTable, natPoolRangeAllocations=natPoolRangeAllocations, natInterfaceInTranslates=natInterfaceInTranslates, natProtocolTable=natProtocolTable, natAddrMapLocalAddrTo=natAddrMapLocalAddrTo, natAddrPortBindProtocol=natAddrPortBindProtocol, natMappingFilterBehavior=natMappingFilterBehavior, natAddrPortBindGlobalAddr=natAddrPortBindGlobalAddr, natSessionMaxIdleTime=natSessionMaxIdleTime, natMappingAddressPooling=natMappingAddressPooling, natPoolPortMin=natPoolPortMin, natCGNCompliance=natCGNCompliance, natSubscriberIntPrefixType=natSubscriberIntPrefixType, natAddrBindInTranslates=natAddrBindInTranslates, natSessionPrivateSrcAddr=natSessionPrivateSrcAddr, natAddrPortBindGlobalAddrType=natAddrPortBindGlobalAddrType, natAddrBindId=natAddrBindId, natMIBGroups=natMIBGroups, natAddrPortBindTranslationEntity=natAddrPortBindTranslationEntity, natNotifPoolWatermarkLow=natNotifPoolWatermarkLow, natInstanceAlias=natInstanceAlias, natOutOfPortErrors=natOutOfPortErrors, natMappingMapBehavior=natMappingMapBehavior, natSubscriberIntPrefixLength=natSubscriberIntPrefixLength, natAddrMapGlobalPortTo=natAddrMapGlobalPortTo, natSessionPrivateDstEPBindId=natSessionPrivateDstEPBindId, natSessionPublicSrcAddr=natSessionPublicSrcAddr, natPoolIndex=natPoolIndex, natCountersEntry=natCountersEntry, natPoolRangeType=natPoolRangeType, natMappingIntRealm=natMappingIntRealm, natL4ProtocolMappingCreations=natL4ProtocolMappingCreations, natSessionPublicAddrType=natSessionPublicAddrType, natPoolWatermarkLow=natPoolWatermarkLow, natOtherDefIdleTimeout=natOtherDefIdleTimeout, natMIBConformance=natMIBConformance, natConfigGroup=natConfigGroup, natAddrMapIndex=natAddrMapIndex, natSubscriberQuotaDrops=natSubscriberQuotaDrops, natSubscriberMappingCreations=natSubscriberMappingCreations, natStatsProtocolGroup=natStatsProtocolGroup, natTcpDefNegTimeout=natTcpDefNegTimeout, natAddrBindMapIndex=natAddrBindMapIndex, natMappingSubsIndex=natMappingSubsIndex, natGroupSubscriberNotifications=natGroupSubscriberNotifications, natPoolRangeEnd=natPoolRangeEnd, natAddrMapOutTranslates=natAddrMapOutTranslates, natSessionPrivateSrcEPBindMode=natSessionPrivateSrcEPBindMode, natAddrPortBindEntry=natAddrPortBindEntry, natSubsInterfaceIdentifierTable=natSubsInterfaceIdentifierTable, natSubscriberVlanIdentifier=natSubscriberVlanIdentifier, natMIBNotificationGroup=natMIBNotificationGroup, natIcmpDefIdleTimeout=natIcmpDefIdleTimeout, natSessionIndex=natSessionIndex, natProtocolOutTranslates=natProtocolOutTranslates, natSubsInterfaceIndex=natSubsInterfaceIndex, natAddrPortBindLocalAddr=natAddrPortBindLocalAddr, natAddrMapProtocol=natAddrMapProtocol, natPoolRangeDeallocations=natPoolRangeDeallocations, natMIB=natMIB, natProtocolInTranslates=natProtocolInTranslates, natCounters=natCounters, natPoolWatermarkHigh=natPoolWatermarkHigh, natPoolEntry=natPoolEntry, natAddrMapGlobalPortFrom=natAddrMapGlobalPortFrom, natMappingTable=natMappingTable, natMappingExtPort=natMappingExtPort, natTranslations=natTranslations, PYSNMP_MODULE_ID=natMIB, natAddrPortBindOutTranslates=natAddrPortBindOutTranslates, natNotifThrottlingInterval=natNotifThrottlingInterval, natTcpDefIdleTimeout=natTcpDefIdleTimeout, natAddrBindNumberOfEntries=natAddrBindNumberOfEntries, natAddrBindEntry=natAddrBindEntry, natSubscribersTable=natSubscribersTable, natMappingIntAddressType=natMappingIntAddressType, natAddrPortBindSessions=natAddrPortBindSessions, natAddrMapCompliance=natAddrMapCompliance, natL4ProtocolResourceErrors=natL4ProtocolResourceErrors, natAddrMapStorageType=natAddrMapStorageType, natMappingEntry=natMappingEntry, natAddrPortBindMapIndex=natAddrPortBindMapIndex, natGroupStatefulObjects=natGroupStatefulObjects, natPoolRealm=natPoolRealm, natInterfaceStorageType=natInterfaceStorageType, natAddrPortBindCurrentIdleTime=natAddrPortBindCurrentIdleTime, natSessionPrivateSrcPort=natSessionPrivateSrcPort, natMapIntAddrSubsIndex=natMapIntAddrSubsIndex, natAddrPortBindLocalPort=natAddrPortBindLocalPort, natSubscriberRealm=natSubscriberRealm, natSubsInterfaceIdRowIndex=natSubsInterfaceIdRowIndex, natAddrMapName=natAddrMapName, natInterfaceRowStatus=natInterfaceRowStatus, natSubscriberResourceErrors=natSubscriberResourceErrors, natQuotaDrops=natQuotaDrops, natMapIntAddrInt=natMapIntAddrInt, natAddrBindCurrentIdleTime=natAddrBindCurrentIdleTime, natInterfaceDiscards=natInterfaceDiscards, natMIBFullCompliance=natMIBFullCompliance, natResourceErrors=natResourceErrors, natMapIntAddrTable=natMapIntAddrTable, natLimitMappings=natLimitMappings, natMappingRemovals=natMappingRemovals, natSessionPublicDstAddr=natSessionPublicDstAddr, natDefTimeouts=natDefTimeouts, natSessionInTranslates=natSessionInTranslates, natAddrBindGlobalAddrType=natAddrBindGlobalAddrType, natPoolRangePoolIndex=natPoolRangePoolIndex, natSubscriberIPEncapsIdType=natSubscriberIPEncapsIdType, natSubscriberVpnIdentifier=natSubscriberVpnIdentifier, natSubsInterfaceIdentifierEntry=natSubsInterfaceIdentifierEntry, natLimitFragments=natLimitFragments, natLimitAddressMappings=natLimitAddressMappings, natAddrMapEntry=natAddrMapEntry, natAddrMapLocalAddrFrom=natAddrMapLocalAddrFrom, natAddrBindOutTranslates=natAddrBindOutTranslates, natMappingExtAddress=natMappingExtAddress, natSubscriberIdentifierType=natSubscriberIdentifierType, natL4ProtocolMappingRemovals=natL4ProtocolMappingRemovals, natAddrMapGlobalAddrTo=natAddrMapGlobalAddrTo, natGroupSubscriberObjects=natGroupSubscriberObjects, natSessionOutTranslates=natSessionOutTranslates, NatSessionId=NatSessionId, natProtocol=natProtocol, natInterfaceServiceType=natInterfaceServiceType, natInterfaceRealm=natInterfaceRealm, natAddrBindLocalAddrType=natAddrBindLocalAddrType, natAddrMapInTranslates=natAddrMapInTranslates, natAddrMapLocalPortFrom=natAddrMapLocalPortFrom, natMIBReadOnlyCompliance=natMIBReadOnlyCompliance, NatAssociationType=NatAssociationType, natInstanceTable=natInstanceTable, natMappingCreations=natMappingCreations, natGroupFragmentObjects=natGroupFragmentObjects, natSessionCurrentIdleTime=natSessionCurrentIdleTime, natL4ProtocolQuotaDrops=natL4ProtocolQuotaDrops, NatBindId=NatBindId, natAddrMapLocalPortTo=natAddrMapLocalPortTo, natSessionPrivateDstEPBindMode=natSessionPrivateDstEPBindMode, natMapIntAddrEntry=natMapIntAddrEntry, natMapIntAddrExtType=natMapIntAddrExtType, natTranslationGroup=natTranslationGroup, natMappingIntPort=natMappingIntPort, natPoolRangeBegin=natPoolRangeBegin, natSubscriberMapNotifyThresh=natSubscriberMapNotifyThresh, natInstanceIndex=natInstanceIndex, natMapIntAddrIntRealm=natMapIntAddrIntRealm, natInstanceEntry=natInstanceEntry, SubscriberIdentifierType=SubscriberIdentifierType, natAddrPortBindLocalAddrType=natAddrPortBindLocalAddrType, natPoolObjects=natPoolObjects, natAddrPortBindTable=natAddrPortBindTable, natPoolRangeTable=natPoolRangeTable, natSessionEntry=natSessionEntry, natAddrPortBindNumberOfEntries=natAddrPortBindNumberOfEntries, NatBindMode=NatBindMode, natMappingsNotifyThreshold=natMappingsNotifyThreshold, natAddrBindTable=natAddrBindTable, natSessionPrivateDstPort=natSessionPrivateDstPort, natGroupBasicNotifications=natGroupBasicNotifications, natStatsInterfaceGroup=natStatsInterfaceGroup, natSubscriberTranslations=natSubscriberTranslations, natAddrPortBindInTranslates=natAddrPortBindInTranslates, natLimitsEntry=natLimitsEntry, natSubscriberLimitMappings=natSubscriberLimitMappings, ProtocolNumber=ProtocolNumber, natMappingIntAddress=natMappingIntAddress, natAddrMapLocalAddrType=natAddrMapLocalAddrType, natAddrMapEntryType=natAddrMapEntryType, natMappingExtAddressType=natMappingExtAddressType, natMapIntAddrExtRealm=natMapIntAddrExtRealm)
mibBuilder.exportSymbols("NAT-MIB", natSubscriberIndex=natSubscriberIndex, natMapObjects=natMapObjects, natFragmentsCompliance=natFragmentsCompliance, natSubsInterfaceIdSubsIndex=natSubsInterfaceIdSubsIndex, natLimitsTable=natLimitsTable)
