#
# PySNMP MIB module UCD-IPFWACC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/netsnmp/UCD-IPFWACC-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 00:31:44 2022
# On host fv-az77-763 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, NotificationType, ObjectIdentity, Integer32, Counter64, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter32, Bits, IpAddress, iso, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "NotificationType", "ObjectIdentity", "Integer32", "Counter64", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter32", "Bits", "IpAddress", "iso", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ucdExperimental, = mibBuilder.importSymbols("UCD-SNMP-MIB", "ucdExperimental")
ucdIpFwAccMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2021, 13, 1))
ucdIpFwAccMIB.setRevisions(('1999-12-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ucdIpFwAccMIB.setRevisionsDescriptions(('SMIv2 version converted from an older MIB definition.',))
if mibBuilder.loadTexts: ucdIpFwAccMIB.setLastUpdated('9912160000Z')
if mibBuilder.loadTexts: ucdIpFwAccMIB.setOrganization('University of California, Davis')
if mibBuilder.loadTexts: ucdIpFwAccMIB.setContactInfo('This mib is no longer being maintained by the University of\n\t California and is now in life-support-mode and being\n\t maintained by the net-snmp project.  The best place to write\n\t for public questions about the net-snmp-coders mailing list\n\t at net-snmp-coders@lists.sourceforge.net.\n\n         postal:   Wes Hardaker\n                   P.O. Box 382\n                   Davis CA  95617\n\n         email:    net-snmp-coders@lists.sourceforge.net\n        ')
if mibBuilder.loadTexts: ucdIpFwAccMIB.setDescription("This module defines MIB components for reading information\n         from the accounting rules IP Firewall. This would typically\n         let you read the rules and the counters. I did not include\n         some flags and fields that I considered irrelevant for the\n         accounting rules. Resetting the counters of the rules by SNMP\n         would be simple, but I don't consider it so useful. I gave no\n         consideration to implementing write access for allowing\n         modification of the accounting rules.\n\n         Cristian.Estan@net.utcluj.ro ")
ipFwAccTable = MibTable((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1), )
if mibBuilder.loadTexts: ipFwAccTable.setStatus('current')
if mibBuilder.loadTexts: ipFwAccTable.setDescription('A table with the accounting rules of the IP firewall')
ipFwAccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1), ).setIndexNames((0, "UCD-IPFWACC-MIB", "ipFwAccIndex"))
if mibBuilder.loadTexts: ipFwAccEntry.setStatus('current')
if mibBuilder.loadTexts: ipFwAccEntry.setDescription('An accounting rule of the IP firewall')
ipFwAccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccIndex.setStatus('current')
if mibBuilder.loadTexts: ipFwAccIndex.setDescription('Reference index for each firewall rule.')
ipFwAccSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ipFwAccSrcAddr.setDescription('The source address in the firewall rule.')
ipFwAccSrcNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccSrcNetMask.setStatus('current')
if mibBuilder.loadTexts: ipFwAccSrcNetMask.setDescription('The netmask of the source address in the firewall rule.')
ipFwAccDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccDstAddr.setStatus('current')
if mibBuilder.loadTexts: ipFwAccDstAddr.setDescription('The destination address in the firewall rule.')
ipFwAccDstNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccDstNetMask.setStatus('current')
if mibBuilder.loadTexts: ipFwAccDstNetMask.setDescription('The netmask of the destination address in the firewall rule.')
ipFwAccViaName = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccViaName.setStatus('current')
if mibBuilder.loadTexts: ipFwAccViaName.setDescription('The name of the interface to which the rule applies. If no\n\t interface is associated with the present rule, this should\n\t contain a dash (-).')
ipFwAccViaAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccViaAddr.setStatus('current')
if mibBuilder.loadTexts: ipFwAccViaAddr.setDescription('The address of the interface to which the rule applies.\n\t Using this parameter makes sense when multiple addresses are\n\t associated to the same physical interface. If not defined\n\t for the current rule this should be set to 0.')
ipFwAccProto = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("all", 2), ("tcp", 3), ("udp", 4), ("icmp", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccProto.setStatus('current')
if mibBuilder.loadTexts: ipFwAccProto.setDescription('The protocol(s) to which the rule applies.')
ipFwAccBidir = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unidirectional", 1), ("bidirectional", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccBidir.setStatus('current')
if mibBuilder.loadTexts: ipFwAccBidir.setDescription('Whether the rule works in both directions (i.e. with the\n\t source and destination parts swapped) or not.')
ipFwAccDir = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("in", 2), ("out", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccDir.setStatus('current')
if mibBuilder.loadTexts: ipFwAccDir.setDescription('Whether the rule applies to packets entering or exiting the\n\t kernel.')
ipFwAccBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccBytes.setStatus('current')
if mibBuilder.loadTexts: ipFwAccBytes.setDescription('The number of bytes that matched this rule since the last\n\t reset of the counters.')
ipFwAccPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPackets.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPackets.setDescription('The number of packets that matched this rule since the last\n\t reset of the counters.')
ipFwAccNrSrcPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccNrSrcPorts.setStatus('current')
if mibBuilder.loadTexts: ipFwAccNrSrcPorts.setDescription('The number of ports that refer to the source address.')
ipFwAccNrDstPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccNrDstPorts.setStatus('current')
if mibBuilder.loadTexts: ipFwAccNrDstPorts.setDescription('The number of ports that refer to the destination address.')
ipFwAccSrcIsRange = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("srchasrange", 1), ("srchasnorange", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccSrcIsRange.setStatus('current')
if mibBuilder.loadTexts: ipFwAccSrcIsRange.setDescription('Interpret the first two ports of the source part as\n\t the upper and lower limit of an interval or not.')
ipFwAccDstIsRange = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dsthasrange", 1), ("dsthasnorange", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccDstIsRange.setStatus('current')
if mibBuilder.loadTexts: ipFwAccDstIsRange.setDescription('Interpret the first two ports of the destination part as\n\t the upper and lower limit of an interval or not.')
ipFwAccPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort1.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort1.setDescription('Port number 1.')
ipFwAccPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort2.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort2.setDescription('Port number 2.')
ipFwAccPort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort3.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort3.setDescription('Port number 3.')
ipFwAccPort4 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort4.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort4.setDescription('Port number 4.')
ipFwAccPort5 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort5.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort5.setDescription('Port number 5.')
ipFwAccPort6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort6.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort6.setDescription('Port number 6.')
ipFwAccPort7 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort7.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort7.setDescription('Port number 7.')
ipFwAccPort8 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort8.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort8.setDescription('Port number 8.')
ipFwAccPort9 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort9.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort9.setDescription('Port number 9.')
ipFwAccPort10 = MibTableColumn((1, 3, 6, 1, 4, 1, 2021, 13, 1, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwAccPort10.setStatus('current')
if mibBuilder.loadTexts: ipFwAccPort10.setDescription('Port number 10.')
mibBuilder.exportSymbols("UCD-IPFWACC-MIB", ipFwAccPort9=ipFwAccPort9, ipFwAccPort3=ipFwAccPort3, ipFwAccNrDstPorts=ipFwAccNrDstPorts, ipFwAccTable=ipFwAccTable, PYSNMP_MODULE_ID=ucdIpFwAccMIB, ipFwAccDstAddr=ipFwAccDstAddr, ipFwAccProto=ipFwAccProto, ipFwAccViaName=ipFwAccViaName, ipFwAccSrcIsRange=ipFwAccSrcIsRange, ipFwAccDir=ipFwAccDir, ipFwAccViaAddr=ipFwAccViaAddr, ipFwAccPort1=ipFwAccPort1, ipFwAccBytes=ipFwAccBytes, ipFwAccSrcAddr=ipFwAccSrcAddr, ipFwAccBidir=ipFwAccBidir, ipFwAccPort2=ipFwAccPort2, ipFwAccEntry=ipFwAccEntry, ipFwAccPort7=ipFwAccPort7, ipFwAccDstIsRange=ipFwAccDstIsRange, ipFwAccPort4=ipFwAccPort4, ipFwAccPort6=ipFwAccPort6, ipFwAccPackets=ipFwAccPackets, ipFwAccPort8=ipFwAccPort8, ipFwAccIndex=ipFwAccIndex, ipFwAccPort5=ipFwAccPort5, ipFwAccSrcNetMask=ipFwAccSrcNetMask, ucdIpFwAccMIB=ucdIpFwAccMIB, ipFwAccNrSrcPorts=ipFwAccNrSrcPorts, ipFwAccPort10=ipFwAccPort10, ipFwAccDstNetMask=ipFwAccDstNetMask)
