#
# PySNMP MIB module PNNI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/PNNI-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 17:04:53 2022
# On host fv-az39-968 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
AtmTrafficDescrParamIndex, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmTrafficDescrParamIndex")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter64, Bits, NotificationType, ObjectIdentity, IpAddress, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, zeroDotZero, Gauge32, Counter32, Unsigned32, MibIdentifier, enterprises, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Bits", "NotificationType", "ObjectIdentity", "IpAddress", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "zeroDotZero", "Gauge32", "Counter32", "Unsigned32", "MibIdentifier", "enterprises", "Integer32", "iso")
RowStatus, DisplayString, TruthValue, TimeStamp, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TruthValue", "TimeStamp", "TextualConvention")
pnniMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 4, 1))
pnniMIB.setRevisions(('2002-04-24 00:00', '1997-03-01 00:00', '1996-02-27 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pnniMIB.setRevisionsDescriptions(('Removed Following TEXTUAL CONVENTION  definitions:\n                     Unsigned32\n                     zeroDotZero.\n\n             Importing Following from SNMPv2-SMI.\n                     Unsigned32\n                     zeroDotZero.', 'Updated version of the PNNI MIB released with the PNNI\n             V1.0 Errata and PICS (af-pnni-81.00).', 'Initial version of the MIB for monitoring and controlling\n             PNNI routing.',))
if mibBuilder.loadTexts: pnniMIB.setLastUpdated('200204240000Z')
if mibBuilder.loadTexts: pnniMIB.setOrganization('The ATM Forum')
if mibBuilder.loadTexts: pnniMIB.setContactInfo('The ATM Forum\n             2570 West El Camino Real, Suite 304\n             Mountain View, CA 94040-1313 USA\n             Phone: +1 415-949-6700\n             Fax:   +1 415-949-6705\n             info@atmforum.com')
if mibBuilder.loadTexts: pnniMIB.setDescription('The MIB module for managing ATM Forum PNNI routing.')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfPnni = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4))
pnniMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1))
class PnniAtmAddr(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.2'
    description = 'The ATM address used by the network entity.  The address\n             types are: no address (0 octets), and NSAP (20 octets).'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class PnniNodeIndex(TextualConvention, Integer32):
    description = 'An index that identifies a logical PNNI entity within the\n             managed system.\n\n             The distinguished value zero indicates the null instance or\n             no instance in the PnniNodeCfgParentNodeIndex.  In all\n             other cases, the distinguished value zero indicates a\n             logical entity within the switching system that manages\n             routes only over non-PNNI interfaces.\n\n             By default, only the node identified by node index one is\n             created, and all PNNI interfaces are associated with that\n             node.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class PnniNodeId(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.3'
    description = 'A PNNI node ID - this is used to identify the logical PNNI\n             node.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(22, 22)
    fixedLength = 22

class PnniPortId(TextualConvention, Unsigned32):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.4'
    description = 'A PNNI port ID - this is used to identify a point of\n             attachment of a logical link to a given logical node.\n\n             The values 0 and 0xffffffff have special meanings in\n             certain contexts and do not identify a specific port.\n\n             The distinguished value 0 indicates that no port is\n             specified.'
    status = 'current'

class PnniAggrToken(TextualConvention, Unsigned32):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.5'
    description = 'A PNNI aggregation token - this is used to determine which\n             links to a given neighbor node are to be aggregated and\n             advertised as a single logical link.'
    status = 'current'

class PnniPeerGroupId(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.2'
    description = 'A PNNI peer group ID.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(14, 14)
    fixedLength = 14

class PnniLevel(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.1'
    description = 'A PNNI routing level indicator.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 104)

class PnniSvccRccIndex(TextualConvention, Integer32):
    description = 'The value of this object identifies the SVCC-based RCC for\n             which the entry contains management information.'
    status = 'current'

class AtmAddrPrefix(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.2'
    description = 'A prefix of one or more ATM End System Addresses.  The\n             significant portion of a prefix is padded with zeros on the\n             right to fill 19 octets.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(19, 19)
    fixedLength = 19

class PnniPrefixLength(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.2'
    description = 'The number of bits that are significant in an ATM address\n             prefix used by PNNI.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 152)

class PnniMetricsTag(TextualConvention, Integer32):
    description = 'An index into the pnniMetricsTable.  The suffix tag is used\n             to indicate that there may be many related entries in the\n             table further discriminated by other index terms.  The\n             distinguished value zero indicates that no metrics are\n             associated with the described entity.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class ServiceCategory(TextualConvention, Integer32):
    reference = 'ATM Forum Traffic Management 4.0 Section 2'
    description = 'Indicates the service category.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("other", 1), ("cbr", 2), ("rtVbr", 3), ("nrtVbr", 4), ("abr", 5), ("ubr", 6))

class ClpType(TextualConvention, Integer32):
    description = 'Indicates the CLP type of a traffic stream.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("clpEqual0", 1), ("clpEqual0Or1", 2))

class TnsType(TextualConvention, Integer32):
    reference = 'ATM Forum UNI Signalling 4.0 Section 2 4.5.22/Q.2931'
    description = 'Indicates the type of network identification of a\n             specified transit network.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 8))
    namedValues = NamedValues(("nationalNetworkIdentification", 2), ("other", 8))

class TnsPlan(TextualConvention, Integer32):
    reference = 'ATM Forum UNI Signalling 4.0 Section 2 4.5.22/Q.2931'
    description = 'Indicates the network identification plan of a\n             specified transit network.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 16))
    namedValues = NamedValues(("carrierIdentificationCode", 1), ("other", 16))

class PnniVersion(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.6.1'
    description = 'Indicates a version of the PNNI protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("unsupported", 1), ("version1point0", 2))

class PnniHelloState(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.6.2.1.2'
    description = 'The state of an instance of the PNNI Hello State machine.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("notApplicable", 1), ("down", 2), ("attempt", 3), ("oneWayInside", 4), ("twoWayInside", 5), ("oneWayOutside", 6), ("twoWayOutside", 7), ("commonOutside", 8))

pnniBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1))
pnniHighestVersion = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 1), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniHighestVersion.setReference('ATM Forum PNNI 1.0 Section 5.6.1')
if mibBuilder.loadTexts: pnniHighestVersion.setStatus('current')
if mibBuilder.loadTexts: pnniHighestVersion.setDescription('The highest version of the PNNI protocol that the\n             software in this switching system is capable of executing.')
pnniLowestVersion = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 2), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLowestVersion.setReference('ATM Forum PNNI 1.0 Section 5.6.1')
if mibBuilder.loadTexts: pnniLowestVersion.setStatus('current')
if mibBuilder.loadTexts: pnniLowestVersion.setDescription('The lowest version of the PNNI Protocol that the\n             software in this switching system is capable of executing.')
pnniDtlCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniDtlCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniDtlCountOriginator.setDescription('The total number of DTL stacks that this switching system\n             has originated as the DTLOriginator and placed into\n             signalling messages. This includes the initial DTL stacks\n             computed by this system as well as any alternate route\n             (second, third choice etc.) DTL stacks computed by this\n             switching system in response to crankbacks.')
pnniDtlCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniDtlCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniDtlCountBorder.setDescription('The number of partial DTL stacks that this switching system\n             has added into signalling messages as an entry border node.\n             This includes the initial partial DTL stacks computed by\n             this system as well as any alternate route (second, third\n             choice etc.) partial DTL stacks computed by this switching\n             system in response to crankbacks.')
pnniCrankbackCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniCrankbackCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniCrankbackCountOriginator.setDescription('The count of the total number of connection setup messages\n             including DTL stacks originated by this switching system\n             that have cranked back to this switching system at all\n             levels of the hierarchy.')
pnniCrankbackCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniCrankbackCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniCrankbackCountBorder.setDescription('The count of the total number of connection setup messages\n             including DTLs added by this switching system as an entry\n             border node that have cranked back to this switching system\n             at all levels of the hierarchy. This count does not include\n             Crankbacks for which this switching system was not the\n             crankback destination, only those crankbacks that were\n             directed to this switching system are counted here.')
pnniAltRouteCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniAltRouteCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniAltRouteCountOriginator.setDescription('The total number of alternate DTL stacks that this\n             switching system has computed and placed into\n             signalling messages as the DTLOriginator.')
pnniAltRouteCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniAltRouteCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniAltRouteCountBorder.setDescription('The total number of alternate partial DTL stacks that this\n             switching system has computed and placed into signalling\n             messages as an entry border node.')
pnniRouteFailCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailCountOriginator.setDescription('The total number of times where the switching system failed\n             to compute a viable DTL stack as the DTLOriginator for some\n             call.  It indicates the number of times a call was cleared\n             from this switching system due to originator routing\n             failure.')
pnniRouteFailCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailCountBorder.setDescription('The total number of times where the switching system failed\n             to compute a viable partial DTL stack as an entry border\n             node for some call.  It indicates the number of times a\n             call was either cleared or cranked back from this switching\n             system due to border routing failure.')
pnniRouteFailUnreachableOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailUnreachableOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailUnreachableOriginator.setDescription("The total number of times where the switching system failed\n             to compute a viable DTL stack as the DTLOriginator because\n             the destination was unreachable, i.e., those calls that are\n             cleared with cause #2 `specified transit network\n             unreachable' or cause #3 `destination unreachable' in the\n             cause IE.")
pnniRouteFailUnreachableBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailUnreachableBorder.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailUnreachableBorder.setDescription("The total number of times where the switching system failed\n             to compute a viable partial DTL stack as an entry border\n             node because the target of the path calculation was\n             unreachable, i.e., those calls that are cleared or cranked\n             back with cause #2 `specified transit network unreachable'\n             or cause #3 `destination unreachable' in the cause IE.")
pnniNodeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2), )
if mibBuilder.loadTexts: pnniNodeTable.setReference('ATM Forum PNNI 1.0 Annex F')
if mibBuilder.loadTexts: pnniNodeTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTable.setDescription('The pnniNodeTable collects attributes that affect the\n             operation of a PNNI logical node.\n\n             There is a single row in this table for each PNNI peer\n             group that the managed system is expected or eligible\n             to become a member of.')
pnniNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"))
if mibBuilder.loadTexts: pnniNodeEntry.setReference('ATM Forum PNNI 1.0 Annex F')
if mibBuilder.loadTexts: pnniNodeEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodeEntry.setDescription('An entry in the table, containing information about a PNNI\n             logical node in this switching system.')
pnniNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 1), PnniNodeIndex())
if mibBuilder.loadTexts: pnniNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNodeIndex.setDescription('A value assigned to a node in this switching system that\n             uniquely identifies it in the MIB.')
pnniNodeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 2), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeLevel.setReference('ATM Forum PNNI 1.0 Section 5.3.1, Annex F')
if mibBuilder.loadTexts: pnniNodeLevel.setStatus('current')
if mibBuilder.loadTexts: pnniNodeLevel.setDescription('The level of PNNI hierarchy at which this node exists. This\n             attribute is used to determine the default node ID and the\n             default peer group ID for this node. This object may only\n             be written when pnniNodeAdminStatus has the value down.')
pnniNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 3), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeId.setReference('ATM Forum PNNI 1.0 Section 5.3.3, Annex F')
if mibBuilder.loadTexts: pnniNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniNodeId.setDescription('The value the switching system is using to represent\n             itself as this node. This object may only be written when\n             pnniNodeAdminStatus has the value down.\n\n             If pnniNodeLowest is true, then the default node ID takes\n             the form defined in Section 5.3.3 for lowest level nodes,\n             with the first octet equal to pnniNodeLevel, the second\n             octet equal to 160, and the last 20 octets equal to\n             pnniNodeAtmAddress.\n\n             If pnniNodeLowest is false, then the default\n             node ID takes the form defined in Section 5.3.3 for logical\n             group nodes, with the first octet equal to pnniNodeLevel,\n             the next fourteen octets equal to the value of\n             pnniNodePeerGroupId for the child node whose election as\n             PGL causes this LGN to be instantiated, the next six octets\n             equal to the ESI of pnniNodeAtmAddress, and the last octet\n             equal to zero.')
pnniNodeLowest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 4), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeLowest.setStatus('current')
if mibBuilder.loadTexts: pnniNodeLowest.setDescription("Indicates whether this node acts as a lowest level node or\n             whether this node is a logical group node that becomes\n             active when one of the other nodes in this switching system\n             becomes a peer group leader.  The value 'false' must not be\n             used with nodes that are not PGL/LGN capable.\n\n             This object may only be\n             written when pnniNodeAdminStatus has the value down.")
pnniNodeAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAdminStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAdminStatus.setDescription('Indicates whether the administrative status of the node is\n             up (the node is allowed to become active) or down (the node\n             is forced to be inactive).\n\n             When pnniNodeAdminStatus is down, then pnniNodeOperStatus\n             must also be down.')
pnniNodeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeOperStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNodeOperStatus.setDescription('Indicates whether the node is active or whether the node\n             has yet to become operational.  When the value is down, all\n             state has been cleared from the node and the node is not\n             communicating with any of its neighbor nodes.')
pnniNodeDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 7), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeDomainName.setStatus('current')
if mibBuilder.loadTexts: pnniNodeDomainName.setDescription('The name of the PNNI routing\n             domain in which this node participates.  All lowest-level\n             PNNI nodes with the same pnniNodeDomainName are presumed to\n             be connected.')
pnniNodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 8), PnniAtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAtmAddress.setReference('ATM Forum PNNI 1.0 Section 5.2.2')
if mibBuilder.loadTexts: pnniNodeAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAtmAddress.setDescription("This node's ATM End System Address.  Remote systems wishing\n             to exchange PNNI protocol packets with this node should\n             direct packets or calls to this address.\n\n             This attribute may only be written when pnniNodeAdminStatus\n             has the value down.")
pnniNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 9), PnniPeerGroupId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePeerGroupId.setReference('ATM Forum PNNI 1.0 Section 5.3.2, Annex F')
if mibBuilder.loadTexts: pnniNodePeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniNodePeerGroupId.setDescription('The Peer Group Identifier of the peer group that the given\n             node is to become a member of.\n\n             The default value of this attribute has the first octet\n             equal to pnniNodeLevel, the next pnniNodeLevel bits equal\n             to the pnniNodeLevel bits starting from the third octet of\n             pnniNodeId, and the remainder padded with zeros.\n\n             This object may only be written when pnniNodeAdminStatus\n             has the value down.')
pnniNodeRestrictedTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeRestrictedTransit.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeRestrictedTransit.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRestrictedTransit.setDescription('Specifies whether the node is restricted to not allowing\n             support of SVCs transiting this node.  This attribute\n             determines the setting of the restricted transit bit in the\n             nodal information group originated by this node.')
pnniNodeComplexRep = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeComplexRep.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeComplexRep.setStatus('current')
if mibBuilder.loadTexts: pnniNodeComplexRep.setDescription("Specifies whether this node uses the complex node\n             representation.  A value of `true' indicates that the\n             complex node representation is used, whereas a value of\n             `false' indicates that the simple node representation is\n             used.  This attribute determines the setting of the nodal\n             representation bit in the nodal information group\n             originated by this node.")
pnniNodeRestrictedBranching = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeRestrictedBranching.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeRestrictedBranching.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRestrictedBranching.setDescription("Indicates whether the node is able to support additional\n             point-to-multipoint branches.  A value of 'false' indicates\n             that additional branches can be supported, and a value of\n             'true' indicates that additional branches cannot be\n             supported.  This attribute reflects the setting of the\n             restricted branching bit in the nodal information group\n             originated by this node.")
pnniNodeDatabaseOverload = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeDatabaseOverload.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeDatabaseOverload.setStatus('current')
if mibBuilder.loadTexts: pnniNodeDatabaseOverload.setDescription('Specifies whether the node is currently operating in\n             topology database overload state.  This attribute has the\n             same value as the Non-transit for PGL Election bit in the\n             nodal information group originated by this node.')
pnniNodePtses = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePtses.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtses.setDescription("Gauges the total number of PTSEs currently in this\n             node's topology database(s).")
pnniNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRowStatus.setDescription('To create, delete, activate and de-activate a Node.')
pnniNodePglTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3), )
if mibBuilder.loadTexts: pnniNodePglTable.setReference('ATM Forum PNNI 1.0 Section 5.10.1')
if mibBuilder.loadTexts: pnniNodePglTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglTable.setDescription('Peer group leader election information for a PNNI node in\n             this switching system.')
pnniNodePglEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1), )
if mibBuilder.loadTexts: pnniNodePglEntry.setReference('ATM Forum PNNI 1.0 Section 5.10.1')
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniNodePglEntry"))
pnniNodePglEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniNodePglEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglEntry.setDescription('An entry in the table, containing PGL election information\n             of a PNNI logical node in this switching system.')
pnniNodePglLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 205))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglLeadershipPriority.setReference('ATM Forum PNNI 1.0 Section 5.10.1.2')
if mibBuilder.loadTexts: pnniNodePglLeadershipPriority.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglLeadershipPriority.setDescription('The Leadership priority value this node should advertise in\n             its nodal information group for the given peer group.  Only\n             the value zero can be used with nodes that are not PGL/LGN\n             capable.  If there is no configured parent node index or no\n             corresponding entry in the pnniNodeTable, then the\n             advertised leadership priority is zero regardless of this\n             value.')
pnniNodeCfgParentNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 2), PnniNodeIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeCfgParentNodeIndex.setReference('ATM Forum PNNI 1.0 Annex F')
if mibBuilder.loadTexts: pnniNodeCfgParentNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNodeCfgParentNodeIndex.setDescription('The local node index used to identify the node that will\n             represent this peer group at the next higher level of\n             hierarchy, if this node becomes peer group leader.  The\n             value 0 indicates that there is no parent node.')
pnniNodePglInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 3), Integer32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglInitTime.setReference('ATM Forum PNNI 1.0 Annex G PGLInitTime')
if mibBuilder.loadTexts: pnniNodePglInitTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglInitTime.setDescription('The amount of time in seconds this node will delay\n             advertising its choice of preferred PGL after having\n             initialized operation and reached the full state with at\n             least one neighbor in the peer group.')
pnniNodePglOverrideDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 4), Integer32().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglOverrideDelay.setReference('ATM Forum PNNI 1.0 Annex G OverrideDelay')
if mibBuilder.loadTexts: pnniNodePglOverrideDelay.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglOverrideDelay.setDescription('The amount of time in seconds a node will wait for itself\n             to be declared the preferred PGL by unanimous agreement\n             among its peers.  In the absence of unanimous agreement\n             this will be the amount of time that will pass before this\n             node considers a two thirds majority as sufficient\n             agreement to declare itself peer group leader, abandoning\n             the attempt to get unanimous agreement.')
pnniNodePglReelectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 5), Integer32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglReelectTime.setReference('ATM Forum PNNI 1.0 Annex G ReElectionInterval')
if mibBuilder.loadTexts: pnniNodePglReelectTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglReelectTime.setDescription('The amount of time in seconds after losing connectivity to\n             the current peer group leader, that this node will wait\n             before re-starting the process of electing a new peer group\n             leader.')
pnniNodePglState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("starting", 1), ("awaiting", 2), ("awaitingFull", 3), ("initialDelay", 4), ("calculating", 5), ("awaitUnanimity", 6), ("operPgl", 7), ("operNotPgl", 8), ("hungElection", 9), ("awaitReElection", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePglState.setReference('ATM Forum PNNI 1.0 Section 5.10.1.1.2')
if mibBuilder.loadTexts: pnniNodePglState.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglState.setDescription("Indicates the state that this node is in with respect to\n             the Peer Group Leader election that takes place in the\n             node's peer group. The values are enumerated in the Peer\n             Group Leader State Machine.")
pnniNodePreferredPgl = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 7), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePreferredPgl.setReference('ATM Forum PNNI 1.0 Section 5.10.1.1.6')
if mibBuilder.loadTexts: pnniNodePreferredPgl.setStatus('current')
if mibBuilder.loadTexts: pnniNodePreferredPgl.setDescription("The Node ID of\n             the node which the local node believes should be or become\n             the peer group leader.  This is also the value the local\n             node is currently advertising in the `Preferred Peer Group\n             Leader Node ID' field of its nodal information group within\n             the given peer group.  If a Preferred PGL has not been\n             chosen, this attribute's value is set to (all) zero(s).")
pnniNodePeerGroupLeader = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 8), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePeerGroupLeader.setStatus('current')
if mibBuilder.loadTexts: pnniNodePeerGroupLeader.setDescription("The Node Identifier of the node which is currently\n             operating as peer group leader of the peer group this node\n             belongs to. If a PGL has not been elected, this attribute's\n             value is set to (all) zero(s).")
pnniNodePglTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePglTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglTimeStamp.setDescription('The time at which the current Peer Group Leader established\n             itself.')
pnniNodeActiveParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 10), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeActiveParentNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniNodeActiveParentNodeId.setDescription('The Node Identifier value being used by the Peer Group\n             Leader to represent this peer group at the next higher\n             level of the hierarchy. If this node is at the highest\n             level of the hierarchy or if no PGL has yet been elected\n             the PNNI Protocol Entity sets the value of this attribute\n             to (all) zero(s).')
pnniNodeTimerTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4), )
if mibBuilder.loadTexts: pnniNodeTimerTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerTable.setDescription('A table of initial PNNI timer values and significant\n             change thresholds.')
pnniNodeTimerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1), )
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniNodeTimerEntry"))
pnniNodeTimerEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniNodeTimerEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerEntry.setDescription('An entry in the table, containing initial PNNI timer values\n             and significant change thresholds of a PNNI logical node in\n             this switching system.')
pnniNodePtseHolddown = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 1), Integer32().clone(10)).setUnits('100 milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePtseHolddown.setReference('ATM Forum PNNI 1.0 Annex G MinPTSEInterval')
if mibBuilder.loadTexts: pnniNodePtseHolddown.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtseHolddown.setDescription('The initial value for the PTSE hold down timer that will be\n             used by the given node to limit the rate at which it can\n             re-originate PTSEs. It must be a positive non-zero number.')
pnniNodeHelloHolddown = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 2), Integer32().clone(10)).setUnits('100 milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHelloHolddown.setReference('ATM Forum PNNI 1.0 Annex G MinHelloInterval')
if mibBuilder.loadTexts: pnniNodeHelloHolddown.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHelloHolddown.setDescription('The initial value for the Hello hold down timer that will\n             be used by the given node to limit the rate at which it\n             sends Hellos. It must be a positive non-zero number.')
pnniNodeHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 3), Integer32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHelloInterval.setReference('ATM Forum PNNI 1.0 Annex G HelloInterval')
if mibBuilder.loadTexts: pnniNodeHelloInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHelloInterval.setDescription('The initial value for the Hello Timer.\n             In the absence of triggered Hellos, this node will send one\n             Hello packet on each of its ports on this interval.')
pnniNodeHelloInactivityFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 4), Integer32().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHelloInactivityFactor.setReference('ATM Forum PNNI 1.0 Annex G InactivityFactor')
if mibBuilder.loadTexts: pnniNodeHelloInactivityFactor.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHelloInactivityFactor.setDescription('The value for the Hello Inactivity factor that this\n             node will use to determine when a neighbor has gone down.')
pnniNodeHlinkInact = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 5), Integer32().clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHlinkInact.setReference('ATM Forum PNNI 1.0 Annex G HorizontalLinkInactivityTime')
if mibBuilder.loadTexts: pnniNodeHlinkInact.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHlinkInact.setDescription('The amount of time a node will continue to\n             advertise a horizontal (logical) link for which it has\n             not received and processed a LGN Horizontal Link\n             information group.')
pnniNodePtseRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 6), Integer32().clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePtseRefreshInterval.setReference('ATM Forum PNNI 1.0 Annex G PTSERefreshInterval')
if mibBuilder.loadTexts: pnniNodePtseRefreshInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtseRefreshInterval.setDescription('The initial value for the Refresh timer that this node will\n             use to drive (re-)origination of PTSEs in the absence of\n             triggered updates.')
pnniNodePtseLifetimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(101, 1000)).clone(200)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePtseLifetimeFactor.setReference('ATM Forum PNNI 1.0 Annex G PTSELifetimeFactor')
if mibBuilder.loadTexts: pnniNodePtseLifetimeFactor.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtseLifetimeFactor.setDescription('The value for the lifetime multiplier, expressed as a\n             percentage.  The result of multiplying the\n             pnniNodePtseRefreshInterval attribute value by this\n             attribute value is used as the initial lifetime that this\n             node places into self-originated PTSEs.')
pnniNodeRxmtInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 8), Integer32().clone(5)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeRxmtInterval.setReference('ATM Forum PNNI 1.0 Annex G DSRxmtInterval,\n             RequestRxmtInterval, PTSERetransmissionInterval')
if mibBuilder.loadTexts: pnniNodeRxmtInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRxmtInterval.setDescription('The period between retransmissions of unacknowledged\n             Database Summary packets, PTSE Request packets, and PTSPs.')
pnniNodePeerDelayedAckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 9), Integer32().clone(10)).setUnits('100 milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePeerDelayedAckInterval.setReference('ATM Forum PNNI 1.0 Annex G PeerDelayedAckInterval,\n             Appendix G')
if mibBuilder.loadTexts: pnniNodePeerDelayedAckInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodePeerDelayedAckInterval.setDescription('The minimum amount of time between transmissions of\n             delayed PTSE acknowledgement packets.')
pnniNodeAvcrPm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAvcrPm.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.4, Annex G AvCR_PM')
if mibBuilder.loadTexts: pnniNodeAvcrPm.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAvcrPm.setDescription('The proportional multiplier used in the algorithms that\n             determine significant change for AvCR parameters, expressed\n             as a percentage.')
pnniNodeAvcrMt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(3)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAvcrMt.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.4, Annex G AvCR_mT')
if mibBuilder.loadTexts: pnniNodeAvcrMt.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAvcrMt.setDescription('The minimum threshold used in the algorithms that determine\n             significant change for AvCR parameters, expressed as a\n             percentage.')
pnniNodeCdvPm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(25)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeCdvPm.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.6, Annex G CDV_PM')
if mibBuilder.loadTexts: pnniNodeCdvPm.setStatus('current')
if mibBuilder.loadTexts: pnniNodeCdvPm.setDescription('The proportional multiplier used in the algorithms that\n             determine significant change for CDV metrics, expressed as\n             a percentage.')
pnniNodeCtdPm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeCtdPm.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.5, Annex G maxCTD_PM')
if mibBuilder.loadTexts: pnniNodeCtdPm.setStatus('current')
if mibBuilder.loadTexts: pnniNodeCtdPm.setDescription('The proportional multiplier used in the algorithms that\n             determine significant change for CTD metrics, expressed as\n             a percentage.')
pnniNodeSvccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5), )
if mibBuilder.loadTexts: pnniNodeSvccTable.setReference('ATM Forum PNNI 1.0 Section 5.5')
if mibBuilder.loadTexts: pnniNodeSvccTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccTable.setDescription('A table of variables related to SVCC-based routing control\n             channels.')
pnniNodeSvccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1), )
if mibBuilder.loadTexts: pnniNodeSvccEntry.setReference('ATM Forum PNNI 1.0 Section 5.5')
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniNodeSvccEntry"))
pnniNodeSvccEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniNodeSvccEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccEntry.setDescription('An entry in the table, containing SVCC-based RCC variables\n             of a PNNI logical node in this switching system.')
pnniNodeSvccInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 1), Integer32().clone(4)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccInitTime.setReference('ATM Forum PNNI 1.0 Annex G InitialLGNSVCTimeout')
if mibBuilder.loadTexts: pnniNodeSvccInitTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccInitTime.setDescription('The amount of time this node will delay initiating\n             establishment of an SVCC to a neighbor with a numerically\n             lower ATM address, after determining that such an SVCC\n             should be established.')
pnniNodeSvccRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 2), Integer32().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccRetryTime.setReference('ATM Forum PNNI 1.0 Annex G RetryLGNSVCTimeout')
if mibBuilder.loadTexts: pnniNodeSvccRetryTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccRetryTime.setDescription('The amount of time this node will delay after an apparently\n             still necessary and viable SVCC-based RCC is unexpectedly\n             torn down, before attempting to re-establish it.')
pnniNodeSvccCallingIntegrityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 3), Integer32().clone(35)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccCallingIntegrityTime.setReference('ATM Forum PNNI 1.0 Annex G SVCCallingIntegrityTime')
if mibBuilder.loadTexts: pnniNodeSvccCallingIntegrityTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccCallingIntegrityTime.setDescription('The amount of time this node will wait for an SVCC, which\n             it has initiated establishment of as the calling party, to\n             become fully established before giving up and tearing it\n             down.')
pnniNodeSvccCalledIntegrityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 4), Integer32().clone(50)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccCalledIntegrityTime.setReference('ATM Forum PNNI 1.0 Annex G SVCCalledIntegrityTime')
if mibBuilder.loadTexts: pnniNodeSvccCalledIntegrityTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccCalledIntegrityTime.setDescription('The amount of time this node will wait for an SVCC, which\n             it has decided to accept as the called party, to become\n             fully established before giving up and tearing it down.')
pnniNodeSvccTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 5), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccTrafficDescriptorIndex.setReference('ATM Forum PNNI 1.0 Section 5.5.2, Annex G\n             RCCMaximumBurstSize, RCCPeakCellRate,\n             RCCSustainableCellRate')
if mibBuilder.loadTexts: pnniNodeSvccTrafficDescriptorIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccTrafficDescriptorIndex.setDescription('An index into the atmTrafficDescrParamTable defined in\n             RFC 1695.  This traffic descriptor is used when\n             establishing switched virtual channels for use as\n             SVCC-based RCCs to/from PNNI logical group nodes.')
pnniScopeMappingTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6), )
if mibBuilder.loadTexts: pnniScopeMappingTable.setReference('ATM Forum PNNI 1.0 Section 5.3.6')
if mibBuilder.loadTexts: pnniScopeMappingTable.setStatus('current')
if mibBuilder.loadTexts: pnniScopeMappingTable.setDescription('The pnniScopeTable contains the mappings of membership and\n             connection scope from organizational scope values (used at\n             UNI interfaces) to PNNI scope (i.e. in terms of PNNI\n             routing level indicators).')
pnniScopeMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1), )
if mibBuilder.loadTexts: pnniScopeMappingEntry.setReference('ATM Forum PNNI 1.0 Section 5.3.6')
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniScopeMappingEntry"))
pnniScopeMappingEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniScopeMappingEntry.setStatus('current')
if mibBuilder.loadTexts: pnniScopeMappingEntry.setDescription('An entry in the table, containing scope mapping information\n             for a PNNI logical node in this switching system.')
pnniScopeLocalNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 1), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeLocalNetwork.setStatus('current')
if mibBuilder.loadTexts: pnniScopeLocalNetwork.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value localNetwork(1).')
pnniScopeLocalNetworkPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 2), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value localNetworkPlusOne(2).')
pnniScopeLocalNetworkPlusTwo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 3), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusTwo.setStatus('current')
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusTwo.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value localNetworkPlusTwo(3).')
pnniScopeSiteMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 4), PnniLevel().clone(80)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeSiteMinusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeSiteMinusOne.setDescription('The highest level of PNNI hierarchy  (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value siteMinusOne(4).')
pnniScopeIntraSite = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 5), PnniLevel().clone(80)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeIntraSite.setStatus('current')
if mibBuilder.loadTexts: pnniScopeIntraSite.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value intraSite(5).')
pnniScopeSitePlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 6), PnniLevel().clone(72)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeSitePlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeSitePlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value sitePlusOne(6).')
pnniScopeOrganizationMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 7), PnniLevel().clone(72)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeOrganizationMinusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeOrganizationMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value organizationMinusOne(7).')
pnniScopeIntraOrganization = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 8), PnniLevel().clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeIntraOrganization.setStatus('current')
if mibBuilder.loadTexts: pnniScopeIntraOrganization.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value intraOrganization(8).')
pnniScopeOrganizationPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 9), PnniLevel().clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeOrganizationPlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeOrganizationPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value organizationPlusOne(9).')
pnniScopeCommunityMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 10), PnniLevel().clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeCommunityMinusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeCommunityMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value communityMinusOne(10).')
pnniScopeIntraCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 11), PnniLevel().clone(48)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeIntraCommunity.setStatus('current')
if mibBuilder.loadTexts: pnniScopeIntraCommunity.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value intraCommunity(11).')
pnniScopeCommunityPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 12), PnniLevel().clone(48)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeCommunityPlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeCommunityPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value communityPlusOne(12).')
pnniScopeRegional = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 13), PnniLevel().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeRegional.setStatus('current')
if mibBuilder.loadTexts: pnniScopeRegional.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value regional(13).')
pnniScopeInterRegional = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 14), PnniLevel().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeInterRegional.setStatus('current')
if mibBuilder.loadTexts: pnniScopeInterRegional.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value interRegional(14).')
pnniScopeGlobal = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 15), PnniLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeGlobal.setStatus('current')
if mibBuilder.loadTexts: pnniScopeGlobal.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI\n             routing level) that lies within the organizational scope\n             value global(15).')
pnniSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7), )
if mibBuilder.loadTexts: pnniSummaryTable.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryTable.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryTable.setDescription('A list of the summary address prefixes that may be\n             advertised by the specified logical PNNI entity.')
pnniSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniSummaryAddress"), (0, "PNNI-MIB", "pnniSummaryPrefixLength"))
if mibBuilder.loadTexts: pnniSummaryEntry.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryEntry.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryEntry.setDescription('An entry in the table, containing summary address prefix\n             information in this switching system.')
pnniSummaryAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 1), AtmAddrPrefix())
if mibBuilder.loadTexts: pnniSummaryAddress.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryAddress.setDescription('The ATM End System Address prefix for the summary.')
pnniSummaryPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 2), PnniPrefixLength())
if mibBuilder.loadTexts: pnniSummaryPrefixLength.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryPrefixLength.setDescription('The prefix length for the summary.')
pnniSummaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("exterior", 2))).clone('internal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryType.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryType.setDescription('The type (e.g. internal or exterior) of summary being\n                        described.')
pnniSummarySuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummarySuppress.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummarySuppress.setDescription("Determines what is done with addresses that are being\n             summarized by the instance. The default value (e.g. false)\n             will indicate that the summary should propagate into the\n             peer group. Network Management will be able to set the\n             value of this attribute to `suppress' (e.g. true), which\n             suppresses the summary and any reachable addresses it\n             summarizes from being advertised into the peer group.")
pnniSummaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertising", 1), ("suppressing", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSummaryState.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryState.setDescription('Indicates whether the summary is currently being advertised\n             by the node within the local switching system into its peer\n             group.')
pnniSummaryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryRowStatus.setDescription('To create, delete, activate and de-activate a summary.')
pnniSummaryAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20), )
if mibBuilder.loadTexts: pnniSummaryAddressTable.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryAddressTable.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressTable.setDescription('A list of the summary address prefixes that may be \n             advertised by the specified logical PNNI entity.')
pnniSummaryAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniSummaryAddressType"), (0, "PNNI-MIB", "pnniSummaryAddressAddress"), (0, "PNNI-MIB", "pnniSummaryAddressPrefixLength"))
if mibBuilder.loadTexts: pnniSummaryAddressEntry.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryAddressEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressEntry.setDescription('An entry in the table, containing summary address prefix\n             information in this switching system.')
pnniSummaryAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("exterior", 2))))
if mibBuilder.loadTexts: pnniSummaryAddressType.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressType.setDescription('The type (e.g. internal or exterior) of summary being\n                        described.')
pnniSummaryAddressAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 2), AtmAddrPrefix())
if mibBuilder.loadTexts: pnniSummaryAddressAddress.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressAddress.setDescription('The ATM End System Address prefix for the summary.')
pnniSummaryAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 3), PnniPrefixLength())
if mibBuilder.loadTexts: pnniSummaryAddressPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressPrefixLength.setDescription('The prefix length for the summary.')
pnniSummaryAddressSuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryAddressSuppress.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressSuppress.setDescription("Determines what is done with addresses that are being\n             summarized by the instance. The default value (e.g. false)\n             will indicate that the summary should propagate into the\n             peer group. Network Management will be able to set the\n             value of this attribute to `suppress' (e.g. true), which\n             suppresses the summary and any reachable addresses it\n             summarizes from being advertised into the peer group.")
pnniSummaryAddressState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertising", 1), ("suppressing", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSummaryAddressState.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressState.setDescription('Indicates whether the summary is currently being advertised\n             by the node within the local switching system into its peer\n             group.')
pnniSummaryAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressRowStatus.setDescription('To create, delete, activate and de-activate a summary.')
pnniIfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8), )
if mibBuilder.loadTexts: pnniIfTable.setStatus('current')
if mibBuilder.loadTexts: pnniIfTable.setDescription("The pnniIfTable contains the attributes necessary to\n             configure a physical interface on a switching system which\n             is capable of being used for PNNI routing.  Interfaces may\n             represent physical connection points (i.e. copper/fiber\n             connection points) or VPCs which have been configured for\n             PNNI's use.  Each interface is attached to a specific\n             lowest-level node within the switching system.\n\n             An ifIndex is used as the instance ID to uniquely identify\n             the interface on the local switching system. This index has\n             the same value as the ifIndex object defined in RFC 1573\n             for the same interface, since this table correlates with\n             the ifTable in RFC 1573.\n\n             One row in this table is created by the managed system for\n             each row in the ifTable that has an ifType of atm(37) or\n             atmLogical(80).")
pnniIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pnniIfEntry.setStatus('current')
if mibBuilder.loadTexts: pnniIfEntry.setDescription('An entry in the table, containing PNNI specific interface\n             information in this switching system.')
pnniIfNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 1), PnniNodeIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniIfNodeIndex.setDescription('Identifies the node within the switching system that the\n             interface is directly attached to.  The value zero is not \n             a valid value.')
pnniIfPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 2), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniIfPortId.setReference('ATM Forum PNNI 1.0 Section 5.3.4')
if mibBuilder.loadTexts: pnniIfPortId.setStatus('current')
if mibBuilder.loadTexts: pnniIfPortId.setDescription('The Port Identifier of the port as selected by the PNNI\n             protocol entity for the given interface.  This value has\n             meaning only within the context of the node to which the\n             port is attached.  The distinguished value zero indicates\n             that no PNNI Port Identifier has been assigned for this\n             interface (for example, this value may be used when the\n             interface is not running PNNI).')
pnniIfAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 3), PnniAggrToken()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAggrToken.setReference('ATM Forum PNNI 1.0 Sections 5.3.5, 5.10.3.1')
if mibBuilder.loadTexts: pnniIfAggrToken.setStatus('current')
if mibBuilder.loadTexts: pnniIfAggrToken.setDescription('The configured aggregation token for this interface.  The\n             aggregation token controls what other links the link\n             associated with this interface will be aggregated together\n             with.')
pnniIfVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfVPCapability.setReference('ATM Forum PNNI 1.0 Section 5.14.9.1 Table 5-34')
if mibBuilder.loadTexts: pnniIfVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniIfVPCapability.setDescription("Indicates whether the interface is capable of having VPCs\n             established within it or not.\n\n             This object may only have the value `true' for physical ATM\n             interfaces, i.e. those with an ifType of atm(37).")
pnniIfAdmWeightCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightCbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightCbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightCbr.setDescription('The administrative weight of this interface for the\n             constant bit rate service category.')
pnniIfAdmWeightRtVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightRtVbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightRtVbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightRtVbr.setDescription('The administrative weight of this interface for the\n             real-time variable bit rate service category.')
pnniIfAdmWeightNrtVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightNrtVbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightNrtVbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightNrtVbr.setDescription('The administrative weight of this interface for the\n             non-real-time variable bit rate service category.')
pnniIfAdmWeightAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightAbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightAbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightAbr.setDescription('The administrative weight of this interface for the\n             available bit rate service category.')
pnniIfAdmWeightUbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightUbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightUbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightUbr.setDescription('The administrative weight of this interface for the\n             unspecified bit rate service category.')
pnniIfRccServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 10), ServiceCategory()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfRccServiceCategory.setReference('ATM Forum PNNI 1.0 Sections 5.5.2, 5.5.3')
if mibBuilder.loadTexts: pnniIfRccServiceCategory.setStatus('current')
if mibBuilder.loadTexts: pnniIfRccServiceCategory.setDescription('The service category used for the PNNI routing control\n             channel (VCI=18) on this interface.')
pnniIfRccTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 11), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfRccTrafficDescrIndex.setReference('ATM Forum PNNI 1.0 Sections 5.5.2, 5.5.3, Annex G\n             RCCMaximumBurstSize, RCCPeakCellRate,\n             RCCSustainableCellRate')
if mibBuilder.loadTexts: pnniIfRccTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: pnniIfRccTrafficDescrIndex.setDescription('The traffic descriptor index referring to the entry in the\n             atmTrafficDescrParamTable defined in RFC 1695 that\n             specifies the traffic allocation for the PNNI routing\n             control channel (VCI=18) on this interface.')
pnniLinkTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9), )
if mibBuilder.loadTexts: pnniLinkTable.setReference('ATM Forum PNNI 1.0 Section 5.6')
if mibBuilder.loadTexts: pnniLinkTable.setStatus('current')
if mibBuilder.loadTexts: pnniLinkTable.setDescription('This table contains the attributes necessary to describe\n             the operation of logical links attached to the local\n             switching system and the relationship with the neighbor\n             nodes on the other end of the links.  Links are attached to\n             a specific node within the switching system.  A\n             concatenation of the Node Index of the node within the\n             local switching system and the port ID are used as the\n             instance ID to uniquely identify the link.  Links may\n             represent horizontal links between lowest level neighboring\n             peers, outside links, uplinks, or horizontal links to/from\n             LGNs.\n\n             The entire pnniLink object is read-only, reflecting the\n             fact that this information is discovered dynamically by the\n             PNNI protocol rather than configured.')
pnniLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniLinkPortId"))
if mibBuilder.loadTexts: pnniLinkEntry.setReference('ATM Forum PNNI 1.0 Section 5.6')
if mibBuilder.loadTexts: pnniLinkEntry.setStatus('current')
if mibBuilder.loadTexts: pnniLinkEntry.setDescription('An entry in the table, containing information about a link\n             attached to a PNNI logical node in this switching system.')
pnniLinkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 1), PnniPortId())
if mibBuilder.loadTexts: pnniLinkPortId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkPortId.setDescription('The Port Identifier of the link as selected by the local\n             node.  This value has meaning only within the context of\n             the node to which the port is attached.')
pnniLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("lowestLevelHorizontalLink", 2), ("horizontalLinkToFromLgn", 3), ("lowestLevelOutsideLink", 4), ("uplink", 5), ("outsideLinkAndUplink", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkType.setStatus('current')
if mibBuilder.loadTexts: pnniLinkType.setDescription('Indicates the type of link being described.')
pnniLinkVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 3), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkVersion.setStatus('current')
if mibBuilder.loadTexts: pnniLinkVersion.setDescription("For horizontal and outside links between lowest-level nodes\n             and for links of unknown type, this attribute indicates the\n             version of PNNI routing protocol used to exchange\n             information over this link.  If communication with the\n             neighbor node has not yet been established, then the\n             Version is set to `unknown'.  For uplinks (where the\n             port ID is not also used for the underlying outside link)\n             or links to/from LGNs, the Version is set to `unknown'.")
pnniLinkHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 4), PnniHelloState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkHelloState.setReference('ATM Forum PNNI 1.0 Section 5.6.2.1.2')
if mibBuilder.loadTexts: pnniLinkHelloState.setStatus('current')
if mibBuilder.loadTexts: pnniLinkHelloState.setDescription('For horizontal and outside links between lowest-level nodes\n             and for links of unknown type, this attribute indicates the\n             state of the Hello protocol exchange over this link.  For\n             links to/from LGNs, this attribute indicates the state of\n             the corresponding LGN Horizontal Link Hello State Machine.\n             For uplinks (where the port ID is not also used for the\n             underlying outside link), this attribute is set to\n             notApplicable.')
pnniLinkRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 5), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkRemoteNodeId.setDescription("Indicates the node identifier of the remote (neighboring)\n             node on the other end of the link.  If the pnniLinkType is\n             `outside link and uplink', this is the node identifier of\n             the lowest-level neighbor node on the other end of the\n             outside link.  If the remote node ID is unknown or if the\n             pnniLinkType is `uplink', this attribute is set to all\n             zeros.")
pnniLinkRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 6), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkRemotePortId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkRemotePortId.setDescription("Indicates the port identifier of the port at the remote end\n             of the link as assigned by the remote node.  If the\n             pnniLinkType is `outside link and uplink', this is the port\n             identifier assigned by the lowest-level neighbor node to\n             identify the outside link.  If the remote port ID is\n             unknown or if the pnniLinkType is `uplink', this attribute\n             is set to zero.")
pnniLinkDerivedAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 7), PnniAggrToken()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkDerivedAggrToken.setReference('ATM Forum PNNI 1.0 Section 5.10.3.1')
if mibBuilder.loadTexts: pnniLinkDerivedAggrToken.setStatus('current')
if mibBuilder.loadTexts: pnniLinkDerivedAggrToken.setDescription('Indicates the derived aggregation token value used on this\n             link.  For horizontal links between lowest-level nodes and\n             when the link type is not yet known, this attribute takes\n             the value of zero.')
pnniLinkUpnodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 8), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkUpnodeId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkUpnodeId.setDescription("For outside links and uplinks, this attribute contains the\n             Node Identifier of the upnode (the neighbor node's identity\n             at the level of the common peer group).  When the upnode\n             has not yet been identified, this attribute is set to zero.\n             For horizontal links or when the link type is not yet\n             known, this attribute is set to zero.")
pnniLinkUpnodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 9), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkUpnodeAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniLinkUpnodeAtmAddress.setDescription('For outside links and uplinks, this attribute contains the\n             ATM End System Address used to establish connections to the\n             upnode.  When the upnode has not yet been identified, this\n             attribute is set to zero.  For horizontal links or when the\n             link type is not yet known, this attribute is set to zero.')
pnniLinkCommonPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 10), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkCommonPeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkCommonPeerGroupId.setDescription('For outside links and uplinks, this attribute contains the\n             peer group identifier of the lowest level common Peer Group\n             in the ancestry of the neighboring node and the node within\n             the local switching system.  The value of this attribute\n             takes on a value determined by the Hello exchange of\n             hierarchical information that occurs between the two\n             lowest-level border nodes.  When the common peer group has\n             not yet been identified, this attribute is set to zero.\n             For horizontal links or when the link type is not yet\n             known, this attribute is set to all zeros.')
pnniLinkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 11), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniLinkIfIndex.setDescription('For horizontal and outside links between lowest-level nodes\n             and for links of unknown type, this attribute identifies\n             the interface to which the logical link corresponds.\n\n             For all other cases, the value of this object is zero.')
pnniLinkSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 12), PnniSvccRccIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkSvccRccIndex.setStatus('current')
if mibBuilder.loadTexts: pnniLinkSvccRccIndex.setDescription("For horizontal links to/from LGNs, this attribute\n             identifies the SVCC-based RCC used to exchange information\n             with the neighboring peer logical group node.  If the\n             pnniLinkType is not `horizontal link to/from LGN', this\n             attribute shall take the value of zero.")
pnniLinkRcvHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkRcvHellos.setStatus('current')
if mibBuilder.loadTexts: pnniLinkRcvHellos.setDescription("For horizontal and outside links between lowest-level nodes\n             and for links of unknown type, this attribute contains a\n             count of the number of Hello Packets received over this\n             link.  If the pnniLinkType is `horizontal link to/from LGN'\n             or `uplink', this attribute is set to zero.")
pnniLinkXmtHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkXmtHellos.setStatus('current')
if mibBuilder.loadTexts: pnniLinkXmtHellos.setDescription("For horizontal and outside links between lowest-level nodes\n             and for links of unknown type, this attribute contains a\n             count of the number of Hello Packets transmitted over this\n             link.  If the pnniLinkType is `horizontal link to/from LGN'\n             or `uplink', this attribute is set to zero.")
pnniNbrPeerTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10), )
if mibBuilder.loadTexts: pnniNbrPeerTable.setReference('ATM Forum PNNI 1.0 Sections 5.7, 5.8')
if mibBuilder.loadTexts: pnniNbrPeerTable.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerTable.setDescription("The pnniNbrPeer Object contains all the attributes\n             necessary to describe the relationship a node in this\n             switching system has with a neighboring node within the\n             same peer group.  A concatenation of the Node Identifier of\n             the node within the local switching system and the\n             neighboring peer's Node Identifier is used to form the\n             instance ID for this object.\n\n             The entire pnniNbrPeer object is read-only, reflecting the\n             fact that neighboring peers are discovered dynamically by\n             the PNNI protocol rather than configured.")
pnniNbrPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniNbrPeerRemoteNodeId"))
if mibBuilder.loadTexts: pnniNbrPeerEntry.setReference('ATM Forum PNNI 1.0 Sections 5.7, 5.8')
if mibBuilder.loadTexts: pnniNbrPeerEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerEntry.setDescription("An entry in the table, containing information about this\n             node's relationship with a neighboring peer node.")
pnniNbrPeerRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniNbrPeerRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRemoteNodeId.setDescription('The Node Identifier of the neighboring peer node.')
pnniNbrPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("npdown", 1), ("negotiating", 2), ("exchanging", 3), ("loading", 4), ("full", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerState.setReference('ATM Forum PNNI 1.0 Section 5.7.2')
if mibBuilder.loadTexts: pnniNbrPeerState.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerState.setDescription("Indicates the state of this node's Neighboring Peer State\n             Machine associated with pnniNbrPeerRemoteNodeId.")
pnniNbrPeerSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 3), PnniSvccRccIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerSvccRccIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerSvccRccIndex.setDescription('Identifies the SVCC-based RCC being used to communicate\n             with the neighboring peer if one exists.  If both the local\n             node and the neighboring peer node are lowest-level nodes,\n             this attribute is set to zero.')
pnniNbrPeerPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerPortCount.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortCount.setDescription('A count of the total number of ports that connect to the\n             neighboring peer.  If the neighboring peer only\n             communicates via an SVCC-based RCC, the value of this\n             attribute is set to zero.  Otherwise it is set to the total\n             number of ports to the neighboring peer in the Hello state\n             2-WayInside.')
pnniNbrPeerRcvDbSums = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvDbSums.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvDbSums.setDescription('A count of the number of Database Summary Packets received\n             from the neighboring peer.')
pnniNbrPeerXmtDbSums = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtDbSums.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtDbSums.setDescription('A count of the number of Database Summary Packets\n             transmitted to the neighboring peer.')
pnniNbrPeerRcvPtsps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvPtsps.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvPtsps.setDescription('A count of the number of PTSPs received from the\n             neighboring peer.')
pnniNbrPeerXmtPtsps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtPtsps.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtPtsps.setDescription('A count of the number of PTSPs (re)transmitted to the\n             neighboring peer.')
pnniNbrPeerRcvPtseReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseReqs.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseReqs.setDescription('A count of the number of PTSE Request packets received from\n             the neighboring peer.')
pnniNbrPeerXmtPtseReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseReqs.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseReqs.setDescription('A count of the number of PTSE Request packets transmitted\n             to the neighboring peer.')
pnniNbrPeerRcvPtseAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseAcks.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseAcks.setDescription('A count of the number of PTSE Ack packets received from the\n             neighboring peer.')
pnniNbrPeerXmtPtseAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseAcks.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseAcks.setDescription('A count of the number of PTSE Ack packets transmitted to\n             the neighboring peer.')
pnniNbrPeerPortTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11), )
if mibBuilder.loadTexts: pnniNbrPeerPortTable.setReference('ATM Forum PNNI 1.0 Section 5.7.1 Port ID List')
if mibBuilder.loadTexts: pnniNbrPeerPortTable.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortTable.setDescription("A table of all ports in Hello state 2-Way Inside to a given\n             neighboring peer node.  A concatenation of the Node Index\n             of the node within the local switching system, the\n             neighbor's Node Identifier and the Interface Index of the\n             port being described forms the instance ID for this object.\n             This object is only used for lowest-level nodes.")
pnniNbrPeerPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniNbrPeerRemoteNodeId"), (0, "PNNI-MIB", "pnniNbrPeerPortId"))
if mibBuilder.loadTexts: pnniNbrPeerPortEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortEntry.setDescription('An entry in the table, containing information about a port\n             in the Hello state 2-Way Inside from a PNNI logical node in\n             this switching system to a neighboring peer node.')
pnniNbrPeerPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11, 1, 1), PnniPortId())
if mibBuilder.loadTexts: pnniNbrPeerPortId.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortId.setDescription('The port ID of a port to the neighboring peer that is in\n             the Hello state 2-Way Inside.')
pnniNbrPeerPortFloodStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerPortFloodStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortFloodStatus.setDescription('Indicates whether the port is being used for transmission\n             of flooding and database synchronization information to the\n             neighboring peer.')
pnniSvccRccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12), )
if mibBuilder.loadTexts: pnniSvccRccTable.setReference('ATM Forum PNNI 1.0 Sections 5.5.6, 5.6.3.1')
if mibBuilder.loadTexts: pnniSvccRccTable.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccTable.setDescription('A table containing the attributes necessary to analyze the\n             operation of the PNNI protocol on SVCC-based Routing\n             Control Channels. This entire object is read-only,\n             reflecting the fact that SVCC-based RCCs are established\n             dynamically during operation of the PNNI protocol rather\n             than configured.')
pnniSvccRccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniSvccRccIndex"))
if mibBuilder.loadTexts: pnniSvccRccEntry.setReference('ATM Forum PNNI 1.0 Sections 5.5.6, 5.6.3.1')
if mibBuilder.loadTexts: pnniSvccRccEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccEntry.setDescription('An entry in the table, containing information about an\n             SVCC-based RCC from a PNNI logical node in this switching\n             system.')
pnniSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 1), PnniSvccRccIndex())
if mibBuilder.loadTexts: pnniSvccRccIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccIndex.setDescription("An index into the node's tables of SVCC-based RCCs.")
pnniSvccRccVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 2), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccVersion.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccVersion.setDescription('The version of the PNNI routing protocol used to exchange\n             information with the neighbor node.')
pnniSvccRccHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 3), PnniHelloState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccHelloState.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccHelloState.setDescription('The state of the Hello protocol exchange over the\n             SVCC-based RCC.\n\n             Note: the Down state indicates that the SVCC\n             establishment is in progress.')
pnniSvccRccRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 4), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccRemoteNodeId.setDescription('The remote node at which the SVCC-based RCC terminates.')
pnniSvccRccRemoteAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 5), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccRemoteAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccRemoteAtmAddress.setDescription('The ATM End System Address to which SVCC establishment is\n             attempted.')
pnniSvccRccRcvHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccRcvHellos.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccRcvHellos.setDescription('A count of the number of Hello Packets received over this\n             SVCC-based RCC.')
pnniSvccRccXmtHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccXmtHellos.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccXmtHellos.setDescription('A count of the number of Hello Packets transmitted over\n             this SVCC-based RCC.')
pnniSvccRccIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 8), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccIfIndex.setDescription('The interface from which the SVCC-based RCC leaves the\n             switching system.  If the SVCC-based RCC has not yet been\n             established, then this attribute takes the value of zero.')
pnniSvccRccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccVpi.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccVpi.setDescription('The VPI used at the interface from which the SVCC-based RCC\n             leaves the switching system.  If the SVCC-based RCC has not\n             yet been established, then this attribute takes the value\n             of zero ')
pnniSvccRccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccVci.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccVci.setDescription('The VCI used at the interface from which the SVCC-based RCC\n             leaves the switching system.  If the SVCC-based RCC has not\n             yet been established, then this attribute takes the value\n             of zero ')
pnniPtseTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13), )
if mibBuilder.loadTexts: pnniPtseTable.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniPtseTable.setStatus('current')
if mibBuilder.loadTexts: pnniPtseTable.setDescription("The pnniPtse object contains the attributes that describe\n             the most recent instances of PTSEs in a node's topology\n             database.  A concatenation of the Node Identifier of the\n             local node that received the PTSE, the originating Node's\n             Node Identifier and the PTSE Identifier are used to form\n             the instance ID for an instance of this object.")
pnniPtseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniPtseOriginatingNodeId"), (0, "PNNI-MIB", "pnniPtseId"))
if mibBuilder.loadTexts: pnniPtseEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniPtseEntry.setStatus('current')
if mibBuilder.loadTexts: pnniPtseEntry.setDescription('An entry in the table, containing information about a PTSE\n             in the topology database of a PNNI logical node in this\n             switching system.')
pnniPtseOriginatingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniPtseOriginatingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniPtseOriginatingNodeId.setDescription('The Node Identifier of the node that originated the PTSE.')
pnniPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 2), Unsigned32())
if mibBuilder.loadTexts: pnniPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniPtseId.setDescription('The value of the PTSE Identifier assigned to the PTSE by\n             its originator.')
pnniPtseType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 96, 97, 224, 256, 288, 289))).clone(namedValues=NamedValues(("other", 1), ("nodalStateParameters", 96), ("nodalInformation", 97), ("internalReachableAddresses", 224), ("exteriorReachableAddresses", 256), ("horizontalLinks", 288), ("uplinks", 289)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseType.setStatus('current')
if mibBuilder.loadTexts: pnniPtseType.setDescription('The type of information contained in the PTSE.')
pnniPtseSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseSequenceNum.setStatus('current')
if mibBuilder.loadTexts: pnniPtseSequenceNum.setDescription('The sequence number of the instance of the PTSE as it\n             appears in the local topology database.')
pnniPtseChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseChecksum.setStatus('current')
if mibBuilder.loadTexts: pnniPtseChecksum.setDescription('The value of the PTSE checksum as it appears in the local\n             topology database.')
pnniPtseLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseLifeTime.setStatus('current')
if mibBuilder.loadTexts: pnniPtseLifeTime.setDescription('The value of the remaining lifetime for the given PTSE as\n             it appears in the local topology database.')
pnniPtseInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseInfo.setStatus('current')
if mibBuilder.loadTexts: pnniPtseInfo.setDescription('An unformatted hexadecimal dump of the PTSE contents in\n             full.\n\n             Note: If the size of the PTSE contents is larger than the\n             maximum size of SNMP packets then this is truncated.')
pnniMapTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14), )
if mibBuilder.loadTexts: pnniMapTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapTable.setDescription('A table containing attributes necessary to find and analyze\n             the operation of all links and nodes within the PNNI\n             hierarchy, as seen from the perspective of a local node.\n             An instance of a pnniMap Object describes a link in terms\n             of a node at one end of the link.  Normally there will be\n             two instances of the pnniMap object in the MIB for each\n             horizontal link. The two instances provide information for\n             Network management to map port identifiers from the nodes\n             at both ends to the link between them.  A concatenation of\n             the Local Node Index, Originating Node Identifier and\n             Originating Port Identifier are used to form the instance\n             ID for this object.\n\n             This entire object is read-only, reflecting the fact that\n             the map is discovered dynamically during operation of the\n             PNNI protocol rather than configured.')
pnniMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapOriginatingNodeId"), (0, "PNNI-MIB", "pnniMapOriginatingPortId"), (0, "PNNI-MIB", "pnniMapIndex"))
if mibBuilder.loadTexts: pnniMapEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapEntry.setDescription('An entry in the table, containing connectivity information\n             about a node or link in the PNNI routing domain, as seen\n             from the perspective of a PNNI logical node in this\n             switching system.')
pnniMapOriginatingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapOriginatingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapOriginatingNodeId.setDescription('The node identifier of the node whose connectivity within\n             itself or to other nodes is being described.')
pnniMapOriginatingPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 2), PnniPortId())
if mibBuilder.loadTexts: pnniMapOriginatingPortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapOriginatingPortId.setDescription('The port identifier of the port as assigned by the\n             originating node, to which the port is attached.')
pnniMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: pnniMapIndex.setStatus('current')
if mibBuilder.loadTexts: pnniMapIndex.setDescription('An index into the set of link and nodal connectivity\n             associated with the originating node and port.  This index\n             is needed since there may be multiple entries for nodal\n             connectivity from a specific node and port pair, in\n             addition to any entry for a horizontal link or uplink.')
pnniMapType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("horizontalLink", 1), ("uplink", 2), ("node", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapType.setStatus('current')
if mibBuilder.loadTexts: pnniMapType.setDescription('The type of PNNI entity being described by this entry in\n             the table.')
pnniMapPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 5), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapPeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniMapPeerGroupId.setDescription('Identifies the peer group of the originating node.')
pnniMapAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 6), PnniAggrToken()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapAggrToken.setStatus('current')
if mibBuilder.loadTexts: pnniMapAggrToken.setDescription('For horizontal links to/from LGNs and for uplinks, this\n             attribute contains the derived aggregation token value for\n             this link.  For nodes and for horizontal links between\n             lowest-level nodes, this attribute is set to zero.')
pnniMapRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 7), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapRemoteNodeId.setDescription("For horizontal links and uplinks, this attribute contains\n             the node identifier of the node at the other end of the\n             link from the originating node.  If unknown, the PNNI\n             protocol entity sets this attribute's value to (all)\n             zero(s).  For nodes, this attribute's value is set to (all)\n             zero(s).")
pnniMapRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 8), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapRemotePortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapRemotePortId.setDescription("For horizontal links and uplinks, this attribute contains\n             the port identifier of the port at the remote end of the\n             link as assigned by the remote node.  If unknown, the PNNI\n             protocol entity sets this attribute's value to zero.\n\n             For nodes, this attribute contains the port identifier of\n             the port at the other end of the spoke or bypass from the\n             originating port.  When the originating port ID is zero, a\n             value of zero indicates the default radius.  When the\n             originating port ID is non-zero, a value of zero indicates\n             the nodal nucleus.")
pnniMapVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniMapVPCapability.setDescription('Indicates whether VPCs\n             can be established across the PNNI entity being described\n             by this entry in the pnniMapTable.')
pnniMapPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniMapPtseId.setDescription('The value of the PTSE Identifier for the PTSE being\n             originated by the originating node which contains the\n             information group(s) describing the PNNI entity.')
pnniMapMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 11), PnniMetricsTag()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniMapMetricsTag.setDescription('An arbitrary integer that is used to associate a set of\n             traffic parameters that are always advertised together.\n             Within this set, the parameters are distinguished by the\n             service categories and direction to which a set of\n             parameters apply.  This value is used as an index into\n             the pnniMetricsTable.  The distinguished value zero\n             indicates that no metrics are associated with the link or\n             nodal connectivity.')
pnniMapNodeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15), )
if mibBuilder.loadTexts: pnniMapNodeTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeTable.setDescription('A list of nodes as seen from the perspective of a local\n             node.  The pnniMapNodeTable contains all information\n             learned by the local node from nodal information PTSEs.\n             This entire object is read-only, reflecting the fact that\n             the map is discovered dynamically during operation of the\n             PNNI protocol rather than configured.')
pnniMapNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapNodeId"))
if mibBuilder.loadTexts: pnniMapNodeEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeEntry.setDescription('An entry in the table, containing information about a node\n             in the PNNI routing domain, as seen from the perspective of\n             a logical node in this switching system.')
pnniMapNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeId.setDescription('Identifies the node whose nodal information is being\n             described.')
pnniMapNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 2), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodePeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodePeerGroupId.setDescription('Identifies the peer group of the originating node.')
pnniMapNodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 3), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeAtmAddress.setDescription('The ATM End System Address of the originating node.')
pnniMapNodeRestrictedTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeRestrictedTransit.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeRestrictedTransit.setDescription("Indicates whether the originating node is restricted to\n             only allow support of SVCs originating or terminating at\n             this node.  A value of `true' indicates that the transit\n             capabilities are restricted, i.e., transit connections are\n             not allowed, whereas a value of `false' indicates that\n             transit connections are allowed.  This attribute reflects\n             the setting of the restricted transit bit received in the\n             nodal information PTSE of the originating node.")
pnniMapNodeComplexRep = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeComplexRep.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeComplexRep.setDescription("Indicates whether the originating node uses the complex\n             node representation.  If the value is `true', the spokes\n             and bypasses that make up the complex node representation\n             should be found in the pnniMapTable.  This attribute\n             reflects the setting of the nodal representation bit\n             received in the nodal information PTSE of the originating\n             node.")
pnniMapNodeRestrictedBranching = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeRestrictedBranching.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeRestrictedBranching.setDescription("Indicates whether the originating node is able to support\n             additional branches.  If the value is 'false', then it can\n             support additional branches.  This attribute reflects the\n             setting of the restricted branching bit received in the\n             nodal information PTSE of the originating node.")
pnniMapNodeDatabaseOverload = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeDatabaseOverload.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeDatabaseOverload.setDescription('Indicates whether the originating node is currently\n             operating in topology database overload state.  This\n             attribute has the same value as the Non-transit for PGL\n             Election bit in the nodal information group originated by\n             this node.')
pnniMapNodeIAmLeader = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeIAmLeader.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeIAmLeader.setDescription("Indicates whether the originating node claims to be peer\n             group leader of its peer group.  This attribute reflects\n             the setting of the 'I am Leader' bit received in the nodal\n             information PTSE of the originating node.")
pnniMapNodeLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeLeadershipPriority.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeLeadershipPriority.setDescription('The Leadership priority value advertised by the originating\n             node.')
pnniMapNodePreferredPgl = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 10), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodePreferredPgl.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodePreferredPgl.setDescription("Identifies the node which the originating node believes\n             should be or is peer group leader of its peer group.  If\n             the originating node has not chosen a Preferred PGL, this\n             attribute's value is set to (all) zero(s).")
pnniMapNodeParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 11), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentNodeId.setDescription("When the originating node is a peer group leader, indicates\n             the node ID of the parent LGN.  If the originating node is\n             not peer group leader of its peer group, this attribute's\n             value is set to (all) zero(s).")
pnniMapNodeParentAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 12), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentAtmAddress.setDescription("When the originating node is a peer group leader, indicates\n             the ATM address of the parent LGN.  If the originating node\n             is not peer group leader of its peer group, this\n             attribute's value is set to (all) zero(s).")
pnniMapNodeParentPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 13), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentPeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentPeerGroupId.setDescription("When the originating node is a peer group leader, indicates\n             the node's parent peer group ID.  If the originating node\n             is not peer group leader of its peer group, this\n             attribute's value is set to (all) zero(s).")
pnniMapNodeParentPglNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 14), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentPglNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentPglNodeId.setDescription("When the originating node is a peer group leader,\n             identifies the node elected as peer group leader of the\n             parent peer group.  If the originating node is not peer\n             group leader of its peer group, this attribute's value is\n             set to (all) zero(s).")
pnniMapAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16), )
if mibBuilder.loadTexts: pnniMapAddrTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrTable.setDescription('The pnniMapAddr MIB Object contains a list of all reachable\n             addresses from each node visible to the local node.  The\n             Local Node Index, Advertising Node ID, Advertised Port ID,\n             Reachable Address, and Address prefix length are combined\n             to form an instance ID for this object.  The entire object\n             is read-only, reflecting the fact that reachable addresses\n             are discovered during dynamic operation of the PNNI\n             protocol rather than configured.')
pnniMapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapAddrAdvertisingNodeId"), (0, "PNNI-MIB", "pnniMapAddrAdvertisedPortId"), (0, "PNNI-MIB", "pnniMapAddrIndex"))
if mibBuilder.loadTexts: pnniMapAddrEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrEntry.setDescription('An entry in the table, containing information about an\n             address prefix reachable from a node in the PNNI routing\n             domain, as seen from the perspective of a PNNI logical node\n             in this switching system.')
pnniMapAddrAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapAddrAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the\n             address prefix.')
pnniMapAddrAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 2), PnniPortId())
if mibBuilder.loadTexts: pnniMapAddrAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach\n             the given address prefix.')
pnniMapAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniMapAddrIndex.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrIndex.setDescription('An arbitrary index that is used to enumerate all of the\n             addresses advertised by the specified node.')
pnniMapAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 4), AtmAddrPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapAddrAddress.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrAddress.setDescription('The value of the ATM End System Address prefix.')
pnniMapAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 5), PnniPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrPrefixLength.setDescription('The Prefix length to be applied to the ATM End System\n             Address prefix.')
pnniMapTnsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17), )
if mibBuilder.loadTexts: pnniMapTnsTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsTable.setDescription('A list of all reachable transit networks from each node\n             visible to the local node.  The Local Node Index,\n             Advertising Node ID, Advertised Port ID, Transit Network\n             Type, Transit Network Plan, and Transit Network ID are\n             combined to form an instance ID for this object. The entire\n             object is read-only, reflecting the fact that reachable\n             transit networks are discovered during dynamic operation of\n             the PNNI protocol rather than configured.')
pnniMapTnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapTnsAdvertisingNodeId"), (0, "PNNI-MIB", "pnniMapTnsAdvertisedPortId"), (0, "PNNI-MIB", "pnniMapTnsType"), (0, "PNNI-MIB", "pnniMapTnsPlan"), (0, "PNNI-MIB", "pnniMapTnsId"))
if mibBuilder.loadTexts: pnniMapTnsEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsEntry.setDescription('An entry in the table, containing information about a\n             transit network reachable from a node in the PNNI routing\n             domain, as seen from the perspective of a PNNI logical node\n             in this switching system.')
pnniMapTnsAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapTnsAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the\n             transit network.')
pnniMapTnsAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 2), PnniPortId())
if mibBuilder.loadTexts: pnniMapTnsAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach\n             the given transit network.')
pnniMapTnsType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 3), TnsType())
if mibBuilder.loadTexts: pnniMapTnsType.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsType.setDescription('The type of network identification used for this transit\n             network.')
pnniMapTnsPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 4), TnsPlan())
if mibBuilder.loadTexts: pnniMapTnsPlan.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsPlan.setDescription('The network identification plan according to which network\n             identification has been assigned.')
pnniMapTnsId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapTnsId.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsId.setDescription('The value of the transit network identifier.')
pnniMetricsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18), )
if mibBuilder.loadTexts: pnniMetricsTable.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3')
if mibBuilder.loadTexts: pnniMetricsTable.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsTable.setDescription("This entity's table of PNNI parameters either associated\n             with a PNNI entity or for the connectivity between a PNNI\n             node and a reachable address or transit network.")
pnniMetricsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMetricsTag"), (0, "PNNI-MIB", "pnniMetricsDirection"), (0, "PNNI-MIB", "pnniMetricsIndex"))
if mibBuilder.loadTexts: pnniMetricsEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3')
if mibBuilder.loadTexts: pnniMetricsEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsEntry.setDescription('A set of parameters that applies to the connectivity from a\n             certain node and port to another node or port or to one or\n             more reachable address prefixes and/or transit networks,\n             for one (or more) particular service category(s).  Note\n             that there can be multiple sets of parameters with the same\n             tag, in which case all sets apply to the specified\n             connectivity.')
pnniMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 1), PnniMetricsTag().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsTag.setDescription('An arbitrary integer that is used to associate a set of\n             traffic parameters that are always advertised together.\n             Within this set, the parameters are distinguished by the\n             service categories and direction to which a set of\n             parameters apply.')
pnniMetricsDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2))))
if mibBuilder.loadTexts: pnniMetricsDirection.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsDirection.setDescription('The direction, with respect to the advertising node, in\n             which the parameters in this entry apply.')
pnniMetricsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniMetricsIndex.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsIndex.setDescription('An index into the set of parameters associated with the\n             given tag and direction.')
pnniMetricsClasses = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsClasses.setReference('ATM Forum Traffic Management 4.0 Section 2,\n             ATM Forum PNNI 1.0 Section 5.8.1.1.3.1')
if mibBuilder.loadTexts: pnniMetricsClasses.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsClasses.setDescription('The service categories to which this set of parameters\n             applies.  This is an integer used as a bit mask with each\n             bit that is set representing a single service category for\n             which the resources indicated are available.  Bit 5\n             represents CBR, bit 4 represents real-time VBR, bit 3\n             represents non-real-time VBR, bit 2 represents ABR, and\n             bit 1 (LSB) represents UBR.')
pnniMetricsGcacClp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 5), ClpType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsGcacClp.setReference('ATM Forum PNNI 1.0 Sections 5.8.1.1.3.1, 5.13.4.1')
if mibBuilder.loadTexts: pnniMetricsGcacClp.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsGcacClp.setDescription('Indicates whether the advertised GCAC parameters apply for\n             CLP=0 traffic or for CLP=0+1 traffic.')
pnniMetricsAdminWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsAdminWeight.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniMetricsAdminWeight.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsAdminWeight.setDescription('The administrative weight from the advertising node to the\n             remote end of the PNNI entity or to the reachable address\n             or transit network, for the specified service categories.')
pnniMetrics1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 7), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics1.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.7')
if mibBuilder.loadTexts: pnniMetrics1.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics1.setDescription('An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For information learned from PNNI nodes, this is the\n             maximum cell rate in cells per second for the specified\n             service categories.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniMetrics2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 8), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics2.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.8')
if mibBuilder.loadTexts: pnniMetrics2.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics2.setDescription('An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For information learned from PNNI nodes, this is the\n             available cell rate in cells per second for the specified\n             service categories.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniMetrics3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 9), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics3.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.3')
if mibBuilder.loadTexts: pnniMetrics3.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics3.setDescription('An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For information learned from PNNI nodes, this is the\n             maximum cell transfer delay in microseconds for the\n             specified service categories.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniMetrics4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 10), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics4.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.2')
if mibBuilder.loadTexts: pnniMetrics4.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics4.setDescription('An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For information learned from PNNI nodes, this is the cell\n             delay variation in microseconds for the specified service\n             categories.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniMetrics5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 11), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics5.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.5')
if mibBuilder.loadTexts: pnniMetrics5.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics5.setDescription("An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For PNNI, this is the cell loss ratio for CLP=0 traffic for\n             the specified service categories.  The cell loss ratio\n             value is computed as 10**(-n) where 'n' is the value\n             returned in this variable.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.")
pnniMetrics6 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 12), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics6.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.6')
if mibBuilder.loadTexts: pnniMetrics6.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics6.setDescription("An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For PNNI, this is the cell loss ratio for CLP=0+1 traffic\n             for the specified service categories.  The cell loss ratio\n             value is computed as 10**(-n) where 'n' is the value\n             returned in this variable.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.")
pnniMetrics7 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 13), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics7.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.9')
if mibBuilder.loadTexts: pnniMetrics7.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics7.setDescription('An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For information learned from PNNI nodes, this is the cell\n             rate margin in cells per second for the specified service\n             categories.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniMetrics8 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 14), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics8.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.10')
if mibBuilder.loadTexts: pnniMetrics8.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics8.setDescription('An alternate routing parameter from the advertising node to\n             the remote end of the PNNI entity or to the reachable\n             address or transit network, for the specified service\n             categories.\n\n             For information learned from PNNI nodes, this is the\n             variance factor in units of 2**(-8) for the specified\n             service categories.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniMetricsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsRowStatus.setDescription('To create, delete, activate and de-activate a set of\n             metrics.')
pnniRoutingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19))
pnniRouteBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 1))
pnniRouteNodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteNodeNumber.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeNumber.setDescription('The number of current precalculated PNNI routes to PNNI\n             nodes that are not invalid.')
pnniRouteAddrNumber = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrNumber.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrNumber.setDescription('The number of current PNNI routes from nodes in the PNNI\n             routing domain to addresses and transit networks that are\n             not invalid.')
pnniRouteNodeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2), )
if mibBuilder.loadTexts: pnniRouteNodeTable.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeTable.setDescription("This entity's PNNI Routing table (of routes to other\n             nodes).")
pnniRouteNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniRouteNodeClass"), (0, "PNNI-MIB", "pnniRouteNodeDestNodeId"), (0, "PNNI-MIB", "pnniRouteNodeDTL"))
if mibBuilder.loadTexts: pnniRouteNodeEntry.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeEntry.setDescription('A particular route to a particular destination node, under\n             a particular policy.')
pnniRouteNodeClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 1), ServiceCategory())
if mibBuilder.loadTexts: pnniRouteNodeClass.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeClass.setDescription('Indicates the service category with which this forwarding\n             table entry is associated.')
pnniRouteNodeDestNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 2), PnniNodeId())
if mibBuilder.loadTexts: pnniRouteNodeDestNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeDestNodeId.setDescription('The node ID of the destination node to which this route\n             proceeds, and at which the DTL stack for this route\n             terminates.')
pnniRouteNodeDTL = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniRouteNodeDTL.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeDTL.setDescription("The index into the owning PNNI node's DTL table of the DTL\n             stack that goes with this route.")
pnniRouteNodeDestPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 4), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeDestPortId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeDestPortId.setDescription('The port ID of the destination node at which the route\n             terminates.  A port ID of zero indicates the node nucleus.\n             When the destination node is represented by the simple node\n             representation, this value should be set to zero.')
pnniRouteNodeProto = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteNodeProto.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeProto.setDescription('The routing mechanism via which this route was learned.')
pnniRouteNodeTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteNodeTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeTimeStamp.setDescription("The time at which this  route  was last  updated  or\n             otherwise  determined  to be correct.  Note that no\n             semantics of  `too  old' can  be implied except through\n             knowledge of the routing  protocol  by  which  the route\n             was learned.")
pnniRouteNodeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 7), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeInfo.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeInfo.setDescription("A reference to MIB definitions specific to the particular\n             routing protocol which is responsible for this route, as\n             determined by the value specified in the route's\n             pnniRouteNodeProto value.  If this information is not\n             present, its value should be set to the OBJECT IDENTIFIER\n             zeroDotZero.")
pnniRouteNodeGcacClp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 8), ClpType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeGcacClp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeGcacClp.setDescription('For PNNI, indicates whether any advertised GCAC parameters\n             apply for CLP=0 traffic or for CLP=0+1 traffic.')
pnniRouteNodeFwdMetricAW = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 9), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetricAW.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetricAW.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetricAW.setDescription('The cumulative administrative weight calculated for the\n             forward direction of this route.  If this metric is not\n             used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeFwdMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 10), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric1.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.7')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric1.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric1.setDescription('An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the\n             maximum possible cell rate (in cells per second) for the\n             forward direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeFwdMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 11), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric2.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.8')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric2.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric2.setDescription('An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the\n             Available cell rate (in cells per second) for the forward\n             direction of the route.  Further information on available\n             bandwidth may be obtainable by reference to the nodal\n             advertisements of the nodes in the path.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeFwdMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 12), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric3.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.3')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric3.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric3.setDescription('An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Maximum Cell Transfer Delay (in microseconds)\n             for the forward direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeFwdMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 13), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric4.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.2')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric4.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric4.setDescription('An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Cell Delay Variation (in microseconds) for the\n             forward direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeFwdMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 14), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric5.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.5')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric5.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric5.setDescription("An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Cell Loss Ratio for CLP=0 traffic for the\n             forward direction of the route. The cell loss ratio value\n             is computed as 10**(-n) where 'n' is the value returned in\n             this variable.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.")
pnniRouteNodeFwdMetric6 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 15), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric6.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.6')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric6.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric6.setDescription("An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Cell Loss Ratio for CLP=0+1 traffic for the\n             forward direction of the route. The cell loss ratio value\n             is computed as 10**(-n) where 'n' is the value returned in\n             this variable.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.")
pnniRouteNodeFwdMetric7 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 16), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric7.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.9')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric7.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric7.setDescription('An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the Cell\n             Rate Margin (in cells per second) for the forward direction\n             of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeFwdMetric8 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 17), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric8.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.10')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric8.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric8.setDescription('An alternate routing parameter for the forward direction of\n             this route.\n\n             For information learned from PNNI nodes, this is the\n             Variance Factor (in units of 2**(-8)) for the forward\n             direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeBwdMetricAW = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 18), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetricAW.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetricAW.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetricAW.setDescription('The administrative weight calculated for the backward\n             direction of this route.  If this metric is not used, its\n             value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 19), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric1.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.7')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric1.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric1.setDescription('An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the\n             maximum possible cell rate (in cells per second) for the\n             backward direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeBwdMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 20), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric2.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.8')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric2.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric2.setDescription('An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the\n             Available cell rate (in cells per second) for the backward\n             direction of the route.  Further information on available\n             bandwidth may be obtainable by reference to the nodal\n             advertisements of the nodes in the path.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeBwdMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 21), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric3.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.3')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric3.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric3.setDescription('An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Maximum Cell Transfer Delay (in microseconds)\n             for the backward direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeBwdMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 22), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric4.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.2')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric4.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric4.setDescription('An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Cell Delay Variation (in microseconds) for the\n             backward direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeBwdMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 23), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric5.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.5')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric5.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric5.setDescription("An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Cell Loss Ratio for CLP=0 traffic for the\n             backward direction of the route. The cell loss ratio value\n             is computed as 10**(-n) where 'n' is the value returned in\n             this variable.\n\n             If  this parameter is not used, its value should be set to\n             0xFFFFFFFF.")
pnniRouteNodeBwdMetric6 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 24), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric6.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.6')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric6.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric6.setDescription("An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the\n             cumulative Cell Loss Ratio for CLP=0+1 traffic for the\n             backward direction of the route. The cell loss ratio value\n             is computed as 10**(-n) where 'n' is the value returned in\n             this variable.\n\n             If  this parameter is not used, its value should be set to\n             0xFFFFFFFF.")
pnniRouteNodeBwdMetric7 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 25), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric7.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.9')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric7.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric7.setDescription('An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the Cell\n             Rate Margin (in cells per second) for the backward\n             direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeBwdMetric8 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 26), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric8.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.10')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric8.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric8.setDescription('An alternate routing parameter for the backward direction\n             of this route.\n\n             For information learned from PNNI nodes, this is the\n             Variance Factor (in units of 2**(-8)) for the backward\n             direction of the route.\n\n             If this parameter is not used, its value should be set to\n             0xFFFFFFFF.')
pnniRouteNodeVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 27), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeVPCapability.setDescription('This attribute indicates whether a VPC setup on this route\n             is possible.')
pnniRouteNodeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 28), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeStatus.setDescription('The row status variable, used according to row installation\n             and removal conventions.')
pnniDTLTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3), )
if mibBuilder.loadTexts: pnniDTLTable.setStatus('current')
if mibBuilder.loadTexts: pnniDTLTable.setDescription('The set of all DTL stacks used for the pre-computed routes\n             maintained by this managed entity.')
pnniDTLEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniDTLIndex"), (0, "PNNI-MIB", "pnniDTLEntryIndex"))
if mibBuilder.loadTexts: pnniDTLEntry.setStatus('current')
if mibBuilder.loadTexts: pnniDTLEntry.setDescription('A segment of a DTL stack.  The complete DTL stack is formed\n             by traversing the rows of the table for which the\n             pnniDTLIndex is the same.  Level transitions are indicated\n             using the pnniDLTLinkType column.')
pnniDTLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniDTLIndex.setStatus('current')
if mibBuilder.loadTexts: pnniDTLIndex.setDescription("The index in the node's DTL table of this DTL stack.")
pnniDTLEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)))
if mibBuilder.loadTexts: pnniDTLEntryIndex.setStatus('current')
if mibBuilder.loadTexts: pnniDTLEntryIndex.setDescription('The index in the current DTL stack of this entry.')
pnniDTLNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 3), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniDTLNodeId.setDescription('The node which is this hop in the DTL stack.')
pnniDTLPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 4), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLPortId.setStatus('current')
if mibBuilder.loadTexts: pnniDTLPortId.setDescription('The port from the pnniDTLNodeId to use as the exit.  If the\n             DTL stack does not care, this is coded as zero.')
pnniDTLLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("horizontal", 2), ("uplink", 3), ("last", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLLinkType.setStatus('current')
if mibBuilder.loadTexts: pnniDTLLinkType.setDescription('The type of link out from this node (pnniDTLNodeId).  This\n             is well defined even if the specific port is not\n             specified.')
pnniDTLStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLStatus.setStatus('current')
if mibBuilder.loadTexts: pnniDTLStatus.setDescription('The row status variable, used according to row installation\n             and removal conventions.')
pnniRouteAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4), )
if mibBuilder.loadTexts: pnniRouteAddrTable.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteAddrTable.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrTable.setDescription('A table containing all the attributes necessary to\n             determine what the PNNI entity believes is reachable in\n             terms of ATM End System Addresses and to determine which\n             nodes are advertising this reachability.  This table is\n             also used to configure static routes to reachable address\n             prefixes.  The local node index that received the\n             reachability information, reachable address, address prefix\n             length, and an index that distinguishes between multiple\n             listings of connectivity to a given address prefix from a\n             given local node are combined to form an instance ID for\n             this object.')
pnniRouteAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniRouteAddrAddress"), (0, "PNNI-MIB", "pnniRouteAddrPrefixLength"), (0, "PNNI-MIB", "pnniRouteAddrIndex"))
if mibBuilder.loadTexts: pnniRouteAddrEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteAddrEntry.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrEntry.setDescription('An entry in the table, containing information about a\n             reachable address prefix.')
pnniRouteAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 1), AtmAddrPrefix())
if mibBuilder.loadTexts: pnniRouteAddrAddress.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrAddress.setDescription('The value of the ATM End System Address prefix.')
pnniRouteAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 2), PnniPrefixLength())
if mibBuilder.loadTexts: pnniRouteAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrPrefixLength.setDescription('The prefix length to be applied to the ATM End System\n             Address prefix.')
pnniRouteAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnniRouteAddrIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrIndex.setDescription('An index into the set of listings of connectivity to a\n             given address prefix from a given local node.')
pnniRouteAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 4), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrIfIndex.setDescription("The local interface over which the reachable address can be\n             reached.  The value zero indicates an unknown interface or\n             reachability through a remote node.\n\n             This object may only have a non-zero value if the value of\n             the corresponding instance of pnniRouteAddrProto is other\n             than 'pnni', pnniRouteAddrType is other than 'reject', and\n             the node identified by pnniRouteAddrAdvertisingNodeId is\n             instantiated within this switching system.")
pnniRouteAddrAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 5), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the\n             address prefix.  If the local node index is zero, then the\n             advertising node ID must be set to all zeros.')
pnniRouteAddrAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 6), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach\n             the given address prefix.')
pnniRouteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("internal", 3), ("exterior", 4))).clone('exterior')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrType.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteAddrType.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrType.setDescription('The type (e.g. internal or exterior) of reachability from\n             the advertising node to the address prefix.\n\n             Reject(2) refers to an address prefix which, if matched,\n             indicates that the message should be discarded as\n             unreachable. This is used in some protocols as a means of\n             correctly aggregating routes.')
pnniRouteAddrProto = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrProto.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrProto.setDescription('The routing mechanism via which the connectivity from the\n             advertising node to the reachable address prefix was\n             learned.')
pnniRouteAddrPnniScope = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 9), PnniLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrPnniScope.setReference('ATM Forum PNNI 1.0 Sections 5.3.6, 5.9.1')
if mibBuilder.loadTexts: pnniRouteAddrPnniScope.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrPnniScope.setDescription('The PNNI scope of advertisement (i.e. level of PNNI\n             hierarchy) of the reachability from the advertising node to\n             the address prefix.')
pnniRouteAddrVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrVPCapability.setReference('ATM Forum PNNI 1.0 Section 5.14.9.1 Table 5-34')
if mibBuilder.loadTexts: pnniRouteAddrVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrVPCapability.setDescription('Indicates whether VPCs can be established from the\n             advertising node to the reachable address prefix.')
pnniRouteAddrMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 11), PnniMetricsTag()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrMetricsTag.setDescription('The index into the pnniMetricsTable for the traffic\n             parameter values that apply for the connectivity from the\n             advertising node to the reachable address prefix.  There\n             will be one or more entries in the pnniMetricsTable whose\n             first instance identifier matches the value of this\n             variable.\n\n             If there are no parameters associated with this reachable\n             address prefix then the distinguished value zero is used.')
pnniRouteAddrPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrPtseId.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniRouteAddrPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrPtseId.setDescription('For reachable addresses learned via PNNI, this attribute\n             contains the value of the PTSE Identifier for the PTSE\n             being originated by the originating node which contains the\n             information group(s) describing the reachable address.  For\n             reachable addresses learned by means other than PNNI, this\n             attribute is set to zero.')
pnniRouteAddrOriginateAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrOriginateAdvertisement.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrOriginateAdvertisement.setDescription("Whether or not the reachable address specified by this\n             entry is to be advertised by the local node into its PNNI\n             routing domain.\n\n             This object may only take on the value 'true' when the\n             value of the corresponding instance of pnniRouteAddrProto\n             is other than 'pnni'.")
pnniRouteAddrInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 14), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrInfo.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrInfo.setDescription("A reference to MIB definitions specific to the particular\n             routing protocol which is responsible for this reachable\n             address prefix, as determined by the value specified in the\n             route's pnniRouteAddrProto value.  If this information is\n             not present, its value should be set to the OBJECT\n             IDENTIFIER zeroDotZero.")
pnniRouteAddrOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("advertised", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrOperStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrOperStatus.setDescription('Indicates whether the reachable address prefix is\n             operationally valid and whether it is being advertised by\n             this node.')
pnniRouteAddrTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrTimeStamp.setDescription('Indicates when the connectivity from the advertising node\n             to the reachable address prefix became known to the local\n             node.')
pnniRouteAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrRowStatus.setDescription('To create, delete, activate and de-activate a reachable\n             address prefix.')
pnniRouteTnsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5), )
if mibBuilder.loadTexts: pnniRouteTnsTable.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3.2')
if mibBuilder.loadTexts: pnniRouteTnsTable.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsTable.setDescription('A table containing all the attributes necessary to\n             determine what transit networks the PNNI entity believes\n             are reachable and to determine which nodes are advertising\n             this reachability.  This table is also used to add static\n             routes to reachable transit networks.  The local node index\n             which received the reachability information, type of\n             network identification, network identification plan,\n             transit network identifier, and an index that distinguishes\n             between multiple listings of connectivity to a given\n             transit network from a given local node are combined to\n             form an instance ID for this object.')
pnniRouteTnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniRouteTnsType"), (0, "PNNI-MIB", "pnniRouteTnsPlan"), (0, "PNNI-MIB", "pnniRouteTnsId"), (0, "PNNI-MIB", "pnniRouteTnsIndex"))
if mibBuilder.loadTexts: pnniRouteTnsEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3.2')
if mibBuilder.loadTexts: pnniRouteTnsEntry.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsEntry.setDescription('An entry in the table, containing information about a\n             reachable transit network.')
pnniRouteTnsType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 1), TnsType())
if mibBuilder.loadTexts: pnniRouteTnsType.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsType.setDescription('The type of network identification used for this transit\n             network.')
pnniRouteTnsPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 2), TnsPlan())
if mibBuilder.loadTexts: pnniRouteTnsPlan.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsPlan.setDescription('The network identification plan according to which network\n             identification has been assigned.')
pnniRouteTnsId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 3), DisplayString())
if mibBuilder.loadTexts: pnniRouteTnsId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsId.setDescription('The value of the transit network identifier.')
pnniRouteTnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnniRouteTnsIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsIndex.setDescription('An index into the set of listings of connectivity to a\n             given transit network from a given local node.')
pnniRouteTnsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 5), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsIfIndex.setDescription("The local interface over which the transit network can be\n             reached.  The value zero indicates an unknown interface or\n             reachability through a remote node.\n\n             This object may only have a non-zero value if the value of\n             the corresponding instance of pnniRouteTnsProto is other\n             than 'pnni' and the node identified by\n             pnniRouteTnsAdvertisingNodeId is instantiated within this\n             switching system.")
pnniRouteTnsAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 6), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the\n             transit network.  If the local node index is zero, then the\n             advertising node ID must also be set to zero.')
pnniRouteTnsAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 7), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsAdvertisedPortId.setDescription('The port identifier used from the advertising node to\n             reach the given transit network.')
pnniRouteTnsRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("other", 1), ("exterior", 4))).clone('exterior')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsRouteType.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteTnsRouteType.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsRouteType.setDescription('The type (e.g. exterior or other) of reachability from the\n             advertising node to the transit network.')
pnniRouteTnsProto = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsProto.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsProto.setDescription('The routing mechanism via which the connectivity from the\n             advertising node to the transit network was learned.')
pnniRouteTnsPnniScope = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 10), PnniLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsPnniScope.setReference('ATM Forum PNNI 1.0 Section 5.3.6')
if mibBuilder.loadTexts: pnniRouteTnsPnniScope.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsPnniScope.setDescription('The PNNI scope of advertisement (i.e. level of PNNI\n             hierarchy) of the reachability from the advertising node to\n             the transit network.')
pnniRouteTnsVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsVPCapability.setReference('ATM Forum PNNI 1.0 Section 5.14.9.1 Table 5-34')
if mibBuilder.loadTexts: pnniRouteTnsVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsVPCapability.setDescription('Indicates whether VPCs can be established from the\n             advertising node to the reachable transit network.')
pnniRouteTnsMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 12), PnniMetricsTag()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsMetricsTag.setDescription('The index into the pnniMetricsTable for the traffic\n             parameter values that apply for the connectivity from the\n             advertising node to the transit network.  There will be one\n             or more entries in the pnniMetricsTable whose first\n             instance identifier matches the value of this variable.\n\n             If there are no parameters associated with this transit\n             network then the distinguished value zero is used.')
pnniRouteTnsPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsPtseId.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniRouteTnsPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsPtseId.setDescription('For reachable transit networks learned via PNNI, this\n             attribute contains the value of the PTSE Identifier for the\n             PTSE being originated by the originating node which\n             contains the information group(s) describing the transit\n             network.  For reachable transit networks learned by means\n             other than PNNI, this attribute is set to zero.')
pnniRouteTnsOriginateAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 14), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsOriginateAdvertisement.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsOriginateAdvertisement.setDescription("Whether or not the transit network specified by this entry\n             is to be advertised by the local node into its PNNI routing\n             domain.\n\n             This object may only take on the value 'true' when the\n             value of the corresponding instance of pnniRouteNodeProto\n             is other than 'pnni'.")
pnniRouteTnsInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 15), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsInfo.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsInfo.setDescription("A reference to MIB definitions specific to the particular\n             routing protocol which is responsible for this transit\n             network, as determined by the value specified in the\n             route's pnniRouteTnsProto value.  If this information is\n             not present, its value should be set to the OBJECT\n             IDENTIFIER zeroDotZero.")
pnniRouteTnsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("advertised", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsOperStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsOperStatus.setDescription('Indicates whether the reachable transit network is\n             operationally valid and whether it is being advertised by\n             this node.')
pnniRouteTnsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 17), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsTimeStamp.setDescription('Indicates how long the connectivity from the advertising\n             node to the reachable transit network has been known to the\n             local node.')
pnniRouteTnsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsRowStatus.setDescription('To create, delete, activate and de-activate a reachable\n             transit network.')
pnniMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2))
pnniMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 1))
pnniMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2))
pnniMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 1, 1)).setObjects(("PNNI-MIB", "pnniGeneralMinGroup"), ("PNNI-MIB", "pnniNodeMinGroup"), ("PNNI-MIB", "pnniNodePglMinGroup"), ("PNNI-MIB", "pnniNodeTimerMinGroup"), ("PNNI-MIB", "pnniScopeMinGroup"), ("PNNI-MIB", "pnniIfMinGroup"), ("PNNI-MIB", "pnniLinkMinGroup"), ("PNNI-MIB", "pnniNbrPeerMinGroup"), ("PNNI-MIB", "pnniNbrPeerPortMinGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMIBCompliance = pnniMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: pnniMIBCompliance.setDescription('The compliance statement for entities which implement\n             the PNNI MIB.\n\n             Groups of PNNI objects required for management of a minimum\n             function node are identified by the suffix MinGroup.\n\n             Groups of PNNI objects required for management of a border\n             node are identified by the suffix BorderGroup.\n\n             Groups of PNNI objects required for management of a PGL/LGN\n             capable node are identified by the suffix LgnGroup.\n\n             Groups of optional PNNI objects are identified by the\n             suffix OptionalGroup.')
pnniGeneralMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 1)).setObjects(("PNNI-MIB", "pnniHighestVersion"), ("PNNI-MIB", "pnniLowestVersion"), ("PNNI-MIB", "pnniDtlCountOriginator"), ("PNNI-MIB", "pnniCrankbackCountOriginator"), ("PNNI-MIB", "pnniAltRouteCountOriginator"), ("PNNI-MIB", "pnniRouteFailCountOriginator"), ("PNNI-MIB", "pnniRouteFailUnreachableOriginator"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniGeneralMinGroup = pnniGeneralMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniGeneralMinGroup.setDescription('A collection of general PNNI objects required for\n             management of a minimum function switching system.')
pnniGeneralBorderGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 2)).setObjects(("PNNI-MIB", "pnniDtlCountBorder"), ("PNNI-MIB", "pnniCrankbackCountBorder"), ("PNNI-MIB", "pnniAltRouteCountBorder"), ("PNNI-MIB", "pnniRouteFailCountBorder"), ("PNNI-MIB", "pnniRouteFailUnreachableBorder"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniGeneralBorderGroup = pnniGeneralBorderGroup.setStatus('current')
if mibBuilder.loadTexts: pnniGeneralBorderGroup.setDescription('A collection of general PNNI objects required for\n             management of a border node.')
pnniNodeMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 3)).setObjects(("PNNI-MIB", "pnniNodeLevel"), ("PNNI-MIB", "pnniNodeId"), ("PNNI-MIB", "pnniNodeLowest"), ("PNNI-MIB", "pnniNodeAdminStatus"), ("PNNI-MIB", "pnniNodeOperStatus"), ("PNNI-MIB", "pnniNodeDomainName"), ("PNNI-MIB", "pnniNodeAtmAddress"), ("PNNI-MIB", "pnniNodePeerGroupId"), ("PNNI-MIB", "pnniNodeRestrictedTransit"), ("PNNI-MIB", "pnniNodeComplexRep"), ("PNNI-MIB", "pnniNodeRestrictedBranching"), ("PNNI-MIB", "pnniNodeDatabaseOverload"), ("PNNI-MIB", "pnniNodePtses"), ("PNNI-MIB", "pnniNodeRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeMinGroup = pnniNodeMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeMinGroup.setDescription('A collection of per node PNNI objects required for\n             management of a minimum function switching system.')
pnniNodePglMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 4)).setObjects(("PNNI-MIB", "pnniNodePglLeadershipPriority"), ("PNNI-MIB", "pnniNodePglInitTime"), ("PNNI-MIB", "pnniNodePglReelectTime"), ("PNNI-MIB", "pnniNodePglState"), ("PNNI-MIB", "pnniNodePreferredPgl"), ("PNNI-MIB", "pnniNodePeerGroupLeader"), ("PNNI-MIB", "pnniNodePglTimeStamp"), ("PNNI-MIB", "pnniNodeActiveParentNodeId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodePglMinGroup = pnniNodePglMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglMinGroup.setDescription('A collection of per node PGL election related PNNI objects\n             required for management of a minimum function switching\n             system.')
pnniNodePglLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 5)).setObjects(("PNNI-MIB", "pnniNodeCfgParentNodeIndex"), ("PNNI-MIB", "pnniNodePglOverrideDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodePglLgnGroup = pnniNodePglLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglLgnGroup.setDescription('A collection of per node PGL election related PNNI objects\n             required for management of a PGL/LGN capable switching\n             system.')
pnniNodeTimerMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 6)).setObjects(("PNNI-MIB", "pnniNodePtseHolddown"), ("PNNI-MIB", "pnniNodeHelloHolddown"), ("PNNI-MIB", "pnniNodeHelloInterval"), ("PNNI-MIB", "pnniNodeHelloInactivityFactor"), ("PNNI-MIB", "pnniNodePtseRefreshInterval"), ("PNNI-MIB", "pnniNodePtseLifetimeFactor"), ("PNNI-MIB", "pnniNodeRxmtInterval"), ("PNNI-MIB", "pnniNodePeerDelayedAckInterval"), ("PNNI-MIB", "pnniNodeAvcrPm"), ("PNNI-MIB", "pnniNodeAvcrMt"), ("PNNI-MIB", "pnniNodeCdvPm"), ("PNNI-MIB", "pnniNodeCtdPm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeTimerMinGroup = pnniNodeTimerMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerMinGroup.setDescription('A collection of per node PNNI objects required for\n             management of timers and significant change thresholds in a\n             minimum function switching system.')
pnniNodeTimerLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 7)).setObjects(("PNNI-MIB", "pnniNodeHlinkInact"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeTimerLgnGroup = pnniNodeTimerLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerLgnGroup.setDescription('A collection of per node PNNI objects required for\n             management of timers in a PGL/LGN capable switching\n             system.')
pnniNodeSvccLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 8)).setObjects(("PNNI-MIB", "pnniNodeSvccInitTime"), ("PNNI-MIB", "pnniNodeSvccRetryTime"), ("PNNI-MIB", "pnniNodeSvccCallingIntegrityTime"), ("PNNI-MIB", "pnniNodeSvccCalledIntegrityTime"), ("PNNI-MIB", "pnniNodeSvccTrafficDescriptorIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeSvccLgnGroup = pnniNodeSvccLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccLgnGroup.setDescription('A collection of per node SVCC-based RCC related PNNI\n             objects required for management of a PGL/LGN capable\n             switching system.')
pnniScopeMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 9)).setObjects(("PNNI-MIB", "pnniScopeLocalNetwork"), ("PNNI-MIB", "pnniScopeLocalNetworkPlusOne"), ("PNNI-MIB", "pnniScopeLocalNetworkPlusTwo"), ("PNNI-MIB", "pnniScopeSiteMinusOne"), ("PNNI-MIB", "pnniScopeIntraSite"), ("PNNI-MIB", "pnniScopeSitePlusOne"), ("PNNI-MIB", "pnniScopeOrganizationMinusOne"), ("PNNI-MIB", "pnniScopeIntraOrganization"), ("PNNI-MIB", "pnniScopeOrganizationPlusOne"), ("PNNI-MIB", "pnniScopeCommunityMinusOne"), ("PNNI-MIB", "pnniScopeIntraCommunity"), ("PNNI-MIB", "pnniScopeCommunityPlusOne"), ("PNNI-MIB", "pnniScopeRegional"), ("PNNI-MIB", "pnniScopeInterRegional"), ("PNNI-MIB", "pnniScopeGlobal"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniScopeMinGroup = pnniScopeMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniScopeMinGroup.setDescription('A collection of per node scope mapping related PNNI objects\n             required for management of a minimum function switching\n             system.')
pnniSummaryLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 10)).setObjects(("PNNI-MIB", "pnniSummaryType"), ("PNNI-MIB", "pnniSummarySuppress"), ("PNNI-MIB", "pnniSummaryState"), ("PNNI-MIB", "pnniSummaryRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniSummaryLgnGroup = pnniSummaryLgnGroup.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryLgnGroup.setDescription('A collection of PNNI objects required for controlling\n             address summarization.')
pnniSummaryAddressLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 31)).setObjects(("PNNI-MIB", "pnniSummaryAddressSuppress"), ("PNNI-MIB", "pnniSummaryAddressState"), ("PNNI-MIB", "pnniSummaryAddressRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniSummaryAddressLgnGroup = pnniSummaryAddressLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressLgnGroup.setDescription('A collection of PNNI objects required for controlling address \n            summarization.')
pnniIfMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 11)).setObjects(("PNNI-MIB", "pnniIfNodeIndex"), ("PNNI-MIB", "pnniIfPortId"), ("PNNI-MIB", "pnniIfVPCapability"), ("PNNI-MIB", "pnniIfAdmWeightCbr"), ("PNNI-MIB", "pnniIfAdmWeightRtVbr"), ("PNNI-MIB", "pnniIfAdmWeightNrtVbr"), ("PNNI-MIB", "pnniIfAdmWeightAbr"), ("PNNI-MIB", "pnniIfAdmWeightUbr"), ("PNNI-MIB", "pnniIfRccServiceCategory"), ("PNNI-MIB", "pnniIfRccTrafficDescrIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniIfMinGroup = pnniIfMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniIfMinGroup.setDescription('A collection of per interface PNNI objects required for\n             management of a minimum function switching system.')
pnniIfBorderGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 12)).setObjects(("PNNI-MIB", "pnniIfAggrToken"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniIfBorderGroup = pnniIfBorderGroup.setStatus('current')
if mibBuilder.loadTexts: pnniIfBorderGroup.setDescription('A collection of per interface PNNI objects required for\n             management of a border node.')
pnniLinkMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 13)).setObjects(("PNNI-MIB", "pnniLinkType"), ("PNNI-MIB", "pnniLinkVersion"), ("PNNI-MIB", "pnniLinkHelloState"), ("PNNI-MIB", "pnniLinkRemoteNodeId"), ("PNNI-MIB", "pnniLinkRemotePortId"), ("PNNI-MIB", "pnniLinkIfIndex"), ("PNNI-MIB", "pnniLinkRcvHellos"), ("PNNI-MIB", "pnniLinkXmtHellos"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniLinkMinGroup = pnniLinkMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniLinkMinGroup.setDescription('A collection of per link PNNI objects required for\n             management of a minimum function switching system.')
pnniLinkBorderOrLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 14)).setObjects(("PNNI-MIB", "pnniLinkDerivedAggrToken"), ("PNNI-MIB", "pnniLinkUpnodeId"), ("PNNI-MIB", "pnniLinkUpnodeAtmAddress"), ("PNNI-MIB", "pnniLinkCommonPeerGroupId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniLinkBorderOrLgnGroup = pnniLinkBorderOrLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniLinkBorderOrLgnGroup.setDescription('A collection of per link PNNI objects required for\n             management of a border node or a PGL/LGN capable switching\n             system.')
pnniLinkLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 15)).setObjects(("PNNI-MIB", "pnniLinkSvccRccIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniLinkLgnGroup = pnniLinkLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniLinkLgnGroup.setDescription('A collection of per link PNNI objects required for\n             management of a PGL/LGN capable switching system.')
pnniNbrPeerMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 16)).setObjects(("PNNI-MIB", "pnniNbrPeerState"), ("PNNI-MIB", "pnniNbrPeerPortCount"), ("PNNI-MIB", "pnniNbrPeerRcvDbSums"), ("PNNI-MIB", "pnniNbrPeerXmtDbSums"), ("PNNI-MIB", "pnniNbrPeerRcvPtsps"), ("PNNI-MIB", "pnniNbrPeerXmtPtsps"), ("PNNI-MIB", "pnniNbrPeerRcvPtseReqs"), ("PNNI-MIB", "pnniNbrPeerXmtPtseReqs"), ("PNNI-MIB", "pnniNbrPeerRcvPtseAcks"), ("PNNI-MIB", "pnniNbrPeerXmtPtseAcks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNbrPeerMinGroup = pnniNbrPeerMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerMinGroup.setDescription('A collection of per neighboring peer PNNI objects required\n             for management of a minimum function switching system.')
pnniNbrPeerLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 17)).setObjects(("PNNI-MIB", "pnniNbrPeerSvccRccIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNbrPeerLgnGroup = pnniNbrPeerLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerLgnGroup.setDescription('A collection of per neighboring peer PNNI objects required\n             for management of a PGL/LGN capable switching system.')
pnniNbrPeerPortMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 18)).setObjects(("PNNI-MIB", "pnniNbrPeerPortFloodStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNbrPeerPortMinGroup = pnniNbrPeerPortMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortMinGroup.setDescription('A collection of per port to neighboring peer PNNI objects\n             required for management of a minimum function switching\n             system.')
pnniSvccRccLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 19)).setObjects(("PNNI-MIB", "pnniSvccRccVersion"), ("PNNI-MIB", "pnniSvccRccHelloState"), ("PNNI-MIB", "pnniSvccRccRemoteNodeId"), ("PNNI-MIB", "pnniSvccRccRemoteAtmAddress"), ("PNNI-MIB", "pnniSvccRccRcvHellos"), ("PNNI-MIB", "pnniSvccRccXmtHellos"), ("PNNI-MIB", "pnniSvccRccIfIndex"), ("PNNI-MIB", "pnniSvccRccVpi"), ("PNNI-MIB", "pnniSvccRccVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniSvccRccLgnGroup = pnniSvccRccLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccLgnGroup.setDescription('A collection of per SVCC-based RCC PNNI objects required\n             for management of a PGL/LGN capable switching system.')
pnniPtseOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 20)).setObjects(("PNNI-MIB", "pnniPtseType"), ("PNNI-MIB", "pnniPtseSequenceNum"), ("PNNI-MIB", "pnniPtseChecksum"), ("PNNI-MIB", "pnniPtseLifeTime"), ("PNNI-MIB", "pnniPtseInfo"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniPtseOptionalGroup = pnniPtseOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniPtseOptionalGroup.setDescription('A collection of optional per PTSE PNNI objects.')
pnniMapOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 21)).setObjects(("PNNI-MIB", "pnniMapType"), ("PNNI-MIB", "pnniMapPeerGroupId"), ("PNNI-MIB", "pnniMapAggrToken"), ("PNNI-MIB", "pnniMapRemoteNodeId"), ("PNNI-MIB", "pnniMapRemotePortId"), ("PNNI-MIB", "pnniMapVPCapability"), ("PNNI-MIB", "pnniMapPtseId"), ("PNNI-MIB", "pnniMapMetricsTag"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapOptionalGroup = pnniMapOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map\n             of nodes and links in the PNNI routing domain.')
pnniMapNodeOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 22)).setObjects(("PNNI-MIB", "pnniMapNodePeerGroupId"), ("PNNI-MIB", "pnniMapNodeAtmAddress"), ("PNNI-MIB", "pnniMapNodeRestrictedTransit"), ("PNNI-MIB", "pnniMapNodeComplexRep"), ("PNNI-MIB", "pnniMapNodeRestrictedBranching"), ("PNNI-MIB", "pnniMapNodeDatabaseOverload"), ("PNNI-MIB", "pnniMapNodeIAmLeader"), ("PNNI-MIB", "pnniMapNodeLeadershipPriority"), ("PNNI-MIB", "pnniMapNodePreferredPgl"), ("PNNI-MIB", "pnniMapNodeParentNodeId"), ("PNNI-MIB", "pnniMapNodeParentAtmAddress"), ("PNNI-MIB", "pnniMapNodeParentPeerGroupId"), ("PNNI-MIB", "pnniMapNodeParentPglNodeId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapNodeOptionalGroup = pnniMapNodeOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map\n             of nodes in the PNNI routing domain.')
pnniMapAddrOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 23)).setObjects(("PNNI-MIB", "pnniMapAddrAddress"), ("PNNI-MIB", "pnniMapAddrPrefixLength"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapAddrOptionalGroup = pnniMapAddrOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map\n             of reachable addresses in the PNNI routing domain.')
pnniMapTnsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 24)).setObjects(("PNNI-MIB", "pnniMapTnsId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapTnsOptionalGroup = pnniMapTnsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map\n             of reachable transit networks in the PNNI routing domain.')
pnniMetricsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 25)).setObjects(("PNNI-MIB", "pnniMetricsClasses"), ("PNNI-MIB", "pnniMetricsGcacClp"), ("PNNI-MIB", "pnniMetricsAdminWeight"), ("PNNI-MIB", "pnniMetrics1"), ("PNNI-MIB", "pnniMetrics2"), ("PNNI-MIB", "pnniMetrics3"), ("PNNI-MIB", "pnniMetrics4"), ("PNNI-MIB", "pnniMetrics5"), ("PNNI-MIB", "pnniMetrics6"), ("PNNI-MIB", "pnniMetrics7"), ("PNNI-MIB", "pnniMetrics8"), ("PNNI-MIB", "pnniMetricsRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMetricsOptionalGroup = pnniMetricsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsOptionalGroup.setDescription('A collection of optional PNNI objects used to manage\n             metrics and attributes associated with PNNI entities.')
pnniRouteGeneralOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 26)).setObjects(("PNNI-MIB", "pnniRouteNodeNumber"), ("PNNI-MIB", "pnniRouteAddrNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteGeneralOptionalGroup = pnniRouteGeneralOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteGeneralOptionalGroup.setDescription('A collection of optional PNNI objects.')
pnniRouteNodeOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 27)).setObjects(("PNNI-MIB", "pnniRouteNodeDestPortId"), ("PNNI-MIB", "pnniRouteNodeProto"), ("PNNI-MIB", "pnniRouteNodeTimeStamp"), ("PNNI-MIB", "pnniRouteNodeInfo"), ("PNNI-MIB", "pnniRouteNodeGcacClp"), ("PNNI-MIB", "pnniRouteNodeFwdMetricAW"), ("PNNI-MIB", "pnniRouteNodeFwdMetric1"), ("PNNI-MIB", "pnniRouteNodeFwdMetric2"), ("PNNI-MIB", "pnniRouteNodeFwdMetric3"), ("PNNI-MIB", "pnniRouteNodeFwdMetric4"), ("PNNI-MIB", "pnniRouteNodeFwdMetric5"), ("PNNI-MIB", "pnniRouteNodeFwdMetric6"), ("PNNI-MIB", "pnniRouteNodeFwdMetric7"), ("PNNI-MIB", "pnniRouteNodeFwdMetric8"), ("PNNI-MIB", "pnniRouteNodeBwdMetricAW"), ("PNNI-MIB", "pnniRouteNodeBwdMetric1"), ("PNNI-MIB", "pnniRouteNodeBwdMetric2"), ("PNNI-MIB", "pnniRouteNodeBwdMetric3"), ("PNNI-MIB", "pnniRouteNodeBwdMetric4"), ("PNNI-MIB", "pnniRouteNodeBwdMetric5"), ("PNNI-MIB", "pnniRouteNodeBwdMetric6"), ("PNNI-MIB", "pnniRouteNodeBwdMetric7"), ("PNNI-MIB", "pnniRouteNodeBwdMetric8"), ("PNNI-MIB", "pnniRouteNodeVPCapability"), ("PNNI-MIB", "pnniRouteNodeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteNodeOptionalGroup = pnniRouteNodeOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeOptionalGroup.setDescription('A collection of optional PNNI objects used to manage\n             precalculated routes to nodes in the PNNI routing domain.')
pnniDTLOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 28)).setObjects(("PNNI-MIB", "pnniDTLNodeId"), ("PNNI-MIB", "pnniDTLPortId"), ("PNNI-MIB", "pnniDTLLinkType"), ("PNNI-MIB", "pnniDTLStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniDTLOptionalGroup = pnniDTLOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniDTLOptionalGroup.setDescription('A collection of optional PNNI objects used to manage\n             precalculated routes to nodes in the PNNI routing domain.')
pnniRouteAddrOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 29)).setObjects(("PNNI-MIB", "pnniRouteAddrIfIndex"), ("PNNI-MIB", "pnniRouteAddrAdvertisingNodeId"), ("PNNI-MIB", "pnniRouteAddrAdvertisedPortId"), ("PNNI-MIB", "pnniRouteAddrType"), ("PNNI-MIB", "pnniRouteAddrProto"), ("PNNI-MIB", "pnniRouteAddrPnniScope"), ("PNNI-MIB", "pnniRouteAddrVPCapability"), ("PNNI-MIB", "pnniRouteAddrMetricsTag"), ("PNNI-MIB", "pnniRouteAddrPtseId"), ("PNNI-MIB", "pnniRouteAddrOriginateAdvertisement"), ("PNNI-MIB", "pnniRouteAddrInfo"), ("PNNI-MIB", "pnniRouteAddrOperStatus"), ("PNNI-MIB", "pnniRouteAddrTimeStamp"), ("PNNI-MIB", "pnniRouteAddrRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteAddrOptionalGroup = pnniRouteAddrOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrOptionalGroup.setDescription('A collection of optional PNNI objects used to manage routes\n             to reachable addresses in the PNNI routing domain.')
pnniRouteTnsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 30)).setObjects(("PNNI-MIB", "pnniRouteTnsIfIndex"), ("PNNI-MIB", "pnniRouteTnsAdvertisingNodeId"), ("PNNI-MIB", "pnniRouteTnsAdvertisedPortId"), ("PNNI-MIB", "pnniRouteTnsRouteType"), ("PNNI-MIB", "pnniRouteTnsProto"), ("PNNI-MIB", "pnniRouteTnsPnniScope"), ("PNNI-MIB", "pnniRouteTnsVPCapability"), ("PNNI-MIB", "pnniRouteTnsMetricsTag"), ("PNNI-MIB", "pnniRouteTnsPtseId"), ("PNNI-MIB", "pnniRouteTnsOriginateAdvertisement"), ("PNNI-MIB", "pnniRouteTnsInfo"), ("PNNI-MIB", "pnniRouteTnsOperStatus"), ("PNNI-MIB", "pnniRouteTnsTimeStamp"), ("PNNI-MIB", "pnniRouteTnsRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteTnsOptionalGroup = pnniRouteTnsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsOptionalGroup.setDescription('A collection of optional PNNI objects used to manage routes\n             to reachable transit networks in the PNNI routing domain.')
mibBuilder.exportSymbols("PNNI-MIB", pnniRouteTnsTimeStamp=pnniRouteTnsTimeStamp, pnniMapNodeParentNodeId=pnniMapNodeParentNodeId, pnniHighestVersion=pnniHighestVersion, pnniSummaryPrefixLength=pnniSummaryPrefixLength, pnniLinkDerivedAggrToken=pnniLinkDerivedAggrToken, pnniRouteTnsOriginateAdvertisement=pnniRouteTnsOriginateAdvertisement, pnniNbrPeerRemoteNodeId=pnniNbrPeerRemoteNodeId, pnniLinkXmtHellos=pnniLinkXmtHellos, pnniMapNodeId=pnniMapNodeId, pnniIfAdmWeightAbr=pnniIfAdmWeightAbr, pnniRouteAddrVPCapability=pnniRouteAddrVPCapability, pnniMapNodeParentPglNodeId=pnniMapNodeParentPglNodeId, pnniMapPeerGroupId=pnniMapPeerGroupId, pnniSummaryAddressAddress=pnniSummaryAddressAddress, pnniRouteNodeEntry=pnniRouteNodeEntry, pnniRouteNodeFwdMetric2=pnniRouteNodeFwdMetric2, pnniRouteTnsProto=pnniRouteTnsProto, pnniMapAddrAdvertisingNodeId=pnniMapAddrAdvertisingNodeId, pnniSvccRccRemoteNodeId=pnniSvccRccRemoteNodeId, pnniRouteAddrIfIndex=pnniRouteAddrIfIndex, pnniMapAddrOptionalGroup=pnniMapAddrOptionalGroup, pnniLinkBorderOrLgnGroup=pnniLinkBorderOrLgnGroup, pnniNodeHelloInactivityFactor=pnniNodeHelloInactivityFactor, pnniPtseOriginatingNodeId=pnniPtseOriginatingNodeId, pnniMapTnsEntry=pnniMapTnsEntry, pnniDtlCountOriginator=pnniDtlCountOriginator, pnniRouteAddrTable=pnniRouteAddrTable, pnniNbrPeerRcvDbSums=pnniNbrPeerRcvDbSums, pnniScopeIntraOrganization=pnniScopeIntraOrganization, pnniRouteNodeDestPortId=pnniRouteNodeDestPortId, pnniRouteAddrPnniScope=pnniRouteAddrPnniScope, pnniMapNodeTable=pnniMapNodeTable, pnniRouteNodeInfo=pnniRouteNodeInfo, PnniNodeIndex=PnniNodeIndex, pnniSvccRccEntry=pnniSvccRccEntry, pnniMapNodeParentPeerGroupId=pnniMapNodeParentPeerGroupId, pnniMapVPCapability=pnniMapVPCapability, pnniRouteNodeBwdMetricAW=pnniRouteNodeBwdMetricAW, pnniScopeSitePlusOne=pnniScopeSitePlusOne, pnniMapAddrPrefixLength=pnniMapAddrPrefixLength, pnniRouteAddrInfo=pnniRouteAddrInfo, atmForumNetworkManagement=atmForumNetworkManagement, pnniMetricsRowStatus=pnniMetricsRowStatus, pnniIfVPCapability=pnniIfVPCapability, pnniRouteNodeBwdMetric8=pnniRouteNodeBwdMetric8, pnniNodePglTimeStamp=pnniNodePglTimeStamp, pnniNbrPeerRcvPtseReqs=pnniNbrPeerRcvPtseReqs, pnniMetricsTable=pnniMetricsTable, ClpType=ClpType, pnniLinkLgnGroup=pnniLinkLgnGroup, pnniRouteAddrOptionalGroup=pnniRouteAddrOptionalGroup, pnniRouteAddrEntry=pnniRouteAddrEntry, pnniRouteNodeOptionalGroup=pnniRouteNodeOptionalGroup, pnniMapAddrTable=pnniMapAddrTable, pnniMetrics4=pnniMetrics4, pnniMapAddrEntry=pnniMapAddrEntry, pnniSummaryTable=pnniSummaryTable, pnniLinkUpnodeAtmAddress=pnniLinkUpnodeAtmAddress, pnniSvccRccHelloState=pnniSvccRccHelloState, pnniIfRccTrafficDescrIndex=pnniIfRccTrafficDescrIndex, pnniLowestVersion=pnniLowestVersion, pnniGeneralMinGroup=pnniGeneralMinGroup, pnniNbrPeerXmtPtseReqs=pnniNbrPeerXmtPtseReqs, pnniSummaryAddressState=pnniSummaryAddressState, pnniMapNodeIAmLeader=pnniMapNodeIAmLeader, pnniIfAdmWeightCbr=pnniIfAdmWeightCbr, pnniNodePglMinGroup=pnniNodePglMinGroup, pnniIfAggrToken=pnniIfAggrToken, pnniScopeSiteMinusOne=pnniScopeSiteMinusOne, pnniNodeTimerMinGroup=pnniNodeTimerMinGroup, pnniIfEntry=pnniIfEntry, pnniRouteAddrOperStatus=pnniRouteAddrOperStatus, pnniNodeId=pnniNodeId, pnniLinkType=pnniLinkType, pnniMapType=pnniMapType, pnniLinkSvccRccIndex=pnniLinkSvccRccIndex, pnniNodePeerDelayedAckInterval=pnniNodePeerDelayedAckInterval, pnniMapRemotePortId=pnniMapRemotePortId, pnniPtseLifeTime=pnniPtseLifeTime, pnniNodeSvccLgnGroup=pnniNodeSvccLgnGroup, pnniPtseSequenceNum=pnniPtseSequenceNum, pnniLinkEntry=pnniLinkEntry, pnniRouteNodeBwdMetric6=pnniRouteNodeBwdMetric6, pnniMapIndex=pnniMapIndex, pnniLinkPortId=pnniLinkPortId, pnniRouteNodeDTL=pnniRouteNodeDTL, pnniNbrPeerPortTable=pnniNbrPeerPortTable, pnniMetrics7=pnniMetrics7, pnniNodeSvccEntry=pnniNodeSvccEntry, pnniNodePglTable=pnniNodePglTable, pnniPtseChecksum=pnniPtseChecksum, pnniNbrPeerState=pnniNbrPeerState, pnniNodeActiveParentNodeId=pnniNodeActiveParentNodeId, pnniRouteAddrPrefixLength=pnniRouteAddrPrefixLength, pnniMetrics6=pnniMetrics6, pnniSummaryAddressRowStatus=pnniSummaryAddressRowStatus, pnniMapAddrIndex=pnniMapAddrIndex, pnniNodeTable=pnniNodeTable, pnniSvccRccTable=pnniSvccRccTable, pnniNodeRxmtInterval=pnniNodeRxmtInterval, pnniRouteNodeBwdMetric7=pnniRouteNodeBwdMetric7, pnniSummaryAddressSuppress=pnniSummaryAddressSuppress, pnniMapAggrToken=pnniMapAggrToken, AtmAddrPrefix=AtmAddrPrefix, TnsType=TnsType, pnniLinkMinGroup=pnniLinkMinGroup, pnniNodePtses=pnniNodePtses, pnniRouteNodeGcacClp=pnniRouteNodeGcacClp, pnniNodeRestrictedTransit=pnniNodeRestrictedTransit, pnniRouteNodeTimeStamp=pnniRouteNodeTimeStamp, pnniMIBGroups=pnniMIBGroups, pnniSummaryAddressType=pnniSummaryAddressType, PnniHelloState=PnniHelloState, pnniMapTnsId=pnniMapTnsId, PnniPeerGroupId=PnniPeerGroupId, pnniNodeDatabaseOverload=pnniNodeDatabaseOverload, PnniNodeId=PnniNodeId, pnniNodeSvccCalledIntegrityTime=pnniNodeSvccCalledIntegrityTime, pnniMIBConformance=pnniMIBConformance, pnniCrankbackCountBorder=pnniCrankbackCountBorder, pnniMIBCompliances=pnniMIBCompliances, pnniNodeSvccRetryTime=pnniNodeSvccRetryTime, PnniPortId=PnniPortId, pnniRouteNodeFwdMetric7=pnniRouteNodeFwdMetric7, pnniPtseOptionalGroup=pnniPtseOptionalGroup, pnniSvccRccRemoteAtmAddress=pnniSvccRccRemoteAtmAddress, pnniSummaryAddress=pnniSummaryAddress, pnniNodePglOverrideDelay=pnniNodePglOverrideDelay, pnniSvccRccRcvHellos=pnniSvccRccRcvHellos, pnniLinkCommonPeerGroupId=pnniLinkCommonPeerGroupId, pnniSvccRccXmtHellos=pnniSvccRccXmtHellos, pnniScopeCommunityPlusOne=pnniScopeCommunityPlusOne, pnniRouteTnsTable=pnniRouteTnsTable, pnniMapAddrAddress=pnniMapAddrAddress, pnniNbrPeerXmtPtseAcks=pnniNbrPeerXmtPtseAcks, pnniRouteNodeFwdMetric1=pnniRouteNodeFwdMetric1, pnniPtseType=pnniPtseType, pnniNbrPeerPortEntry=pnniNbrPeerPortEntry, pnniScopeCommunityMinusOne=pnniScopeCommunityMinusOne, pnniNodeLevel=pnniNodeLevel, pnniNodeRestrictedBranching=pnniNodeRestrictedBranching, pnniRouteTnsRowStatus=pnniRouteTnsRowStatus, pnniRouteTnsIndex=pnniRouteTnsIndex, pnniNodePtseLifetimeFactor=pnniNodePtseLifetimeFactor, pnniDTLEntryIndex=pnniDTLEntryIndex, pnniRouteNodeFwdMetric6=pnniRouteNodeFwdMetric6, PnniSvccRccIndex=PnniSvccRccIndex, pnniMetricsIndex=pnniMetricsIndex, pnniRouteTnsPtseId=pnniRouteTnsPtseId, pnniMetricsOptionalGroup=pnniMetricsOptionalGroup, pnniRouteFailCountBorder=pnniRouteFailCountBorder, pnniMetricsTag=pnniMetricsTag, pnniNodeHlinkInact=pnniNodeHlinkInact, pnniMapNodeDatabaseOverload=pnniMapNodeDatabaseOverload, pnniMapNodeRestrictedTransit=pnniMapNodeRestrictedTransit, pnniNbrPeerRcvPtseAcks=pnniNbrPeerRcvPtseAcks, pnniNodePglLeadershipPriority=pnniNodePglLeadershipPriority, pnniPtseEntry=pnniPtseEntry, pnniNodeTimerEntry=pnniNodeTimerEntry, pnniIfMinGroup=pnniIfMinGroup, pnniRouteTnsEntry=pnniRouteTnsEntry, pnniMapNodeAtmAddress=pnniMapNodeAtmAddress, pnniMapOptionalGroup=pnniMapOptionalGroup, pnniMapTnsAdvertisingNodeId=pnniMapTnsAdvertisingNodeId, pnniNodeIndex=pnniNodeIndex, pnniMapRemoteNodeId=pnniMapRemoteNodeId, pnniRouteNodeNumber=pnniRouteNodeNumber, pnniRouteAddrNumber=pnniRouteAddrNumber, pnniRouteTnsVPCapability=pnniRouteTnsVPCapability, pnniScopeRegional=pnniScopeRegional, pnniRouteAddrMetricsTag=pnniRouteAddrMetricsTag, pnniSvccRccVersion=pnniSvccRccVersion, pnniIfBorderGroup=pnniIfBorderGroup, pnniNodeOperStatus=pnniNodeOperStatus, pnniDTLStatus=pnniDTLStatus, pnniRouteAddrOriginateAdvertisement=pnniRouteAddrOriginateAdvertisement, pnniScopeOrganizationMinusOne=pnniScopeOrganizationMinusOne, pnniMapTnsTable=pnniMapTnsTable, pnniRouteTnsOperStatus=pnniRouteTnsOperStatus, pnniMIBObjects=pnniMIBObjects, pnniRouteTnsPlan=pnniRouteTnsPlan, pnniNodeRowStatus=pnniNodeRowStatus, pnniAltRouteCountOriginator=pnniAltRouteCountOriginator, pnniRouteBaseGroup=pnniRouteBaseGroup, pnniMetricsClasses=pnniMetricsClasses, pnniRouteNodeVPCapability=pnniRouteNodeVPCapability, pnniNodeSvccInitTime=pnniNodeSvccInitTime, pnniRouteTnsRouteType=pnniRouteTnsRouteType, PnniVersion=PnniVersion, pnniDTLLinkType=pnniDTLLinkType, pnniCrankbackCountOriginator=pnniCrankbackCountOriginator, pnniSummarySuppress=pnniSummarySuppress, pnniNodePglState=pnniNodePglState, pnniRouteAddrType=pnniRouteAddrType, pnniNodeAvcrMt=pnniNodeAvcrMt, pnniNodeTimerTable=pnniNodeTimerTable, pnniRouteNodeFwdMetric3=pnniRouteNodeFwdMetric3, PYSNMP_MODULE_ID=pnniMIB, pnniRouteFailUnreachableBorder=pnniRouteFailUnreachableBorder, pnniScopeLocalNetworkPlusTwo=pnniScopeLocalNetworkPlusTwo, PnniAtmAddr=PnniAtmAddr, pnniRouteNodeBwdMetric4=pnniRouteNodeBwdMetric4, pnniScopeMinGroup=pnniScopeMinGroup, pnniSvccRccLgnGroup=pnniSvccRccLgnGroup, pnniMIB=pnniMIB, pnniMetrics8=pnniMetrics8, pnniIfAdmWeightUbr=pnniIfAdmWeightUbr, pnniNbrPeerPortCount=pnniNbrPeerPortCount, pnniRouteTnsMetricsTag=pnniRouteTnsMetricsTag, pnniScopeMappingEntry=pnniScopeMappingEntry, PnniLevel=PnniLevel, pnniSummaryEntry=pnniSummaryEntry, pnniMapNodePreferredPgl=pnniMapNodePreferredPgl, pnniSummaryAddressTable=pnniSummaryAddressTable, pnniNbrPeerPortId=pnniNbrPeerPortId, pnniRouteNodeFwdMetricAW=pnniRouteNodeFwdMetricAW, atmForum=atmForum, ServiceCategory=ServiceCategory, pnniNodeComplexRep=pnniNodeComplexRep, pnniRouteNodeTable=pnniRouteNodeTable, PnniMetricsTag=PnniMetricsTag, pnniRouteTnsId=pnniRouteTnsId, pnniPtseTable=pnniPtseTable, pnniBaseGroup=pnniBaseGroup, pnniRouteAddrRowStatus=pnniRouteAddrRowStatus, pnniScopeLocalNetworkPlusOne=pnniScopeLocalNetworkPlusOne, pnniNbrPeerXmtPtsps=pnniNbrPeerXmtPtsps, pnniMapOriginatingPortId=pnniMapOriginatingPortId, pnniScopeMappingTable=pnniScopeMappingTable, pnniSummaryRowStatus=pnniSummaryRowStatus, pnniNodePreferredPgl=pnniNodePreferredPgl, pnniNodePtseRefreshInterval=pnniNodePtseRefreshInterval, pnniMapAddrAdvertisedPortId=pnniMapAddrAdvertisedPortId, pnniMapNodeRestrictedBranching=pnniMapNodeRestrictedBranching, pnniNodeAvcrPm=pnniNodeAvcrPm, pnniMetrics2=pnniMetrics2, pnniMapTnsAdvertisedPortId=pnniMapTnsAdvertisedPortId, pnniRouteNodeClass=pnniRouteNodeClass, pnniMetricsEntry=pnniMetricsEntry, pnniNbrPeerPortFloodStatus=pnniNbrPeerPortFloodStatus, pnniRouteTnsOptionalGroup=pnniRouteTnsOptionalGroup, pnniNbrPeerLgnGroup=pnniNbrPeerLgnGroup, pnniSvccRccIndex=pnniSvccRccIndex, pnniNbrPeerMinGroup=pnniNbrPeerMinGroup, pnniRouteNodeBwdMetric3=pnniRouteNodeBwdMetric3, pnniLinkRemoteNodeId=pnniLinkRemoteNodeId, pnniRouteNodeFwdMetric4=pnniRouteNodeFwdMetric4, pnniRouteAddrTimeStamp=pnniRouteAddrTimeStamp, pnniScopeOrganizationPlusOne=pnniScopeOrganizationPlusOne, pnniRoutingGroup=pnniRoutingGroup, pnniSummaryAddressPrefixLength=pnniSummaryAddressPrefixLength, pnniRouteTnsIfIndex=pnniRouteTnsIfIndex, pnniNodeAdminStatus=pnniNodeAdminStatus, pnniMetricsGcacClp=pnniMetricsGcacClp)
mibBuilder.exportSymbols("PNNI-MIB", pnniMapTnsPlan=pnniMapTnsPlan, pnniRouteAddrIndex=pnniRouteAddrIndex, pnniPtseId=pnniPtseId, pnniGeneralBorderGroup=pnniGeneralBorderGroup, pnniMapTnsOptionalGroup=pnniMapTnsOptionalGroup, pnniNodePeerGroupLeader=pnniNodePeerGroupLeader, pnniNodeHelloHolddown=pnniNodeHelloHolddown, pnniMetrics1=pnniMetrics1, pnniSvccRccVpi=pnniSvccRccVpi, pnniNodePglLgnGroup=pnniNodePglLgnGroup, pnniLinkTable=pnniLinkTable, pnniNodeCdvPm=pnniNodeCdvPm, pnniSummaryType=pnniSummaryType, pnniAltRouteCountBorder=pnniAltRouteCountBorder, pnniNodeAtmAddress=pnniNodeAtmAddress, pnniSummaryAddressEntry=pnniSummaryAddressEntry, pnniDTLEntry=pnniDTLEntry, pnniMetrics3=pnniMetrics3, pnniNodePeerGroupId=pnniNodePeerGroupId, pnniMapMetricsTag=pnniMapMetricsTag, pnniScopeLocalNetwork=pnniScopeLocalNetwork, pnniSummaryAddressLgnGroup=pnniSummaryAddressLgnGroup, pnniNbrPeerPortMinGroup=pnniNbrPeerPortMinGroup, pnniRouteGeneralOptionalGroup=pnniRouteGeneralOptionalGroup, pnniRouteTnsPnniScope=pnniRouteTnsPnniScope, pnniRouteAddrAdvertisedPortId=pnniRouteAddrAdvertisedPortId, pnniIfRccServiceCategory=pnniIfRccServiceCategory, pnniNodeDomainName=pnniNodeDomainName, pnniRouteAddrPtseId=pnniRouteAddrPtseId, pnniRouteNodeBwdMetric5=pnniRouteNodeBwdMetric5, pnniSummaryLgnGroup=pnniSummaryLgnGroup, pnniNodeSvccCallingIntegrityTime=pnniNodeSvccCallingIntegrityTime, pnniMapEntry=pnniMapEntry, pnniMapNodeComplexRep=pnniMapNodeComplexRep, pnniDTLOptionalGroup=pnniDTLOptionalGroup, pnniMapPtseId=pnniMapPtseId, pnniIfNodeIndex=pnniIfNodeIndex, pnniRouteFailUnreachableOriginator=pnniRouteFailUnreachableOriginator, pnniMapNodeOptionalGroup=pnniMapNodeOptionalGroup, pnniRouteTnsInfo=pnniRouteTnsInfo, pnniMapTable=pnniMapTable, pnniRouteNodeDestNodeId=pnniRouteNodeDestNodeId, pnniMapOriginatingNodeId=pnniMapOriginatingNodeId, pnniIfTable=pnniIfTable, pnniRouteNodeStatus=pnniRouteNodeStatus, pnniRouteAddrAdvertisingNodeId=pnniRouteAddrAdvertisingNodeId, pnniMapNodeParentAtmAddress=pnniMapNodeParentAtmAddress, pnniNbrPeerTable=pnniNbrPeerTable, pnniIfAdmWeightNrtVbr=pnniIfAdmWeightNrtVbr, pnniNbrPeerEntry=pnniNbrPeerEntry, atmfPnni=atmfPnni, pnniNodeCtdPm=pnniNodeCtdPm, pnniMapTnsType=pnniMapTnsType, pnniRouteTnsAdvertisedPortId=pnniRouteTnsAdvertisedPortId, pnniNbrPeerRcvPtsps=pnniNbrPeerRcvPtsps, pnniScopeGlobal=pnniScopeGlobal, pnniLinkHelloState=pnniLinkHelloState, pnniSummaryState=pnniSummaryState, pnniIfPortId=pnniIfPortId, pnniLinkVersion=pnniLinkVersion, pnniMetricsDirection=pnniMetricsDirection, pnniNodeMinGroup=pnniNodeMinGroup, pnniMapNodePeerGroupId=pnniMapNodePeerGroupId, pnniNbrPeerSvccRccIndex=pnniNbrPeerSvccRccIndex, pnniLinkRcvHellos=pnniLinkRcvHellos, pnniLinkUpnodeId=pnniLinkUpnodeId, pnniRouteFailCountOriginator=pnniRouteFailCountOriginator, pnniNodePglReelectTime=pnniNodePglReelectTime, pnniScopeIntraSite=pnniScopeIntraSite, pnniLinkIfIndex=pnniLinkIfIndex, pnniPtseInfo=pnniPtseInfo, PnniAggrToken=PnniAggrToken, pnniNodeTimerLgnGroup=pnniNodeTimerLgnGroup, pnniMIBCompliance=pnniMIBCompliance, pnniMapNodeLeadershipPriority=pnniMapNodeLeadershipPriority, pnniLinkRemotePortId=pnniLinkRemotePortId, pnniNodePglInitTime=pnniNodePglInitTime, pnniNodeHelloInterval=pnniNodeHelloInterval, PnniPrefixLength=PnniPrefixLength, pnniRouteNodeProto=pnniRouteNodeProto, pnniScopeInterRegional=pnniScopeInterRegional, pnniDTLNodeId=pnniDTLNodeId, pnniRouteNodeFwdMetric8=pnniRouteNodeFwdMetric8, pnniRouteNodeBwdMetric1=pnniRouteNodeBwdMetric1, pnniRouteAddrProto=pnniRouteAddrProto, pnniIfAdmWeightRtVbr=pnniIfAdmWeightRtVbr, pnniRouteTnsAdvertisingNodeId=pnniRouteTnsAdvertisingNodeId, pnniDTLIndex=pnniDTLIndex, pnniNodeCfgParentNodeIndex=pnniNodeCfgParentNodeIndex, pnniDTLTable=pnniDTLTable, pnniNodeSvccTable=pnniNodeSvccTable, pnniNbrPeerXmtDbSums=pnniNbrPeerXmtDbSums, pnniRouteAddrAddress=pnniRouteAddrAddress, pnniScopeIntraCommunity=pnniScopeIntraCommunity, pnniDtlCountBorder=pnniDtlCountBorder, pnniNodeLowest=pnniNodeLowest, pnniDTLPortId=pnniDTLPortId, pnniNodePtseHolddown=pnniNodePtseHolddown, pnniMetrics5=pnniMetrics5, pnniSvccRccVci=pnniSvccRccVci, pnniMetricsAdminWeight=pnniMetricsAdminWeight, pnniRouteNodeFwdMetric5=pnniRouteNodeFwdMetric5, TnsPlan=TnsPlan, pnniSvccRccIfIndex=pnniSvccRccIfIndex, pnniMapNodeEntry=pnniMapNodeEntry, pnniRouteNodeBwdMetric2=pnniRouteNodeBwdMetric2, pnniNodeSvccTrafficDescriptorIndex=pnniNodeSvccTrafficDescriptorIndex, pnniNodeEntry=pnniNodeEntry, pnniRouteTnsType=pnniRouteTnsType, pnniNodePglEntry=pnniNodePglEntry)
