#
# PySNMP MIB module MPLS-LDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/output/asn1/MPLS-LDP-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 15:33:31 2022
# On host fv-az42-180 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
AtmVpIdentifier, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
ObjectIdentity, MibIdentifier, Unsigned32, iso, Counter32, Bits, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter64, Integer32, ModuleIdentity, TimeTicks, experimental, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibIdentifier", "Unsigned32", "iso", "Counter32", "Bits", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter64", "Integer32", "ModuleIdentity", "TimeTicks", "experimental", "Gauge32")
TruthValue, StorageType, RowStatus, TimeInterval, TimeStamp, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "StorageType", "RowStatus", "TimeInterval", "TimeStamp", "TextualConvention", "DisplayString")
mplsLdpMIB = ModuleIdentity((1, 3, 6, 1, 3, 97))
if mibBuilder.loadTexts: mplsLdpMIB.setLastUpdated('200008291200Z')
if mibBuilder.loadTexts: mplsLdpMIB.setOrganization('Multiprotocol Label Switching (mpls)\n                  Working Group')
if mibBuilder.loadTexts: mplsLdpMIB.setContactInfo('Joan Cucchiara (jcucchiara@brixnet.com)\n         Brix Networks\n\n         Hans Sjostrand (hans.sjostrand@ericsson.com)\n         Ericsson\n\n         James V. Luciani (jluciani@tollbridgetech.com)\n         TollBridge Technologies')
if mibBuilder.loadTexts: mplsLdpMIB.setDescription("This MIB contains managed object definitions for the\n        'Multiprotocol Label Switching, Label Distribution\n        Protocol, LDP' document.")
class MplsLsrIdentifier(TextualConvention, OctetString):
    description = 'The Label Switch Router (LSR) identifier\n        is the first 4 bytes or the Router Id component\n        of the Label Distribution Protocol (LDP) identifier.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class MplsLdpGenAddr(TextualConvention, OctetString):
    description = 'The value of an network layer or data link\n        layer address.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 64)

class MplsLabel(TextualConvention, Integer32):
    description = 'This value represents an MPLS label.\n        The label contents are specific to\n        the label being represented.\n\n        The label carried in an MPLS shim header\n        (for LDP, the Generic Label) is a 20-bit number\n        represented by 4 octets. Bits 0-19 contain a\n        label or a reserved label value.  Bits 20-31 MUST\n        be zero.\n\n        The frame relay label can be either 10-bits or\n        23-bits depending on the DLCI field size and the\n        upper 22-bits or upper 9-bits must be zero, respectively.\n\n        For an ATM label the lower 16-bits represents the VCI,\n        the next 12-bits represents the VPI and the remaining\n        bits MUST be zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class MplsLdpIdentifier(TextualConvention, OctetString):
    description = 'The LDP identifier is a six octet quantity\n        which is used to identify an Label Switch Router\n        (LSR) label space.\n\n        The first four octets encode an IP address\n        assigned to the LSR, and the last two octets\n        identify a specific label space within the LSR.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class MplsLdpLabelTypes(TextualConvention, Integer32):
    description = 'The Layer 2 label types which are defined for\n        MPLS LDP are generic(1), atm(2), or frameRelay(3).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("generic", 1), ("atm", 2), ("frameRelay", 3))

class MplsAtmVcIdentifier(TextualConvention, Integer32):
    description = 'The VCI value for a VCL. The maximum VCI value\n            cannot exceed the value allowable by\n            atmInterfaceMaxVciBits defined in ATM-MIB.\n            The minimum value is 32, values 0 to 31 are\n            reserved for other uses by the ITU and ATM\n            Forum.  32 is typically the default value\n            for the Control VC.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(32, 65535)

mplsLdpObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1))
mplsLdpNotifications = MibIdentifier((1, 3, 6, 1, 3, 97, 2))
mplsLdpConformance = MibIdentifier((1, 3, 6, 1, 3, 97, 3))
mplsLdpLsrObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 1))
mplsLdpEntityObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2))
mplsLdpLsrId = MibScalar((1, 3, 6, 1, 3, 97, 1, 1, 1), MplsLsrIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpLsrId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrId.setDescription("The LSR's Identifier.")
mplsLdpLsrLoopDetectionCapable = MibScalar((1, 3, 6, 1, 3, 97, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("hopCount", 3), ("pathVector", 4), ("hopCountAndPathVector", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpLsrLoopDetectionCapable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrLoopDetectionCapable.setDescription('A indication of whether this LSR supports\n        loop detection.\n\n        none(1) -- Loop Detection is not supported\n                   on this LSR.\n\n        other(2) -- Loop Detection is supported but\n                    by a method other than those\n                    listed below.\n\n        hopCount(3) -- Loop Detection is supported by\n                       Hop Count only.\n\n        pathVector(4) -- Loop Detection is supported by\n                        Path Vector only.\n\n        hopCountAndPathVector(5) -- Loop Detection is\n                             supported by both Hop Count\n                             And Path Vector.\n\n        Since Loop Detection is determined during\n        Session Initialization, an individual session\n        may not be running with loop detection.  This\n        object simply gives an indication of whether or not the\n        LSR has the ability to support Loop Detection and\n        which types.')
mplsLdpEntityIndexNext = MibScalar((1, 3, 6, 1, 3, 97, 1, 2, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndexNext.setDescription('This object contains an appropriate value to\n        be used for mplsLdpEntityIndex when creating\n        entries in the mplsLdpEntityTable. The value\n        0 indicates that no unassigned entries are\n        available. To obtain the mplsLdpEntityIndex\n        value for a new entry, the manager issues a\n        management protocol retrieval operation to obtain\n        the current value of this object.  After each\n        retrieval, the agent should modify the value to\n        the next unassigned index.')
mplsLdpEntityTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 2), )
if mibBuilder.loadTexts: mplsLdpEntityTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTable.setDescription('This table contains information about the\n        MPLS Label Distribution Protocol Entities which\n        exist on this Label Switch Router (LSR).')
mplsLdpEntityEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityEntry.setDescription('An entry in this table represents an LDP entity.\n        An entry can be created by a network administrator\n        or by an SNMP agent as instructed by LDP.')
mplsLdpEntityLdpId = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 1), MplsLdpIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setReference('LDP Specification, Section on LDP Identifiers.')
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setDescription('The LDP identifier.\n\n        The first four octets encode an IP address\n        assigned to the LSR, and the last two octets\n        identify a specific label space within the\n        LSR.')
mplsLdpEntityIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpEntityIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndex.setDescription("This index is used as a secondary index to uniquely\n        identify this row.  Before creating a row in this table,\n        the 'mplsLdpEntityIndexNext' object should be retrieved.\n        That value should be used for the value of this index\n        when creating a row in this table.  (NOTE:  if a value\n        of zero (0) is retrieved, that indicates that no rows\n        can be created in this table at this time.\n\n        A secondary index (this object) is needed by some\n        but not all, LDP implementations.  For example\n        in an LDP implementation which uses PPP, this\n        index may be needed.")
mplsLdpEntityProtocolVersion = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 3), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityProtocolVersion.setDescription('The version number of the protocol.  The value of 0 on a\n       read indicates that the version of the protocol is unknown.\n       Otherwise, the value of this object represents the version\n       of the LDP protocol.')
mplsLdpEntityAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAdminStatus.setDescription("The administrative status of this LDP Entity.\n        If this object is changed from 'enable' to 'disable'\n        and this entity has already attempted to establish\n        contact with a Peer (which implies that the\n        'mplsLdpEntityRowStatus' object has been set to\n        'active'), then all contact with that\n        Peer is lost and all information from that Peer\n        needs to be removed from the MIB.\n        At this point the user is able to change values\n        which are related to this entity.\n\n        When the admin status is set back to 'up', then\n        this Entity will attempt to establish new sessions\n        with the Peer.")
mplsLdpEntityOperStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityOperStatus.setDescription('The operational status of this LDP Entity.')
mplsLdpEntityWellKnownTcpDiscoveryPort = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 6), Unsigned32().clone(646)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityWellKnownTcpDiscoveryPort.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownTcpDiscoveryPort.setDescription('The well known TCP Discovery Port for\n        LDP.')
mplsLdpEntityWellKnownUdpDiscoveryPort = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 7), Unsigned32().clone(646)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityWellKnownUdpDiscoveryPort.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownUdpDiscoveryPort.setDescription('The well known UDP Discovery Port for\n        LDP.')
mplsLdpEntityMaxPduLength = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(4096)).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setReference("See Section on the 'Initialization Message' in the\n       LDP Specification.")
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setDescription('The maximum PDU Length that is sent in\n       the Common Session Parameters of an Initialization\n       Message. A value of 255 or less specifies the\n       default maximum length of 4096 octets.')
mplsLdpEntityKeepAliveHoldTimer = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(40)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityKeepAliveHoldTimer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityKeepAliveHoldTimer.setDescription('The two octet value which is the proposed keep alive hold\n        timer for this LDP Entity.')
mplsLdpEntityHelloHoldTimer = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityHelloHoldTimer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityHelloHoldTimer.setDescription('The two octet value which is the proposed Hello hold\n        timer for this LDP Entity. A value of 0 means use the\n        default, which is 15 seconds for Link Hellos and 45\n        seconds for Targeted Hellos.  A value of 65535 means\n        infinite.')
mplsLdpEntityFailedInitSessionTrapEnable = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionTrapEnable.setDescription("Indicates whether the\n        'mplsLdpFailedInitSessionThresholdExceeded'\n        trap should be generated.\n\n        If the value of this object is 'enabled(1)'\n        then the trap will generated.  If the value\n        of this object is 'disabled(2)' then the\n        trap will not be generated.  The DEFVAL\n        is set to 'enabled(1)'.")
mplsLdpEntityFailedInitSessionThreshold = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 12), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionThreshold.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionThreshold.setDescription("When attempting to establish a session with a\n        given Peer, the given LDP Entity should\n        send out the SNMP notification,\n        'mplsLdpFailedInitSessionThresholdExceeded', when\n        the number of Session Initialization messages sent\n        exceeds this threshold.\n\n        A value of 0 (zero) for this object\n        indicates that the threshold is infinity, and\n        the SNMP notification will never be sent\n        when the value of this object is 0 (zero).")
mplsLdpEntityLabelDistributionMethod = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("downstreamOnDemand", 1), ("downstreamUnsolicited", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityLabelDistributionMethod.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLabelDistributionMethod.setDescription('For any given LDP session, the method of\n        label distribution must be specified.')
mplsLdpEntityLabelRetentionMode = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("conservative", 1), ("liberal", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityLabelRetentionMode.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLabelRetentionMode.setDescription('The LDP Entity can be configured to use either\n        conservative or liberal label retention mode.\n\n        If the value of this object is conservative(1)\n        then advertized label mappings are retained\n        only if they will be used to forward packets,\n        i.e. if label came from a valid next hop.\n\n        If the value of this object is liberal(2)\n        then all advertized label mappings are retained\n        whether they are from a valid next hop or not.')
mplsLdpEntityPVLimitMismatchTrapEnable = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityPVLimitMismatchTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityPVLimitMismatchTrapEnable.setDescription("Indicates whether the 'mplsLdpPathVectorLimitMismatch'\n        trap should be generated.\n\n        If the value of this object is 'enabled(1)'\n        then the trap will generated.  If the value\n        of this object is 'disabled(2)' then the\n        trap will not be generated.  The DEFVAL\n        is set to 'enabled(1)'.")
mplsLdpEntityPathVectorLimit = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityPathVectorLimit.setDescription("If the value of this object is 0 (zero) then\n        Loop Dection for Path Vectors is disabled.\n\n        Otherwise, if this object has a value greater than\n        zero, then Loop Dection for Path Vectors is enabled,\n        and the Path Vector Limit is this value.\n        Also, the value of the object,\n        'mplsLdpLsrLoopDetectionCapable', must be set to\n        either 'pathVector(4)' or 'hopCountAndPathVector(5)',\n        if this object has a value greater than 0 (zero).")
mplsLdpEntityHopCountLimit = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityHopCountLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityHopCountLimit.setDescription("If the value of this object is 0 (zero),\n        then Loop Detection using Hop Counters is\n        disabled.\n\n        If the value of this object is greater than\n        0 (zero) then Loop Detection using Hop\n        Counters is enabled, and this object\n        specifies this Entity's maximum allowable\n        value for the Hop Count.\n        Also, the value of the object\n        mplsLdpLsrLoopDetectionCapable must be set\n        to either 'hopCount(3)' or\n        'hopCountAndPathVector(5)' if this object\n        has a value greater than 0 (zero).")
mplsLdpEntityTargetedPeer = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeer.setDescription('If this LDP entity uses targeted peer then set\n        this to true.')
mplsLdpEntityTargetedPeerAddrType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 19), AddressFamilyNumbers()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddrType.setDescription('The type of the internetwork layer address used for\n        the Extended Discovery. This object indicates how\n        the value of mplsLdpEntityTargetedPeerAddr is to\n        be interpreted.')
mplsLdpEntityTargetedPeerAddr = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 20), MplsLdpGenAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddr.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddr.setDescription('The value of the internetwork layer address used for\n        the Extended Discovery.')
mplsLdpEntityOptionalParameters = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 21), MplsLdpLabelTypes()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityOptionalParameters.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityOptionalParameters.setDescription('Specifies the optional parameters for the LDP\n        Initialization Message.  If the value is generic(1)\n        then no optional parameters will be sent in\n        the LDP Initialization message associated with\n        this Entity.\n\n        If the value is atmParameters(2) then\n        a row must be created in the mplsLdpEntityAtmParms\n        Table, which corresponds to this entry.\n\n        If the value is frameRelayParameters(3) then\n        a row must be created in the mplsLdpEntityFrameRelayParms\n        Table, which corresponds to this entry.')
mplsLdpEntityDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 22), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion\n        at which any one or more of this entity's counters\n        suffered a discontinuity.  The relevant counters are the\n        specific instances associated with this entity of\n        any Counter32, or Counter64 object contained\n        in the 'mplsLdpEntityStatsTable'.  If no such\n        discontinuities have occurred since the last\n        re-initialization of the local management\n        subsytem, then this object contains a zero\n        value.")
mplsLdpEntityStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 23), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 24), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityRowStatus.setDescription("An object that allows entries in this table to\n         be created and deleted using the\n         RowStatus convention.\n         Once the 'mplsLdpEntityAdminStatus' object has\n         the value of 'up' and this object has the value\n         of 'active' then the Entity will atttempt to\n         contact an LDP Peer.  If the value of this object\n         is changed to 'notInService', then the Entity looses\n         contact with the LDP Peer and all information related\n         to that Peer must be removed from the MIB.  This has\n         the same effect as changing 'mplsLdpEntityAdminStatus'\n         from 'enable' to 'disable'.\n\n         When this object is set to 'active' and the value of\n         the 'mplsLdpEntityAdminStatus' is 'enable' then\n         this Entity will attempt to contact the Peer and\n         establish new sessions.")
mplsLdpEntityGenericObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2, 3))
mplsLdpEntityConfGenericLabelRangeTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 3, 1), )
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeTable.setDescription("The MPLS LDP Entity Configurable Generic Label Range Table.\n        The purpose of this table is to provide a mechanism\n        for specifying a contiguous range of generic labels,\n        or a 'label range' for LDP Entities.\n\n        LDP Entities which use Generic Labels must have at least one\n        entry in this table.")
mplsLdpEntityConfGenericLabelRangeEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeMinimum"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeMaximum"))
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeEntry.setDescription("A row in the LDP Entity Configurable Generic Label\n        Range Table.  One entry in this table contains\n        information on a single range of labels\n        represented by the configured Upper and Lower\n        Bounds pairs.  NOTE: there is NO corresponding\n        LDP message which relates to the information\n        in this table, however, this table does provide\n        a way for a user to 'reserve' a generic label\n        range.\n\n        NOTE:  The ranges for a specific LDP Entity\n        are UNIQUE and non-overlapping.\n\n        A row will not be created unless a unique and\n        non-overlapping range is specified.  Thus, row\n        creation implies a one-shot row creation of\n        LDP EntityID and LowerBound and\n        UpperBound.")
mplsLdpEntityConfGenericLabelRangeMinimum = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)))
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMinimum.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMinimum.setDescription('The minimum label configured for this range.')
mplsLdpEntityConfGenericLabelRangeMaximum = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)))
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMaximum.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMaximum.setDescription('The maximum label configured for this range.')
mplsLdpEntityConfGenericIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfGenericIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of\n       the 'ifLayer' where these Generic Label would be created, or\n       0 (zero).  The value of zero means that the InterfaceIndex\n       is not known.  For example, if the InterfaceIndex is\n       created subsequent to the Generic Label's creation, then\n       it would not be known.  However, if the InterfaceIndex\n       is known, then it must be represented by this value.\n\n       If an InterfaceIndex becomes known, then the\n       network management entity (e.g. SNMP agent) responsible\n       for this object MUST change the value from 0 (zero) to the\n       value of the InterfaceIndex.  If this Generic Label is\n       being used in forwarding data, then the value of this\n       object MUST be the InterfaceIndex.")
mplsLdpEntityConfGenericLabelRangeStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityConfGenericLabelRangeRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeRowStatus.setDescription("An object that allows entries in this\n        table to be created and deleted using\n        the RowStatus convention.\n\n        There must exist at least one entry in this\n        table for every LDP Entity that has a\n        generic label configured.\n\n        NOTE:  This RowStatus object should\n        have the same value of the 'mplsLdpEntityRowStatus'\n        related to this entry.")
mplsLdpEntityAtmObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2, 4))
mplsLdpEntityAtmParmsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 4, 1), )
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsTable.setDescription("This table contains information about the\n        ATM specific information which could be used\n        in the 'Optional Parameters' and other ATM specific\n        information.")
mplsLdpEntityAtmParmsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsEntry.setDescription('An entry in this table represents the ATM parameters\n        and ATM information for this LDP entity.')
mplsLdpEntityAtmIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of\n       the 'ifLayer' where the ATM Labels 'owned' by this\n       entry were created, or 0 (zero).  The value of zero\n       means that the InterfaceIndex is not known.  For example,\n       if the InterfaceIndex is created subsequent to the\n       ATM Label's creation, then it would not be known.\n       However, if the InterfaceIndex is known, then it must\n       be represented by this value.\n\n       If an InterfaceIndex becomes known, then the\n       network management entity (e.g. SNMP agent) responsible\n       for this object MUST change the value from 0 (zero) to the\n       value of the InterfaceIndex.  If an ATM Label is\n       being used in forwarding data, then the value of this\n       object MUST be the InterfaceIndex.")
mplsLdpEntityAtmMergeCap = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("notSupported", 0), ("vcMerge", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setDescription('Denotes the Merge Capability of this Entity.')
mplsLdpEntityAtmLabelRangeComponents = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLabelRangeComponents.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLabelRangeComponents.setDescription('Number of LabelRange Components in the Initialization\n        message.  This also represents the number of entries\n        in the mplsLdpLabelRangeComponentsTable which correspond\n        to this entry.')
mplsLdpEntityAtmVcDirectionality = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirectional", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)',\n        a given VCI, within a given VPI, is used as a\n        label for both directions independently.\n\n        If the value of this object is 'unidirectional(1)',\n        a given VCI within a VPI designates one direction.")
mplsLdpEntityAtmLsrConnectivity = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("indirect", 2))).clone('direct')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setDescription('The peer LSR may be connected indirectly by means of an\n        ATM VP so that the VPI values may be different on either\n        endpoint so the label MUST be encoded entirely within the\n        VCI field.')
mplsLdpEntityDefaultControlVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 6), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVpi.setDescription('The default VPI value for the non-MPLS connection.  The\n        default value of this is 0 (zero) but other values may\n        be configured.  This object allows a different value\n        to be configured.')
mplsLdpEntityDefaultControlVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 7), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVci.setDescription('The Default VCI value for a non-MPLS connection.  The\n        default value of this is 32 but other values may be\n        configured.  This object allows a different value to\n        be configured.')
mplsLdpEntityUnlabTrafVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 8), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVpi.setDescription("VPI value of the VCC supporting unlabelled traffic.  This\n        non-MPLS connection is used to carry unlabelled (IP)\n        packets.  The default value is the same as the default\n        value of the 'mplsLdpEntityDefaultControlVpi', however\n        another value may be configured.")
mplsLdpEntityUnlabTrafVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 9), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVci.setDescription("VCI value of the VCC supporting unlabelled traffic.\n        This non-MPLS connection is used to carry unlabelled (IP)\n        packets. The default value is the same as the default\n        value of the 'mplsLdpEntityDefaultControlVci', however\n        another value may be configured.")
mplsLdpEntityAtmStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 10), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityAtmRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setDescription("An object that allows entries in this table to\n        be created and deleted using the\n        RowStatus convention.\n\n        NOTE:  This RowStatus object should\n        have the same value of the 'mplsLdpEntityRowStatus'\n        related to this entry.")
mplsLdpEntityConfAtmLabelRangeTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 4, 2), )
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeTable.setDescription("The MPLS LDP Entity Configurable ATM Label Range Table.\n        The purpose of this table is to provide a mechanism\n        for specifying a contiguous range of vpi's\n        with a contiguous range of vci's, or a 'label range'\n        for LDP Entities.\n\n        LDP Entities which use ATM must have at least one\n        entry in this table.")
mplsLdpEntityConfAtmLabelRangeEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMinimumVpi"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMinimumVci"))
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeEntry.setDescription('A row in the LDP Entity Configurable ATM Label\n        Range Table.  One entry in this table contains\n        information on a single range of labels\n        represented by the configured Upper and Lower\n        Bounds VPI/VCI pairs.  These are the same\n        data used in the Initialization Message.\n\n        NOTE:  The ranges for a specific LDP Entity\n        are UNIQUE and non-overlapping.  For example,\n        for a specific LDP Entity index, there could\n        be one entry having ConfLowerBound vpi/vci == 0/32, and\n        ConfUpperBound vpi/vci == 0/100, and a second entry\n        for this same interface with ConfLowerBound\n        vpi/vci == 0/101 and ConfUpperBound vpi/vci == 0/200.\n        However, there could not be a third entry with\n        ConfLowerBound vpi/vci == 0/200 and\n        ConfUpperBound vpi/vci == 0/300 because this label\n        range overlaps with the second entry (i.e. both\n        entries now have 0/200).\n\n        A row will not be created unless a unique and\n        non-overlapping range is specified.  Thus, row\n        creation implies a one-shot row creation of\n        LDP EntityID and ConfLowerBound vpi/vci and\n        ConfUpperBound vpi/vci.  At least one label\n        range entry for a specific LDP Entity MUST\n        include the default VPI/VCI  values denoted\n        in the LDP Entity Table.')
mplsLdpEntityConfAtmLabelRangeMinimumVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVpi.setDescription('The minimum VPI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeMinimumVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVci.setDescription('The minimum VCI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeMaximumVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 3), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVpi.setDescription('The maximum VPI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeMaximumVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVci.setDescription('The maximum VCI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityConfAtmLabelRangeRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeRowStatus.setDescription("An object that allows entries in this\n        table to be created and deleted using\n        the RowStatus convention.\n\n        There must exist at least one entry in this\n        table for every LDP Entity that has\n        'mplsLdpEntityOptionalParameters' object with\n        a value of 'atmSessionParameters'.\n\n        NOTE:  This RowStatus object should\n        have the same value of the 'mplsLdpEntityRowStatus'\n        related to this entry.")
mplsLdpEntityFrameRelayObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2, 5))
mplsLdpEntityFrameRelayParmsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 5, 1), )
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsTable.setDescription('This table contains information about the\n        Optional Parameters to specify what this Entity is\n        going to specify for Frame Relay specific\n        LDP Intialization Messages.')
mplsLdpEntityFrameRelayParmsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsEntry.setDescription('An entry in this table represents the Frame Relay\n        optional parameters associated with the LDP entity.')
mplsLdpEntityFrIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of\n       the 'ifLayer' where the Frame Relay Labels 'owned' by this\n       entry were created, or 0 (zero).  The value of zero\n       means that the InterfaceIndex is not known.  For example,\n       if the InterfaceIndex is created subsequent to the\n       Frame Relay Label's creation, then it would not be known.\n       However, if the InterfaceIndex is known, then it must\n       be represented by this value.\n\n       If an InterfaceIndex becomes known, then the\n       network management entity (e.g. SNMP agent) responsible\n       for this object MUST change the value from 0 (zero) to the\n       value of the InterfaceIndex.  If an Frame Relay Label is\n       being used in forwarding data, then the value of this\n       object MUST be the InterfaceIndex.")
mplsLdpEntityFrMergeCap = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notSupported", 0), ("supported", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrMergeCap.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrMergeCap.setDescription('This represents whether or not Frame Relay merge\n        capability is supported.')
mplsLdpEntityFrLabelRangeComponents = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrLabelRangeComponents.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrLabelRangeComponents.setDescription('Number of LabelRange Components in the Initialization\n        message.  This also represents the number of entries\n        in the mplsLdpEntityConfFrLabelRangeTable which correspond\n        to this entry.')
mplsLdpEntityFrLen = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("tenDlciBits", 0), ("twentyThreeDlciBits", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrLen.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrLen.setDescription('This object specifies the DLCI bits.')
mplsLdpEntityFrVcDirectionality = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirection", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrVcDirectionality.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)', then\n        the LSR supports the use of a given DLCI as a label for\n        both directions independently.  If the value of\n        this object is 'unidirectional(1)', then the LSR\n        uses the given DLCI as a label in only one direction.")
mplsLdpEntityFrParmsStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrParmsStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrParmsStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityFrParmsRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrParmsRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrParmsRowStatus.setDescription("An object that allows entries in this table to\n        be created and deleted using the\n        RowStatus convention.\n        NOTE:  This RowStatus object should\n        have the same value of the 'mplsLdpEntityRowStatus'\n        related to this entry.")
mplsLdpEntityConfFrLabelRangeTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 5, 2), )
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeTable.setDescription('This table contains information about the\n        Optional Parameters to specify what this Entity is\n        going to specify for Frame Relay specific\n        LDP Intialization Messages.')
mplsLdpEntityConfFrLabelRangeEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpConfFrMinimumDlci"))
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeEntry.setDescription('An entry in this table represents the Frame Relay\n        optional parameters associated with the LDP entity.')
mplsLdpConfFrMinimumDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303)))
if mibBuilder.loadTexts: mplsLdpConfFrMinimumDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrMinimumDlci.setDescription("The lower bound which is supported.  This value should\n        be the same as that in the Frame Relay Label Range\n        Component's Minimum DLCI field.")
mplsLdpConfFrMaximumDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpConfFrMaximumDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrMaximumDlci.setDescription("The upper bound which is supported.  This value should\n        be the same as that in the Frame Relay Label Range\n        Component's Maximum DLCI field.")
mplsLdpConfFrStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 3), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpConfFrStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrStorageType.setDescription('The storage type for this entry.')
mplsLdpConfFrRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpConfFrRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrRowStatus.setDescription("An object that allows entries in this table to\n        be created and deleted using the\n        RowStatus convention.\n\n        If the value of the object\n        'mplsLdpEntityOptionalParameters' contains the\n        value of 'frameRelaySessionParameters(3)' then\n        there must be at least one corresponding entry\n        in this table.\n\n        NOTE:  This RowStatus object should\n        have the same value of the 'mplsLdpEntityRowStatus'\n        related to this entry.")
mplsLdpEntityStatsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 6), )
if mibBuilder.loadTexts: mplsLdpEntityStatsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsTable.setDescription('This table is a read-only table which augments\n        the mplsLdpEntityTable.  The purpose of this\n        table is to keep statistical information about\n        the LDP Entities on the LSR.')
mplsLdpEntityStatsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 6, 1), )
mplsLdpEntityEntry.registerAugmentions(("MPLS-LDP-MIB", "mplsLdpEntityStatsEntry"))
mplsLdpEntityStatsEntry.setIndexNames(*mplsLdpEntityEntry.getIndexNames())
if mibBuilder.loadTexts: mplsLdpEntityStatsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsEntry.setDescription('A row in this table contains statistical information\n        about an LDP Entity.  Some counters contained in a\n        row are for fatal errors received during a former\n        LDP Session associated with this entry.  For example,\n        an Ldp Pdu received on a TCP connection during an\n        LDP Session contains a fatal error.  That\n        error is counted here, because the\n        session is terminated.\n\n        If the error is NOT fatal (i.e. and the Session\n        remains), then the error is counted in the\n        mplsLdpSessionStatsEntry.')
mplsLdpAttemptedSessions = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpAttemptedSessions.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAttemptedSessions.setDescription('A count of the total attempted sessions for\n        this LDP Entity.')
mplsLdpSessionRejectedNoHelloErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedNoHelloErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedNoHelloErrors.setDescription('A count of the Session Rejected/No Hello Error\n        Notification Messages sent or received by\n        this LDP Entity.')
mplsLdpSessionRejectedAdvertisementErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedAdvertisementErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedAdvertisementErrors.setDescription('A count of the Session Rejected/Parameters\n        Advertisement Mode Error Notification Messages sent\n        or received by this LDP Entity.')
mplsLdpSessionRejectedMaxPduErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedMaxPduErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedMaxPduErrors.setDescription('A count of the Session Rejected/Parameters\n        Max Pdu Length Error Notification Messages sent\n        or received by this LDP Entity.')
mplsLdpSessionRejectedLabelRangeErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedLabelRangeErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedLabelRangeErrors.setDescription('A count of the Session Rejected/Parameters\n        Label Range Notification Messages sent\n        or received by this LDP Entity.')
mplsLdpBadLdpIdentifierErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadLdpIdentifierErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadLdpIdentifierErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadLdpIdentifierErrors.setDescription('This object counts the number of Bad LDP Identifier\n        Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.')
mplsLdpBadPduLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadPduLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadPduLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadPduLengthErrors.setDescription('This object counts the number of Bad Pdu Length\n        Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.')
mplsLdpBadMessageLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadMessageLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadMessageLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadMessageLengthErrors.setDescription('This object counts the number of Bad Message\n        Length Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.')
mplsLdpBadTlvLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadTlvLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadTlvLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadTlvLengthErrors.setDescription('This object counts the number of Bad TLV\n        Length Fatal Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.')
mplsLdpMalformedTlvValueErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpMalformedTlvValueErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpMalformedTlvValueErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpMalformedTlvValueErrors.setDescription('This object counts the number of Malformed TLV\n        Value Fatal Errors detected by the session(s)\n        (past and present) associated with this\n        LDP Entity.')
mplsLdpKeepAliveTimerExpiredErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpKeepAliveTimerExpiredErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpKeepAliveTimerExpiredErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpKeepAliveTimerExpiredErrors.setDescription('This object counts the number of Session Keep Alive\n        Timer Expired Errors detected by the session(s)\n        (past and present) associated with this LDP Entity.')
mplsLdpShutdownNotifReceived = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpShutdownNotifReceived.setStatus('current')
if mibBuilder.loadTexts: mplsLdpShutdownNotifReceived.setDescription('This object counts the number of Shutdown Notfications\n        received related to session(s) (past and present)\n        associated with this LDP Entity.')
mplsLdpShutdownNotifSent = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpShutdownNotifSent.setStatus('current')
if mibBuilder.loadTexts: mplsLdpShutdownNotifSent.setDescription('This object counts the number of Shutdown Notfications\n        sent related to session(s) (past and present) associated\n        with this LDP Entity.')
mplsLdpSessionObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 3))
mplsLdpPeerTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 1), )
if mibBuilder.loadTexts: mplsLdpPeerTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerTable.setDescription('Information about LDP peers known by Entities in\n        the mplsLdpEntityTable.  The information in this table\n        is based on information from the Entity-Peer interaction\n        during session initialization but is not appropriate\n        for the mplsLdpSessionTable, because objects in this\n        table may or may not be used in session establishment.')
mplsLdpPeerEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"))
if mibBuilder.loadTexts: mplsLdpPeerEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerEntry.setDescription('Information about a single Peer which is related\n        to a Session.  NOTE:  this table is used to\n        augment the mplsLdpSessionTable.')
mplsLdpPeerLdpId = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 1), MplsLdpIdentifier())
if mibBuilder.loadTexts: mplsLdpPeerLdpId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLdpId.setDescription('The LDP identifier of this LDP Peer.')
mplsLdpPeerLabelDistributionMethod = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("downstreamOnDemand", 1), ("downstreamUnsolicited", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerLabelDistributionMethod.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLabelDistributionMethod.setDescription('For any given LDP session, the method of\n        label distribution must be specified.')
mplsLdpPeerLoopDetectionForPV = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerLoopDetectionForPV.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLoopDetectionForPV.setDescription('An indication of whether loop detection based\n        on path vectors is disabled or enabled for this Peer.\n\n        If this object has a value of disabled(0),\n        then loop detection is disabled.  Otherwise, if this\n        object has a value of enabled(1), then loop detection\n        based on path vectors is enabled.')
mplsLdpPeerPathVectorLimit = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerPathVectorLimit.setDescription("If the value of 'mplsLdpPeerLoopDetectionForPV' for\n        this entry is 'enabled(1)', the this object represents\n        that Path Vector Limit for this peer.\n\n        If the value of 'mplsLdpPeerLoopDetectionForPV' for\n        this entry is 'disabled(0)', then this value should\n        be 0 (zero).")
mplsLdpHelloAdjacencyObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 3, 2))
mplsLdpHelloAdjacencyTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 2, 1), )
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyTable.setDescription('A table of Hello Adjacencies for Sessions.')
mplsLdpHelloAdjacencyEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpHelloAdjacencyIndex"))
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyEntry.setDescription('Each row represents a single LDP Hello Adjacency.\n        An LDP Session can have one or more Hello adjacencies.')
mplsLdpHelloAdjacencyIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyIndex.setDescription('An identifier for this specific adjacency.')
mplsLdpHelloAdjacencyHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1, 2), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTimeRemaining.setDescription("The time remaining for this Hello Adjacency.\n        This interval will change when the 'next'\n        Hello message which corresponds to this\n        Hello Adjacency is received.")
mplsLdpHelloAdjacencyType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("link", 1), ("targeted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyType.setDescription("This adjacency is the result of a 'link'\n        hello if the value of this object is link(1).\n        Otherwise, it is a result of a 'targeted'\n        hello, targeted(2).")
mplsLdpSessionUpDownTrapEnable = MibScalar((1, 3, 6, 1, 3, 97, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsLdpSessionUpDownTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionUpDownTrapEnable.setDescription("Indicates whether the traps, 'mplsLdpSessionUp' and\n        'mplsLdpSessionDown' will be generated or not.\n\n        If the value of this object is 'enabled(1)'\n        then the traps will generated.  If the value\n        of this object is 'disabled(2)' then the\n        traps will not be generated.  The DEFVAL\n        is set to 'disabled(2)'.")
mplsLdpSessionTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 4), )
if mibBuilder.loadTexts: mplsLdpSessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionTable.setDescription('A table of Sessions between the LDP Entities and\n        LDP Peers.  Each row represents a single session.')
mplsLdpSessionEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 4, 1), )
mplsLdpPeerEntry.registerAugmentions(("MPLS-LDP-MIB", "mplsLdpSessionEntry"))
mplsLdpSessionEntry.setIndexNames(*mplsLdpPeerEntry.getIndexNames())
if mibBuilder.loadTexts: mplsLdpSessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionEntry.setDescription("An entry in this table represents information on a\n        single session between an LDP Entity and LDP Peer.\n        The information contained in a row is read-only.\n\n        Please note:  the Path Vector Limit for the\n        Session is the value which is configured in\n        the corresponding mplsLdpEntityEntry. The\n        Peer's Path Vector Limit is in noted in the\n        mplsLdpPeerTable.\n\n        Values which may differ from those configured are\n        noted in the objects of this table, the\n        mplsLdpAtmSessionTable and the\n        mplsLdpFrameRelaySessionTable. A value will\n        differ if it was negotiated between the\n        Entity and the Peer. Values may or may not\n        be negotiated. For example, if the values\n        are the same then no negotiation takes place.\n        If they are negotiated, then they may differ.")
mplsLdpSessionState = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonexistent", 1), ("initialized", 2), ("openrec", 3), ("opensent", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionState.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionState.setDescription('The current state of the session, all of the\n        states 1 - 5 are based on the state machine for\n        session negotiation behavior.')
mplsLdpSessionProtocolVersion = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionProtocolVersion.setDescription('The version of the LDP Protocol which\n        this session is using.')
mplsLdpSessionKeepAliveHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 3), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveHoldTimeRemaining.setDescription('The keep alive hold time remaining for this session.')
mplsLdpSessionMaxPduLength = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionMaxPduLength.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionMaxPduLength.setDescription('The value of maximum allowable length for LDP PDUs for\n        this session.  This value may have been negotiated during\n        the Session Initialization.')
mplsLdpSessionDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\n        which any one or more of this session's counters\n        suffered a discontinuity.  The relevant counters are\n        the specific instances associated with this session\n        of any Counter32 or Counter64 object contained in the\n        mplsLdpSessionStatsTable.  If no such discontinuities have\n        occurred since the last re-initialization of the local\n        management subsystem, then this object contains a zero\n        value.\n\n        Also, an NMS can distinguish when a session\n        between a given Entity and Peer goes away and then is\n        're-established'.  This value would change and\n        thus indicate to the NMS that this is a\n        different session.")
mplsLdpAtmSessionTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 5), )
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setDescription("A table which relates Sessions in the\n        'mplsLdpSessionTable' and their label\n        range intersections.  There could be one\n        or more label range intersections between an\n        LDP Entity and LDP Peer using ATM as the underlying\n        media. Each row represents a single label range\n        intersection.\n\n        NOTE:  this table cannot use the 'AUGMENTS'\n        clause because there is not necessarily a one-to-one\n        mapping between this table and the mplsLdpSessionTable.")
mplsLdpAtmSessionEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 5, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeLowerBoundVpi"), (0, "MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeLowerBoundVci"))
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setDescription('An entry in this table represents information on a\n        single label range intersection between an LDP Entity\n        and LDP Peer.\n\n        The information contained in a row is read-only.')
mplsLdpSessionAtmLabelRangeLowerBoundVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVpi.setDescription('The minimum VPI number for this range.')
mplsLdpSessionAtmLabelRangeLowerBoundVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVci.setDescription('The minimum VCI number for this range.')
mplsLdpSessionAtmLabelRangeUpperBoundVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 3), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVpi.setDescription('The maximum VPI number for this range.')
mplsLdpSessionAtmLabelRangeUpperBoundVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVci.setDescription('The maximum VCI number for this range.')
mplsLdpFrameRelaySessionTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 6), )
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionTable.setDescription("A table of Frame Relay label range intersections\n        between the LDP Entities and LDP Peers.\n        Each row represents a single label range intersection.\n\n        NOTE:  this table cannot use the 'AUGMENTS'\n        clause because there is not necessarily a one-to-one\n        mapping between this table and the mplsLdpSessionTable.")
mplsLdpFrameRelaySessionEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 6, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpFrSessionMinDlci"))
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionEntry.setDescription('An entry in this table represents information on a\n        single label range intersection between an\n        LDP Entity and LDP Peer.\n\n        The information contained in a row is read-only.')
mplsLdpFrSessionMinDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303)))
if mibBuilder.loadTexts: mplsLdpFrSessionMinDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrSessionMinDlci.setDescription('The lower bound of DLCIs which are supported.')
mplsLdpFrSessionMaxDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpFrSessionMaxDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrSessionMaxDlci.setDescription('The upper bound of DLCIs which are supported.')
mplsLdpFrSessionLen = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("tenDlciBits", 0), ("twentyThreeDlciBits", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpFrSessionLen.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrSessionLen.setDescription('This object specifies the DLCI bits.')
mplsLdpSessionStatsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 7), )
if mibBuilder.loadTexts: mplsLdpSessionStatsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsTable.setDescription('A table of statistics for Sessions between\n        LDP Entities and LDP Peers.')
mplsLdpSessionStatsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 7, 1), )
mplsLdpPeerEntry.registerAugmentions(("MPLS-LDP-MIB", "mplsLdpSessionStatsEntry"))
mplsLdpSessionStatsEntry.setIndexNames(*mplsLdpPeerEntry.getIndexNames())
if mibBuilder.loadTexts: mplsLdpSessionStatsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsEntry.setDescription('An entry in this table represents statistical\n        information on a single session between an LDP\n        Entity and LDP Peer.')
mplsLdpSessionStatsUnknownMessageTypeErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownMessageTypeErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownMessageTypeErrors.setDescription('This object counts the number of Unknown Message Type\n        Errors detected during this session.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpSeeionDiscontinuityTime.')
mplsLdpSessionStatsUnknownTlvErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownTlvErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownTlvErrors.setDescription('This object counts the number of Unknown TLV Errors\n        detected during this session.\n\n        Discontinuities in the value of this counter can occur\n        at re-initialization of the management system, and at\n        other times as indicated by the value of\n        mplsLdpSeeionDiscontinuityTime.')
mplsFecObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 3, 8))
mplsFecIndexNext = MibScalar((1, 3, 6, 1, 3, 97, 1, 3, 8, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsFecIndexNext.setDescription('This object contains an appropriate value to\n        be used for mplsFecIndex when creating\n        entries in the mplsFecTable. The value\n        0 indicates that no unassigned entries are\n        available. To obtain the mplsFecIndex\n        value for a new entry, the manager issues a\n        management protocol retrieval operation to obtain\n        the current value of this object.  After each\n        retrieval, the agent should modify the value to\n        the next unassigned index.')
mplsFecTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 8, 2), )
if mibBuilder.loadTexts: mplsFecTable.setStatus('current')
if mibBuilder.loadTexts: mplsFecTable.setDescription('This table represents the FEC\n        (Forwarding Equivalence Class)\n        Information associated with an LSP.')
mplsFecEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsFecIndex"))
if mibBuilder.loadTexts: mplsFecEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFecEntry.setDescription('Each row represents a single FEC Element.')
mplsFecIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsFecIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFecIndex.setDescription('The index which uniquely identifies this entry.')
mplsFecType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("prefix", 1), ("hostAddress", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecType.setStatus('current')
if mibBuilder.loadTexts: mplsFecType.setDescription("The type of the FEC.  If the value of this object\n        is 'prefix(1)' then the FEC type described by this\n        row is for address prefixes.\n\n        If the value of this object is 'hostAddress(2)' then\n        the FEC type described by this row is a host address.")
mplsFecAddressLength = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecAddressLength.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddressLength.setDescription("If the value of 'mplsFecType' is 'prefix(1)'\n        then the value of this object is the length in\n        bits of the address prefix represented by\n        'mplsFecAddress', or if the length is zero then\n        this is a special value which indicates that the\n        prefix matches all addresses.  In this case the\n        prefix is also zero (i.e. 'mplsFecAddress' will\n        have the value of zero.)")
mplsFecAddressFamily = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 4), AddressFamilyNumbers()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecAddressFamily.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddressFamily.setDescription('The value of this object is from the Address Family\n        Numbers.')
mplsFecAddress = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 5), MplsLdpGenAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecAddress.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddress.setDescription("If the value of 'mplsFecType' is 'prefix(1)'\n        then the value of this object is the address prefix.\n        If the value of the 'mplsFecAddressLength'\n        is object is zero, then this object should also be\n        zero.\n\n        If the value of the 'mplsFecType' is 'host(2)'\n        then this is the host address.")
mplsFecStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsFecStorageType.setDescription('The storage type for this entry.')
mplsFecRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsFecRowStatus.setDescription('An object that allows entries in this table to\n         be created and deleted using the\n         RowStatus convention.')
mplsLdpSessionInLabelMapTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 9), )
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapTable.setDescription("A table of Session's Ingress Labels which\n        are Mapped to the LSR MIB's mplsInSegmentTable.\n        Each row represents a single Ingress Label.")
mplsLdpSessionInLabelMapEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 9, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabel"))
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapEntry.setDescription("An entry in this table represents information on a\n        single LDP LSP which is represented by\n        a session's index triple (mplsLdpEntityLdpId,\n        mplsLdpEntityIndex, mplsLdpPeerLdpId) AND the\n        index tuple (mplsLdpSessionInLabel, mplsInSegmentIfIndex)\n        from the LSR MIB's mplsInSegmentTable.\n        The information contained in a row is read-only.")
mplsLdpSessionInLabelIfIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: mplsLdpSessionInLabelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelIfIndex.setDescription("The ifIndex of the 'mplsLdpSessionInLabel' which should\n        have the same value as the 'mplsInSegmentIfIndex' in\n        the LSR MIB.")
mplsLdpSessionInLabel = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 2), MplsLabel())
if mibBuilder.loadTexts: mplsLdpSessionInLabel.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabel.setDescription("The incoming label of this LSP.  This has the same value\n        as the 'mplsInSegmentLabel' in the LSR MIB.")
mplsLdpSessionInLabelType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 3), MplsLdpLabelTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionInLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelType.setDescription("The Layer 2 Label Type for 'mplsLdpInLabel'.")
mplsLdpSessionInLabelConnectionType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("xconnect", 2), ("terminates", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionInLabelConnectionType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelConnectionType.setDescription('The type of LSP connection.\n        The possible values are:\n\n        unknown(1) --    this may be the value if the LSP\n                         is in a state of flux.  It is\n                         considered to be a temporary\n                         situation.\n        xconnect(2) --   if the mapping between the\n                         session and the insegment\n                         is associated with an LSP which\n                         is a true cross-connection.\n        terminates(3) -- if the mapping between the\n                         session and the insegment\n                         is associated with an LSP which\n                         terminates on this LSR and is\n                         not a cross-connection.')
mplsLdpSessionOutLabelMapTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 10), )
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapTable.setDescription("A table of Session's Egress Labels which\n        are Mapped to the LSR MIB.\n        Each row represents a single Egress Label.")
mplsLdpSessionOutLabelMapEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 10, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabel"))
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapEntry.setDescription('An entry in this table represents information on a\n        single session between an LDP Entity and LDP Peer.\n        The information contained in a row is read-only.')
mplsLdpSessionOutLabelIfIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: mplsLdpSessionOutLabelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelIfIndex.setDescription("The ifIndex of the 'mplsLdpSessionOutLabel'.")
mplsLdpSessionOutLabel = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 2), MplsLabel())
if mibBuilder.loadTexts: mplsLdpSessionOutLabel.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabel.setDescription('The outgoing label of this LSP.')
mplsLdpSessionOutLabelType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 3), MplsLdpLabelTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionOutLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelType.setDescription("The Layer 2 Label Type for 'mplsLdpOutLabel'.")
mplsLdpSessionOutLabelConnectionType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("xconnect", 2), ("starts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionOutLabelConnectionType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelConnectionType.setDescription('The type of LSP connection.\n        The possible values are:\n\n        unknown(1) --  this may be the value if the LSP\n                       is in a state of flux.  It is\n                       considered to be a temporary\n                       situation.\n        xconnect(2) -- if the mapping between the\n                       session and the outsegment\n                       is associated with an LSP which\n                       is a true cross-connection.\n        starts(3) -- if the mapping between the\n                      session and the insegment\n                      is associated with an LSP which\n                      starts on this LSR and is\n                      considered an ingress to the LSP.')
mplsLdpSessionOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutSegmentIndex.setDescription("This value should contain the same value as\n       the 'mplsOutSegmentIndex' in the LSR MIB.\n\n       NOTE: this value will never be zero, because\n       this table only maps from Sessions to true\n       outsegments.")
mplsLdpSessionXCMapTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 11), )
if mibBuilder.loadTexts: mplsLdpSessionXCMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionXCMapTable.setDescription("A table of Session's Labels which\n        are Mapped to the LSR MIB 's XConnect table.\n        Each row represents a single cross connect.")
mplsLdpSessionXCMapEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 11, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabel"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabel"))
if mibBuilder.loadTexts: mplsLdpSessionXCMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionXCMapEntry.setDescription('An entry in this table represents information on a\n        single session between an LDP Entity and LDP Peer.\n        The information contained in a row is read-only.')
mplsLdpSessionXCIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionXCIndex.setDescription("This value should contain the same value as\n       the 'mplsXCIndex' in the LSR MIB.\n\n       NOTE: this value will never be zero, because\n       this table only maps from Sessions to true\n       cross connects.")
mplsXCsFecsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 13), )
if mibBuilder.loadTexts: mplsXCsFecsTable.setStatus('current')
if mibBuilder.loadTexts: mplsXCsFecsTable.setDescription('A table which shows the relationship between\n      cross-connects and FECs.  Each row represents\n      a single cross connect to FEC association.\n      This table is read-only.')
mplsXCsFecsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 13, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabel"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabel"), (0, "MPLS-LDP-MIB", "mplsFecIndex"))
if mibBuilder.loadTexts: mplsXCsFecsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsXCsFecsEntry.setDescription('An entry represents a single cross connect\n      to FEC association.')
mplsXCFecOperStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("inUse", 2), ("notInUse", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCFecOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCFecOperStatus.setDescription('An indication of the operational status of\n      the FEC associated with this cross connect.\n\n      unknown(1) - this is a temporary state which\n                   may indicate the LSP-FEC association\n                   is in a state of transition.\n\n      inUse(2) - the FEC associated with the XC is\n                 currently being applied.\n\n      notInUse(3) - the FEC associated with the XC is\n                    not being applied.  Eventually, this\n                    entry may be aged out.')
mplsXCFecOperStatusLastChange = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 13, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCFecOperStatusLastChange.setStatus('current')
if mibBuilder.loadTexts: mplsXCFecOperStatusLastChange.setDescription('This value of sysUpTime when the\n      mplsXCFecOperStatus last changed state.')
mplsLdpSessionPeerAddressTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 12), )
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressTable.setDescription("This table 'extends' the mplsLdpSessionTable.\n        This table is used to store Label Address Information\n        from Label Address Messages received by this LSR from\n        Peers.  This table is read-only and should be updated\n        when Label Withdraw Address Messages are received, i.e.\n        Rows should be deleted as apropriate.\n\n        NOTE:  since more than one address may be contained\n        in a Label Address Message, this table 'extends',\n        rather than 'AUGMENTS' the mplsLdpSessionTable's\n        information.")
mplsLdpSessionPeerAddressEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 12, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionPeerAddressIndex"))
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressEntry.setDescription("An entry in this table represents information on\n        session's for a single next hop address which was\n        advertised in an Address Message from the LDP peer.\n        The information contained in a row is read-only.")
mplsLdpSessionPeerAddressIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressIndex.setDescription('An index which uniquely identifies this entry within\n        a given session.')
mplsLdpSessionPeerNextHopAddressType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 12, 1, 2), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddressType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddressType.setDescription('The internetwork layer address type of this Next Hop\n        Address as specified in the Label Address Message\n        associated with this Session. The value of this\n        object indicates how to interpret the value of\n        mplsLdpSessionPeerNextHopAddress.')
mplsLdpSessionPeerNextHopAddress = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 12, 1, 3), MplsLdpGenAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddress.setReference('LDP Specification [18] defines only IPv4 for LDP Protocol\n        Version 1, see section 3.4.3.')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddress.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddress.setDescription('The value of the next hop address.')
mplsLdpNotificationPrefix = MibIdentifier((1, 3, 6, 1, 3, 97, 2, 0))
mplsLdpFailedInitSessionThresholdExceeded = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 1)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityFailedInitSessionThreshold"))
if mibBuilder.loadTexts: mplsLdpFailedInitSessionThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFailedInitSessionThresholdExceeded.setDescription("This notification is generated when the value of\n        the 'mplsLdpEntityFailedInitSessionTrapEnable' object\n        is 'enabled(1)' and the value of the\n        'mplsLdpEntityFailedInitSessionThreshold' object has\n        been exceeded.")
mplsLdpPathVectorLimitMismatch = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 2)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityPathVectorLimit"), ("MPLS-LDP-MIB", "mplsLdpPeerPathVectorLimit"))
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setDescription("This notification is generated when the value\n        of the value of the\n        'mplsLdpEntityFailedInitSessionTrapEnable'\n        object is 'enabled(1)' and the\n        'mplsLdpEntityPathVectorLimit' does NOT match\n        the value of the 'mplsLdpPeerPathVectorLimit' for\n        a specific Entity.")
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setReference('LDP Specification, Section 3.5.3.')
mplsLdpSessionUp = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 3)).setObjects(("MPLS-LDP-MIB", "mplsLdpSessionState"))
if mibBuilder.loadTexts: mplsLdpSessionUp.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionUp.setDescription("Generation of this trap occurs when the\n        'mplsLdpSessionUpDownTrapEnable' object is 'enabled(1)'\n        and the value of 'mplsLdpSessionState' changes from\n        any state except 'nonexistent(1)' to 'operational(5)'.")
mplsLdpSessionDown = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 4)).setObjects(("MPLS-LDP-MIB", "mplsLdpSessionState"))
if mibBuilder.loadTexts: mplsLdpSessionDown.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionDown.setDescription("Generation of this trap occurs when the\n        'mplsLdpSessionUpDownTrapEnable' object is\n        'enabled(1)' and the value of\n        'mplsLdpSessionState' changes from\n        'operational(5)' to any other state.")
mplsLdpGroups = MibIdentifier((1, 3, 6, 1, 3, 97, 3, 1))
mplsLdpCompliances = MibIdentifier((1, 3, 6, 1, 3, 97, 3, 2))
mplsLdpModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 97, 3, 2, 1)).setObjects(("MPLS-LDP-MIB", "mplsLdpGeneralGroup"), ("MPLS-LDP-MIB", "mplsLdpNotificationsGroup"), ("MPLS-LDP-MIB", "mplsLdpGenericGroup"), ("MPLS-LDP-MIB", "mplsLdpAtmGroup"), ("MPLS-LDP-MIB", "mplsLdpFrameRelayGroup"), ("MPLS-LDP-MIB", "mplsLdpMappingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpModuleCompliance = mplsLdpModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpModuleCompliance.setDescription('The basic implentation requirements for agents that\n        support the MPLS LDP MIB.')
mplsLdpGeneralGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 1)).setObjects(("MPLS-LDP-MIB", "mplsLdpLsrId"), ("MPLS-LDP-MIB", "mplsLdpLsrLoopDetectionCapable"), ("MPLS-LDP-MIB", "mplsLdpEntityIndexNext"), ("MPLS-LDP-MIB", "mplsLdpEntityProtocolVersion"), ("MPLS-LDP-MIB", "mplsLdpEntityAdminStatus"), ("MPLS-LDP-MIB", "mplsLdpEntityOperStatus"), ("MPLS-LDP-MIB", "mplsLdpEntityWellKnownTcpDiscoveryPort"), ("MPLS-LDP-MIB", "mplsLdpEntityWellKnownUdpDiscoveryPort"), ("MPLS-LDP-MIB", "mplsLdpEntityMaxPduLength"), ("MPLS-LDP-MIB", "mplsLdpEntityKeepAliveHoldTimer"), ("MPLS-LDP-MIB", "mplsLdpEntityHelloHoldTimer"), ("MPLS-LDP-MIB", "mplsLdpEntityFailedInitSessionTrapEnable"), ("MPLS-LDP-MIB", "mplsLdpEntityFailedInitSessionThreshold"), ("MPLS-LDP-MIB", "mplsLdpEntityLabelDistributionMethod"), ("MPLS-LDP-MIB", "mplsLdpEntityLabelRetentionMode"), ("MPLS-LDP-MIB", "mplsLdpEntityPVLimitMismatchTrapEnable"), ("MPLS-LDP-MIB", "mplsLdpEntityPathVectorLimit"), ("MPLS-LDP-MIB", "mplsLdpEntityHopCountLimit"), ("MPLS-LDP-MIB", "mplsLdpEntityTargetedPeer"), ("MPLS-LDP-MIB", "mplsLdpEntityTargetedPeerAddrType"), ("MPLS-LDP-MIB", "mplsLdpEntityTargetedPeerAddr"), ("MPLS-LDP-MIB", "mplsLdpEntityOptionalParameters"), ("MPLS-LDP-MIB", "mplsLdpEntityDiscontinuityTime"), ("MPLS-LDP-MIB", "mplsLdpEntityStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityRowStatus"), ("MPLS-LDP-MIB", "mplsLdpAttemptedSessions"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedNoHelloErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedAdvertisementErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedMaxPduErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedLabelRangeErrors"), ("MPLS-LDP-MIB", "mplsLdpBadLdpIdentifierErrors"), ("MPLS-LDP-MIB", "mplsLdpBadPduLengthErrors"), ("MPLS-LDP-MIB", "mplsLdpBadMessageLengthErrors"), ("MPLS-LDP-MIB", "mplsLdpBadTlvLengthErrors"), ("MPLS-LDP-MIB", "mplsLdpMalformedTlvValueErrors"), ("MPLS-LDP-MIB", "mplsLdpKeepAliveTimerExpiredErrors"), ("MPLS-LDP-MIB", "mplsLdpShutdownNotifReceived"), ("MPLS-LDP-MIB", "mplsLdpShutdownNotifSent"), ("MPLS-LDP-MIB", "mplsLdpPeerLabelDistributionMethod"), ("MPLS-LDP-MIB", "mplsLdpPeerLoopDetectionForPV"), ("MPLS-LDP-MIB", "mplsLdpPeerPathVectorLimit"), ("MPLS-LDP-MIB", "mplsLdpHelloAdjacencyHoldTimeRemaining"), ("MPLS-LDP-MIB", "mplsLdpHelloAdjacencyType"), ("MPLS-LDP-MIB", "mplsLdpSessionUpDownTrapEnable"), ("MPLS-LDP-MIB", "mplsLdpSessionState"), ("MPLS-LDP-MIB", "mplsLdpSessionProtocolVersion"), ("MPLS-LDP-MIB", "mplsLdpSessionKeepAliveHoldTimeRemaining"), ("MPLS-LDP-MIB", "mplsLdpSessionMaxPduLength"), ("MPLS-LDP-MIB", "mplsLdpSessionDiscontinuityTime"), ("MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownMessageTypeErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownTlvErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionPeerNextHopAddressType"), ("MPLS-LDP-MIB", "mplsLdpSessionPeerNextHopAddress"), ("MPLS-LDP-MIB", "mplsFecIndexNext"), ("MPLS-LDP-MIB", "mplsFecType"), ("MPLS-LDP-MIB", "mplsFecAddressFamily"), ("MPLS-LDP-MIB", "mplsFecAddressLength"), ("MPLS-LDP-MIB", "mplsFecAddress"), ("MPLS-LDP-MIB", "mplsFecStorageType"), ("MPLS-LDP-MIB", "mplsFecRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpGeneralGroup = mplsLdpGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpGeneralGroup.setDescription('Objects that apply to all MPLS LDP implementations.')
mplsLdpGenericGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 2)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityConfGenericIfIndexOrZero"), ("MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpGenericGroup = mplsLdpGenericGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpGenericGroup.setDescription('Objects that apply to all MPLS LDP implementations\n        using Generic Lables.')
mplsLdpAtmGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 3)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityAtmIfIndexOrZero"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmMergeCap"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmLabelRangeComponents"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmVcDirectionality"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmLsrConnectivity"), ("MPLS-LDP-MIB", "mplsLdpEntityDefaultControlVpi"), ("MPLS-LDP-MIB", "mplsLdpEntityDefaultControlVci"), ("MPLS-LDP-MIB", "mplsLdpEntityUnlabTrafVpi"), ("MPLS-LDP-MIB", "mplsLdpEntityUnlabTrafVci"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmRowStatus"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMaximumVpi"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMaximumVci"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeRowStatus"), ("MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeUpperBoundVpi"), ("MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeUpperBoundVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmGroup = mplsLdpAtmGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmGroup.setDescription('Objects that apply to all MPLS LDP implementations\n        over ATM.')
mplsLdpFrameRelayGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 4)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityFrIfIndexOrZero"), ("MPLS-LDP-MIB", "mplsLdpEntityFrMergeCap"), ("MPLS-LDP-MIB", "mplsLdpEntityFrLabelRangeComponents"), ("MPLS-LDP-MIB", "mplsLdpEntityFrLen"), ("MPLS-LDP-MIB", "mplsLdpEntityFrVcDirectionality"), ("MPLS-LDP-MIB", "mplsLdpEntityFrParmsStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityFrParmsRowStatus"), ("MPLS-LDP-MIB", "mplsLdpConfFrMaximumDlci"), ("MPLS-LDP-MIB", "mplsLdpConfFrStorageType"), ("MPLS-LDP-MIB", "mplsLdpConfFrRowStatus"), ("MPLS-LDP-MIB", "mplsLdpFrSessionMaxDlci"), ("MPLS-LDP-MIB", "mplsLdpFrSessionLen"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpFrameRelayGroup = mplsLdpFrameRelayGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelayGroup.setDescription('Objects that apply to all MPLS LDP implementations over\n        Frame Relay.')
mplsLdpMappingGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 5)).setObjects(("MPLS-LDP-MIB", "mplsLdpSessionInLabelType"), ("MPLS-LDP-MIB", "mplsLdpSessionInLabelConnectionType"), ("MPLS-LDP-MIB", "mplsLdpSessionOutLabelType"), ("MPLS-LDP-MIB", "mplsLdpSessionOutLabelConnectionType"), ("MPLS-LDP-MIB", "mplsLdpSessionOutSegmentIndex"), ("MPLS-LDP-MIB", "mplsLdpSessionXCIndex"), ("MPLS-LDP-MIB", "mplsXCFecOperStatus"), ("MPLS-LDP-MIB", "mplsXCFecOperStatusLastChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpMappingGroup = mplsLdpMappingGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpMappingGroup.setDescription('These objects are optional and only need to be supported\n        for LDP implementations which support the\n        tables, mplsInSegmentTable, mplsOutSegmentTable\n        and mplsXCTable, in the LSR MIB.')
mplsLdpNotificationsGroup = NotificationGroup((1, 3, 6, 1, 3, 97, 3, 1, 6)).setObjects(("MPLS-LDP-MIB", "mplsLdpFailedInitSessionThresholdExceeded"), ("MPLS-LDP-MIB", "mplsLdpPathVectorLimitMismatch"), ("MPLS-LDP-MIB", "mplsLdpSessionUp"), ("MPLS-LDP-MIB", "mplsLdpSessionDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpNotificationsGroup = mplsLdpNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpNotificationsGroup.setDescription('The notification(s) which an MPLS LDP implemention\n         is required to implement.')
mibBuilder.exportSymbols("MPLS-LDP-MIB", mplsLdpFrameRelaySessionTable=mplsLdpFrameRelaySessionTable, mplsLdpConformance=mplsLdpConformance, mplsLdpHelloAdjacencyIndex=mplsLdpHelloAdjacencyIndex, MplsLsrIdentifier=MplsLsrIdentifier, mplsLdpEntityStorageType=mplsLdpEntityStorageType, mplsFecRowStatus=mplsFecRowStatus, mplsLdpEntityFrameRelayParmsEntry=mplsLdpEntityFrameRelayParmsEntry, mplsLdpEntityPathVectorLimit=mplsLdpEntityPathVectorLimit, mplsLdpEntityFrMergeCap=mplsLdpEntityFrMergeCap, mplsLdpSessionUp=mplsLdpSessionUp, mplsLdpObjects=mplsLdpObjects, mplsLdpSessionXCIndex=mplsLdpSessionXCIndex, mplsLdpShutdownNotifSent=mplsLdpShutdownNotifSent, mplsLdpShutdownNotifReceived=mplsLdpShutdownNotifReceived, mplsLdpHelloAdjacencyObjects=mplsLdpHelloAdjacencyObjects, mplsLdpPeerLabelDistributionMethod=mplsLdpPeerLabelDistributionMethod, mplsLdpSessionRejectedMaxPduErrors=mplsLdpSessionRejectedMaxPduErrors, mplsLdpNotificationsGroup=mplsLdpNotificationsGroup, mplsLdpEntityTargetedPeer=mplsLdpEntityTargetedPeer, mplsLdpEntityDefaultControlVpi=mplsLdpEntityDefaultControlVpi, mplsLdpSessionInLabelType=mplsLdpSessionInLabelType, mplsLdpEntityStatsTable=mplsLdpEntityStatsTable, mplsLdpSessionXCMapTable=mplsLdpSessionXCMapTable, MplsAtmVcIdentifier=MplsAtmVcIdentifier, mplsLdpFrSessionLen=mplsLdpFrSessionLen, mplsLdpEntityHelloHoldTimer=mplsLdpEntityHelloHoldTimer, mplsLdpSessionInLabelMapTable=mplsLdpSessionInLabelMapTable, mplsLdpPathVectorLimitMismatch=mplsLdpPathVectorLimitMismatch, mplsFecTable=mplsFecTable, mplsLdpEntityIndex=mplsLdpEntityIndex, mplsLdpSessionRejectedAdvertisementErrors=mplsLdpSessionRejectedAdvertisementErrors, mplsLdpEntityConfGenericLabelRangeRowStatus=mplsLdpEntityConfGenericLabelRangeRowStatus, MplsLdpGenAddr=MplsLdpGenAddr, mplsLdpSessionPeerAddressTable=mplsLdpSessionPeerAddressTable, mplsLdpFrSessionMaxDlci=mplsLdpFrSessionMaxDlci, mplsLdpPeerPathVectorLimit=mplsLdpPeerPathVectorLimit, mplsLdpSessionOutLabelMapEntry=mplsLdpSessionOutLabelMapEntry, mplsLdpFrameRelayGroup=mplsLdpFrameRelayGroup, mplsLdpGeneralGroup=mplsLdpGeneralGroup, mplsLdpEntityAtmParmsTable=mplsLdpEntityAtmParmsTable, mplsLdpEntityUnlabTrafVpi=mplsLdpEntityUnlabTrafVpi, mplsLdpConfFrStorageType=mplsLdpConfFrStorageType, mplsLdpSessionEntry=mplsLdpSessionEntry, mplsLdpLsrObjects=mplsLdpLsrObjects, mplsLdpEntityFrIfIndexOrZero=mplsLdpEntityFrIfIndexOrZero, mplsLdpEntityDiscontinuityTime=mplsLdpEntityDiscontinuityTime, mplsLdpEntityAtmVcDirectionality=mplsLdpEntityAtmVcDirectionality, mplsLdpPeerEntry=mplsLdpPeerEntry, mplsLdpSessionInLabelIfIndex=mplsLdpSessionInLabelIfIndex, mplsLdpSessionRejectedNoHelloErrors=mplsLdpSessionRejectedNoHelloErrors, mplsLdpPeerLoopDetectionForPV=mplsLdpPeerLoopDetectionForPV, mplsLdpEntityConfAtmLabelRangeTable=mplsLdpEntityConfAtmLabelRangeTable, mplsLdpEntityFrameRelayObjects=mplsLdpEntityFrameRelayObjects, mplsLdpEntityConfFrLabelRangeEntry=mplsLdpEntityConfFrLabelRangeEntry, mplsLdpSessionTable=mplsLdpSessionTable, mplsLdpSessionOutLabelType=mplsLdpSessionOutLabelType, mplsLdpSessionOutLabelIfIndex=mplsLdpSessionOutLabelIfIndex, mplsLdpBadPduLengthErrors=mplsLdpBadPduLengthErrors, mplsLdpEntityDefaultControlVci=mplsLdpEntityDefaultControlVci, mplsLdpMappingGroup=mplsLdpMappingGroup, mplsLdpConfFrRowStatus=mplsLdpConfFrRowStatus, mplsLdpEntityConfGenericLabelRangeMaximum=mplsLdpEntityConfGenericLabelRangeMaximum, mplsLdpLsrId=mplsLdpLsrId, mplsLdpSessionPeerAddressEntry=mplsLdpSessionPeerAddressEntry, mplsLdpEntityWellKnownTcpDiscoveryPort=mplsLdpEntityWellKnownTcpDiscoveryPort, mplsLdpMalformedTlvValueErrors=mplsLdpMalformedTlvValueErrors, mplsLdpSessionAtmLabelRangeLowerBoundVpi=mplsLdpSessionAtmLabelRangeLowerBoundVpi, mplsLdpEntityConfAtmLabelRangeStorageType=mplsLdpEntityConfAtmLabelRangeStorageType, mplsLdpSessionXCMapEntry=mplsLdpSessionXCMapEntry, mplsLdpEntityFrParmsRowStatus=mplsLdpEntityFrParmsRowStatus, mplsLdpEntityProtocolVersion=mplsLdpEntityProtocolVersion, mplsLdpEntityAdminStatus=mplsLdpEntityAdminStatus, mplsLdpEntityAtmObjects=mplsLdpEntityAtmObjects, mplsXCsFecsTable=mplsXCsFecsTable, mplsLdpSessionInLabel=mplsLdpSessionInLabel, mplsLdpEntityAtmMergeCap=mplsLdpEntityAtmMergeCap, mplsLdpSessionAtmLabelRangeUpperBoundVpi=mplsLdpSessionAtmLabelRangeUpperBoundVpi, mplsLdpEntityMaxPduLength=mplsLdpEntityMaxPduLength, mplsLdpEntityConfAtmLabelRangeMaximumVpi=mplsLdpEntityConfAtmLabelRangeMaximumVpi, mplsXCFecOperStatus=mplsXCFecOperStatus, mplsLdpSessionOutLabelMapTable=mplsLdpSessionOutLabelMapTable, mplsLdpEntityOptionalParameters=mplsLdpEntityOptionalParameters, mplsLdpEntityOperStatus=mplsLdpEntityOperStatus, mplsLdpEntityFrLen=mplsLdpEntityFrLen, mplsLdpEntityUnlabTrafVci=mplsLdpEntityUnlabTrafVci, mplsFecIndexNext=mplsFecIndexNext, mplsLdpAttemptedSessions=mplsLdpAttemptedSessions, mplsXCFecOperStatusLastChange=mplsXCFecOperStatusLastChange, mplsLdpHelloAdjacencyHoldTimeRemaining=mplsLdpHelloAdjacencyHoldTimeRemaining, mplsFecIndex=mplsFecIndex, mplsLdpEntityEntry=mplsLdpEntityEntry, mplsLdpSessionStatsTable=mplsLdpSessionStatsTable, mplsLdpBadMessageLengthErrors=mplsLdpBadMessageLengthErrors, PYSNMP_MODULE_ID=mplsLdpMIB, mplsLdpEntityTargetedPeerAddr=mplsLdpEntityTargetedPeerAddr, mplsLdpPeerTable=mplsLdpPeerTable, mplsLdpSessionState=mplsLdpSessionState, mplsLdpSessionInLabelConnectionType=mplsLdpSessionInLabelConnectionType, mplsLdpEntityFrLabelRangeComponents=mplsLdpEntityFrLabelRangeComponents, mplsLdpEntityIndexNext=mplsLdpEntityIndexNext, mplsLdpEntityConfGenericIfIndexOrZero=mplsLdpEntityConfGenericIfIndexOrZero, mplsLdpEntityLabelRetentionMode=mplsLdpEntityLabelRetentionMode, mplsLdpEntityFailedInitSessionTrapEnable=mplsLdpEntityFailedInitSessionTrapEnable, mplsLdpHelloAdjacencyType=mplsLdpHelloAdjacencyType, mplsLdpSessionPeerAddressIndex=mplsLdpSessionPeerAddressIndex, mplsLdpEntityConfGenericLabelRangeEntry=mplsLdpEntityConfGenericLabelRangeEntry, mplsLdpBadLdpIdentifierErrors=mplsLdpBadLdpIdentifierErrors, mplsLdpEntityAtmParmsEntry=mplsLdpEntityAtmParmsEntry, mplsFecAddressLength=mplsFecAddressLength, mplsLdpSessionMaxPduLength=mplsLdpSessionMaxPduLength, mplsLdpSessionStatsUnknownMessageTypeErrors=mplsLdpSessionStatsUnknownMessageTypeErrors, mplsLdpCompliances=mplsLdpCompliances, mplsLdpFrSessionMinDlci=mplsLdpFrSessionMinDlci, mplsLdpBadTlvLengthErrors=mplsLdpBadTlvLengthErrors, MplsLdpLabelTypes=MplsLdpLabelTypes, mplsLdpEntityConfAtmLabelRangeEntry=mplsLdpEntityConfAtmLabelRangeEntry, mplsLdpAtmGroup=mplsLdpAtmGroup, mplsLdpSessionPeerNextHopAddressType=mplsLdpSessionPeerNextHopAddressType, mplsLdpHelloAdjacencyEntry=mplsLdpHelloAdjacencyEntry, mplsFecAddressFamily=mplsFecAddressFamily, mplsLdpHelloAdjacencyTable=mplsLdpHelloAdjacencyTable, mplsFecType=mplsFecType, mplsLdpSessionOutLabel=mplsLdpSessionOutLabel, mplsFecAddress=mplsFecAddress, mplsLdpEntityGenericObjects=mplsLdpEntityGenericObjects, mplsLdpEntityStatsEntry=mplsLdpEntityStatsEntry, mplsLdpEntityPVLimitMismatchTrapEnable=mplsLdpEntityPVLimitMismatchTrapEnable, mplsLdpEntityWellKnownUdpDiscoveryPort=mplsLdpEntityWellKnownUdpDiscoveryPort, mplsLdpSessionProtocolVersion=mplsLdpSessionProtocolVersion, mplsLdpSessionKeepAliveHoldTimeRemaining=mplsLdpSessionKeepAliveHoldTimeRemaining, mplsLdpGroups=mplsLdpGroups, mplsLdpEntityAtmLabelRangeComponents=mplsLdpEntityAtmLabelRangeComponents, mplsLdpLsrLoopDetectionCapable=mplsLdpLsrLoopDetectionCapable, mplsLdpEntityHopCountLimit=mplsLdpEntityHopCountLimit, mplsLdpFrameRelaySessionEntry=mplsLdpFrameRelaySessionEntry, mplsLdpConfFrMaximumDlci=mplsLdpConfFrMaximumDlci, mplsLdpEntityConfFrLabelRangeTable=mplsLdpEntityConfFrLabelRangeTable, mplsLdpSessionRejectedLabelRangeErrors=mplsLdpSessionRejectedLabelRangeErrors, mplsLdpEntityConfGenericLabelRangeTable=mplsLdpEntityConfGenericLabelRangeTable, mplsLdpSessionAtmLabelRangeUpperBoundVci=mplsLdpSessionAtmLabelRangeUpperBoundVci, mplsLdpNotificationPrefix=mplsLdpNotificationPrefix, mplsLdpMIB=mplsLdpMIB, MplsLabel=MplsLabel, mplsLdpSessionInLabelMapEntry=mplsLdpSessionInLabelMapEntry, mplsLdpSessionOutSegmentIndex=mplsLdpSessionOutSegmentIndex, mplsLdpEntityConfAtmLabelRangeMinimumVci=mplsLdpEntityConfAtmLabelRangeMinimumVci, mplsLdpSessionDown=mplsLdpSessionDown, mplsLdpConfFrMinimumDlci=mplsLdpConfFrMinimumDlci, mplsLdpKeepAliveTimerExpiredErrors=mplsLdpKeepAliveTimerExpiredErrors, mplsLdpEntityAtmRowStatus=mplsLdpEntityAtmRowStatus, mplsLdpEntityAtmIfIndexOrZero=mplsLdpEntityAtmIfIndexOrZero, mplsLdpEntityConfAtmLabelRangeMinimumVpi=mplsLdpEntityConfAtmLabelRangeMinimumVpi, mplsLdpEntityLdpId=mplsLdpEntityLdpId, mplsLdpEntityConfAtmLabelRangeMaximumVci=mplsLdpEntityConfAtmLabelRangeMaximumVci, mplsLdpEntityConfGenericLabelRangeMinimum=mplsLdpEntityConfGenericLabelRangeMinimum, mplsLdpGenericGroup=mplsLdpGenericGroup, mplsLdpModuleCompliance=mplsLdpModuleCompliance, mplsLdpEntityFrParmsStorageType=mplsLdpEntityFrParmsStorageType, mplsLdpSessionStatsUnknownTlvErrors=mplsLdpSessionStatsUnknownTlvErrors, mplsLdpNotifications=mplsLdpNotifications, mplsLdpEntityTargetedPeerAddrType=mplsLdpEntityTargetedPeerAddrType, mplsLdpEntityRowStatus=mplsLdpEntityRowStatus, mplsLdpEntityFrameRelayParmsTable=mplsLdpEntityFrameRelayParmsTable, mplsLdpEntityAtmStorageType=mplsLdpEntityAtmStorageType, mplsLdpSessionStatsEntry=mplsLdpSessionStatsEntry, mplsLdpEntityTable=mplsLdpEntityTable, mplsLdpSessionUpDownTrapEnable=mplsLdpSessionUpDownTrapEnable, mplsLdpEntityFailedInitSessionThreshold=mplsLdpEntityFailedInitSessionThreshold, mplsLdpEntityConfGenericLabelRangeStorageType=mplsLdpEntityConfGenericLabelRangeStorageType, mplsLdpSessionDiscontinuityTime=mplsLdpSessionDiscontinuityTime, MplsLdpIdentifier=MplsLdpIdentifier, mplsLdpAtmSessionEntry=mplsLdpAtmSessionEntry, mplsLdpEntityFrVcDirectionality=mplsLdpEntityFrVcDirectionality, mplsLdpSessionObjects=mplsLdpSessionObjects, mplsLdpPeerLdpId=mplsLdpPeerLdpId, mplsFecEntry=mplsFecEntry, mplsLdpSessionAtmLabelRangeLowerBoundVci=mplsLdpSessionAtmLabelRangeLowerBoundVci, mplsLdpSessionOutLabelConnectionType=mplsLdpSessionOutLabelConnectionType, mplsLdpSessionPeerNextHopAddress=mplsLdpSessionPeerNextHopAddress, mplsLdpFailedInitSessionThresholdExceeded=mplsLdpFailedInitSessionThresholdExceeded, mplsLdpEntityAtmLsrConnectivity=mplsLdpEntityAtmLsrConnectivity, mplsLdpEntityConfAtmLabelRangeRowStatus=mplsLdpEntityConfAtmLabelRangeRowStatus, mplsLdpEntityKeepAliveHoldTimer=mplsLdpEntityKeepAliveHoldTimer, mplsLdpEntityObjects=mplsLdpEntityObjects, mplsLdpAtmSessionTable=mplsLdpAtmSessionTable, mplsLdpEntityLabelDistributionMethod=mplsLdpEntityLabelDistributionMethod, mplsFecObjects=mplsFecObjects, mplsFecStorageType=mplsFecStorageType, mplsXCsFecsEntry=mplsXCsFecsEntry)
